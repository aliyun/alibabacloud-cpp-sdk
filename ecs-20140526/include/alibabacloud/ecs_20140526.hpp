// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_ECS20140526_H_
#define ALIBABACLOUD_ECS20140526_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Ecs20140526 {
class AcceptInquiredSystemEventRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> eventId{};
  shared_ptr<string> choice{};

  AcceptInquiredSystemEventRequest() {}

  explicit AcceptInquiredSystemEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (choice) {
      res["Choice"] = boost::any(*choice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("Choice") != m.end() && !m["Choice"].empty()) {
      choice = make_shared<string>(boost::any_cast<string>(m["Choice"]));
    }
  }


  virtual ~AcceptInquiredSystemEventRequest() = default;
};
class AcceptInquiredSystemEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AcceptInquiredSystemEventResponseBody() {}

  explicit AcceptInquiredSystemEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AcceptInquiredSystemEventResponseBody() = default;
};
class AcceptInquiredSystemEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AcceptInquiredSystemEventResponseBody> body{};

  AcceptInquiredSystemEventResponse() {}

  explicit AcceptInquiredSystemEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AcceptInquiredSystemEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AcceptInquiredSystemEventResponseBody>(model1);
      }
    }
  }


  virtual ~AcceptInquiredSystemEventResponse() = default;
};
class ActivateRouterInterfaceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> routerInterfaceId{};

  ActivateRouterInterfaceRequest() {}

  explicit ActivateRouterInterfaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (routerInterfaceId) {
      res["RouterInterfaceId"] = boost::any(*routerInterfaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RouterInterfaceId") != m.end() && !m["RouterInterfaceId"].empty()) {
      routerInterfaceId = make_shared<string>(boost::any_cast<string>(m["RouterInterfaceId"]));
    }
  }


  virtual ~ActivateRouterInterfaceRequest() = default;
};
class ActivateRouterInterfaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ActivateRouterInterfaceResponseBody() {}

  explicit ActivateRouterInterfaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ActivateRouterInterfaceResponseBody() = default;
};
class ActivateRouterInterfaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ActivateRouterInterfaceResponseBody> body{};

  ActivateRouterInterfaceResponse() {}

  explicit ActivateRouterInterfaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ActivateRouterInterfaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ActivateRouterInterfaceResponseBody>(model1);
      }
    }
  }


  virtual ~ActivateRouterInterfaceResponse() = default;
};
class AddBandwidthPackageIpsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> ipCount{};
  shared_ptr<string> clientToken{};

  AddBandwidthPackageIpsRequest() {}

  explicit AddBandwidthPackageIpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (ipCount) {
      res["IpCount"] = boost::any(*ipCount);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("IpCount") != m.end() && !m["IpCount"].empty()) {
      ipCount = make_shared<string>(boost::any_cast<string>(m["IpCount"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~AddBandwidthPackageIpsRequest() = default;
};
class AddBandwidthPackageIpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddBandwidthPackageIpsResponseBody() {}

  explicit AddBandwidthPackageIpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddBandwidthPackageIpsResponseBody() = default;
};
class AddBandwidthPackageIpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddBandwidthPackageIpsResponseBody> body{};

  AddBandwidthPackageIpsResponse() {}

  explicit AddBandwidthPackageIpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddBandwidthPackageIpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddBandwidthPackageIpsResponseBody>(model1);
      }
    }
  }


  virtual ~AddBandwidthPackageIpsResponse() = default;
};
class AddTagsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  AddTagsRequestTag() {}

  explicit AddTagsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~AddTagsRequestTag() = default;
};
class AddTagsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceId{};
  shared_ptr<vector<AddTagsRequestTag>> tag{};

  AddTagsRequest() {}

  explicit AddTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<AddTagsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddTagsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<AddTagsRequestTag>>(expect1);
      }
    }
  }


  virtual ~AddTagsRequest() = default;
};
class AddTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddTagsResponseBody() {}

  explicit AddTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddTagsResponseBody() = default;
};
class AddTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddTagsResponseBody> body{};

  AddTagsResponse() {}

  explicit AddTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddTagsResponseBody>(model1);
      }
    }
  }


  virtual ~AddTagsResponse() = default;
};
class AllocateDedicatedHostsRequestNetworkAttributes : public Darabonba::Model {
public:
  shared_ptr<long> slbUdpTimeout{};
  shared_ptr<long> udpTimeout{};

  AllocateDedicatedHostsRequestNetworkAttributes() {}

  explicit AllocateDedicatedHostsRequestNetworkAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (slbUdpTimeout) {
      res["SlbUdpTimeout"] = boost::any(*slbUdpTimeout);
    }
    if (udpTimeout) {
      res["UdpTimeout"] = boost::any(*udpTimeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SlbUdpTimeout") != m.end() && !m["SlbUdpTimeout"].empty()) {
      slbUdpTimeout = make_shared<long>(boost::any_cast<long>(m["SlbUdpTimeout"]));
    }
    if (m.find("UdpTimeout") != m.end() && !m["UdpTimeout"].empty()) {
      udpTimeout = make_shared<long>(boost::any_cast<long>(m["UdpTimeout"]));
    }
  }


  virtual ~AllocateDedicatedHostsRequestNetworkAttributes() = default;
};
class AllocateDedicatedHostsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  AllocateDedicatedHostsRequestTag() {}

  explicit AllocateDedicatedHostsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~AllocateDedicatedHostsRequestTag() = default;
};
class AllocateDedicatedHostsRequest : public Darabonba::Model {
public:
  shared_ptr<AllocateDedicatedHostsRequestNetworkAttributes> networkAttributes{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<AllocateDedicatedHostsRequestTag>> tag{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> dedicatedHostName{};
  shared_ptr<string> dedicatedHostClusterId{};
  shared_ptr<string> dedicatedHostType{};
  shared_ptr<string> actionOnMaintenance{};
  shared_ptr<string> description{};
  shared_ptr<string> autoPlacement{};
  shared_ptr<double> cpuOverCommitRatio{};
  shared_ptr<long> minQuantity{};
  shared_ptr<string> chargeType{};
  shared_ptr<long> quantity{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewPeriod{};
  shared_ptr<string> autoReleaseTime{};
  shared_ptr<string> clientToken{};

  AllocateDedicatedHostsRequest() {}

  explicit AllocateDedicatedHostsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkAttributes) {
      res["NetworkAttributes"] = networkAttributes ? boost::any(networkAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (dedicatedHostName) {
      res["DedicatedHostName"] = boost::any(*dedicatedHostName);
    }
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    if (dedicatedHostType) {
      res["DedicatedHostType"] = boost::any(*dedicatedHostType);
    }
    if (actionOnMaintenance) {
      res["ActionOnMaintenance"] = boost::any(*actionOnMaintenance);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (autoPlacement) {
      res["AutoPlacement"] = boost::any(*autoPlacement);
    }
    if (cpuOverCommitRatio) {
      res["CpuOverCommitRatio"] = boost::any(*cpuOverCommitRatio);
    }
    if (minQuantity) {
      res["MinQuantity"] = boost::any(*minQuantity);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoRenewPeriod) {
      res["AutoRenewPeriod"] = boost::any(*autoRenewPeriod);
    }
    if (autoReleaseTime) {
      res["AutoReleaseTime"] = boost::any(*autoReleaseTime);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkAttributes") != m.end() && !m["NetworkAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkAttributes"].type()) {
        AllocateDedicatedHostsRequestNetworkAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkAttributes"]));
        networkAttributes = make_shared<AllocateDedicatedHostsRequestNetworkAttributes>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<AllocateDedicatedHostsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AllocateDedicatedHostsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<AllocateDedicatedHostsRequestTag>>(expect1);
      }
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("DedicatedHostName") != m.end() && !m["DedicatedHostName"].empty()) {
      dedicatedHostName = make_shared<string>(boost::any_cast<string>(m["DedicatedHostName"]));
    }
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
    if (m.find("DedicatedHostType") != m.end() && !m["DedicatedHostType"].empty()) {
      dedicatedHostType = make_shared<string>(boost::any_cast<string>(m["DedicatedHostType"]));
    }
    if (m.find("ActionOnMaintenance") != m.end() && !m["ActionOnMaintenance"].empty()) {
      actionOnMaintenance = make_shared<string>(boost::any_cast<string>(m["ActionOnMaintenance"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("AutoPlacement") != m.end() && !m["AutoPlacement"].empty()) {
      autoPlacement = make_shared<string>(boost::any_cast<string>(m["AutoPlacement"]));
    }
    if (m.find("CpuOverCommitRatio") != m.end() && !m["CpuOverCommitRatio"].empty()) {
      cpuOverCommitRatio = make_shared<double>(boost::any_cast<double>(m["CpuOverCommitRatio"]));
    }
    if (m.find("MinQuantity") != m.end() && !m["MinQuantity"].empty()) {
      minQuantity = make_shared<long>(boost::any_cast<long>(m["MinQuantity"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("AutoRenewPeriod") != m.end() && !m["AutoRenewPeriod"].empty()) {
      autoRenewPeriod = make_shared<long>(boost::any_cast<long>(m["AutoRenewPeriod"]));
    }
    if (m.find("AutoReleaseTime") != m.end() && !m["AutoReleaseTime"].empty()) {
      autoReleaseTime = make_shared<string>(boost::any_cast<string>(m["AutoReleaseTime"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~AllocateDedicatedHostsRequest() = default;
};
class AllocateDedicatedHostsResponseBodyDedicatedHostIdSets : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dedicatedHostId{};

  AllocateDedicatedHostsResponseBodyDedicatedHostIdSets() {}

  explicit AllocateDedicatedHostsResponseBodyDedicatedHostIdSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DedicatedHostId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DedicatedHostId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dedicatedHostId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AllocateDedicatedHostsResponseBodyDedicatedHostIdSets() = default;
};
class AllocateDedicatedHostsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<AllocateDedicatedHostsResponseBodyDedicatedHostIdSets> dedicatedHostIdSets{};

  AllocateDedicatedHostsResponseBody() {}

  explicit AllocateDedicatedHostsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (dedicatedHostIdSets) {
      res["DedicatedHostIdSets"] = dedicatedHostIdSets ? boost::any(dedicatedHostIdSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DedicatedHostIdSets") != m.end() && !m["DedicatedHostIdSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedHostIdSets"].type()) {
        AllocateDedicatedHostsResponseBodyDedicatedHostIdSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedHostIdSets"]));
        dedicatedHostIdSets = make_shared<AllocateDedicatedHostsResponseBodyDedicatedHostIdSets>(model1);
      }
    }
  }


  virtual ~AllocateDedicatedHostsResponseBody() = default;
};
class AllocateDedicatedHostsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AllocateDedicatedHostsResponseBody> body{};

  AllocateDedicatedHostsResponse() {}

  explicit AllocateDedicatedHostsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AllocateDedicatedHostsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AllocateDedicatedHostsResponseBody>(model1);
      }
    }
  }


  virtual ~AllocateDedicatedHostsResponse() = default;
};
class AllocateEipAddressRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> bandwidth{};
  shared_ptr<string> ISP{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> activityId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> clientToken{};

  AllocateEipAddressRequest() {}

  explicit AllocateEipAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (ISP) {
      res["ISP"] = boost::any(*ISP);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (activityId) {
      res["ActivityId"] = boost::any(*activityId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<string>(boost::any_cast<string>(m["Bandwidth"]));
    }
    if (m.find("ISP") != m.end() && !m["ISP"].empty()) {
      ISP = make_shared<string>(boost::any_cast<string>(m["ISP"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("ActivityId") != m.end() && !m["ActivityId"].empty()) {
      activityId = make_shared<long>(boost::any_cast<long>(m["ActivityId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~AllocateEipAddressRequest() = default;
};
class AllocateEipAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> allocationId{};
  shared_ptr<string> eipAddress{};

  AllocateEipAddressResponseBody() {}

  explicit AllocateEipAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (eipAddress) {
      res["EipAddress"] = boost::any(*eipAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("EipAddress") != m.end() && !m["EipAddress"].empty()) {
      eipAddress = make_shared<string>(boost::any_cast<string>(m["EipAddress"]));
    }
  }


  virtual ~AllocateEipAddressResponseBody() = default;
};
class AllocateEipAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AllocateEipAddressResponseBody> body{};

  AllocateEipAddressResponse() {}

  explicit AllocateEipAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AllocateEipAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AllocateEipAddressResponseBody>(model1);
      }
    }
  }


  virtual ~AllocateEipAddressResponse() = default;
};
class AllocatePublicIpAddressRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> vlanId{};
  shared_ptr<string> ownerAccount{};

  AllocatePublicIpAddressRequest() {}

  explicit AllocatePublicIpAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (vlanId) {
      res["VlanId"] = boost::any(*vlanId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("VlanId") != m.end() && !m["VlanId"].empty()) {
      vlanId = make_shared<string>(boost::any_cast<string>(m["VlanId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~AllocatePublicIpAddressRequest() = default;
};
class AllocatePublicIpAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> ipAddress{};
  shared_ptr<string> requestId{};

  AllocatePublicIpAddressResponseBody() {}

  explicit AllocatePublicIpAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AllocatePublicIpAddressResponseBody() = default;
};
class AllocatePublicIpAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AllocatePublicIpAddressResponseBody> body{};

  AllocatePublicIpAddressResponse() {}

  explicit AllocatePublicIpAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AllocatePublicIpAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AllocatePublicIpAddressResponseBody>(model1);
      }
    }
  }


  virtual ~AllocatePublicIpAddressResponse() = default;
};
class ApplyAutoSnapshotPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<string> diskIds{};

  ApplyAutoSnapshotPolicyRequest() {}

  explicit ApplyAutoSnapshotPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["regionId"] = boost::any(*regionId);
    }
    if (autoSnapshotPolicyId) {
      res["autoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    if (diskIds) {
      res["diskIds"] = boost::any(*diskIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("regionId") != m.end() && !m["regionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["regionId"]));
    }
    if (m.find("autoSnapshotPolicyId") != m.end() && !m["autoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["autoSnapshotPolicyId"]));
    }
    if (m.find("diskIds") != m.end() && !m["diskIds"].empty()) {
      diskIds = make_shared<string>(boost::any_cast<string>(m["diskIds"]));
    }
  }


  virtual ~ApplyAutoSnapshotPolicyRequest() = default;
};
class ApplyAutoSnapshotPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ApplyAutoSnapshotPolicyResponseBody() {}

  explicit ApplyAutoSnapshotPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ApplyAutoSnapshotPolicyResponseBody() = default;
};
class ApplyAutoSnapshotPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ApplyAutoSnapshotPolicyResponseBody> body{};

  ApplyAutoSnapshotPolicyResponse() {}

  explicit ApplyAutoSnapshotPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyAutoSnapshotPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyAutoSnapshotPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyAutoSnapshotPolicyResponse() = default;
};
class AssignIpv6AddressesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<long> ipv6AddressCount{};
  shared_ptr<vector<string>> ipv6Address{};

  AssignIpv6AddressesRequest() {}

  explicit AssignIpv6AddressesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (ipv6AddressCount) {
      res["Ipv6AddressCount"] = boost::any(*ipv6AddressCount);
    }
    if (ipv6Address) {
      res["Ipv6Address"] = boost::any(*ipv6Address);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("Ipv6AddressCount") != m.end() && !m["Ipv6AddressCount"].empty()) {
      ipv6AddressCount = make_shared<long>(boost::any_cast<long>(m["Ipv6AddressCount"]));
    }
    if (m.find("Ipv6Address") != m.end() && !m["Ipv6Address"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ipv6Address"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ipv6Address"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipv6Address = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AssignIpv6AddressesRequest() = default;
};
class AssignIpv6AddressesResponseBodyIpv6Sets : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ipv6Address{};

  AssignIpv6AddressesResponseBodyIpv6Sets() {}

  explicit AssignIpv6AddressesResponseBodyIpv6Sets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6Address) {
      res["Ipv6Address"] = boost::any(*ipv6Address);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6Address") != m.end() && !m["Ipv6Address"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ipv6Address"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ipv6Address"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipv6Address = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AssignIpv6AddressesResponseBodyIpv6Sets() = default;
};
class AssignIpv6AddressesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<AssignIpv6AddressesResponseBodyIpv6Sets> ipv6Sets{};

  AssignIpv6AddressesResponseBody() {}

  explicit AssignIpv6AddressesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (ipv6Sets) {
      res["Ipv6Sets"] = ipv6Sets ? boost::any(ipv6Sets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("Ipv6Sets") != m.end() && !m["Ipv6Sets"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ipv6Sets"].type()) {
        AssignIpv6AddressesResponseBodyIpv6Sets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ipv6Sets"]));
        ipv6Sets = make_shared<AssignIpv6AddressesResponseBodyIpv6Sets>(model1);
      }
    }
  }


  virtual ~AssignIpv6AddressesResponseBody() = default;
};
class AssignIpv6AddressesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AssignIpv6AddressesResponseBody> body{};

  AssignIpv6AddressesResponse() {}

  explicit AssignIpv6AddressesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssignIpv6AddressesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssignIpv6AddressesResponseBody>(model1);
      }
    }
  }


  virtual ~AssignIpv6AddressesResponse() = default;
};
class AssignPrivateIpAddressesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<long> secondaryPrivateIpAddressCount{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<string>> privateIpAddress{};

  AssignPrivateIpAddressesRequest() {}

  explicit AssignPrivateIpAddressesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (secondaryPrivateIpAddressCount) {
      res["SecondaryPrivateIpAddressCount"] = boost::any(*secondaryPrivateIpAddressCount);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("SecondaryPrivateIpAddressCount") != m.end() && !m["SecondaryPrivateIpAddressCount"].empty()) {
      secondaryPrivateIpAddressCount = make_shared<long>(boost::any_cast<long>(m["SecondaryPrivateIpAddressCount"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrivateIpAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrivateIpAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      privateIpAddress = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AssignPrivateIpAddressesRequest() = default;
};
class AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSetPrivateIpSet : public Darabonba::Model {
public:
  shared_ptr<vector<string>> privateIpAddress{};

  AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSetPrivateIpSet() {}

  explicit AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSetPrivateIpSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrivateIpAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrivateIpAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      privateIpAddress = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSetPrivateIpSet() = default;
};
class AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSet : public Darabonba::Model {
public:
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSetPrivateIpSet> privateIpSet{};

  AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSet() {}

  explicit AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (privateIpSet) {
      res["PrivateIpSet"] = privateIpSet ? boost::any(privateIpSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("PrivateIpSet") != m.end() && !m["PrivateIpSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivateIpSet"].type()) {
        AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSetPrivateIpSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivateIpSet"]));
        privateIpSet = make_shared<AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSetPrivateIpSet>(model1);
      }
    }
  }


  virtual ~AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSet() = default;
};
class AssignPrivateIpAddressesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSet> assignedPrivateIpAddressesSet{};

  AssignPrivateIpAddressesResponseBody() {}

  explicit AssignPrivateIpAddressesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (assignedPrivateIpAddressesSet) {
      res["AssignedPrivateIpAddressesSet"] = assignedPrivateIpAddressesSet ? boost::any(assignedPrivateIpAddressesSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("AssignedPrivateIpAddressesSet") != m.end() && !m["AssignedPrivateIpAddressesSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["AssignedPrivateIpAddressesSet"].type()) {
        AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AssignedPrivateIpAddressesSet"]));
        assignedPrivateIpAddressesSet = make_shared<AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSet>(model1);
      }
    }
  }


  virtual ~AssignPrivateIpAddressesResponseBody() = default;
};
class AssignPrivateIpAddressesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AssignPrivateIpAddressesResponseBody> body{};

  AssignPrivateIpAddressesResponse() {}

  explicit AssignPrivateIpAddressesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssignPrivateIpAddressesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssignPrivateIpAddressesResponseBody>(model1);
      }
    }
  }


  virtual ~AssignPrivateIpAddressesResponse() = default;
};
class AssociateEipAddressRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> allocationId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> instanceType{};

  AssociateEipAddressRequest() {}

  explicit AssociateEipAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
  }


  virtual ~AssociateEipAddressRequest() = default;
};
class AssociateEipAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AssociateEipAddressResponseBody() {}

  explicit AssociateEipAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AssociateEipAddressResponseBody() = default;
};
class AssociateEipAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AssociateEipAddressResponseBody> body{};

  AssociateEipAddressResponse() {}

  explicit AssociateEipAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociateEipAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociateEipAddressResponseBody>(model1);
      }
    }
  }


  virtual ~AssociateEipAddressResponse() = default;
};
class AssociateHaVipRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> haVipId{};
  shared_ptr<string> instanceId{};

  AssociateHaVipRequest() {}

  explicit AssociateHaVipRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (haVipId) {
      res["HaVipId"] = boost::any(*haVipId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("HaVipId") != m.end() && !m["HaVipId"].empty()) {
      haVipId = make_shared<string>(boost::any_cast<string>(m["HaVipId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~AssociateHaVipRequest() = default;
};
class AssociateHaVipResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AssociateHaVipResponseBody() {}

  explicit AssociateHaVipResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AssociateHaVipResponseBody() = default;
};
class AssociateHaVipResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AssociateHaVipResponseBody> body{};

  AssociateHaVipResponse() {}

  explicit AssociateHaVipResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociateHaVipResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociateHaVipResponseBody>(model1);
      }
    }
  }


  virtual ~AssociateHaVipResponse() = default;
};
class AttachClassicLinkVpcRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> vpcId{};

  AttachClassicLinkVpcRequest() {}

  explicit AttachClassicLinkVpcRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~AttachClassicLinkVpcRequest() = default;
};
class AttachClassicLinkVpcResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AttachClassicLinkVpcResponseBody() {}

  explicit AttachClassicLinkVpcResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AttachClassicLinkVpcResponseBody() = default;
};
class AttachClassicLinkVpcResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AttachClassicLinkVpcResponseBody> body{};

  AttachClassicLinkVpcResponse() {}

  explicit AttachClassicLinkVpcResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachClassicLinkVpcResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachClassicLinkVpcResponseBody>(model1);
      }
    }
  }


  virtual ~AttachClassicLinkVpcResponse() = default;
};
class AttachDiskRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> diskId{};
  shared_ptr<string> device{};
  shared_ptr<bool> deleteWithInstance{};
  shared_ptr<bool> bootable{};
  shared_ptr<string> password{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> ownerAccount{};

  AttachDiskRequest() {}

  explicit AttachDiskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    if (bootable) {
      res["Bootable"] = boost::any(*bootable);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<bool>(boost::any_cast<bool>(m["DeleteWithInstance"]));
    }
    if (m.find("Bootable") != m.end() && !m["Bootable"].empty()) {
      bootable = make_shared<bool>(boost::any_cast<bool>(m["Bootable"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~AttachDiskRequest() = default;
};
class AttachDiskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AttachDiskResponseBody() {}

  explicit AttachDiskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AttachDiskResponseBody() = default;
};
class AttachDiskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AttachDiskResponseBody> body{};

  AttachDiskResponse() {}

  explicit AttachDiskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachDiskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachDiskResponseBody>(model1);
      }
    }
  }


  virtual ~AttachDiskResponse() = default;
};
class AttachInstanceRamRoleRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ramRoleName{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> policy{};

  AttachInstanceRamRoleRequest() {}

  explicit AttachInstanceRamRoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
  }


  virtual ~AttachInstanceRamRoleRequest() = default;
};
class AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResultsAttachInstanceRamRoleResult : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> success{};

  AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResultsAttachInstanceRamRoleResult() {}

  explicit AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResultsAttachInstanceRamRoleResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResultsAttachInstanceRamRoleResult() = default;
};
class AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResults : public Darabonba::Model {
public:
  shared_ptr<vector<AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResultsAttachInstanceRamRoleResult>> attachInstanceRamRoleResult{};

  AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResults() {}

  explicit AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachInstanceRamRoleResult) {
      vector<boost::any> temp1;
      for(auto item1:*attachInstanceRamRoleResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AttachInstanceRamRoleResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachInstanceRamRoleResult") != m.end() && !m["AttachInstanceRamRoleResult"].empty()) {
      if (typeid(vector<boost::any>) == m["AttachInstanceRamRoleResult"].type()) {
        vector<AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResultsAttachInstanceRamRoleResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AttachInstanceRamRoleResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResultsAttachInstanceRamRoleResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attachInstanceRamRoleResult = make_shared<vector<AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResultsAttachInstanceRamRoleResult>>(expect1);
      }
    }
  }


  virtual ~AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResults() = default;
};
class AttachInstanceRamRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> ramRoleName{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> failCount{};
  shared_ptr<AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResults> attachInstanceRamRoleResults{};

  AttachInstanceRamRoleResponseBody() {}

  explicit AttachInstanceRamRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (failCount) {
      res["FailCount"] = boost::any(*failCount);
    }
    if (attachInstanceRamRoleResults) {
      res["AttachInstanceRamRoleResults"] = attachInstanceRamRoleResults ? boost::any(attachInstanceRamRoleResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("FailCount") != m.end() && !m["FailCount"].empty()) {
      failCount = make_shared<long>(boost::any_cast<long>(m["FailCount"]));
    }
    if (m.find("AttachInstanceRamRoleResults") != m.end() && !m["AttachInstanceRamRoleResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["AttachInstanceRamRoleResults"].type()) {
        AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AttachInstanceRamRoleResults"]));
        attachInstanceRamRoleResults = make_shared<AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResults>(model1);
      }
    }
  }


  virtual ~AttachInstanceRamRoleResponseBody() = default;
};
class AttachInstanceRamRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AttachInstanceRamRoleResponseBody> body{};

  AttachInstanceRamRoleResponse() {}

  explicit AttachInstanceRamRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachInstanceRamRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachInstanceRamRoleResponseBody>(model1);
      }
    }
  }


  virtual ~AttachInstanceRamRoleResponse() = default;
};
class AttachKeyPairRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> instanceIds{};

  AttachKeyPairRequest() {}

  explicit AttachKeyPairRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
  }


  virtual ~AttachKeyPairRequest() = default;
};
class AttachKeyPairResponseBodyResultsResult : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> success{};

  AttachKeyPairResponseBodyResultsResult() {}

  explicit AttachKeyPairResponseBodyResultsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~AttachKeyPairResponseBodyResultsResult() = default;
};
class AttachKeyPairResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<vector<AttachKeyPairResponseBodyResultsResult>> result{};

  AttachKeyPairResponseBodyResults() {}

  explicit AttachKeyPairResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<AttachKeyPairResponseBodyResultsResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachKeyPairResponseBodyResultsResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<AttachKeyPairResponseBodyResultsResult>>(expect1);
      }
    }
  }


  virtual ~AttachKeyPairResponseBodyResults() = default;
};
class AttachKeyPairResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> keyPairName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> totalCount{};
  shared_ptr<string> failCount{};
  shared_ptr<AttachKeyPairResponseBodyResults> results{};

  AttachKeyPairResponseBody() {}

  explicit AttachKeyPairResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (failCount) {
      res["FailCount"] = boost::any(*failCount);
    }
    if (results) {
      res["Results"] = results ? boost::any(results->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
    if (m.find("FailCount") != m.end() && !m["FailCount"].empty()) {
      failCount = make_shared<string>(boost::any_cast<string>(m["FailCount"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(map<string, boost::any>) == m["Results"].type()) {
        AttachKeyPairResponseBodyResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Results"]));
        results = make_shared<AttachKeyPairResponseBodyResults>(model1);
      }
    }
  }


  virtual ~AttachKeyPairResponseBody() = default;
};
class AttachKeyPairResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AttachKeyPairResponseBody> body{};

  AttachKeyPairResponse() {}

  explicit AttachKeyPairResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachKeyPairResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachKeyPairResponseBody>(model1);
      }
    }
  }


  virtual ~AttachKeyPairResponse() = default;
};
class AttachNetworkInterfaceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> trunkNetworkInstanceId{};
  shared_ptr<bool> waitForNetworkConfigurationReady{};

  AttachNetworkInterfaceRequest() {}

  explicit AttachNetworkInterfaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (trunkNetworkInstanceId) {
      res["TrunkNetworkInstanceId"] = boost::any(*trunkNetworkInstanceId);
    }
    if (waitForNetworkConfigurationReady) {
      res["WaitForNetworkConfigurationReady"] = boost::any(*waitForNetworkConfigurationReady);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TrunkNetworkInstanceId") != m.end() && !m["TrunkNetworkInstanceId"].empty()) {
      trunkNetworkInstanceId = make_shared<string>(boost::any_cast<string>(m["TrunkNetworkInstanceId"]));
    }
    if (m.find("WaitForNetworkConfigurationReady") != m.end() && !m["WaitForNetworkConfigurationReady"].empty()) {
      waitForNetworkConfigurationReady = make_shared<bool>(boost::any_cast<bool>(m["WaitForNetworkConfigurationReady"]));
    }
  }


  virtual ~AttachNetworkInterfaceRequest() = default;
};
class AttachNetworkInterfaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AttachNetworkInterfaceResponseBody() {}

  explicit AttachNetworkInterfaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AttachNetworkInterfaceResponseBody() = default;
};
class AttachNetworkInterfaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AttachNetworkInterfaceResponseBody> body{};

  AttachNetworkInterfaceResponse() {}

  explicit AttachNetworkInterfaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachNetworkInterfaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachNetworkInterfaceResponseBody>(model1);
      }
    }
  }


  virtual ~AttachNetworkInterfaceResponse() = default;
};
class AuthorizeSecurityGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> portRange{};
  shared_ptr<string> sourceGroupId{};
  shared_ptr<long> sourceGroupOwnerId{};
  shared_ptr<string> sourceGroupOwnerAccount{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> ipv6SourceCidrIp{};
  shared_ptr<string> sourcePrefixListId{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<string> destCidrIp{};
  shared_ptr<string> ipv6DestCidrIp{};
  shared_ptr<string> policy{};
  shared_ptr<string> priority{};
  shared_ptr<string> nicType{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};

  AuthorizeSecurityGroupRequest() {}

  explicit AuthorizeSecurityGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (sourceGroupId) {
      res["SourceGroupId"] = boost::any(*sourceGroupId);
    }
    if (sourceGroupOwnerId) {
      res["SourceGroupOwnerId"] = boost::any(*sourceGroupOwnerId);
    }
    if (sourceGroupOwnerAccount) {
      res["SourceGroupOwnerAccount"] = boost::any(*sourceGroupOwnerAccount);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (ipv6SourceCidrIp) {
      res["Ipv6SourceCidrIp"] = boost::any(*ipv6SourceCidrIp);
    }
    if (sourcePrefixListId) {
      res["SourcePrefixListId"] = boost::any(*sourcePrefixListId);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (destCidrIp) {
      res["DestCidrIp"] = boost::any(*destCidrIp);
    }
    if (ipv6DestCidrIp) {
      res["Ipv6DestCidrIp"] = boost::any(*ipv6DestCidrIp);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (nicType) {
      res["NicType"] = boost::any(*nicType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("SourceGroupId") != m.end() && !m["SourceGroupId"].empty()) {
      sourceGroupId = make_shared<string>(boost::any_cast<string>(m["SourceGroupId"]));
    }
    if (m.find("SourceGroupOwnerId") != m.end() && !m["SourceGroupOwnerId"].empty()) {
      sourceGroupOwnerId = make_shared<long>(boost::any_cast<long>(m["SourceGroupOwnerId"]));
    }
    if (m.find("SourceGroupOwnerAccount") != m.end() && !m["SourceGroupOwnerAccount"].empty()) {
      sourceGroupOwnerAccount = make_shared<string>(boost::any_cast<string>(m["SourceGroupOwnerAccount"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("Ipv6SourceCidrIp") != m.end() && !m["Ipv6SourceCidrIp"].empty()) {
      ipv6SourceCidrIp = make_shared<string>(boost::any_cast<string>(m["Ipv6SourceCidrIp"]));
    }
    if (m.find("SourcePrefixListId") != m.end() && !m["SourcePrefixListId"].empty()) {
      sourcePrefixListId = make_shared<string>(boost::any_cast<string>(m["SourcePrefixListId"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("DestCidrIp") != m.end() && !m["DestCidrIp"].empty()) {
      destCidrIp = make_shared<string>(boost::any_cast<string>(m["DestCidrIp"]));
    }
    if (m.find("Ipv6DestCidrIp") != m.end() && !m["Ipv6DestCidrIp"].empty()) {
      ipv6DestCidrIp = make_shared<string>(boost::any_cast<string>(m["Ipv6DestCidrIp"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("NicType") != m.end() && !m["NicType"].empty()) {
      nicType = make_shared<string>(boost::any_cast<string>(m["NicType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~AuthorizeSecurityGroupRequest() = default;
};
class AuthorizeSecurityGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AuthorizeSecurityGroupResponseBody() {}

  explicit AuthorizeSecurityGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AuthorizeSecurityGroupResponseBody() = default;
};
class AuthorizeSecurityGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AuthorizeSecurityGroupResponseBody> body{};

  AuthorizeSecurityGroupResponse() {}

  explicit AuthorizeSecurityGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AuthorizeSecurityGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AuthorizeSecurityGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AuthorizeSecurityGroupResponse() = default;
};
class AuthorizeSecurityGroupEgressRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> portRange{};
  shared_ptr<string> destGroupId{};
  shared_ptr<long> destGroupOwnerId{};
  shared_ptr<string> destGroupOwnerAccount{};
  shared_ptr<string> destCidrIp{};
  shared_ptr<string> ipv6DestCidrIp{};
  shared_ptr<string> destPrefixListId{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> ipv6SourceCidrIp{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<string> policy{};
  shared_ptr<string> priority{};
  shared_ptr<string> nicType{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};

  AuthorizeSecurityGroupEgressRequest() {}

  explicit AuthorizeSecurityGroupEgressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (destGroupId) {
      res["DestGroupId"] = boost::any(*destGroupId);
    }
    if (destGroupOwnerId) {
      res["DestGroupOwnerId"] = boost::any(*destGroupOwnerId);
    }
    if (destGroupOwnerAccount) {
      res["DestGroupOwnerAccount"] = boost::any(*destGroupOwnerAccount);
    }
    if (destCidrIp) {
      res["DestCidrIp"] = boost::any(*destCidrIp);
    }
    if (ipv6DestCidrIp) {
      res["Ipv6DestCidrIp"] = boost::any(*ipv6DestCidrIp);
    }
    if (destPrefixListId) {
      res["DestPrefixListId"] = boost::any(*destPrefixListId);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (ipv6SourceCidrIp) {
      res["Ipv6SourceCidrIp"] = boost::any(*ipv6SourceCidrIp);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (nicType) {
      res["NicType"] = boost::any(*nicType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("DestGroupId") != m.end() && !m["DestGroupId"].empty()) {
      destGroupId = make_shared<string>(boost::any_cast<string>(m["DestGroupId"]));
    }
    if (m.find("DestGroupOwnerId") != m.end() && !m["DestGroupOwnerId"].empty()) {
      destGroupOwnerId = make_shared<long>(boost::any_cast<long>(m["DestGroupOwnerId"]));
    }
    if (m.find("DestGroupOwnerAccount") != m.end() && !m["DestGroupOwnerAccount"].empty()) {
      destGroupOwnerAccount = make_shared<string>(boost::any_cast<string>(m["DestGroupOwnerAccount"]));
    }
    if (m.find("DestCidrIp") != m.end() && !m["DestCidrIp"].empty()) {
      destCidrIp = make_shared<string>(boost::any_cast<string>(m["DestCidrIp"]));
    }
    if (m.find("Ipv6DestCidrIp") != m.end() && !m["Ipv6DestCidrIp"].empty()) {
      ipv6DestCidrIp = make_shared<string>(boost::any_cast<string>(m["Ipv6DestCidrIp"]));
    }
    if (m.find("DestPrefixListId") != m.end() && !m["DestPrefixListId"].empty()) {
      destPrefixListId = make_shared<string>(boost::any_cast<string>(m["DestPrefixListId"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("Ipv6SourceCidrIp") != m.end() && !m["Ipv6SourceCidrIp"].empty()) {
      ipv6SourceCidrIp = make_shared<string>(boost::any_cast<string>(m["Ipv6SourceCidrIp"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("NicType") != m.end() && !m["NicType"].empty()) {
      nicType = make_shared<string>(boost::any_cast<string>(m["NicType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~AuthorizeSecurityGroupEgressRequest() = default;
};
class AuthorizeSecurityGroupEgressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AuthorizeSecurityGroupEgressResponseBody() {}

  explicit AuthorizeSecurityGroupEgressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AuthorizeSecurityGroupEgressResponseBody() = default;
};
class AuthorizeSecurityGroupEgressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AuthorizeSecurityGroupEgressResponseBody> body{};

  AuthorizeSecurityGroupEgressResponse() {}

  explicit AuthorizeSecurityGroupEgressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AuthorizeSecurityGroupEgressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AuthorizeSecurityGroupEgressResponseBody>(model1);
      }
    }
  }


  virtual ~AuthorizeSecurityGroupEgressResponse() = default;
};
class CancelAutoSnapshotPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> diskIds{};

  CancelAutoSnapshotPolicyRequest() {}

  explicit CancelAutoSnapshotPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["regionId"] = boost::any(*regionId);
    }
    if (diskIds) {
      res["diskIds"] = boost::any(*diskIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("regionId") != m.end() && !m["regionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["regionId"]));
    }
    if (m.find("diskIds") != m.end() && !m["diskIds"].empty()) {
      diskIds = make_shared<string>(boost::any_cast<string>(m["diskIds"]));
    }
  }


  virtual ~CancelAutoSnapshotPolicyRequest() = default;
};
class CancelAutoSnapshotPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CancelAutoSnapshotPolicyResponseBody() {}

  explicit CancelAutoSnapshotPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelAutoSnapshotPolicyResponseBody() = default;
};
class CancelAutoSnapshotPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CancelAutoSnapshotPolicyResponseBody> body{};

  CancelAutoSnapshotPolicyResponse() {}

  explicit CancelAutoSnapshotPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelAutoSnapshotPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelAutoSnapshotPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~CancelAutoSnapshotPolicyResponse() = default;
};
class CancelCopyImageRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> ownerAccount{};

  CancelCopyImageRequest() {}

  explicit CancelCopyImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~CancelCopyImageRequest() = default;
};
class CancelCopyImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CancelCopyImageResponseBody() {}

  explicit CancelCopyImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelCopyImageResponseBody() = default;
};
class CancelCopyImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CancelCopyImageResponseBody> body{};

  CancelCopyImageResponse() {}

  explicit CancelCopyImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelCopyImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelCopyImageResponseBody>(model1);
      }
    }
  }


  virtual ~CancelCopyImageResponse() = default;
};
class CancelImagePipelineExecutionRequestTemplateTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CancelImagePipelineExecutionRequestTemplateTag() {}

  explicit CancelImagePipelineExecutionRequestTemplateTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CancelImagePipelineExecutionRequestTemplateTag() = default;
};
class CancelImagePipelineExecutionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<CancelImagePipelineExecutionRequestTemplateTag>> templateTag{};
  shared_ptr<string> executionId{};

  CancelImagePipelineExecutionRequest() {}

  explicit CancelImagePipelineExecutionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (templateTag) {
      vector<boost::any> temp1;
      for(auto item1:*templateTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TemplateTag"] = boost::any(temp1);
    }
    if (executionId) {
      res["ExecutionId"] = boost::any(*executionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TemplateTag") != m.end() && !m["TemplateTag"].empty()) {
      if (typeid(vector<boost::any>) == m["TemplateTag"].type()) {
        vector<CancelImagePipelineExecutionRequestTemplateTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TemplateTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CancelImagePipelineExecutionRequestTemplateTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templateTag = make_shared<vector<CancelImagePipelineExecutionRequestTemplateTag>>(expect1);
      }
    }
    if (m.find("ExecutionId") != m.end() && !m["ExecutionId"].empty()) {
      executionId = make_shared<string>(boost::any_cast<string>(m["ExecutionId"]));
    }
  }


  virtual ~CancelImagePipelineExecutionRequest() = default;
};
class CancelImagePipelineExecutionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CancelImagePipelineExecutionResponseBody() {}

  explicit CancelImagePipelineExecutionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelImagePipelineExecutionResponseBody() = default;
};
class CancelImagePipelineExecutionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CancelImagePipelineExecutionResponseBody> body{};

  CancelImagePipelineExecutionResponse() {}

  explicit CancelImagePipelineExecutionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelImagePipelineExecutionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelImagePipelineExecutionResponseBody>(model1);
      }
    }
  }


  virtual ~CancelImagePipelineExecutionResponse() = default;
};
class CancelPhysicalConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> userCidr{};

  CancelPhysicalConnectionRequest() {}

  explicit CancelPhysicalConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (userCidr) {
      res["UserCidr"] = boost::any(*userCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("UserCidr") != m.end() && !m["UserCidr"].empty()) {
      userCidr = make_shared<string>(boost::any_cast<string>(m["UserCidr"]));
    }
  }


  virtual ~CancelPhysicalConnectionRequest() = default;
};
class CancelPhysicalConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CancelPhysicalConnectionResponseBody() {}

  explicit CancelPhysicalConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelPhysicalConnectionResponseBody() = default;
};
class CancelPhysicalConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CancelPhysicalConnectionResponseBody> body{};

  CancelPhysicalConnectionResponse() {}

  explicit CancelPhysicalConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelPhysicalConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelPhysicalConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~CancelPhysicalConnectionResponse() = default;
};
class CancelSimulatedSystemEventsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> eventId{};

  CancelSimulatedSystemEventsRequest() {}

  explicit CancelSimulatedSystemEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EventId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EventId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eventId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CancelSimulatedSystemEventsRequest() = default;
};
class CancelSimulatedSystemEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CancelSimulatedSystemEventsResponseBody() {}

  explicit CancelSimulatedSystemEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelSimulatedSystemEventsResponseBody() = default;
};
class CancelSimulatedSystemEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CancelSimulatedSystemEventsResponseBody> body{};

  CancelSimulatedSystemEventsResponse() {}

  explicit CancelSimulatedSystemEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelSimulatedSystemEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelSimulatedSystemEventsResponseBody>(model1);
      }
    }
  }


  virtual ~CancelSimulatedSystemEventsResponse() = default;
};
class CancelTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};

  CancelTaskRequest() {}

  explicit CancelTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CancelTaskRequest() = default;
};
class CancelTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CancelTaskResponseBody() {}

  explicit CancelTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelTaskResponseBody() = default;
};
class CancelTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CancelTaskResponseBody> body{};

  CancelTaskResponse() {}

  explicit CancelTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CancelTaskResponse() = default;
};
class ConnectRouterInterfaceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> routerInterfaceId{};

  ConnectRouterInterfaceRequest() {}

  explicit ConnectRouterInterfaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (routerInterfaceId) {
      res["RouterInterfaceId"] = boost::any(*routerInterfaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RouterInterfaceId") != m.end() && !m["RouterInterfaceId"].empty()) {
      routerInterfaceId = make_shared<string>(boost::any_cast<string>(m["RouterInterfaceId"]));
    }
  }


  virtual ~ConnectRouterInterfaceRequest() = default;
};
class ConnectRouterInterfaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ConnectRouterInterfaceResponseBody() {}

  explicit ConnectRouterInterfaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConnectRouterInterfaceResponseBody() = default;
};
class ConnectRouterInterfaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ConnectRouterInterfaceResponseBody> body{};

  ConnectRouterInterfaceResponse() {}

  explicit ConnectRouterInterfaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConnectRouterInterfaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConnectRouterInterfaceResponseBody>(model1);
      }
    }
  }


  virtual ~ConnectRouterInterfaceResponse() = default;
};
class ConvertNatPublicIpToEipRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  ConvertNatPublicIpToEipRequest() {}

  explicit ConvertNatPublicIpToEipRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ConvertNatPublicIpToEipRequest() = default;
};
class ConvertNatPublicIpToEipResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ConvertNatPublicIpToEipResponseBody() {}

  explicit ConvertNatPublicIpToEipResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConvertNatPublicIpToEipResponseBody() = default;
};
class ConvertNatPublicIpToEipResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ConvertNatPublicIpToEipResponseBody> body{};

  ConvertNatPublicIpToEipResponse() {}

  explicit ConvertNatPublicIpToEipResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConvertNatPublicIpToEipResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConvertNatPublicIpToEipResponseBody>(model1);
      }
    }
  }


  virtual ~ConvertNatPublicIpToEipResponse() = default;
};
class CopyImageRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CopyImageRequestTag() {}

  explicit CopyImageRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CopyImageRequestTag() = default;
};
class CopyImageRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> destinationImageName{};
  shared_ptr<string> destinationDescription{};
  shared_ptr<string> imageId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> destinationRegionId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<bool> encrypted{};
  shared_ptr<string> KMSKeyId{};
  shared_ptr<string> encryptAlgorithm{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<CopyImageRequestTag>> tag{};

  CopyImageRequest() {}

  explicit CopyImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (destinationImageName) {
      res["DestinationImageName"] = boost::any(*destinationImageName);
    }
    if (destinationDescription) {
      res["DestinationDescription"] = boost::any(*destinationDescription);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (destinationRegionId) {
      res["DestinationRegionId"] = boost::any(*destinationRegionId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (encryptAlgorithm) {
      res["EncryptAlgorithm"] = boost::any(*encryptAlgorithm);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DestinationImageName") != m.end() && !m["DestinationImageName"].empty()) {
      destinationImageName = make_shared<string>(boost::any_cast<string>(m["DestinationImageName"]));
    }
    if (m.find("DestinationDescription") != m.end() && !m["DestinationDescription"].empty()) {
      destinationDescription = make_shared<string>(boost::any_cast<string>(m["DestinationDescription"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DestinationRegionId") != m.end() && !m["DestinationRegionId"].empty()) {
      destinationRegionId = make_shared<string>(boost::any_cast<string>(m["DestinationRegionId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<bool>(boost::any_cast<bool>(m["Encrypted"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("EncryptAlgorithm") != m.end() && !m["EncryptAlgorithm"].empty()) {
      encryptAlgorithm = make_shared<string>(boost::any_cast<string>(m["EncryptAlgorithm"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CopyImageRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CopyImageRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CopyImageRequestTag>>(expect1);
      }
    }
  }


  virtual ~CopyImageRequest() = default;
};
class CopyImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> requestId{};

  CopyImageResponseBody() {}

  explicit CopyImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CopyImageResponseBody() = default;
};
class CopyImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CopyImageResponseBody> body{};

  CopyImageResponse() {}

  explicit CopyImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CopyImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CopyImageResponseBody>(model1);
      }
    }
  }


  virtual ~CopyImageResponse() = default;
};
class CopySnapshotRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CopySnapshotRequestTag() {}

  explicit CopySnapshotRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CopySnapshotRequestTag() = default;
};
class CopySnapshotRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<CopySnapshotRequestTag>> tag{};
  shared_ptr<string> regionId{};
  shared_ptr<string> destinationRegionId{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> destinationSnapshotName{};
  shared_ptr<string> destinationSnapshotDescription{};
  shared_ptr<long> retentionDays{};

  CopySnapshotRequest() {}

  explicit CopySnapshotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (destinationRegionId) {
      res["DestinationRegionId"] = boost::any(*destinationRegionId);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (destinationSnapshotName) {
      res["DestinationSnapshotName"] = boost::any(*destinationSnapshotName);
    }
    if (destinationSnapshotDescription) {
      res["DestinationSnapshotDescription"] = boost::any(*destinationSnapshotDescription);
    }
    if (retentionDays) {
      res["RetentionDays"] = boost::any(*retentionDays);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CopySnapshotRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CopySnapshotRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CopySnapshotRequestTag>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DestinationRegionId") != m.end() && !m["DestinationRegionId"].empty()) {
      destinationRegionId = make_shared<string>(boost::any_cast<string>(m["DestinationRegionId"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("DestinationSnapshotName") != m.end() && !m["DestinationSnapshotName"].empty()) {
      destinationSnapshotName = make_shared<string>(boost::any_cast<string>(m["DestinationSnapshotName"]));
    }
    if (m.find("DestinationSnapshotDescription") != m.end() && !m["DestinationSnapshotDescription"].empty()) {
      destinationSnapshotDescription = make_shared<string>(boost::any_cast<string>(m["DestinationSnapshotDescription"]));
    }
    if (m.find("RetentionDays") != m.end() && !m["RetentionDays"].empty()) {
      retentionDays = make_shared<long>(boost::any_cast<long>(m["RetentionDays"]));
    }
  }


  virtual ~CopySnapshotRequest() = default;
};
class CopySnapshotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> snapshotId{};
  shared_ptr<string> requestId{};

  CopySnapshotResponseBody() {}

  explicit CopySnapshotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CopySnapshotResponseBody() = default;
};
class CopySnapshotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CopySnapshotResponseBody> body{};

  CopySnapshotResponse() {}

  explicit CopySnapshotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CopySnapshotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CopySnapshotResponseBody>(model1);
      }
    }
  }


  virtual ~CopySnapshotResponse() = default;
};
class CreateActivationRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> description{};
  shared_ptr<long> instanceCount{};
  shared_ptr<long> timeToLiveInHours{};
  shared_ptr<string> ipAddressRange{};

  CreateActivationRequest() {}

  explicit CreateActivationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (timeToLiveInHours) {
      res["TimeToLiveInHours"] = boost::any(*timeToLiveInHours);
    }
    if (ipAddressRange) {
      res["IpAddressRange"] = boost::any(*ipAddressRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("TimeToLiveInHours") != m.end() && !m["TimeToLiveInHours"].empty()) {
      timeToLiveInHours = make_shared<long>(boost::any_cast<long>(m["TimeToLiveInHours"]));
    }
    if (m.find("IpAddressRange") != m.end() && !m["IpAddressRange"].empty()) {
      ipAddressRange = make_shared<string>(boost::any_cast<string>(m["IpAddressRange"]));
    }
  }


  virtual ~CreateActivationRequest() = default;
};
class CreateActivationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> activationCode{};
  shared_ptr<string> activationId{};

  CreateActivationResponseBody() {}

  explicit CreateActivationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (activationCode) {
      res["ActivationCode"] = boost::any(*activationCode);
    }
    if (activationId) {
      res["ActivationId"] = boost::any(*activationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ActivationCode") != m.end() && !m["ActivationCode"].empty()) {
      activationCode = make_shared<string>(boost::any_cast<string>(m["ActivationCode"]));
    }
    if (m.find("ActivationId") != m.end() && !m["ActivationId"].empty()) {
      activationId = make_shared<string>(boost::any_cast<string>(m["ActivationId"]));
    }
  }


  virtual ~CreateActivationResponseBody() = default;
};
class CreateActivationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateActivationResponseBody> body{};

  CreateActivationResponse() {}

  explicit CreateActivationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateActivationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateActivationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateActivationResponse() = default;
};
class CreateAutoProvisioningGroupRequestLaunchConfigurationDataDisk : public Darabonba::Model {
public:
  shared_ptr<string> performanceLevel{};
  shared_ptr<string> kmsKeyId{};
  shared_ptr<string> description{};
  shared_ptr<string> snapshotId{};
  shared_ptr<long> size{};
  shared_ptr<string> device{};
  shared_ptr<string> diskName{};
  shared_ptr<string> category{};
  shared_ptr<bool> deleteWithInstance{};
  shared_ptr<bool> encrypted{};

  CreateAutoProvisioningGroupRequestLaunchConfigurationDataDisk() {}

  explicit CreateAutoProvisioningGroupRequestLaunchConfigurationDataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (kmsKeyId) {
      res["KmsKeyId"] = boost::any(*kmsKeyId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("KmsKeyId") != m.end() && !m["KmsKeyId"].empty()) {
      kmsKeyId = make_shared<string>(boost::any_cast<string>(m["KmsKeyId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<bool>(boost::any_cast<bool>(m["DeleteWithInstance"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<bool>(boost::any_cast<bool>(m["Encrypted"]));
    }
  }


  virtual ~CreateAutoProvisioningGroupRequestLaunchConfigurationDataDisk() = default;
};
class CreateAutoProvisioningGroupRequestLaunchConfigurationTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateAutoProvisioningGroupRequestLaunchConfigurationTag() {}

  explicit CreateAutoProvisioningGroupRequestLaunchConfigurationTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateAutoProvisioningGroupRequestLaunchConfigurationTag() = default;
};
class CreateAutoProvisioningGroupRequestLaunchConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> ioOptimized{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidthIn{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceDescription{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> ramRoleName{};
  shared_ptr<string> securityEnhancementStrategy{};
  shared_ptr<string> userData{};
  shared_ptr<string> systemDiskCategory{};
  shared_ptr<long> systemDiskSize{};
  shared_ptr<string> systemDiskName{};
  shared_ptr<string> systemDiskDescription{};
  shared_ptr<string> systemDiskPerformanceLevel{};
  shared_ptr<bool> passwordInherit{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> creditSpecification{};
  shared_ptr<string> deploymentSetId{};
  shared_ptr<vector<CreateAutoProvisioningGroupRequestLaunchConfigurationDataDisk>> dataDisk{};
  shared_ptr<vector<CreateAutoProvisioningGroupRequestLaunchConfigurationTag>> tag{};
  shared_ptr<vector<string>> hostNames{};

  CreateAutoProvisioningGroupRequestLaunchConfiguration() {}

  explicit CreateAutoProvisioningGroupRequestLaunchConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidthIn) {
      res["InternetMaxBandwidthIn"] = boost::any(*internetMaxBandwidthIn);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceDescription) {
      res["InstanceDescription"] = boost::any(*instanceDescription);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    if (securityEnhancementStrategy) {
      res["SecurityEnhancementStrategy"] = boost::any(*securityEnhancementStrategy);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (systemDiskCategory) {
      res["SystemDiskCategory"] = boost::any(*systemDiskCategory);
    }
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    if (systemDiskName) {
      res["SystemDiskName"] = boost::any(*systemDiskName);
    }
    if (systemDiskDescription) {
      res["SystemDiskDescription"] = boost::any(*systemDiskDescription);
    }
    if (systemDiskPerformanceLevel) {
      res["SystemDiskPerformanceLevel"] = boost::any(*systemDiskPerformanceLevel);
    }
    if (passwordInherit) {
      res["PasswordInherit"] = boost::any(*passwordInherit);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (creditSpecification) {
      res["CreditSpecification"] = boost::any(*creditSpecification);
    }
    if (deploymentSetId) {
      res["DeploymentSetId"] = boost::any(*deploymentSetId);
    }
    if (dataDisk) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisk"] = boost::any(temp1);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (hostNames) {
      res["HostNames"] = boost::any(*hostNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("InternetMaxBandwidthIn") != m.end() && !m["InternetMaxBandwidthIn"].empty()) {
      internetMaxBandwidthIn = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthIn"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceDescription") != m.end() && !m["InstanceDescription"].empty()) {
      instanceDescription = make_shared<string>(boost::any_cast<string>(m["InstanceDescription"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
    if (m.find("SecurityEnhancementStrategy") != m.end() && !m["SecurityEnhancementStrategy"].empty()) {
      securityEnhancementStrategy = make_shared<string>(boost::any_cast<string>(m["SecurityEnhancementStrategy"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("SystemDiskCategory") != m.end() && !m["SystemDiskCategory"].empty()) {
      systemDiskCategory = make_shared<string>(boost::any_cast<string>(m["SystemDiskCategory"]));
    }
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskSize"]));
    }
    if (m.find("SystemDiskName") != m.end() && !m["SystemDiskName"].empty()) {
      systemDiskName = make_shared<string>(boost::any_cast<string>(m["SystemDiskName"]));
    }
    if (m.find("SystemDiskDescription") != m.end() && !m["SystemDiskDescription"].empty()) {
      systemDiskDescription = make_shared<string>(boost::any_cast<string>(m["SystemDiskDescription"]));
    }
    if (m.find("SystemDiskPerformanceLevel") != m.end() && !m["SystemDiskPerformanceLevel"].empty()) {
      systemDiskPerformanceLevel = make_shared<string>(boost::any_cast<string>(m["SystemDiskPerformanceLevel"]));
    }
    if (m.find("PasswordInherit") != m.end() && !m["PasswordInherit"].empty()) {
      passwordInherit = make_shared<bool>(boost::any_cast<bool>(m["PasswordInherit"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("CreditSpecification") != m.end() && !m["CreditSpecification"].empty()) {
      creditSpecification = make_shared<string>(boost::any_cast<string>(m["CreditSpecification"]));
    }
    if (m.find("DeploymentSetId") != m.end() && !m["DeploymentSetId"].empty()) {
      deploymentSetId = make_shared<string>(boost::any_cast<string>(m["DeploymentSetId"]));
    }
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisk"].type()) {
        vector<CreateAutoProvisioningGroupRequestLaunchConfigurationDataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAutoProvisioningGroupRequestLaunchConfigurationDataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisk = make_shared<vector<CreateAutoProvisioningGroupRequestLaunchConfigurationDataDisk>>(expect1);
      }
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateAutoProvisioningGroupRequestLaunchConfigurationTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAutoProvisioningGroupRequestLaunchConfigurationTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateAutoProvisioningGroupRequestLaunchConfigurationTag>>(expect1);
      }
    }
    if (m.find("HostNames") != m.end() && !m["HostNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HostNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HostNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateAutoProvisioningGroupRequestLaunchConfiguration() = default;
};
class CreateAutoProvisioningGroupRequestLaunchTemplateConfig : public Darabonba::Model {
public:
  shared_ptr<string> vSwitchId{};
  shared_ptr<double> maxPrice{};
  shared_ptr<long> priority{};
  shared_ptr<string> instanceType{};
  shared_ptr<double> weightedCapacity{};

  CreateAutoProvisioningGroupRequestLaunchTemplateConfig() {}

  explicit CreateAutoProvisioningGroupRequestLaunchTemplateConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (maxPrice) {
      res["MaxPrice"] = boost::any(*maxPrice);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (weightedCapacity) {
      res["WeightedCapacity"] = boost::any(*weightedCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("MaxPrice") != m.end() && !m["MaxPrice"].empty()) {
      maxPrice = make_shared<double>(boost::any_cast<double>(m["MaxPrice"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("WeightedCapacity") != m.end() && !m["WeightedCapacity"].empty()) {
      weightedCapacity = make_shared<double>(boost::any_cast<double>(m["WeightedCapacity"]));
    }
  }


  virtual ~CreateAutoProvisioningGroupRequestLaunchTemplateConfig() = default;
};
class CreateAutoProvisioningGroupRequestSystemDiskConfig : public Darabonba::Model {
public:
  shared_ptr<string> diskCategory{};

  CreateAutoProvisioningGroupRequestSystemDiskConfig() {}

  explicit CreateAutoProvisioningGroupRequestSystemDiskConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskCategory) {
      res["DiskCategory"] = boost::any(*diskCategory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskCategory") != m.end() && !m["DiskCategory"].empty()) {
      diskCategory = make_shared<string>(boost::any_cast<string>(m["DiskCategory"]));
    }
  }


  virtual ~CreateAutoProvisioningGroupRequestSystemDiskConfig() = default;
};
class CreateAutoProvisioningGroupRequestDataDiskConfig : public Darabonba::Model {
public:
  shared_ptr<string> diskCategory{};

  CreateAutoProvisioningGroupRequestDataDiskConfig() {}

  explicit CreateAutoProvisioningGroupRequestDataDiskConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskCategory) {
      res["DiskCategory"] = boost::any(*diskCategory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskCategory") != m.end() && !m["DiskCategory"].empty()) {
      diskCategory = make_shared<string>(boost::any_cast<string>(m["DiskCategory"]));
    }
  }


  virtual ~CreateAutoProvisioningGroupRequestDataDiskConfig() = default;
};
class CreateAutoProvisioningGroupRequest : public Darabonba::Model {
public:
  shared_ptr<CreateAutoProvisioningGroupRequestLaunchConfiguration> launchConfiguration{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> autoProvisioningGroupName{};
  shared_ptr<string> autoProvisioningGroupType{};
  shared_ptr<string> spotAllocationStrategy{};
  shared_ptr<string> spotInstanceInterruptionBehavior{};
  shared_ptr<long> spotInstancePoolsToUseCount{};
  shared_ptr<string> payAsYouGoAllocationStrategy{};
  shared_ptr<string> excessCapacityTerminationPolicy{};
  shared_ptr<string> validFrom{};
  shared_ptr<string> validUntil{};
  shared_ptr<bool> terminateInstancesWithExpiration{};
  shared_ptr<bool> terminateInstances{};
  shared_ptr<double> maxSpotPrice{};
  shared_ptr<string> totalTargetCapacity{};
  shared_ptr<string> payAsYouGoTargetCapacity{};
  shared_ptr<string> spotTargetCapacity{};
  shared_ptr<string> defaultTargetCapacityType{};
  shared_ptr<string> launchTemplateId{};
  shared_ptr<string> launchTemplateVersion{};
  shared_ptr<string> description{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<CreateAutoProvisioningGroupRequestLaunchTemplateConfig>> launchTemplateConfig{};
  shared_ptr<vector<CreateAutoProvisioningGroupRequestSystemDiskConfig>> systemDiskConfig{};
  shared_ptr<vector<CreateAutoProvisioningGroupRequestDataDiskConfig>> dataDiskConfig{};
  shared_ptr<string> minTargetCapacity{};

  CreateAutoProvisioningGroupRequest() {}

  explicit CreateAutoProvisioningGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (launchConfiguration) {
      res["LaunchConfiguration"] = launchConfiguration ? boost::any(launchConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (autoProvisioningGroupName) {
      res["AutoProvisioningGroupName"] = boost::any(*autoProvisioningGroupName);
    }
    if (autoProvisioningGroupType) {
      res["AutoProvisioningGroupType"] = boost::any(*autoProvisioningGroupType);
    }
    if (spotAllocationStrategy) {
      res["SpotAllocationStrategy"] = boost::any(*spotAllocationStrategy);
    }
    if (spotInstanceInterruptionBehavior) {
      res["SpotInstanceInterruptionBehavior"] = boost::any(*spotInstanceInterruptionBehavior);
    }
    if (spotInstancePoolsToUseCount) {
      res["SpotInstancePoolsToUseCount"] = boost::any(*spotInstancePoolsToUseCount);
    }
    if (payAsYouGoAllocationStrategy) {
      res["PayAsYouGoAllocationStrategy"] = boost::any(*payAsYouGoAllocationStrategy);
    }
    if (excessCapacityTerminationPolicy) {
      res["ExcessCapacityTerminationPolicy"] = boost::any(*excessCapacityTerminationPolicy);
    }
    if (validFrom) {
      res["ValidFrom"] = boost::any(*validFrom);
    }
    if (validUntil) {
      res["ValidUntil"] = boost::any(*validUntil);
    }
    if (terminateInstancesWithExpiration) {
      res["TerminateInstancesWithExpiration"] = boost::any(*terminateInstancesWithExpiration);
    }
    if (terminateInstances) {
      res["TerminateInstances"] = boost::any(*terminateInstances);
    }
    if (maxSpotPrice) {
      res["MaxSpotPrice"] = boost::any(*maxSpotPrice);
    }
    if (totalTargetCapacity) {
      res["TotalTargetCapacity"] = boost::any(*totalTargetCapacity);
    }
    if (payAsYouGoTargetCapacity) {
      res["PayAsYouGoTargetCapacity"] = boost::any(*payAsYouGoTargetCapacity);
    }
    if (spotTargetCapacity) {
      res["SpotTargetCapacity"] = boost::any(*spotTargetCapacity);
    }
    if (defaultTargetCapacityType) {
      res["DefaultTargetCapacityType"] = boost::any(*defaultTargetCapacityType);
    }
    if (launchTemplateId) {
      res["LaunchTemplateId"] = boost::any(*launchTemplateId);
    }
    if (launchTemplateVersion) {
      res["LaunchTemplateVersion"] = boost::any(*launchTemplateVersion);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (launchTemplateConfig) {
      vector<boost::any> temp1;
      for(auto item1:*launchTemplateConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LaunchTemplateConfig"] = boost::any(temp1);
    }
    if (systemDiskConfig) {
      vector<boost::any> temp1;
      for(auto item1:*systemDiskConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SystemDiskConfig"] = boost::any(temp1);
    }
    if (dataDiskConfig) {
      vector<boost::any> temp1;
      for(auto item1:*dataDiskConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDiskConfig"] = boost::any(temp1);
    }
    if (minTargetCapacity) {
      res["MinTargetCapacity"] = boost::any(*minTargetCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LaunchConfiguration") != m.end() && !m["LaunchConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["LaunchConfiguration"].type()) {
        CreateAutoProvisioningGroupRequestLaunchConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LaunchConfiguration"]));
        launchConfiguration = make_shared<CreateAutoProvisioningGroupRequestLaunchConfiguration>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("AutoProvisioningGroupName") != m.end() && !m["AutoProvisioningGroupName"].empty()) {
      autoProvisioningGroupName = make_shared<string>(boost::any_cast<string>(m["AutoProvisioningGroupName"]));
    }
    if (m.find("AutoProvisioningGroupType") != m.end() && !m["AutoProvisioningGroupType"].empty()) {
      autoProvisioningGroupType = make_shared<string>(boost::any_cast<string>(m["AutoProvisioningGroupType"]));
    }
    if (m.find("SpotAllocationStrategy") != m.end() && !m["SpotAllocationStrategy"].empty()) {
      spotAllocationStrategy = make_shared<string>(boost::any_cast<string>(m["SpotAllocationStrategy"]));
    }
    if (m.find("SpotInstanceInterruptionBehavior") != m.end() && !m["SpotInstanceInterruptionBehavior"].empty()) {
      spotInstanceInterruptionBehavior = make_shared<string>(boost::any_cast<string>(m["SpotInstanceInterruptionBehavior"]));
    }
    if (m.find("SpotInstancePoolsToUseCount") != m.end() && !m["SpotInstancePoolsToUseCount"].empty()) {
      spotInstancePoolsToUseCount = make_shared<long>(boost::any_cast<long>(m["SpotInstancePoolsToUseCount"]));
    }
    if (m.find("PayAsYouGoAllocationStrategy") != m.end() && !m["PayAsYouGoAllocationStrategy"].empty()) {
      payAsYouGoAllocationStrategy = make_shared<string>(boost::any_cast<string>(m["PayAsYouGoAllocationStrategy"]));
    }
    if (m.find("ExcessCapacityTerminationPolicy") != m.end() && !m["ExcessCapacityTerminationPolicy"].empty()) {
      excessCapacityTerminationPolicy = make_shared<string>(boost::any_cast<string>(m["ExcessCapacityTerminationPolicy"]));
    }
    if (m.find("ValidFrom") != m.end() && !m["ValidFrom"].empty()) {
      validFrom = make_shared<string>(boost::any_cast<string>(m["ValidFrom"]));
    }
    if (m.find("ValidUntil") != m.end() && !m["ValidUntil"].empty()) {
      validUntil = make_shared<string>(boost::any_cast<string>(m["ValidUntil"]));
    }
    if (m.find("TerminateInstancesWithExpiration") != m.end() && !m["TerminateInstancesWithExpiration"].empty()) {
      terminateInstancesWithExpiration = make_shared<bool>(boost::any_cast<bool>(m["TerminateInstancesWithExpiration"]));
    }
    if (m.find("TerminateInstances") != m.end() && !m["TerminateInstances"].empty()) {
      terminateInstances = make_shared<bool>(boost::any_cast<bool>(m["TerminateInstances"]));
    }
    if (m.find("MaxSpotPrice") != m.end() && !m["MaxSpotPrice"].empty()) {
      maxSpotPrice = make_shared<double>(boost::any_cast<double>(m["MaxSpotPrice"]));
    }
    if (m.find("TotalTargetCapacity") != m.end() && !m["TotalTargetCapacity"].empty()) {
      totalTargetCapacity = make_shared<string>(boost::any_cast<string>(m["TotalTargetCapacity"]));
    }
    if (m.find("PayAsYouGoTargetCapacity") != m.end() && !m["PayAsYouGoTargetCapacity"].empty()) {
      payAsYouGoTargetCapacity = make_shared<string>(boost::any_cast<string>(m["PayAsYouGoTargetCapacity"]));
    }
    if (m.find("SpotTargetCapacity") != m.end() && !m["SpotTargetCapacity"].empty()) {
      spotTargetCapacity = make_shared<string>(boost::any_cast<string>(m["SpotTargetCapacity"]));
    }
    if (m.find("DefaultTargetCapacityType") != m.end() && !m["DefaultTargetCapacityType"].empty()) {
      defaultTargetCapacityType = make_shared<string>(boost::any_cast<string>(m["DefaultTargetCapacityType"]));
    }
    if (m.find("LaunchTemplateId") != m.end() && !m["LaunchTemplateId"].empty()) {
      launchTemplateId = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateId"]));
    }
    if (m.find("LaunchTemplateVersion") != m.end() && !m["LaunchTemplateVersion"].empty()) {
      launchTemplateVersion = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateVersion"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("LaunchTemplateConfig") != m.end() && !m["LaunchTemplateConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["LaunchTemplateConfig"].type()) {
        vector<CreateAutoProvisioningGroupRequestLaunchTemplateConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LaunchTemplateConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAutoProvisioningGroupRequestLaunchTemplateConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        launchTemplateConfig = make_shared<vector<CreateAutoProvisioningGroupRequestLaunchTemplateConfig>>(expect1);
      }
    }
    if (m.find("SystemDiskConfig") != m.end() && !m["SystemDiskConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["SystemDiskConfig"].type()) {
        vector<CreateAutoProvisioningGroupRequestSystemDiskConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SystemDiskConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAutoProvisioningGroupRequestSystemDiskConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        systemDiskConfig = make_shared<vector<CreateAutoProvisioningGroupRequestSystemDiskConfig>>(expect1);
      }
    }
    if (m.find("DataDiskConfig") != m.end() && !m["DataDiskConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDiskConfig"].type()) {
        vector<CreateAutoProvisioningGroupRequestDataDiskConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDiskConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAutoProvisioningGroupRequestDataDiskConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDiskConfig = make_shared<vector<CreateAutoProvisioningGroupRequestDataDiskConfig>>(expect1);
      }
    }
    if (m.find("MinTargetCapacity") != m.end() && !m["MinTargetCapacity"].empty()) {
      minTargetCapacity = make_shared<string>(boost::any_cast<string>(m["MinTargetCapacity"]));
    }
  }


  virtual ~CreateAutoProvisioningGroupRequest() = default;
};
class CreateAutoProvisioningGroupResponseBodyLaunchResultsLaunchResultInstanceIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceId{};

  CreateAutoProvisioningGroupResponseBodyLaunchResultsLaunchResultInstanceIds() {}

  explicit CreateAutoProvisioningGroupResponseBodyLaunchResultsLaunchResultInstanceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateAutoProvisioningGroupResponseBodyLaunchResultsLaunchResultInstanceIds() = default;
};
class CreateAutoProvisioningGroupResponseBodyLaunchResultsLaunchResult : public Darabonba::Model {
public:
  shared_ptr<string> zoneId{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<CreateAutoProvisioningGroupResponseBodyLaunchResultsLaunchResultInstanceIds> instanceIds{};

  CreateAutoProvisioningGroupResponseBodyLaunchResultsLaunchResult() {}

  explicit CreateAutoProvisioningGroupResponseBodyLaunchResultsLaunchResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (instanceIds) {
      res["InstanceIds"] = instanceIds ? boost::any(instanceIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceIds"].type()) {
        CreateAutoProvisioningGroupResponseBodyLaunchResultsLaunchResultInstanceIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceIds"]));
        instanceIds = make_shared<CreateAutoProvisioningGroupResponseBodyLaunchResultsLaunchResultInstanceIds>(model1);
      }
    }
  }


  virtual ~CreateAutoProvisioningGroupResponseBodyLaunchResultsLaunchResult() = default;
};
class CreateAutoProvisioningGroupResponseBodyLaunchResults : public Darabonba::Model {
public:
  shared_ptr<vector<CreateAutoProvisioningGroupResponseBodyLaunchResultsLaunchResult>> launchResult{};

  CreateAutoProvisioningGroupResponseBodyLaunchResults() {}

  explicit CreateAutoProvisioningGroupResponseBodyLaunchResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (launchResult) {
      vector<boost::any> temp1;
      for(auto item1:*launchResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LaunchResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LaunchResult") != m.end() && !m["LaunchResult"].empty()) {
      if (typeid(vector<boost::any>) == m["LaunchResult"].type()) {
        vector<CreateAutoProvisioningGroupResponseBodyLaunchResultsLaunchResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LaunchResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAutoProvisioningGroupResponseBodyLaunchResultsLaunchResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        launchResult = make_shared<vector<CreateAutoProvisioningGroupResponseBodyLaunchResultsLaunchResult>>(expect1);
      }
    }
  }


  virtual ~CreateAutoProvisioningGroupResponseBodyLaunchResults() = default;
};
class CreateAutoProvisioningGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> autoProvisioningGroupId{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateAutoProvisioningGroupResponseBodyLaunchResults> launchResults{};

  CreateAutoProvisioningGroupResponseBody() {}

  explicit CreateAutoProvisioningGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoProvisioningGroupId) {
      res["AutoProvisioningGroupId"] = boost::any(*autoProvisioningGroupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (launchResults) {
      res["LaunchResults"] = launchResults ? boost::any(launchResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoProvisioningGroupId") != m.end() && !m["AutoProvisioningGroupId"].empty()) {
      autoProvisioningGroupId = make_shared<string>(boost::any_cast<string>(m["AutoProvisioningGroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("LaunchResults") != m.end() && !m["LaunchResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["LaunchResults"].type()) {
        CreateAutoProvisioningGroupResponseBodyLaunchResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LaunchResults"]));
        launchResults = make_shared<CreateAutoProvisioningGroupResponseBodyLaunchResults>(model1);
      }
    }
  }


  virtual ~CreateAutoProvisioningGroupResponseBody() = default;
};
class CreateAutoProvisioningGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateAutoProvisioningGroupResponseBody> body{};

  CreateAutoProvisioningGroupResponse() {}

  explicit CreateAutoProvisioningGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAutoProvisioningGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAutoProvisioningGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAutoProvisioningGroupResponse() = default;
};
class CreateAutoSnapshotPolicyRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateAutoSnapshotPolicyRequestTag() {}

  explicit CreateAutoSnapshotPolicyRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateAutoSnapshotPolicyRequestTag() = default;
};
class CreateAutoSnapshotPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> autoSnapshotPolicyName{};
  shared_ptr<string> timePoints{};
  shared_ptr<string> repeatWeekdays{};
  shared_ptr<long> retentionDays{};
  shared_ptr<bool> enableCrossRegionCopy{};
  shared_ptr<string> targetCopyRegions{};
  shared_ptr<long> copiedSnapshotsRetentionDays{};
  shared_ptr<vector<CreateAutoSnapshotPolicyRequestTag>> tag{};
  shared_ptr<string> resourceGroupId{};

  CreateAutoSnapshotPolicyRequest() {}

  explicit CreateAutoSnapshotPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["regionId"] = boost::any(*regionId);
    }
    if (autoSnapshotPolicyName) {
      res["autoSnapshotPolicyName"] = boost::any(*autoSnapshotPolicyName);
    }
    if (timePoints) {
      res["timePoints"] = boost::any(*timePoints);
    }
    if (repeatWeekdays) {
      res["repeatWeekdays"] = boost::any(*repeatWeekdays);
    }
    if (retentionDays) {
      res["retentionDays"] = boost::any(*retentionDays);
    }
    if (enableCrossRegionCopy) {
      res["EnableCrossRegionCopy"] = boost::any(*enableCrossRegionCopy);
    }
    if (targetCopyRegions) {
      res["TargetCopyRegions"] = boost::any(*targetCopyRegions);
    }
    if (copiedSnapshotsRetentionDays) {
      res["CopiedSnapshotsRetentionDays"] = boost::any(*copiedSnapshotsRetentionDays);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("regionId") != m.end() && !m["regionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["regionId"]));
    }
    if (m.find("autoSnapshotPolicyName") != m.end() && !m["autoSnapshotPolicyName"].empty()) {
      autoSnapshotPolicyName = make_shared<string>(boost::any_cast<string>(m["autoSnapshotPolicyName"]));
    }
    if (m.find("timePoints") != m.end() && !m["timePoints"].empty()) {
      timePoints = make_shared<string>(boost::any_cast<string>(m["timePoints"]));
    }
    if (m.find("repeatWeekdays") != m.end() && !m["repeatWeekdays"].empty()) {
      repeatWeekdays = make_shared<string>(boost::any_cast<string>(m["repeatWeekdays"]));
    }
    if (m.find("retentionDays") != m.end() && !m["retentionDays"].empty()) {
      retentionDays = make_shared<long>(boost::any_cast<long>(m["retentionDays"]));
    }
    if (m.find("EnableCrossRegionCopy") != m.end() && !m["EnableCrossRegionCopy"].empty()) {
      enableCrossRegionCopy = make_shared<bool>(boost::any_cast<bool>(m["EnableCrossRegionCopy"]));
    }
    if (m.find("TargetCopyRegions") != m.end() && !m["TargetCopyRegions"].empty()) {
      targetCopyRegions = make_shared<string>(boost::any_cast<string>(m["TargetCopyRegions"]));
    }
    if (m.find("CopiedSnapshotsRetentionDays") != m.end() && !m["CopiedSnapshotsRetentionDays"].empty()) {
      copiedSnapshotsRetentionDays = make_shared<long>(boost::any_cast<long>(m["CopiedSnapshotsRetentionDays"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateAutoSnapshotPolicyRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAutoSnapshotPolicyRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateAutoSnapshotPolicyRequestTag>>(expect1);
      }
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~CreateAutoSnapshotPolicyRequest() = default;
};
class CreateAutoSnapshotPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<string> requestId{};

  CreateAutoSnapshotPolicyResponseBody() {}

  explicit CreateAutoSnapshotPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoSnapshotPolicyId) {
      res["AutoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoSnapshotPolicyId") != m.end() && !m["AutoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["AutoSnapshotPolicyId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAutoSnapshotPolicyResponseBody() = default;
};
class CreateAutoSnapshotPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateAutoSnapshotPolicyResponseBody> body{};

  CreateAutoSnapshotPolicyResponse() {}

  explicit CreateAutoSnapshotPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAutoSnapshotPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAutoSnapshotPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAutoSnapshotPolicyResponse() = default;
};
class CreateCapacityReservationRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> matchCriteria{};

  CreateCapacityReservationRequestPrivatePoolOptions() {}

  explicit CreateCapacityReservationRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (matchCriteria) {
      res["MatchCriteria"] = boost::any(*matchCriteria);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("MatchCriteria") != m.end() && !m["MatchCriteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["MatchCriteria"]));
    }
  }


  virtual ~CreateCapacityReservationRequestPrivatePoolOptions() = default;
};
class CreateCapacityReservationRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateCapacityReservationRequestTag() {}

  explicit CreateCapacityReservationRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateCapacityReservationRequestTag() = default;
};
class CreateCapacityReservationRequest : public Darabonba::Model {
public:
  shared_ptr<CreateCapacityReservationRequestPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<CreateCapacityReservationRequestTag>> tag{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<long> instanceAmount{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> endTimeType{};
  shared_ptr<string> platform{};
  shared_ptr<vector<string>> zoneId{};

  CreateCapacityReservationRequest() {}

  explicit CreateCapacityReservationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privatePoolOptions) {
      res["PrivatePoolOptions"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceAmount) {
      res["InstanceAmount"] = boost::any(*instanceAmount);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (endTimeType) {
      res["EndTimeType"] = boost::any(*endTimeType);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolOptions"].type()) {
        CreateCapacityReservationRequestPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolOptions"]));
        privatePoolOptions = make_shared<CreateCapacityReservationRequestPrivatePoolOptions>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateCapacityReservationRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCapacityReservationRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateCapacityReservationRequestTag>>(expect1);
      }
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceAmount") != m.end() && !m["InstanceAmount"].empty()) {
      instanceAmount = make_shared<long>(boost::any_cast<long>(m["InstanceAmount"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EndTimeType") != m.end() && !m["EndTimeType"].empty()) {
      endTimeType = make_shared<string>(boost::any_cast<string>(m["EndTimeType"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ZoneId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ZoneId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      zoneId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateCapacityReservationRequest() = default;
};
class CreateCapacityReservationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> privatePoolOptionsId{};
  shared_ptr<string> requestId{};

  CreateCapacityReservationResponseBody() {}

  explicit CreateCapacityReservationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privatePoolOptionsId) {
      res["PrivatePoolOptionsId"] = boost::any(*privatePoolOptionsId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivatePoolOptionsId") != m.end() && !m["PrivatePoolOptionsId"].empty()) {
      privatePoolOptionsId = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptionsId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCapacityReservationResponseBody() = default;
};
class CreateCapacityReservationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateCapacityReservationResponseBody> body{};

  CreateCapacityReservationResponse() {}

  explicit CreateCapacityReservationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCapacityReservationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCapacityReservationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCapacityReservationResponse() = default;
};
class CreateCommandRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> type{};
  shared_ptr<string> commandContent{};
  shared_ptr<string> workingDir{};
  shared_ptr<long> timeout{};
  shared_ptr<bool> enableParameter{};

  CreateCommandRequest() {}

  explicit CreateCommandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (commandContent) {
      res["CommandContent"] = boost::any(*commandContent);
    }
    if (workingDir) {
      res["WorkingDir"] = boost::any(*workingDir);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (enableParameter) {
      res["EnableParameter"] = boost::any(*enableParameter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("CommandContent") != m.end() && !m["CommandContent"].empty()) {
      commandContent = make_shared<string>(boost::any_cast<string>(m["CommandContent"]));
    }
    if (m.find("WorkingDir") != m.end() && !m["WorkingDir"].empty()) {
      workingDir = make_shared<string>(boost::any_cast<string>(m["WorkingDir"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("EnableParameter") != m.end() && !m["EnableParameter"].empty()) {
      enableParameter = make_shared<bool>(boost::any_cast<bool>(m["EnableParameter"]));
    }
  }


  virtual ~CreateCommandRequest() = default;
};
class CreateCommandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> commandId{};
  shared_ptr<string> requestId{};

  CreateCommandResponseBody() {}

  explicit CreateCommandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commandId) {
      res["CommandId"] = boost::any(*commandId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommandId") != m.end() && !m["CommandId"].empty()) {
      commandId = make_shared<string>(boost::any_cast<string>(m["CommandId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCommandResponseBody() = default;
};
class CreateCommandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateCommandResponseBody> body{};

  CreateCommandResponse() {}

  explicit CreateCommandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCommandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCommandResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCommandResponse() = default;
};
class CreateDedicatedBlockStorageClusterRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> dedicatedBlockStorageClusterName{};
  shared_ptr<string> category{};
  shared_ptr<long> capacity{};
  shared_ptr<string> description{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> fromApp{};
  shared_ptr<string> clientToken{};

  CreateDedicatedBlockStorageClusterRequest() {}

  explicit CreateDedicatedBlockStorageClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (dedicatedBlockStorageClusterName) {
      res["DedicatedBlockStorageClusterName"] = boost::any(*dedicatedBlockStorageClusterName);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (capacity) {
      res["Capacity"] = boost::any(*capacity);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (fromApp) {
      res["FromApp"] = boost::any(*fromApp);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("DedicatedBlockStorageClusterName") != m.end() && !m["DedicatedBlockStorageClusterName"].empty()) {
      dedicatedBlockStorageClusterName = make_shared<string>(boost::any_cast<string>(m["DedicatedBlockStorageClusterName"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Capacity") != m.end() && !m["Capacity"].empty()) {
      capacity = make_shared<long>(boost::any_cast<long>(m["Capacity"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("FromApp") != m.end() && !m["FromApp"].empty()) {
      fromApp = make_shared<string>(boost::any_cast<string>(m["FromApp"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~CreateDedicatedBlockStorageClusterRequest() = default;
};
class CreateDedicatedBlockStorageClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedBlockStorageClusterOrderId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> dedicatedBlockStorageClusterId{};

  CreateDedicatedBlockStorageClusterResponseBody() {}

  explicit CreateDedicatedBlockStorageClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedBlockStorageClusterOrderId) {
      res["DedicatedBlockStorageClusterOrderId"] = boost::any(*dedicatedBlockStorageClusterOrderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (dedicatedBlockStorageClusterId) {
      res["DedicatedBlockStorageClusterId"] = boost::any(*dedicatedBlockStorageClusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedBlockStorageClusterOrderId") != m.end() && !m["DedicatedBlockStorageClusterOrderId"].empty()) {
      dedicatedBlockStorageClusterOrderId = make_shared<string>(boost::any_cast<string>(m["DedicatedBlockStorageClusterOrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DedicatedBlockStorageClusterId") != m.end() && !m["DedicatedBlockStorageClusterId"].empty()) {
      dedicatedBlockStorageClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedBlockStorageClusterId"]));
    }
  }


  virtual ~CreateDedicatedBlockStorageClusterResponseBody() = default;
};
class CreateDedicatedBlockStorageClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDedicatedBlockStorageClusterResponseBody> body{};

  CreateDedicatedBlockStorageClusterResponse() {}

  explicit CreateDedicatedBlockStorageClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDedicatedBlockStorageClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDedicatedBlockStorageClusterResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDedicatedBlockStorageClusterResponse() = default;
};
class CreateDedicatedHostClusterRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateDedicatedHostClusterRequestTag() {}

  explicit CreateDedicatedHostClusterRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDedicatedHostClusterRequestTag() = default;
};
class CreateDedicatedHostClusterRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> dryRun{};
  shared_ptr<vector<CreateDedicatedHostClusterRequestTag>> tag{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> dedicatedHostClusterName{};
  shared_ptr<string> description{};

  CreateDedicatedHostClusterRequest() {}

  explicit CreateDedicatedHostClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (dedicatedHostClusterName) {
      res["DedicatedHostClusterName"] = boost::any(*dedicatedHostClusterName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateDedicatedHostClusterRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDedicatedHostClusterRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateDedicatedHostClusterRequestTag>>(expect1);
      }
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("DedicatedHostClusterName") != m.end() && !m["DedicatedHostClusterName"].empty()) {
      dedicatedHostClusterName = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~CreateDedicatedHostClusterRequest() = default;
};
class CreateDedicatedHostClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedHostClusterId{};
  shared_ptr<string> requestId{};

  CreateDedicatedHostClusterResponseBody() {}

  explicit CreateDedicatedHostClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDedicatedHostClusterResponseBody() = default;
};
class CreateDedicatedHostClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDedicatedHostClusterResponseBody> body{};

  CreateDedicatedHostClusterResponse() {}

  explicit CreateDedicatedHostClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDedicatedHostClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDedicatedHostClusterResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDedicatedHostClusterResponse() = default;
};
class CreateDemandRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> demandName{};
  shared_ptr<string> demandDescription{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> amount{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  CreateDemandRequest() {}

  explicit CreateDemandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (demandName) {
      res["DemandName"] = boost::any(*demandName);
    }
    if (demandDescription) {
      res["DemandDescription"] = boost::any(*demandDescription);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("DemandName") != m.end() && !m["DemandName"].empty()) {
      demandName = make_shared<string>(boost::any_cast<string>(m["DemandName"]));
    }
    if (m.find("DemandDescription") != m.end() && !m["DemandDescription"].empty()) {
      demandDescription = make_shared<string>(boost::any_cast<string>(m["DemandDescription"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~CreateDemandRequest() = default;
};
class CreateDemandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> demandId{};
  shared_ptr<string> requestId{};

  CreateDemandResponseBody() {}

  explicit CreateDemandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demandId) {
      res["DemandId"] = boost::any(*demandId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemandId") != m.end() && !m["DemandId"].empty()) {
      demandId = make_shared<string>(boost::any_cast<string>(m["DemandId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDemandResponseBody() = default;
};
class CreateDemandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDemandResponseBody> body{};

  CreateDemandResponse() {}

  explicit CreateDemandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDemandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDemandResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDemandResponse() = default;
};
class CreateDeploymentSetRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> onUnableToRedeployFailedInstance{};
  shared_ptr<string> description{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> deploymentSetName{};
  shared_ptr<string> domain{};
  shared_ptr<string> granularity{};
  shared_ptr<string> strategy{};
  shared_ptr<long> groupCount{};
  shared_ptr<string> ownerAccount{};

  CreateDeploymentSetRequest() {}

  explicit CreateDeploymentSetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (onUnableToRedeployFailedInstance) {
      res["OnUnableToRedeployFailedInstance"] = boost::any(*onUnableToRedeployFailedInstance);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (deploymentSetName) {
      res["DeploymentSetName"] = boost::any(*deploymentSetName);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (granularity) {
      res["Granularity"] = boost::any(*granularity);
    }
    if (strategy) {
      res["Strategy"] = boost::any(*strategy);
    }
    if (groupCount) {
      res["GroupCount"] = boost::any(*groupCount);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("OnUnableToRedeployFailedInstance") != m.end() && !m["OnUnableToRedeployFailedInstance"].empty()) {
      onUnableToRedeployFailedInstance = make_shared<string>(boost::any_cast<string>(m["OnUnableToRedeployFailedInstance"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DeploymentSetName") != m.end() && !m["DeploymentSetName"].empty()) {
      deploymentSetName = make_shared<string>(boost::any_cast<string>(m["DeploymentSetName"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Granularity") != m.end() && !m["Granularity"].empty()) {
      granularity = make_shared<string>(boost::any_cast<string>(m["Granularity"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      strategy = make_shared<string>(boost::any_cast<string>(m["Strategy"]));
    }
    if (m.find("GroupCount") != m.end() && !m["GroupCount"].empty()) {
      groupCount = make_shared<long>(boost::any_cast<long>(m["GroupCount"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~CreateDeploymentSetRequest() = default;
};
class CreateDeploymentSetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> deploymentSetId{};
  shared_ptr<string> requestId{};

  CreateDeploymentSetResponseBody() {}

  explicit CreateDeploymentSetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deploymentSetId) {
      res["DeploymentSetId"] = boost::any(*deploymentSetId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeploymentSetId") != m.end() && !m["DeploymentSetId"].empty()) {
      deploymentSetId = make_shared<string>(boost::any_cast<string>(m["DeploymentSetId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDeploymentSetResponseBody() = default;
};
class CreateDeploymentSetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDeploymentSetResponseBody> body{};

  CreateDeploymentSetResponse() {}

  explicit CreateDeploymentSetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDeploymentSetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDeploymentSetResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDeploymentSetResponse() = default;
};
class CreateDiskRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateDiskRequestTag() {}

  explicit CreateDiskRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDiskRequestTag() = default;
};
class CreateDiskRequestArn : public Darabonba::Model {
public:
  shared_ptr<string> roleType{};
  shared_ptr<string> rolearn{};
  shared_ptr<long> assumeRoleFor{};

  CreateDiskRequestArn() {}

  explicit CreateDiskRequestArn(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleType) {
      res["RoleType"] = boost::any(*roleType);
    }
    if (rolearn) {
      res["Rolearn"] = boost::any(*rolearn);
    }
    if (assumeRoleFor) {
      res["AssumeRoleFor"] = boost::any(*assumeRoleFor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleType") != m.end() && !m["RoleType"].empty()) {
      roleType = make_shared<string>(boost::any_cast<string>(m["RoleType"]));
    }
    if (m.find("Rolearn") != m.end() && !m["Rolearn"].empty()) {
      rolearn = make_shared<string>(boost::any_cast<string>(m["Rolearn"]));
    }
    if (m.find("AssumeRoleFor") != m.end() && !m["AssumeRoleFor"].empty()) {
      assumeRoleFor = make_shared<long>(boost::any_cast<long>(m["AssumeRoleFor"]));
    }
  }


  virtual ~CreateDiskRequestArn() = default;
};
class CreateDiskRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> diskName{};
  shared_ptr<long> size{};
  shared_ptr<string> diskCategory{};
  shared_ptr<string> description{};
  shared_ptr<bool> encrypted{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> KMSKeyId{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<string> advancedFeatures{};
  shared_ptr<string> storageSetId{};
  shared_ptr<string> encryptAlgorithm{};
  shared_ptr<long> storageSetPartitionNumber{};
  shared_ptr<string> dedicatedBlockStorageClusterId{};
  shared_ptr<string> multiAttach{};
  shared_ptr<vector<CreateDiskRequestTag>> tag{};
  shared_ptr<vector<CreateDiskRequestArn>> arn{};

  CreateDiskRequest() {}

  explicit CreateDiskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (diskCategory) {
      res["DiskCategory"] = boost::any(*diskCategory);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (advancedFeatures) {
      res["AdvancedFeatures"] = boost::any(*advancedFeatures);
    }
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    if (encryptAlgorithm) {
      res["EncryptAlgorithm"] = boost::any(*encryptAlgorithm);
    }
    if (storageSetPartitionNumber) {
      res["StorageSetPartitionNumber"] = boost::any(*storageSetPartitionNumber);
    }
    if (dedicatedBlockStorageClusterId) {
      res["DedicatedBlockStorageClusterId"] = boost::any(*dedicatedBlockStorageClusterId);
    }
    if (multiAttach) {
      res["MultiAttach"] = boost::any(*multiAttach);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (arn) {
      vector<boost::any> temp1;
      for(auto item1:*arn){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Arn"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("DiskCategory") != m.end() && !m["DiskCategory"].empty()) {
      diskCategory = make_shared<string>(boost::any_cast<string>(m["DiskCategory"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<bool>(boost::any_cast<bool>(m["Encrypted"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("AdvancedFeatures") != m.end() && !m["AdvancedFeatures"].empty()) {
      advancedFeatures = make_shared<string>(boost::any_cast<string>(m["AdvancedFeatures"]));
    }
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
    if (m.find("EncryptAlgorithm") != m.end() && !m["EncryptAlgorithm"].empty()) {
      encryptAlgorithm = make_shared<string>(boost::any_cast<string>(m["EncryptAlgorithm"]));
    }
    if (m.find("StorageSetPartitionNumber") != m.end() && !m["StorageSetPartitionNumber"].empty()) {
      storageSetPartitionNumber = make_shared<long>(boost::any_cast<long>(m["StorageSetPartitionNumber"]));
    }
    if (m.find("DedicatedBlockStorageClusterId") != m.end() && !m["DedicatedBlockStorageClusterId"].empty()) {
      dedicatedBlockStorageClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedBlockStorageClusterId"]));
    }
    if (m.find("MultiAttach") != m.end() && !m["MultiAttach"].empty()) {
      multiAttach = make_shared<string>(boost::any_cast<string>(m["MultiAttach"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateDiskRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDiskRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateDiskRequestTag>>(expect1);
      }
    }
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      if (typeid(vector<boost::any>) == m["Arn"].type()) {
        vector<CreateDiskRequestArn> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Arn"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDiskRequestArn model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        arn = make_shared<vector<CreateDiskRequestArn>>(expect1);
      }
    }
  }


  virtual ~CreateDiskRequest() = default;
};
class CreateDiskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> diskId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> orderId{};

  CreateDiskResponseBody() {}

  explicit CreateDiskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~CreateDiskResponseBody() = default;
};
class CreateDiskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDiskResponseBody> body{};

  CreateDiskResponse() {}

  explicit CreateDiskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDiskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDiskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDiskResponse() = default;
};
class CreateDiskReplicaPairRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> diskId{};
  shared_ptr<string> destinationRegionId{};
  shared_ptr<string> destinationDiskId{};
  shared_ptr<string> pairName{};
  shared_ptr<string> description{};
  shared_ptr<long> asyncCycle{};

  CreateDiskReplicaPairRequest() {}

  explicit CreateDiskReplicaPairRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (destinationRegionId) {
      res["DestinationRegionId"] = boost::any(*destinationRegionId);
    }
    if (destinationDiskId) {
      res["DestinationDiskId"] = boost::any(*destinationDiskId);
    }
    if (pairName) {
      res["PairName"] = boost::any(*pairName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (asyncCycle) {
      res["AsyncCycle"] = boost::any(*asyncCycle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("DestinationRegionId") != m.end() && !m["DestinationRegionId"].empty()) {
      destinationRegionId = make_shared<string>(boost::any_cast<string>(m["DestinationRegionId"]));
    }
    if (m.find("DestinationDiskId") != m.end() && !m["DestinationDiskId"].empty()) {
      destinationDiskId = make_shared<string>(boost::any_cast<string>(m["DestinationDiskId"]));
    }
    if (m.find("PairName") != m.end() && !m["PairName"].empty()) {
      pairName = make_shared<string>(boost::any_cast<string>(m["PairName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("AsyncCycle") != m.end() && !m["AsyncCycle"].empty()) {
      asyncCycle = make_shared<long>(boost::any_cast<long>(m["AsyncCycle"]));
    }
  }


  virtual ~CreateDiskReplicaPairRequest() = default;
};
class CreateDiskReplicaPairResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> pairId{};
  shared_ptr<string> requestId{};

  CreateDiskReplicaPairResponseBody() {}

  explicit CreateDiskReplicaPairResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pairId) {
      res["PairId"] = boost::any(*pairId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PairId") != m.end() && !m["PairId"].empty()) {
      pairId = make_shared<string>(boost::any_cast<string>(m["PairId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDiskReplicaPairResponseBody() = default;
};
class CreateDiskReplicaPairResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDiskReplicaPairResponseBody> body{};

  CreateDiskReplicaPairResponse() {}

  explicit CreateDiskReplicaPairResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDiskReplicaPairResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDiskReplicaPairResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDiskReplicaPairResponse() = default;
};
class CreateElasticityAssuranceRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> matchCriteria{};

  CreateElasticityAssuranceRequestPrivatePoolOptions() {}

  explicit CreateElasticityAssuranceRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (matchCriteria) {
      res["MatchCriteria"] = boost::any(*matchCriteria);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("MatchCriteria") != m.end() && !m["MatchCriteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["MatchCriteria"]));
    }
  }


  virtual ~CreateElasticityAssuranceRequestPrivatePoolOptions() = default;
};
class CreateElasticityAssuranceRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateElasticityAssuranceRequestTag() {}

  explicit CreateElasticityAssuranceRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateElasticityAssuranceRequestTag() = default;
};
class CreateElasticityAssuranceRequest : public Darabonba::Model {
public:
  shared_ptr<CreateElasticityAssuranceRequestPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<CreateElasticityAssuranceRequestTag>> tag{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> assuranceTimes{};
  shared_ptr<long> instanceAmount{};
  shared_ptr<long> instanceCpuCoreCount{};
  shared_ptr<string> startTime{};
  shared_ptr<vector<string>> zoneId{};
  shared_ptr<vector<string>> instanceType{};

  CreateElasticityAssuranceRequest() {}

  explicit CreateElasticityAssuranceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privatePoolOptions) {
      res["PrivatePoolOptions"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (assuranceTimes) {
      res["AssuranceTimes"] = boost::any(*assuranceTimes);
    }
    if (instanceAmount) {
      res["InstanceAmount"] = boost::any(*instanceAmount);
    }
    if (instanceCpuCoreCount) {
      res["InstanceCpuCoreCount"] = boost::any(*instanceCpuCoreCount);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolOptions"].type()) {
        CreateElasticityAssuranceRequestPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolOptions"]));
        privatePoolOptions = make_shared<CreateElasticityAssuranceRequestPrivatePoolOptions>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateElasticityAssuranceRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateElasticityAssuranceRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateElasticityAssuranceRequestTag>>(expect1);
      }
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("AssuranceTimes") != m.end() && !m["AssuranceTimes"].empty()) {
      assuranceTimes = make_shared<string>(boost::any_cast<string>(m["AssuranceTimes"]));
    }
    if (m.find("InstanceAmount") != m.end() && !m["InstanceAmount"].empty()) {
      instanceAmount = make_shared<long>(boost::any_cast<long>(m["InstanceAmount"]));
    }
    if (m.find("InstanceCpuCoreCount") != m.end() && !m["InstanceCpuCoreCount"].empty()) {
      instanceCpuCoreCount = make_shared<long>(boost::any_cast<long>(m["InstanceCpuCoreCount"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ZoneId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ZoneId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      zoneId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceType = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateElasticityAssuranceRequest() = default;
};
class CreateElasticityAssuranceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> privatePoolOptionsId{};
  shared_ptr<string> orderId{};

  CreateElasticityAssuranceResponseBody() {}

  explicit CreateElasticityAssuranceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (privatePoolOptionsId) {
      res["PrivatePoolOptionsId"] = boost::any(*privatePoolOptionsId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PrivatePoolOptionsId") != m.end() && !m["PrivatePoolOptionsId"].empty()) {
      privatePoolOptionsId = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptionsId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~CreateElasticityAssuranceResponseBody() = default;
};
class CreateElasticityAssuranceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateElasticityAssuranceResponseBody> body{};

  CreateElasticityAssuranceResponse() {}

  explicit CreateElasticityAssuranceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateElasticityAssuranceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateElasticityAssuranceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateElasticityAssuranceResponse() = default;
};
class CreateForwardEntryRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> forwardTableId{};
  shared_ptr<string> externalIp{};
  shared_ptr<string> externalPort{};
  shared_ptr<string> internalIp{};
  shared_ptr<string> internalPort{};
  shared_ptr<string> ipProtocol{};

  CreateForwardEntryRequest() {}

  explicit CreateForwardEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (forwardTableId) {
      res["ForwardTableId"] = boost::any(*forwardTableId);
    }
    if (externalIp) {
      res["ExternalIp"] = boost::any(*externalIp);
    }
    if (externalPort) {
      res["ExternalPort"] = boost::any(*externalPort);
    }
    if (internalIp) {
      res["InternalIp"] = boost::any(*internalIp);
    }
    if (internalPort) {
      res["InternalPort"] = boost::any(*internalPort);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ForwardTableId") != m.end() && !m["ForwardTableId"].empty()) {
      forwardTableId = make_shared<string>(boost::any_cast<string>(m["ForwardTableId"]));
    }
    if (m.find("ExternalIp") != m.end() && !m["ExternalIp"].empty()) {
      externalIp = make_shared<string>(boost::any_cast<string>(m["ExternalIp"]));
    }
    if (m.find("ExternalPort") != m.end() && !m["ExternalPort"].empty()) {
      externalPort = make_shared<string>(boost::any_cast<string>(m["ExternalPort"]));
    }
    if (m.find("InternalIp") != m.end() && !m["InternalIp"].empty()) {
      internalIp = make_shared<string>(boost::any_cast<string>(m["InternalIp"]));
    }
    if (m.find("InternalPort") != m.end() && !m["InternalPort"].empty()) {
      internalPort = make_shared<string>(boost::any_cast<string>(m["InternalPort"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
  }


  virtual ~CreateForwardEntryRequest() = default;
};
class CreateForwardEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> forwardEntryId{};
  shared_ptr<string> requestId{};

  CreateForwardEntryResponseBody() {}

  explicit CreateForwardEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardEntryId) {
      res["ForwardEntryId"] = boost::any(*forwardEntryId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardEntryId") != m.end() && !m["ForwardEntryId"].empty()) {
      forwardEntryId = make_shared<string>(boost::any_cast<string>(m["ForwardEntryId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateForwardEntryResponseBody() = default;
};
class CreateForwardEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateForwardEntryResponseBody> body{};

  CreateForwardEntryResponse() {}

  explicit CreateForwardEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateForwardEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateForwardEntryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateForwardEntryResponse() = default;
};
class CreateHaVipRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> description{};

  CreateHaVipRequest() {}

  explicit CreateHaVipRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~CreateHaVipRequest() = default;
};
class CreateHaVipResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> haVipId{};
  shared_ptr<string> requestId{};

  CreateHaVipResponseBody() {}

  explicit CreateHaVipResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (haVipId) {
      res["HaVipId"] = boost::any(*haVipId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HaVipId") != m.end() && !m["HaVipId"].empty()) {
      haVipId = make_shared<string>(boost::any_cast<string>(m["HaVipId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateHaVipResponseBody() = default;
};
class CreateHaVipResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateHaVipResponseBody> body{};

  CreateHaVipResponse() {}

  explicit CreateHaVipResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateHaVipResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateHaVipResponseBody>(model1);
      }
    }
  }


  virtual ~CreateHaVipResponse() = default;
};
class CreateHpcClusterRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};

  CreateHpcClusterRequest() {}

  explicit CreateHpcClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateHpcClusterRequest() = default;
};
class CreateHpcClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> hpcClusterId{};
  shared_ptr<string> requestId{};

  CreateHpcClusterResponseBody() {}

  explicit CreateHpcClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hpcClusterId) {
      res["HpcClusterId"] = boost::any(*hpcClusterId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HpcClusterId") != m.end() && !m["HpcClusterId"].empty()) {
      hpcClusterId = make_shared<string>(boost::any_cast<string>(m["HpcClusterId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateHpcClusterResponseBody() = default;
};
class CreateHpcClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateHpcClusterResponseBody> body{};

  CreateHpcClusterResponse() {}

  explicit CreateHpcClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateHpcClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateHpcClusterResponseBody>(model1);
      }
    }
  }


  virtual ~CreateHpcClusterResponse() = default;
};
class CreateImageRequestDiskDeviceMapping : public Darabonba::Model {
public:
  shared_ptr<string> snapshotId{};
  shared_ptr<long> size{};
  shared_ptr<string> device{};
  shared_ptr<string> diskType{};

  CreateImageRequestDiskDeviceMapping() {}

  explicit CreateImageRequestDiskDeviceMapping(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
  }


  virtual ~CreateImageRequestDiskDeviceMapping() = default;
};
class CreateImageRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateImageRequestTag() {}

  explicit CreateImageRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateImageRequestTag() = default;
};
class CreateImageRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> imageName{};
  shared_ptr<string> imageFamily{};
  shared_ptr<string> imageVersion{};
  shared_ptr<string> description{};
  shared_ptr<string> platform{};
  shared_ptr<string> architecture{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<CreateImageRequestDiskDeviceMapping>> diskDeviceMapping{};
  shared_ptr<vector<CreateImageRequestTag>> tag{};

  CreateImageRequest() {}

  explicit CreateImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (imageFamily) {
      res["ImageFamily"] = boost::any(*imageFamily);
    }
    if (imageVersion) {
      res["ImageVersion"] = boost::any(*imageVersion);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (architecture) {
      res["Architecture"] = boost::any(*architecture);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (diskDeviceMapping) {
      vector<boost::any> temp1;
      for(auto item1:*diskDeviceMapping){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiskDeviceMapping"] = boost::any(temp1);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("ImageFamily") != m.end() && !m["ImageFamily"].empty()) {
      imageFamily = make_shared<string>(boost::any_cast<string>(m["ImageFamily"]));
    }
    if (m.find("ImageVersion") != m.end() && !m["ImageVersion"].empty()) {
      imageVersion = make_shared<string>(boost::any_cast<string>(m["ImageVersion"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("Architecture") != m.end() && !m["Architecture"].empty()) {
      architecture = make_shared<string>(boost::any_cast<string>(m["Architecture"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("DiskDeviceMapping") != m.end() && !m["DiskDeviceMapping"].empty()) {
      if (typeid(vector<boost::any>) == m["DiskDeviceMapping"].type()) {
        vector<CreateImageRequestDiskDeviceMapping> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiskDeviceMapping"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateImageRequestDiskDeviceMapping model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diskDeviceMapping = make_shared<vector<CreateImageRequestDiskDeviceMapping>>(expect1);
      }
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateImageRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateImageRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateImageRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateImageRequest() = default;
};
class CreateImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> requestId{};

  CreateImageResponseBody() {}

  explicit CreateImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateImageResponseBody() = default;
};
class CreateImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateImageResponseBody> body{};

  CreateImageResponse() {}

  explicit CreateImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateImageResponseBody>(model1);
      }
    }
  }


  virtual ~CreateImageResponse() = default;
};
class CreateImageComponentRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateImageComponentRequestTag() {}

  explicit CreateImageComponentRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateImageComponentRequestTag() = default;
};
class CreateImageComponentRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateImageComponentRequestTag>> tag{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> systemType{};
  shared_ptr<string> componentType{};
  shared_ptr<string> content{};
  shared_ptr<string> clientToken{};

  CreateImageComponentRequest() {}

  explicit CreateImageComponentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (systemType) {
      res["SystemType"] = boost::any(*systemType);
    }
    if (componentType) {
      res["ComponentType"] = boost::any(*componentType);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateImageComponentRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateImageComponentRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateImageComponentRequestTag>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SystemType") != m.end() && !m["SystemType"].empty()) {
      systemType = make_shared<string>(boost::any_cast<string>(m["SystemType"]));
    }
    if (m.find("ComponentType") != m.end() && !m["ComponentType"].empty()) {
      componentType = make_shared<string>(boost::any_cast<string>(m["ComponentType"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~CreateImageComponentRequest() = default;
};
class CreateImageComponentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> imageComponentId{};
  shared_ptr<string> requestId{};

  CreateImageComponentResponseBody() {}

  explicit CreateImageComponentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageComponentId) {
      res["ImageComponentId"] = boost::any(*imageComponentId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageComponentId") != m.end() && !m["ImageComponentId"].empty()) {
      imageComponentId = make_shared<string>(boost::any_cast<string>(m["ImageComponentId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateImageComponentResponseBody() = default;
};
class CreateImageComponentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateImageComponentResponseBody> body{};

  CreateImageComponentResponse() {}

  explicit CreateImageComponentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateImageComponentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateImageComponentResponseBody>(model1);
      }
    }
  }


  virtual ~CreateImageComponentResponse() = default;
};
class CreateImagePipelineRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateImagePipelineRequestTag() {}

  explicit CreateImagePipelineRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateImagePipelineRequestTag() = default;
};
class CreateImagePipelineRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateImagePipelineRequestTag>> tag{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<int>> addAccount{};
  shared_ptr<vector<string>> toRegionId{};
  shared_ptr<string> baseImageType{};
  shared_ptr<string> baseImage{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> imageName{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> systemDiskSize{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<bool> deleteInstanceOnFailure{};
  shared_ptr<string> buildContent{};
  shared_ptr<string> clientToken{};

  CreateImagePipelineRequest() {}

  explicit CreateImagePipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (addAccount) {
      res["AddAccount"] = boost::any(*addAccount);
    }
    if (toRegionId) {
      res["ToRegionId"] = boost::any(*toRegionId);
    }
    if (baseImageType) {
      res["BaseImageType"] = boost::any(*baseImageType);
    }
    if (baseImage) {
      res["BaseImage"] = boost::any(*baseImage);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (deleteInstanceOnFailure) {
      res["DeleteInstanceOnFailure"] = boost::any(*deleteInstanceOnFailure);
    }
    if (buildContent) {
      res["BuildContent"] = boost::any(*buildContent);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateImagePipelineRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateImagePipelineRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateImagePipelineRequestTag>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("AddAccount") != m.end() && !m["AddAccount"].empty()) {
      vector<int> toVec1;
      if (typeid(vector<boost::any>) == m["AddAccount"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AddAccount"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<int>(item));
        }
      }
      addAccount = make_shared<vector<int>>(toVec1);
    }
    if (m.find("ToRegionId") != m.end() && !m["ToRegionId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ToRegionId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ToRegionId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      toRegionId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("BaseImageType") != m.end() && !m["BaseImageType"].empty()) {
      baseImageType = make_shared<string>(boost::any_cast<string>(m["BaseImageType"]));
    }
    if (m.find("BaseImage") != m.end() && !m["BaseImage"].empty()) {
      baseImage = make_shared<string>(boost::any_cast<string>(m["BaseImage"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskSize"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("DeleteInstanceOnFailure") != m.end() && !m["DeleteInstanceOnFailure"].empty()) {
      deleteInstanceOnFailure = make_shared<bool>(boost::any_cast<bool>(m["DeleteInstanceOnFailure"]));
    }
    if (m.find("BuildContent") != m.end() && !m["BuildContent"].empty()) {
      buildContent = make_shared<string>(boost::any_cast<string>(m["BuildContent"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~CreateImagePipelineRequest() = default;
};
class CreateImagePipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> imagePipelineId{};
  shared_ptr<string> requestId{};

  CreateImagePipelineResponseBody() {}

  explicit CreateImagePipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imagePipelineId) {
      res["ImagePipelineId"] = boost::any(*imagePipelineId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImagePipelineId") != m.end() && !m["ImagePipelineId"].empty()) {
      imagePipelineId = make_shared<string>(boost::any_cast<string>(m["ImagePipelineId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateImagePipelineResponseBody() = default;
};
class CreateImagePipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateImagePipelineResponseBody> body{};

  CreateImagePipelineResponse() {}

  explicit CreateImagePipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateImagePipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateImagePipelineResponseBody>(model1);
      }
    }
  }


  virtual ~CreateImagePipelineResponse() = default;
};
class CreateInstanceRequestSystemDisk : public Darabonba::Model {
public:
  shared_ptr<long> size{};
  shared_ptr<string> category{};
  shared_ptr<string> diskName{};
  shared_ptr<string> description{};
  shared_ptr<string> performanceLevel{};

  CreateInstanceRequestSystemDisk() {}

  explicit CreateInstanceRequestSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
  }


  virtual ~CreateInstanceRequestSystemDisk() = default;
};
class CreateInstanceRequestHibernationOptions : public Darabonba::Model {
public:
  shared_ptr<bool> configured{};

  CreateInstanceRequestHibernationOptions() {}

  explicit CreateInstanceRequestHibernationOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configured) {
      res["Configured"] = boost::any(*configured);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configured") != m.end() && !m["Configured"].empty()) {
      configured = make_shared<bool>(boost::any_cast<bool>(m["Configured"]));
    }
  }


  virtual ~CreateInstanceRequestHibernationOptions() = default;
};
class CreateInstanceRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> matchCriteria{};
  shared_ptr<string> id{};

  CreateInstanceRequestPrivatePoolOptions() {}

  explicit CreateInstanceRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchCriteria) {
      res["MatchCriteria"] = boost::any(*matchCriteria);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MatchCriteria") != m.end() && !m["MatchCriteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["MatchCriteria"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~CreateInstanceRequestPrivatePoolOptions() = default;
};
class CreateInstanceRequestDataDisk : public Darabonba::Model {
public:
  shared_ptr<string> performanceLevel{};
  shared_ptr<string> description{};
  shared_ptr<string> snapshotId{};
  shared_ptr<long> size{};
  shared_ptr<string> device{};
  shared_ptr<string> diskName{};
  shared_ptr<string> category{};
  shared_ptr<bool> deleteWithInstance{};
  shared_ptr<string> KMSKeyId{};
  shared_ptr<string> encryptAlgorithm{};
  shared_ptr<bool> encrypted{};

  CreateInstanceRequestDataDisk() {}

  explicit CreateInstanceRequestDataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (encryptAlgorithm) {
      res["EncryptAlgorithm"] = boost::any(*encryptAlgorithm);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<bool>(boost::any_cast<bool>(m["DeleteWithInstance"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("EncryptAlgorithm") != m.end() && !m["EncryptAlgorithm"].empty()) {
      encryptAlgorithm = make_shared<string>(boost::any_cast<string>(m["EncryptAlgorithm"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<bool>(boost::any_cast<bool>(m["Encrypted"]));
    }
  }


  virtual ~CreateInstanceRequestDataDisk() = default;
};
class CreateInstanceRequestArn : public Darabonba::Model {
public:
  shared_ptr<string> roleType{};
  shared_ptr<string> rolearn{};
  shared_ptr<long> assumeRoleFor{};

  CreateInstanceRequestArn() {}

  explicit CreateInstanceRequestArn(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleType) {
      res["RoleType"] = boost::any(*roleType);
    }
    if (rolearn) {
      res["Rolearn"] = boost::any(*rolearn);
    }
    if (assumeRoleFor) {
      res["AssumeRoleFor"] = boost::any(*assumeRoleFor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleType") != m.end() && !m["RoleType"].empty()) {
      roleType = make_shared<string>(boost::any_cast<string>(m["RoleType"]));
    }
    if (m.find("Rolearn") != m.end() && !m["Rolearn"].empty()) {
      rolearn = make_shared<string>(boost::any_cast<string>(m["Rolearn"]));
    }
    if (m.find("AssumeRoleFor") != m.end() && !m["AssumeRoleFor"].empty()) {
      assumeRoleFor = make_shared<long>(boost::any_cast<long>(m["AssumeRoleFor"]));
    }
  }


  virtual ~CreateInstanceRequestArn() = default;
};
class CreateInstanceRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateInstanceRequestTag() {}

  explicit CreateInstanceRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateInstanceRequestTag() = default;
};
class CreateInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<CreateInstanceRequestSystemDisk> systemDisk{};
  shared_ptr<CreateInstanceRequestHibernationOptions> hibernationOptions{};
  shared_ptr<CreateInstanceRequestPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageFamily{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewPeriod{};
  shared_ptr<long> internetMaxBandwidthIn{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> hostName{};
  shared_ptr<string> password{};
  shared_ptr<bool> passwordInherit{};
  shared_ptr<string> deploymentSetId{};
  shared_ptr<long> deploymentSetGroupNo{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> vlanId{};
  shared_ptr<string> innerIpAddress{};
  shared_ptr<string> nodeControllerId{};
  shared_ptr<string> description{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> ioOptimized{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<bool> useAdditionalService{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> userData{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<string> keyPairName{};
  shared_ptr<double> spotPriceLimit{};
  shared_ptr<long> spotDuration{};
  shared_ptr<string> spotInterruptionBehavior{};
  shared_ptr<string> ramRoleName{};
  shared_ptr<string> securityEnhancementStrategy{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> hpcClusterId{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> creditSpecification{};
  shared_ptr<bool> deletionProtection{};
  shared_ptr<string> affinity{};
  shared_ptr<string> tenancy{};
  shared_ptr<string> storageSetId{};
  shared_ptr<long> storageSetPartitionNumber{};
  shared_ptr<string> httpEndpoint{};
  shared_ptr<string> httpTokens{};
  shared_ptr<long> httpPutResponseHopLimit{};
  shared_ptr<vector<CreateInstanceRequestDataDisk>> dataDisk{};
  shared_ptr<vector<CreateInstanceRequestArn>> arn{};
  shared_ptr<vector<CreateInstanceRequestTag>> tag{};

  CreateInstanceRequest() {}

  explicit CreateInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hibernationOptions) {
      res["HibernationOptions"] = hibernationOptions ? boost::any(hibernationOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (privatePoolOptions) {
      res["PrivatePoolOptions"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageFamily) {
      res["ImageFamily"] = boost::any(*imageFamily);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoRenewPeriod) {
      res["AutoRenewPeriod"] = boost::any(*autoRenewPeriod);
    }
    if (internetMaxBandwidthIn) {
      res["InternetMaxBandwidthIn"] = boost::any(*internetMaxBandwidthIn);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (passwordInherit) {
      res["PasswordInherit"] = boost::any(*passwordInherit);
    }
    if (deploymentSetId) {
      res["DeploymentSetId"] = boost::any(*deploymentSetId);
    }
    if (deploymentSetGroupNo) {
      res["DeploymentSetGroupNo"] = boost::any(*deploymentSetGroupNo);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (vlanId) {
      res["VlanId"] = boost::any(*vlanId);
    }
    if (innerIpAddress) {
      res["InnerIpAddress"] = boost::any(*innerIpAddress);
    }
    if (nodeControllerId) {
      res["NodeControllerId"] = boost::any(*nodeControllerId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (useAdditionalService) {
      res["UseAdditionalService"] = boost::any(*useAdditionalService);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (spotPriceLimit) {
      res["SpotPriceLimit"] = boost::any(*spotPriceLimit);
    }
    if (spotDuration) {
      res["SpotDuration"] = boost::any(*spotDuration);
    }
    if (spotInterruptionBehavior) {
      res["SpotInterruptionBehavior"] = boost::any(*spotInterruptionBehavior);
    }
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    if (securityEnhancementStrategy) {
      res["SecurityEnhancementStrategy"] = boost::any(*securityEnhancementStrategy);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (hpcClusterId) {
      res["HpcClusterId"] = boost::any(*hpcClusterId);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (creditSpecification) {
      res["CreditSpecification"] = boost::any(*creditSpecification);
    }
    if (deletionProtection) {
      res["DeletionProtection"] = boost::any(*deletionProtection);
    }
    if (affinity) {
      res["Affinity"] = boost::any(*affinity);
    }
    if (tenancy) {
      res["Tenancy"] = boost::any(*tenancy);
    }
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    if (storageSetPartitionNumber) {
      res["StorageSetPartitionNumber"] = boost::any(*storageSetPartitionNumber);
    }
    if (httpEndpoint) {
      res["HttpEndpoint"] = boost::any(*httpEndpoint);
    }
    if (httpTokens) {
      res["HttpTokens"] = boost::any(*httpTokens);
    }
    if (httpPutResponseHopLimit) {
      res["HttpPutResponseHopLimit"] = boost::any(*httpPutResponseHopLimit);
    }
    if (dataDisk) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisk"] = boost::any(temp1);
    }
    if (arn) {
      vector<boost::any> temp1;
      for(auto item1:*arn){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Arn"] = boost::any(temp1);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        CreateInstanceRequestSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<CreateInstanceRequestSystemDisk>(model1);
      }
    }
    if (m.find("HibernationOptions") != m.end() && !m["HibernationOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["HibernationOptions"].type()) {
        CreateInstanceRequestHibernationOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HibernationOptions"]));
        hibernationOptions = make_shared<CreateInstanceRequestHibernationOptions>(model1);
      }
    }
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolOptions"].type()) {
        CreateInstanceRequestPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolOptions"]));
        privatePoolOptions = make_shared<CreateInstanceRequestPrivatePoolOptions>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageFamily") != m.end() && !m["ImageFamily"].empty()) {
      imageFamily = make_shared<string>(boost::any_cast<string>(m["ImageFamily"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("AutoRenewPeriod") != m.end() && !m["AutoRenewPeriod"].empty()) {
      autoRenewPeriod = make_shared<long>(boost::any_cast<long>(m["AutoRenewPeriod"]));
    }
    if (m.find("InternetMaxBandwidthIn") != m.end() && !m["InternetMaxBandwidthIn"].empty()) {
      internetMaxBandwidthIn = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthIn"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("PasswordInherit") != m.end() && !m["PasswordInherit"].empty()) {
      passwordInherit = make_shared<bool>(boost::any_cast<bool>(m["PasswordInherit"]));
    }
    if (m.find("DeploymentSetId") != m.end() && !m["DeploymentSetId"].empty()) {
      deploymentSetId = make_shared<string>(boost::any_cast<string>(m["DeploymentSetId"]));
    }
    if (m.find("DeploymentSetGroupNo") != m.end() && !m["DeploymentSetGroupNo"].empty()) {
      deploymentSetGroupNo = make_shared<long>(boost::any_cast<long>(m["DeploymentSetGroupNo"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("VlanId") != m.end() && !m["VlanId"].empty()) {
      vlanId = make_shared<string>(boost::any_cast<string>(m["VlanId"]));
    }
    if (m.find("InnerIpAddress") != m.end() && !m["InnerIpAddress"].empty()) {
      innerIpAddress = make_shared<string>(boost::any_cast<string>(m["InnerIpAddress"]));
    }
    if (m.find("NodeControllerId") != m.end() && !m["NodeControllerId"].empty()) {
      nodeControllerId = make_shared<string>(boost::any_cast<string>(m["NodeControllerId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("UseAdditionalService") != m.end() && !m["UseAdditionalService"].empty()) {
      useAdditionalService = make_shared<bool>(boost::any_cast<bool>(m["UseAdditionalService"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("SpotPriceLimit") != m.end() && !m["SpotPriceLimit"].empty()) {
      spotPriceLimit = make_shared<double>(boost::any_cast<double>(m["SpotPriceLimit"]));
    }
    if (m.find("SpotDuration") != m.end() && !m["SpotDuration"].empty()) {
      spotDuration = make_shared<long>(boost::any_cast<long>(m["SpotDuration"]));
    }
    if (m.find("SpotInterruptionBehavior") != m.end() && !m["SpotInterruptionBehavior"].empty()) {
      spotInterruptionBehavior = make_shared<string>(boost::any_cast<string>(m["SpotInterruptionBehavior"]));
    }
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
    if (m.find("SecurityEnhancementStrategy") != m.end() && !m["SecurityEnhancementStrategy"].empty()) {
      securityEnhancementStrategy = make_shared<string>(boost::any_cast<string>(m["SecurityEnhancementStrategy"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("HpcClusterId") != m.end() && !m["HpcClusterId"].empty()) {
      hpcClusterId = make_shared<string>(boost::any_cast<string>(m["HpcClusterId"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("CreditSpecification") != m.end() && !m["CreditSpecification"].empty()) {
      creditSpecification = make_shared<string>(boost::any_cast<string>(m["CreditSpecification"]));
    }
    if (m.find("DeletionProtection") != m.end() && !m["DeletionProtection"].empty()) {
      deletionProtection = make_shared<bool>(boost::any_cast<bool>(m["DeletionProtection"]));
    }
    if (m.find("Affinity") != m.end() && !m["Affinity"].empty()) {
      affinity = make_shared<string>(boost::any_cast<string>(m["Affinity"]));
    }
    if (m.find("Tenancy") != m.end() && !m["Tenancy"].empty()) {
      tenancy = make_shared<string>(boost::any_cast<string>(m["Tenancy"]));
    }
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
    if (m.find("StorageSetPartitionNumber") != m.end() && !m["StorageSetPartitionNumber"].empty()) {
      storageSetPartitionNumber = make_shared<long>(boost::any_cast<long>(m["StorageSetPartitionNumber"]));
    }
    if (m.find("HttpEndpoint") != m.end() && !m["HttpEndpoint"].empty()) {
      httpEndpoint = make_shared<string>(boost::any_cast<string>(m["HttpEndpoint"]));
    }
    if (m.find("HttpTokens") != m.end() && !m["HttpTokens"].empty()) {
      httpTokens = make_shared<string>(boost::any_cast<string>(m["HttpTokens"]));
    }
    if (m.find("HttpPutResponseHopLimit") != m.end() && !m["HttpPutResponseHopLimit"].empty()) {
      httpPutResponseHopLimit = make_shared<long>(boost::any_cast<long>(m["HttpPutResponseHopLimit"]));
    }
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisk"].type()) {
        vector<CreateInstanceRequestDataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateInstanceRequestDataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisk = make_shared<vector<CreateInstanceRequestDataDisk>>(expect1);
      }
    }
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      if (typeid(vector<boost::any>) == m["Arn"].type()) {
        vector<CreateInstanceRequestArn> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Arn"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateInstanceRequestArn model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        arn = make_shared<vector<CreateInstanceRequestArn>>(expect1);
      }
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateInstanceRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateInstanceRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateInstanceRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateInstanceRequest() = default;
};
class CreateInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> orderId{};
  shared_ptr<double> tradePrice{};

  CreateInstanceResponseBody() {}

  explicit CreateInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
  }


  virtual ~CreateInstanceResponseBody() = default;
};
class CreateInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateInstanceResponseBody> body{};

  CreateInstanceResponse() {}

  explicit CreateInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateInstanceResponse() = default;
};
class CreateKeyPairRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateKeyPairRequestTag() {}

  explicit CreateKeyPairRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateKeyPairRequestTag() = default;
};
class CreateKeyPairRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<CreateKeyPairRequestTag>> tag{};

  CreateKeyPairRequest() {}

  explicit CreateKeyPairRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateKeyPairRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateKeyPairRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateKeyPairRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateKeyPairRequest() = default;
};
class CreateKeyPairResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> privateKeyBody{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> keyPairId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> keyPairFingerPrint{};

  CreateKeyPairResponseBody() {}

  explicit CreateKeyPairResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateKeyBody) {
      res["PrivateKeyBody"] = boost::any(*privateKeyBody);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (keyPairId) {
      res["KeyPairId"] = boost::any(*keyPairId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (keyPairFingerPrint) {
      res["KeyPairFingerPrint"] = boost::any(*keyPairFingerPrint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateKeyBody") != m.end() && !m["PrivateKeyBody"].empty()) {
      privateKeyBody = make_shared<string>(boost::any_cast<string>(m["PrivateKeyBody"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("KeyPairId") != m.end() && !m["KeyPairId"].empty()) {
      keyPairId = make_shared<string>(boost::any_cast<string>(m["KeyPairId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("KeyPairFingerPrint") != m.end() && !m["KeyPairFingerPrint"].empty()) {
      keyPairFingerPrint = make_shared<string>(boost::any_cast<string>(m["KeyPairFingerPrint"]));
    }
  }


  virtual ~CreateKeyPairResponseBody() = default;
};
class CreateKeyPairResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateKeyPairResponseBody> body{};

  CreateKeyPairResponse() {}

  explicit CreateKeyPairResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateKeyPairResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateKeyPairResponseBody>(model1);
      }
    }
  }


  virtual ~CreateKeyPairResponse() = default;
};
class CreateLaunchTemplateRequestSystemDisk : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<long> size{};
  shared_ptr<string> diskName{};
  shared_ptr<string> description{};
  shared_ptr<long> iops{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<bool> deleteWithInstance{};

  CreateLaunchTemplateRequestSystemDisk() {}

  explicit CreateLaunchTemplateRequestSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (iops) {
      res["Iops"] = boost::any(*iops);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Iops") != m.end() && !m["Iops"].empty()) {
      iops = make_shared<long>(boost::any_cast<long>(m["Iops"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<bool>(boost::any_cast<bool>(m["DeleteWithInstance"]));
    }
  }


  virtual ~CreateLaunchTemplateRequestSystemDisk() = default;
};
class CreateLaunchTemplateRequestTemplateTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateLaunchTemplateRequestTemplateTag() {}

  explicit CreateLaunchTemplateRequestTemplateTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateLaunchTemplateRequestTemplateTag() = default;
};
class CreateLaunchTemplateRequestDataDisk : public Darabonba::Model {
public:
  shared_ptr<string> performanceLevel{};
  shared_ptr<string> description{};
  shared_ptr<string> snapshotId{};
  shared_ptr<long> size{};
  shared_ptr<string> device{};
  shared_ptr<string> diskName{};
  shared_ptr<string> category{};
  shared_ptr<bool> deleteWithInstance{};
  shared_ptr<string> encrypted{};

  CreateLaunchTemplateRequestDataDisk() {}

  explicit CreateLaunchTemplateRequestDataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<bool>(boost::any_cast<bool>(m["DeleteWithInstance"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<string>(boost::any_cast<string>(m["Encrypted"]));
    }
  }


  virtual ~CreateLaunchTemplateRequestDataDisk() = default;
};
class CreateLaunchTemplateRequestNetworkInterface : public Darabonba::Model {
public:
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> networkInterfaceName{};
  shared_ptr<string> description{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> primaryIpAddress{};
  shared_ptr<vector<string>> securityGroupIds{};

  CreateLaunchTemplateRequestNetworkInterface() {}

  explicit CreateLaunchTemplateRequestNetworkInterface(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (networkInterfaceName) {
      res["NetworkInterfaceName"] = boost::any(*networkInterfaceName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (primaryIpAddress) {
      res["PrimaryIpAddress"] = boost::any(*primaryIpAddress);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("NetworkInterfaceName") != m.end() && !m["NetworkInterfaceName"].empty()) {
      networkInterfaceName = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("PrimaryIpAddress") != m.end() && !m["PrimaryIpAddress"].empty()) {
      primaryIpAddress = make_shared<string>(boost::any_cast<string>(m["PrimaryIpAddress"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateLaunchTemplateRequestNetworkInterface() = default;
};
class CreateLaunchTemplateRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateLaunchTemplateRequestTag() {}

  explicit CreateLaunchTemplateRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateLaunchTemplateRequestTag() = default;
};
class CreateLaunchTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<CreateLaunchTemplateRequestSystemDisk> systemDisk{};
  shared_ptr<vector<CreateLaunchTemplateRequestTemplateTag>> templateTag{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<CreateLaunchTemplateRequestDataDisk>> dataDisk{};
  shared_ptr<vector<CreateLaunchTemplateRequestNetworkInterface>> networkInterface{};
  shared_ptr<vector<CreateLaunchTemplateRequestTag>> tag{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<string> launchTemplateName{};
  shared_ptr<string> versionDescription{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageOwnerAlias{};
  shared_ptr<bool> passwordInherit{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> description{};
  shared_ptr<long> internetMaxBandwidthIn{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> hostName{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> ioOptimized{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<long> period{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<bool> enableVmOsConfig{};
  shared_ptr<string> networkType{};
  shared_ptr<string> userData{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> ramRoleName{};
  shared_ptr<string> autoReleaseTime{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<double> spotPriceLimit{};
  shared_ptr<long> spotDuration{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> templateResourceGroupId{};
  shared_ptr<string> securityEnhancementStrategy{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> deploymentSetId{};

  CreateLaunchTemplateRequest() {}

  explicit CreateLaunchTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateTag) {
      vector<boost::any> temp1;
      for(auto item1:*templateTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TemplateTag"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dataDisk) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisk"] = boost::any(temp1);
    }
    if (networkInterface) {
      vector<boost::any> temp1;
      for(auto item1:*networkInterface){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkInterface"] = boost::any(temp1);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    if (launchTemplateName) {
      res["LaunchTemplateName"] = boost::any(*launchTemplateName);
    }
    if (versionDescription) {
      res["VersionDescription"] = boost::any(*versionDescription);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageOwnerAlias) {
      res["ImageOwnerAlias"] = boost::any(*imageOwnerAlias);
    }
    if (passwordInherit) {
      res["PasswordInherit"] = boost::any(*passwordInherit);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (internetMaxBandwidthIn) {
      res["InternetMaxBandwidthIn"] = boost::any(*internetMaxBandwidthIn);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (enableVmOsConfig) {
      res["EnableVmOsConfig"] = boost::any(*enableVmOsConfig);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    if (autoReleaseTime) {
      res["AutoReleaseTime"] = boost::any(*autoReleaseTime);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (spotPriceLimit) {
      res["SpotPriceLimit"] = boost::any(*spotPriceLimit);
    }
    if (spotDuration) {
      res["SpotDuration"] = boost::any(*spotDuration);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (templateResourceGroupId) {
      res["TemplateResourceGroupId"] = boost::any(*templateResourceGroupId);
    }
    if (securityEnhancementStrategy) {
      res["SecurityEnhancementStrategy"] = boost::any(*securityEnhancementStrategy);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (deploymentSetId) {
      res["DeploymentSetId"] = boost::any(*deploymentSetId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        CreateLaunchTemplateRequestSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<CreateLaunchTemplateRequestSystemDisk>(model1);
      }
    }
    if (m.find("TemplateTag") != m.end() && !m["TemplateTag"].empty()) {
      if (typeid(vector<boost::any>) == m["TemplateTag"].type()) {
        vector<CreateLaunchTemplateRequestTemplateTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TemplateTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateLaunchTemplateRequestTemplateTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templateTag = make_shared<vector<CreateLaunchTemplateRequestTemplateTag>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisk"].type()) {
        vector<CreateLaunchTemplateRequestDataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateLaunchTemplateRequestDataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisk = make_shared<vector<CreateLaunchTemplateRequestDataDisk>>(expect1);
      }
    }
    if (m.find("NetworkInterface") != m.end() && !m["NetworkInterface"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkInterface"].type()) {
        vector<CreateLaunchTemplateRequestNetworkInterface> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkInterface"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateLaunchTemplateRequestNetworkInterface model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkInterface = make_shared<vector<CreateLaunchTemplateRequestNetworkInterface>>(expect1);
      }
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateLaunchTemplateRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateLaunchTemplateRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateLaunchTemplateRequestTag>>(expect1);
      }
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LaunchTemplateName") != m.end() && !m["LaunchTemplateName"].empty()) {
      launchTemplateName = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateName"]));
    }
    if (m.find("VersionDescription") != m.end() && !m["VersionDescription"].empty()) {
      versionDescription = make_shared<string>(boost::any_cast<string>(m["VersionDescription"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageOwnerAlias") != m.end() && !m["ImageOwnerAlias"].empty()) {
      imageOwnerAlias = make_shared<string>(boost::any_cast<string>(m["ImageOwnerAlias"]));
    }
    if (m.find("PasswordInherit") != m.end() && !m["PasswordInherit"].empty()) {
      passwordInherit = make_shared<bool>(boost::any_cast<bool>(m["PasswordInherit"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InternetMaxBandwidthIn") != m.end() && !m["InternetMaxBandwidthIn"].empty()) {
      internetMaxBandwidthIn = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthIn"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("EnableVmOsConfig") != m.end() && !m["EnableVmOsConfig"].empty()) {
      enableVmOsConfig = make_shared<bool>(boost::any_cast<bool>(m["EnableVmOsConfig"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
    if (m.find("AutoReleaseTime") != m.end() && !m["AutoReleaseTime"].empty()) {
      autoReleaseTime = make_shared<string>(boost::any_cast<string>(m["AutoReleaseTime"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("SpotPriceLimit") != m.end() && !m["SpotPriceLimit"].empty()) {
      spotPriceLimit = make_shared<double>(boost::any_cast<double>(m["SpotPriceLimit"]));
    }
    if (m.find("SpotDuration") != m.end() && !m["SpotDuration"].empty()) {
      spotDuration = make_shared<long>(boost::any_cast<long>(m["SpotDuration"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("TemplateResourceGroupId") != m.end() && !m["TemplateResourceGroupId"].empty()) {
      templateResourceGroupId = make_shared<string>(boost::any_cast<string>(m["TemplateResourceGroupId"]));
    }
    if (m.find("SecurityEnhancementStrategy") != m.end() && !m["SecurityEnhancementStrategy"].empty()) {
      securityEnhancementStrategy = make_shared<string>(boost::any_cast<string>(m["SecurityEnhancementStrategy"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("DeploymentSetId") != m.end() && !m["DeploymentSetId"].empty()) {
      deploymentSetId = make_shared<string>(boost::any_cast<string>(m["DeploymentSetId"]));
    }
  }


  virtual ~CreateLaunchTemplateRequest() = default;
};
class CreateLaunchTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> launchTemplateId{};
  shared_ptr<string> requestId{};

  CreateLaunchTemplateResponseBody() {}

  explicit CreateLaunchTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (launchTemplateId) {
      res["LaunchTemplateId"] = boost::any(*launchTemplateId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LaunchTemplateId") != m.end() && !m["LaunchTemplateId"].empty()) {
      launchTemplateId = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLaunchTemplateResponseBody() = default;
};
class CreateLaunchTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateLaunchTemplateResponseBody> body{};

  CreateLaunchTemplateResponse() {}

  explicit CreateLaunchTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLaunchTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLaunchTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLaunchTemplateResponse() = default;
};
class CreateLaunchTemplateVersionRequestSystemDisk : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<long> size{};
  shared_ptr<string> diskName{};
  shared_ptr<string> description{};
  shared_ptr<long> iops{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<bool> deleteWithInstance{};

  CreateLaunchTemplateVersionRequestSystemDisk() {}

  explicit CreateLaunchTemplateVersionRequestSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (iops) {
      res["Iops"] = boost::any(*iops);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Iops") != m.end() && !m["Iops"].empty()) {
      iops = make_shared<long>(boost::any_cast<long>(m["Iops"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<bool>(boost::any_cast<bool>(m["DeleteWithInstance"]));
    }
  }


  virtual ~CreateLaunchTemplateVersionRequestSystemDisk() = default;
};
class CreateLaunchTemplateVersionRequestDataDisk : public Darabonba::Model {
public:
  shared_ptr<string> performanceLevel{};
  shared_ptr<string> description{};
  shared_ptr<string> snapshotId{};
  shared_ptr<long> size{};
  shared_ptr<string> device{};
  shared_ptr<string> diskName{};
  shared_ptr<string> category{};
  shared_ptr<bool> deleteWithInstance{};
  shared_ptr<string> encrypted{};

  CreateLaunchTemplateVersionRequestDataDisk() {}

  explicit CreateLaunchTemplateVersionRequestDataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<bool>(boost::any_cast<bool>(m["DeleteWithInstance"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<string>(boost::any_cast<string>(m["Encrypted"]));
    }
  }


  virtual ~CreateLaunchTemplateVersionRequestDataDisk() = default;
};
class CreateLaunchTemplateVersionRequestNetworkInterface : public Darabonba::Model {
public:
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> networkInterfaceName{};
  shared_ptr<string> description{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> primaryIpAddress{};
  shared_ptr<vector<string>> securityGroupIds{};

  CreateLaunchTemplateVersionRequestNetworkInterface() {}

  explicit CreateLaunchTemplateVersionRequestNetworkInterface(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (networkInterfaceName) {
      res["NetworkInterfaceName"] = boost::any(*networkInterfaceName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (primaryIpAddress) {
      res["PrimaryIpAddress"] = boost::any(*primaryIpAddress);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("NetworkInterfaceName") != m.end() && !m["NetworkInterfaceName"].empty()) {
      networkInterfaceName = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("PrimaryIpAddress") != m.end() && !m["PrimaryIpAddress"].empty()) {
      primaryIpAddress = make_shared<string>(boost::any_cast<string>(m["PrimaryIpAddress"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateLaunchTemplateVersionRequestNetworkInterface() = default;
};
class CreateLaunchTemplateVersionRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateLaunchTemplateVersionRequestTag() {}

  explicit CreateLaunchTemplateVersionRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateLaunchTemplateVersionRequestTag() = default;
};
class CreateLaunchTemplateVersionRequest : public Darabonba::Model {
public:
  shared_ptr<CreateLaunchTemplateVersionRequestSystemDisk> systemDisk{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<CreateLaunchTemplateVersionRequestDataDisk>> dataDisk{};
  shared_ptr<vector<CreateLaunchTemplateVersionRequestNetworkInterface>> networkInterface{};
  shared_ptr<vector<CreateLaunchTemplateVersionRequestTag>> tag{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<string> launchTemplateId{};
  shared_ptr<string> launchTemplateName{};
  shared_ptr<string> versionDescription{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageOwnerAlias{};
  shared_ptr<bool> passwordInherit{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> description{};
  shared_ptr<long> internetMaxBandwidthIn{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> hostName{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> ioOptimized{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<long> period{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<bool> enableVmOsConfig{};
  shared_ptr<string> networkType{};
  shared_ptr<string> userData{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> ramRoleName{};
  shared_ptr<string> autoReleaseTime{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<double> spotPriceLimit{};
  shared_ptr<long> spotDuration{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityEnhancementStrategy{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> deploymentSetId{};

  CreateLaunchTemplateVersionRequest() {}

  explicit CreateLaunchTemplateVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dataDisk) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisk"] = boost::any(temp1);
    }
    if (networkInterface) {
      vector<boost::any> temp1;
      for(auto item1:*networkInterface){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkInterface"] = boost::any(temp1);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    if (launchTemplateId) {
      res["LaunchTemplateId"] = boost::any(*launchTemplateId);
    }
    if (launchTemplateName) {
      res["LaunchTemplateName"] = boost::any(*launchTemplateName);
    }
    if (versionDescription) {
      res["VersionDescription"] = boost::any(*versionDescription);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageOwnerAlias) {
      res["ImageOwnerAlias"] = boost::any(*imageOwnerAlias);
    }
    if (passwordInherit) {
      res["PasswordInherit"] = boost::any(*passwordInherit);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (internetMaxBandwidthIn) {
      res["InternetMaxBandwidthIn"] = boost::any(*internetMaxBandwidthIn);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (enableVmOsConfig) {
      res["EnableVmOsConfig"] = boost::any(*enableVmOsConfig);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    if (autoReleaseTime) {
      res["AutoReleaseTime"] = boost::any(*autoReleaseTime);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (spotPriceLimit) {
      res["SpotPriceLimit"] = boost::any(*spotPriceLimit);
    }
    if (spotDuration) {
      res["SpotDuration"] = boost::any(*spotDuration);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityEnhancementStrategy) {
      res["SecurityEnhancementStrategy"] = boost::any(*securityEnhancementStrategy);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (deploymentSetId) {
      res["DeploymentSetId"] = boost::any(*deploymentSetId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        CreateLaunchTemplateVersionRequestSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<CreateLaunchTemplateVersionRequestSystemDisk>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisk"].type()) {
        vector<CreateLaunchTemplateVersionRequestDataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateLaunchTemplateVersionRequestDataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisk = make_shared<vector<CreateLaunchTemplateVersionRequestDataDisk>>(expect1);
      }
    }
    if (m.find("NetworkInterface") != m.end() && !m["NetworkInterface"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkInterface"].type()) {
        vector<CreateLaunchTemplateVersionRequestNetworkInterface> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkInterface"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateLaunchTemplateVersionRequestNetworkInterface model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkInterface = make_shared<vector<CreateLaunchTemplateVersionRequestNetworkInterface>>(expect1);
      }
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateLaunchTemplateVersionRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateLaunchTemplateVersionRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateLaunchTemplateVersionRequestTag>>(expect1);
      }
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LaunchTemplateId") != m.end() && !m["LaunchTemplateId"].empty()) {
      launchTemplateId = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateId"]));
    }
    if (m.find("LaunchTemplateName") != m.end() && !m["LaunchTemplateName"].empty()) {
      launchTemplateName = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateName"]));
    }
    if (m.find("VersionDescription") != m.end() && !m["VersionDescription"].empty()) {
      versionDescription = make_shared<string>(boost::any_cast<string>(m["VersionDescription"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageOwnerAlias") != m.end() && !m["ImageOwnerAlias"].empty()) {
      imageOwnerAlias = make_shared<string>(boost::any_cast<string>(m["ImageOwnerAlias"]));
    }
    if (m.find("PasswordInherit") != m.end() && !m["PasswordInherit"].empty()) {
      passwordInherit = make_shared<bool>(boost::any_cast<bool>(m["PasswordInherit"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InternetMaxBandwidthIn") != m.end() && !m["InternetMaxBandwidthIn"].empty()) {
      internetMaxBandwidthIn = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthIn"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("EnableVmOsConfig") != m.end() && !m["EnableVmOsConfig"].empty()) {
      enableVmOsConfig = make_shared<bool>(boost::any_cast<bool>(m["EnableVmOsConfig"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
    if (m.find("AutoReleaseTime") != m.end() && !m["AutoReleaseTime"].empty()) {
      autoReleaseTime = make_shared<string>(boost::any_cast<string>(m["AutoReleaseTime"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("SpotPriceLimit") != m.end() && !m["SpotPriceLimit"].empty()) {
      spotPriceLimit = make_shared<double>(boost::any_cast<double>(m["SpotPriceLimit"]));
    }
    if (m.find("SpotDuration") != m.end() && !m["SpotDuration"].empty()) {
      spotDuration = make_shared<long>(boost::any_cast<long>(m["SpotDuration"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityEnhancementStrategy") != m.end() && !m["SecurityEnhancementStrategy"].empty()) {
      securityEnhancementStrategy = make_shared<string>(boost::any_cast<string>(m["SecurityEnhancementStrategy"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("DeploymentSetId") != m.end() && !m["DeploymentSetId"].empty()) {
      deploymentSetId = make_shared<string>(boost::any_cast<string>(m["DeploymentSetId"]));
    }
  }


  virtual ~CreateLaunchTemplateVersionRequest() = default;
};
class CreateLaunchTemplateVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> launchTemplateVersionNumber{};
  shared_ptr<string> requestId{};

  CreateLaunchTemplateVersionResponseBody() {}

  explicit CreateLaunchTemplateVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (launchTemplateVersionNumber) {
      res["LaunchTemplateVersionNumber"] = boost::any(*launchTemplateVersionNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LaunchTemplateVersionNumber") != m.end() && !m["LaunchTemplateVersionNumber"].empty()) {
      launchTemplateVersionNumber = make_shared<long>(boost::any_cast<long>(m["LaunchTemplateVersionNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLaunchTemplateVersionResponseBody() = default;
};
class CreateLaunchTemplateVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateLaunchTemplateVersionResponseBody> body{};

  CreateLaunchTemplateVersionResponse() {}

  explicit CreateLaunchTemplateVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLaunchTemplateVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLaunchTemplateVersionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLaunchTemplateVersionResponse() = default;
};
class CreateNatGatewayRequestBandwidthPackage : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> zone{};
  shared_ptr<long> ipCount{};

  CreateNatGatewayRequestBandwidthPackage() {}

  explicit CreateNatGatewayRequestBandwidthPackage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (zone) {
      res["Zone"] = boost::any(*zone);
    }
    if (ipCount) {
      res["IpCount"] = boost::any(*ipCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("Zone") != m.end() && !m["Zone"].empty()) {
      zone = make_shared<string>(boost::any_cast<string>(m["Zone"]));
    }
    if (m.find("IpCount") != m.end() && !m["IpCount"].empty()) {
      ipCount = make_shared<long>(boost::any_cast<long>(m["IpCount"]));
    }
  }


  virtual ~CreateNatGatewayRequestBandwidthPackage() = default;
};
class CreateNatGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<CreateNatGatewayRequestBandwidthPackage>> bandwidthPackage{};

  CreateNatGatewayRequest() {}

  explicit CreateNatGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (bandwidthPackage) {
      vector<boost::any> temp1;
      for(auto item1:*bandwidthPackage){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BandwidthPackage"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("BandwidthPackage") != m.end() && !m["BandwidthPackage"].empty()) {
      if (typeid(vector<boost::any>) == m["BandwidthPackage"].type()) {
        vector<CreateNatGatewayRequestBandwidthPackage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BandwidthPackage"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateNatGatewayRequestBandwidthPackage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bandwidthPackage = make_shared<vector<CreateNatGatewayRequestBandwidthPackage>>(expect1);
      }
    }
  }


  virtual ~CreateNatGatewayRequest() = default;
};
class CreateNatGatewayResponseBodyForwardTableIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> forwardTableId{};

  CreateNatGatewayResponseBodyForwardTableIds() {}

  explicit CreateNatGatewayResponseBodyForwardTableIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardTableId) {
      res["ForwardTableId"] = boost::any(*forwardTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardTableId") != m.end() && !m["ForwardTableId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ForwardTableId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ForwardTableId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      forwardTableId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateNatGatewayResponseBodyForwardTableIds() = default;
};
class CreateNatGatewayResponseBodyBandwidthPackageIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> bandwidthPackageId{};

  CreateNatGatewayResponseBodyBandwidthPackageIds() {}

  explicit CreateNatGatewayResponseBodyBandwidthPackageIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BandwidthPackageId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BandwidthPackageId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      bandwidthPackageId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateNatGatewayResponseBodyBandwidthPackageIds() = default;
};
class CreateNatGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateNatGatewayResponseBodyForwardTableIds> forwardTableIds{};
  shared_ptr<CreateNatGatewayResponseBodyBandwidthPackageIds> bandwidthPackageIds{};

  CreateNatGatewayResponseBody() {}

  explicit CreateNatGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (forwardTableIds) {
      res["ForwardTableIds"] = forwardTableIds ? boost::any(forwardTableIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bandwidthPackageIds) {
      res["BandwidthPackageIds"] = bandwidthPackageIds ? boost::any(bandwidthPackageIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ForwardTableIds") != m.end() && !m["ForwardTableIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["ForwardTableIds"].type()) {
        CreateNatGatewayResponseBodyForwardTableIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ForwardTableIds"]));
        forwardTableIds = make_shared<CreateNatGatewayResponseBodyForwardTableIds>(model1);
      }
    }
    if (m.find("BandwidthPackageIds") != m.end() && !m["BandwidthPackageIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["BandwidthPackageIds"].type()) {
        CreateNatGatewayResponseBodyBandwidthPackageIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BandwidthPackageIds"]));
        bandwidthPackageIds = make_shared<CreateNatGatewayResponseBodyBandwidthPackageIds>(model1);
      }
    }
  }


  virtual ~CreateNatGatewayResponseBody() = default;
};
class CreateNatGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateNatGatewayResponseBody> body{};

  CreateNatGatewayResponse() {}

  explicit CreateNatGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNatGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNatGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNatGatewayResponse() = default;
};
class CreateNetworkInterfaceRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateNetworkInterfaceRequestTag() {}

  explicit CreateNetworkInterfaceRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateNetworkInterfaceRequestTag() = default;
};
class CreateNetworkInterfaceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<CreateNetworkInterfaceRequestTag>> tag{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> primaryIpAddress{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> networkInterfaceName{};
  shared_ptr<string> description{};
  shared_ptr<bool> visible{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> businessType{};
  shared_ptr<long> secondaryPrivateIpAddressCount{};
  shared_ptr<long> queueNumber{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> networkInterfaceTrafficMode{};
  shared_ptr<long> queuePairNumber{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<vector<string>> privateIpAddress{};
  shared_ptr<vector<string>> ipv6Address{};
  shared_ptr<long> ipv6AddressCount{};

  CreateNetworkInterfaceRequest() {}

  explicit CreateNetworkInterfaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (primaryIpAddress) {
      res["PrimaryIpAddress"] = boost::any(*primaryIpAddress);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (networkInterfaceName) {
      res["NetworkInterfaceName"] = boost::any(*networkInterfaceName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (visible) {
      res["Visible"] = boost::any(*visible);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (secondaryPrivateIpAddressCount) {
      res["SecondaryPrivateIpAddressCount"] = boost::any(*secondaryPrivateIpAddressCount);
    }
    if (queueNumber) {
      res["QueueNumber"] = boost::any(*queueNumber);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (networkInterfaceTrafficMode) {
      res["NetworkInterfaceTrafficMode"] = boost::any(*networkInterfaceTrafficMode);
    }
    if (queuePairNumber) {
      res["QueuePairNumber"] = boost::any(*queuePairNumber);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (ipv6Address) {
      res["Ipv6Address"] = boost::any(*ipv6Address);
    }
    if (ipv6AddressCount) {
      res["Ipv6AddressCount"] = boost::any(*ipv6AddressCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateNetworkInterfaceRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateNetworkInterfaceRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateNetworkInterfaceRequestTag>>(expect1);
      }
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("PrimaryIpAddress") != m.end() && !m["PrimaryIpAddress"].empty()) {
      primaryIpAddress = make_shared<string>(boost::any_cast<string>(m["PrimaryIpAddress"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("NetworkInterfaceName") != m.end() && !m["NetworkInterfaceName"].empty()) {
      networkInterfaceName = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Visible") != m.end() && !m["Visible"].empty()) {
      visible = make_shared<bool>(boost::any_cast<bool>(m["Visible"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("SecondaryPrivateIpAddressCount") != m.end() && !m["SecondaryPrivateIpAddressCount"].empty()) {
      secondaryPrivateIpAddressCount = make_shared<long>(boost::any_cast<long>(m["SecondaryPrivateIpAddressCount"]));
    }
    if (m.find("QueueNumber") != m.end() && !m["QueueNumber"].empty()) {
      queueNumber = make_shared<long>(boost::any_cast<long>(m["QueueNumber"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("NetworkInterfaceTrafficMode") != m.end() && !m["NetworkInterfaceTrafficMode"].empty()) {
      networkInterfaceTrafficMode = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceTrafficMode"]));
    }
    if (m.find("QueuePairNumber") != m.end() && !m["QueuePairNumber"].empty()) {
      queuePairNumber = make_shared<long>(boost::any_cast<long>(m["QueuePairNumber"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrivateIpAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrivateIpAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      privateIpAddress = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Ipv6Address") != m.end() && !m["Ipv6Address"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ipv6Address"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ipv6Address"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipv6Address = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Ipv6AddressCount") != m.end() && !m["Ipv6AddressCount"].empty()) {
      ipv6AddressCount = make_shared<long>(boost::any_cast<long>(m["Ipv6AddressCount"]));
    }
  }


  virtual ~CreateNetworkInterfaceRequest() = default;
};
class CreateNetworkInterfaceResponseBodySecurityGroupIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> securityGroupId{};

  CreateNetworkInterfaceResponseBodySecurityGroupIds() {}

  explicit CreateNetworkInterfaceResponseBodySecurityGroupIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateNetworkInterfaceResponseBodySecurityGroupIds() = default;
};
class CreateNetworkInterfaceResponseBodyPrivateIpSetsPrivateIpSet : public Darabonba::Model {
public:
  shared_ptr<string> privateIpAddress{};
  shared_ptr<bool> primary{};

  CreateNetworkInterfaceResponseBodyPrivateIpSetsPrivateIpSet() {}

  explicit CreateNetworkInterfaceResponseBodyPrivateIpSetsPrivateIpSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (primary) {
      res["Primary"] = boost::any(*primary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("Primary") != m.end() && !m["Primary"].empty()) {
      primary = make_shared<bool>(boost::any_cast<bool>(m["Primary"]));
    }
  }


  virtual ~CreateNetworkInterfaceResponseBodyPrivateIpSetsPrivateIpSet() = default;
};
class CreateNetworkInterfaceResponseBodyPrivateIpSets : public Darabonba::Model {
public:
  shared_ptr<vector<CreateNetworkInterfaceResponseBodyPrivateIpSetsPrivateIpSet>> privateIpSet{};

  CreateNetworkInterfaceResponseBodyPrivateIpSets() {}

  explicit CreateNetworkInterfaceResponseBodyPrivateIpSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateIpSet) {
      vector<boost::any> temp1;
      for(auto item1:*privateIpSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrivateIpSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateIpSet") != m.end() && !m["PrivateIpSet"].empty()) {
      if (typeid(vector<boost::any>) == m["PrivateIpSet"].type()) {
        vector<CreateNetworkInterfaceResponseBodyPrivateIpSetsPrivateIpSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrivateIpSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateNetworkInterfaceResponseBodyPrivateIpSetsPrivateIpSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        privateIpSet = make_shared<vector<CreateNetworkInterfaceResponseBodyPrivateIpSetsPrivateIpSet>>(expect1);
      }
    }
  }


  virtual ~CreateNetworkInterfaceResponseBodyPrivateIpSets() = default;
};
class CreateNetworkInterfaceResponseBodyTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  CreateNetworkInterfaceResponseBodyTagsTag() {}

  explicit CreateNetworkInterfaceResponseBodyTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~CreateNetworkInterfaceResponseBodyTagsTag() = default;
};
class CreateNetworkInterfaceResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<vector<CreateNetworkInterfaceResponseBodyTagsTag>> tag{};

  CreateNetworkInterfaceResponseBodyTags() {}

  explicit CreateNetworkInterfaceResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateNetworkInterfaceResponseBodyTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateNetworkInterfaceResponseBodyTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateNetworkInterfaceResponseBodyTagsTag>>(expect1);
      }
    }
  }


  virtual ~CreateNetworkInterfaceResponseBodyTags() = default;
};
class CreateNetworkInterfaceResponseBodyIpv6SetsIpv6Set : public Darabonba::Model {
public:
  shared_ptr<string> ipv6Address{};

  CreateNetworkInterfaceResponseBodyIpv6SetsIpv6Set() {}

  explicit CreateNetworkInterfaceResponseBodyIpv6SetsIpv6Set(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6Address) {
      res["Ipv6Address"] = boost::any(*ipv6Address);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6Address") != m.end() && !m["Ipv6Address"].empty()) {
      ipv6Address = make_shared<string>(boost::any_cast<string>(m["Ipv6Address"]));
    }
  }


  virtual ~CreateNetworkInterfaceResponseBodyIpv6SetsIpv6Set() = default;
};
class CreateNetworkInterfaceResponseBodyIpv6Sets : public Darabonba::Model {
public:
  shared_ptr<vector<CreateNetworkInterfaceResponseBodyIpv6SetsIpv6Set>> ipv6Set{};

  CreateNetworkInterfaceResponseBodyIpv6Sets() {}

  explicit CreateNetworkInterfaceResponseBodyIpv6Sets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6Set) {
      vector<boost::any> temp1;
      for(auto item1:*ipv6Set){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv6Set"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6Set") != m.end() && !m["Ipv6Set"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv6Set"].type()) {
        vector<CreateNetworkInterfaceResponseBodyIpv6SetsIpv6Set> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv6Set"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateNetworkInterfaceResponseBodyIpv6SetsIpv6Set model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv6Set = make_shared<vector<CreateNetworkInterfaceResponseBodyIpv6SetsIpv6Set>>(expect1);
      }
    }
  }


  virtual ~CreateNetworkInterfaceResponseBodyIpv6Sets() = default;
};
class CreateNetworkInterfaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> networkInterfaceName{};
  shared_ptr<string> macAddress{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<long> serviceID{};
  shared_ptr<string> ownerId{};
  shared_ptr<bool> serviceManaged{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> description{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<CreateNetworkInterfaceResponseBodySecurityGroupIds> securityGroupIds{};
  shared_ptr<CreateNetworkInterfaceResponseBodyPrivateIpSets> privateIpSets{};
  shared_ptr<CreateNetworkInterfaceResponseBodyTags> tags{};
  shared_ptr<CreateNetworkInterfaceResponseBodyIpv6Sets> ipv6Sets{};

  CreateNetworkInterfaceResponseBody() {}

  explicit CreateNetworkInterfaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (networkInterfaceName) {
      res["NetworkInterfaceName"] = boost::any(*networkInterfaceName);
    }
    if (macAddress) {
      res["MacAddress"] = boost::any(*macAddress);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (serviceID) {
      res["ServiceID"] = boost::any(*serviceID);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (serviceManaged) {
      res["ServiceManaged"] = boost::any(*serviceManaged);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = securityGroupIds ? boost::any(securityGroupIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (privateIpSets) {
      res["PrivateIpSets"] = privateIpSets ? boost::any(privateIpSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipv6Sets) {
      res["Ipv6Sets"] = ipv6Sets ? boost::any(ipv6Sets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("NetworkInterfaceName") != m.end() && !m["NetworkInterfaceName"].empty()) {
      networkInterfaceName = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceName"]));
    }
    if (m.find("MacAddress") != m.end() && !m["MacAddress"].empty()) {
      macAddress = make_shared<string>(boost::any_cast<string>(m["MacAddress"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("ServiceID") != m.end() && !m["ServiceID"].empty()) {
      serviceID = make_shared<long>(boost::any_cast<long>(m["ServiceID"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ServiceManaged") != m.end() && !m["ServiceManaged"].empty()) {
      serviceManaged = make_shared<bool>(boost::any_cast<bool>(m["ServiceManaged"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityGroupIds"].type()) {
        CreateNetworkInterfaceResponseBodySecurityGroupIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityGroupIds"]));
        securityGroupIds = make_shared<CreateNetworkInterfaceResponseBodySecurityGroupIds>(model1);
      }
    }
    if (m.find("PrivateIpSets") != m.end() && !m["PrivateIpSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivateIpSets"].type()) {
        CreateNetworkInterfaceResponseBodyPrivateIpSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivateIpSets"]));
        privateIpSets = make_shared<CreateNetworkInterfaceResponseBodyPrivateIpSets>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        CreateNetworkInterfaceResponseBodyTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<CreateNetworkInterfaceResponseBodyTags>(model1);
      }
    }
    if (m.find("Ipv6Sets") != m.end() && !m["Ipv6Sets"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ipv6Sets"].type()) {
        CreateNetworkInterfaceResponseBodyIpv6Sets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ipv6Sets"]));
        ipv6Sets = make_shared<CreateNetworkInterfaceResponseBodyIpv6Sets>(model1);
      }
    }
  }


  virtual ~CreateNetworkInterfaceResponseBody() = default;
};
class CreateNetworkInterfaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateNetworkInterfaceResponseBody> body{};

  CreateNetworkInterfaceResponse() {}

  explicit CreateNetworkInterfaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNetworkInterfaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNetworkInterfaceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNetworkInterfaceResponse() = default;
};
class CreateNetworkInterfacePermissionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<long> accountId{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<string> permission{};

  CreateNetworkInterfacePermissionRequest() {}

  explicit CreateNetworkInterfacePermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (permission) {
      res["Permission"] = boost::any(*permission);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("Permission") != m.end() && !m["Permission"].empty()) {
      permission = make_shared<string>(boost::any_cast<string>(m["Permission"]));
    }
  }


  virtual ~CreateNetworkInterfacePermissionRequest() = default;
};
class CreateNetworkInterfacePermissionResponseBodyNetworkInterfacePermission : public Darabonba::Model {
public:
  shared_ptr<string> permission{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<long> accountId{};
  shared_ptr<string> networkInterfacePermissionId{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> permissionState{};

  CreateNetworkInterfacePermissionResponseBodyNetworkInterfacePermission() {}

  explicit CreateNetworkInterfacePermissionResponseBodyNetworkInterfacePermission(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (permission) {
      res["Permission"] = boost::any(*permission);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (networkInterfacePermissionId) {
      res["NetworkInterfacePermissionId"] = boost::any(*networkInterfacePermissionId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (permissionState) {
      res["PermissionState"] = boost::any(*permissionState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Permission") != m.end() && !m["Permission"].empty()) {
      permission = make_shared<string>(boost::any_cast<string>(m["Permission"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("NetworkInterfacePermissionId") != m.end() && !m["NetworkInterfacePermissionId"].empty()) {
      networkInterfacePermissionId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfacePermissionId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("PermissionState") != m.end() && !m["PermissionState"].empty()) {
      permissionState = make_shared<string>(boost::any_cast<string>(m["PermissionState"]));
    }
  }


  virtual ~CreateNetworkInterfacePermissionResponseBodyNetworkInterfacePermission() = default;
};
class CreateNetworkInterfacePermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateNetworkInterfacePermissionResponseBodyNetworkInterfacePermission> networkInterfacePermission{};

  CreateNetworkInterfacePermissionResponseBody() {}

  explicit CreateNetworkInterfacePermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (networkInterfacePermission) {
      res["NetworkInterfacePermission"] = networkInterfacePermission ? boost::any(networkInterfacePermission->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NetworkInterfacePermission") != m.end() && !m["NetworkInterfacePermission"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkInterfacePermission"].type()) {
        CreateNetworkInterfacePermissionResponseBodyNetworkInterfacePermission model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkInterfacePermission"]));
        networkInterfacePermission = make_shared<CreateNetworkInterfacePermissionResponseBodyNetworkInterfacePermission>(model1);
      }
    }
  }


  virtual ~CreateNetworkInterfacePermissionResponseBody() = default;
};
class CreateNetworkInterfacePermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateNetworkInterfacePermissionResponseBody> body{};

  CreateNetworkInterfacePermissionResponse() {}

  explicit CreateNetworkInterfacePermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNetworkInterfacePermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNetworkInterfacePermissionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNetworkInterfacePermissionResponse() = default;
};
class CreatePhysicalConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> accessPointId{};
  shared_ptr<string> type{};
  shared_ptr<string> lineOperator{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> peerLocation{};
  shared_ptr<string> portType{};
  shared_ptr<string> redundantPhysicalConnectionId{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> circuitCode{};
  shared_ptr<string> clientToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> userCidr{};

  CreatePhysicalConnectionRequest() {}

  explicit CreatePhysicalConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (accessPointId) {
      res["AccessPointId"] = boost::any(*accessPointId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (lineOperator) {
      res["LineOperator"] = boost::any(*lineOperator);
    }
    if (bandwidth) {
      res["bandwidth"] = boost::any(*bandwidth);
    }
    if (peerLocation) {
      res["PeerLocation"] = boost::any(*peerLocation);
    }
    if (portType) {
      res["PortType"] = boost::any(*portType);
    }
    if (redundantPhysicalConnectionId) {
      res["RedundantPhysicalConnectionId"] = boost::any(*redundantPhysicalConnectionId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (circuitCode) {
      res["CircuitCode"] = boost::any(*circuitCode);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (userCidr) {
      res["UserCidr"] = boost::any(*userCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AccessPointId") != m.end() && !m["AccessPointId"].empty()) {
      accessPointId = make_shared<string>(boost::any_cast<string>(m["AccessPointId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("LineOperator") != m.end() && !m["LineOperator"].empty()) {
      lineOperator = make_shared<string>(boost::any_cast<string>(m["LineOperator"]));
    }
    if (m.find("bandwidth") != m.end() && !m["bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["bandwidth"]));
    }
    if (m.find("PeerLocation") != m.end() && !m["PeerLocation"].empty()) {
      peerLocation = make_shared<string>(boost::any_cast<string>(m["PeerLocation"]));
    }
    if (m.find("PortType") != m.end() && !m["PortType"].empty()) {
      portType = make_shared<string>(boost::any_cast<string>(m["PortType"]));
    }
    if (m.find("RedundantPhysicalConnectionId") != m.end() && !m["RedundantPhysicalConnectionId"].empty()) {
      redundantPhysicalConnectionId = make_shared<string>(boost::any_cast<string>(m["RedundantPhysicalConnectionId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("CircuitCode") != m.end() && !m["CircuitCode"].empty()) {
      circuitCode = make_shared<string>(boost::any_cast<string>(m["CircuitCode"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("UserCidr") != m.end() && !m["UserCidr"].empty()) {
      userCidr = make_shared<string>(boost::any_cast<string>(m["UserCidr"]));
    }
  }


  virtual ~CreatePhysicalConnectionRequest() = default;
};
class CreatePhysicalConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<string> requestId{};

  CreatePhysicalConnectionResponseBody() {}

  explicit CreatePhysicalConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreatePhysicalConnectionResponseBody() = default;
};
class CreatePhysicalConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreatePhysicalConnectionResponseBody> body{};

  CreatePhysicalConnectionResponse() {}

  explicit CreatePhysicalConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePhysicalConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePhysicalConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePhysicalConnectionResponse() = default;
};
class CreatePrefixListRequestEntry : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> cidr{};

  CreatePrefixListRequestEntry() {}

  explicit CreatePrefixListRequestEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (cidr) {
      res["Cidr"] = boost::any(*cidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Cidr") != m.end() && !m["Cidr"].empty()) {
      cidr = make_shared<string>(boost::any_cast<string>(m["Cidr"]));
    }
  }


  virtual ~CreatePrefixListRequestEntry() = default;
};
class CreatePrefixListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<CreatePrefixListRequestEntry>> entry{};
  shared_ptr<long> maxEntries{};
  shared_ptr<string> addressFamily{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> prefixListName{};
  shared_ptr<string> description{};

  CreatePrefixListRequest() {}

  explicit CreatePrefixListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (entry) {
      vector<boost::any> temp1;
      for(auto item1:*entry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Entry"] = boost::any(temp1);
    }
    if (maxEntries) {
      res["MaxEntries"] = boost::any(*maxEntries);
    }
    if (addressFamily) {
      res["AddressFamily"] = boost::any(*addressFamily);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (prefixListName) {
      res["PrefixListName"] = boost::any(*prefixListName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Entry") != m.end() && !m["Entry"].empty()) {
      if (typeid(vector<boost::any>) == m["Entry"].type()) {
        vector<CreatePrefixListRequestEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Entry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePrefixListRequestEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entry = make_shared<vector<CreatePrefixListRequestEntry>>(expect1);
      }
    }
    if (m.find("MaxEntries") != m.end() && !m["MaxEntries"].empty()) {
      maxEntries = make_shared<long>(boost::any_cast<long>(m["MaxEntries"]));
    }
    if (m.find("AddressFamily") != m.end() && !m["AddressFamily"].empty()) {
      addressFamily = make_shared<string>(boost::any_cast<string>(m["AddressFamily"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("PrefixListName") != m.end() && !m["PrefixListName"].empty()) {
      prefixListName = make_shared<string>(boost::any_cast<string>(m["PrefixListName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~CreatePrefixListRequest() = default;
};
class CreatePrefixListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> prefixListId{};
  shared_ptr<string> requestId{};

  CreatePrefixListResponseBody() {}

  explicit CreatePrefixListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (prefixListId) {
      res["PrefixListId"] = boost::any(*prefixListId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrefixListId") != m.end() && !m["PrefixListId"].empty()) {
      prefixListId = make_shared<string>(boost::any_cast<string>(m["PrefixListId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreatePrefixListResponseBody() = default;
};
class CreatePrefixListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreatePrefixListResponseBody> body{};

  CreatePrefixListResponse() {}

  explicit CreatePrefixListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePrefixListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePrefixListResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePrefixListResponse() = default;
};
class CreateResource02RequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateResource02RequestFilter() {}

  explicit CreateResource02RequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateResource02RequestFilter() = default;
};
class CreateResource02Request : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<vector<CreateResource02RequestFilter>> filter{};

  CreateResource02Request() {}

  explicit CreateResource02Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<CreateResource02RequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateResource02RequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<CreateResource02RequestFilter>>(expect1);
      }
    }
  }


  virtual ~CreateResource02Request() = default;
};
class CreateResource02ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> requestId{};
  shared_ptr<string> ids{};

  CreateResource02ResponseBody() {}

  explicit CreateResource02ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ids) {
      res["ids"] = boost::any(*ids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ids") != m.end() && !m["ids"].empty()) {
      ids = make_shared<string>(boost::any_cast<string>(m["ids"]));
    }
  }


  virtual ~CreateResource02ResponseBody() = default;
};
class CreateResource02Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateResource02ResponseBody> body{};

  CreateResource02Response() {}

  explicit CreateResource02Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateResource02ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateResource02ResponseBody>(model1);
      }
    }
  }


  virtual ~CreateResource02Response() = default;
};
class CreateRouteEntryRequestNextHopList : public Darabonba::Model {
public:
  shared_ptr<string> nextHopId{};
  shared_ptr<string> nextHopType{};

  CreateRouteEntryRequestNextHopList() {}

  explicit CreateRouteEntryRequestNextHopList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextHopId) {
      res["NextHopId"] = boost::any(*nextHopId);
    }
    if (nextHopType) {
      res["NextHopType"] = boost::any(*nextHopType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextHopId") != m.end() && !m["NextHopId"].empty()) {
      nextHopId = make_shared<string>(boost::any_cast<string>(m["NextHopId"]));
    }
    if (m.find("NextHopType") != m.end() && !m["NextHopType"].empty()) {
      nextHopType = make_shared<string>(boost::any_cast<string>(m["NextHopType"]));
    }
  }


  virtual ~CreateRouteEntryRequestNextHopList() = default;
};
class CreateRouteEntryRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> routeTableId{};
  shared_ptr<string> destinationCidrBlock{};
  shared_ptr<string> nextHopId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> nextHopType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<vector<CreateRouteEntryRequestNextHopList>> nextHopList{};

  CreateRouteEntryRequest() {}

  explicit CreateRouteEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (destinationCidrBlock) {
      res["DestinationCidrBlock"] = boost::any(*destinationCidrBlock);
    }
    if (nextHopId) {
      res["NextHopId"] = boost::any(*nextHopId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (nextHopType) {
      res["NextHopType"] = boost::any(*nextHopType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (nextHopList) {
      vector<boost::any> temp1;
      for(auto item1:*nextHopList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NextHopList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("DestinationCidrBlock") != m.end() && !m["DestinationCidrBlock"].empty()) {
      destinationCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestinationCidrBlock"]));
    }
    if (m.find("NextHopId") != m.end() && !m["NextHopId"].empty()) {
      nextHopId = make_shared<string>(boost::any_cast<string>(m["NextHopId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("NextHopType") != m.end() && !m["NextHopType"].empty()) {
      nextHopType = make_shared<string>(boost::any_cast<string>(m["NextHopType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("NextHopList") != m.end() && !m["NextHopList"].empty()) {
      if (typeid(vector<boost::any>) == m["NextHopList"].type()) {
        vector<CreateRouteEntryRequestNextHopList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NextHopList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRouteEntryRequestNextHopList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nextHopList = make_shared<vector<CreateRouteEntryRequestNextHopList>>(expect1);
      }
    }
  }


  virtual ~CreateRouteEntryRequest() = default;
};
class CreateRouteEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateRouteEntryResponseBody() {}

  explicit CreateRouteEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateRouteEntryResponseBody() = default;
};
class CreateRouteEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateRouteEntryResponseBody> body{};

  CreateRouteEntryResponse() {}

  explicit CreateRouteEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRouteEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRouteEntryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRouteEntryResponse() = default;
};
class CreateRouterInterfaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> role{};
  shared_ptr<string> oppositeRegionId{};
  shared_ptr<string> spec{};
  shared_ptr<string> routerType{};
  shared_ptr<string> routerId{};
  shared_ptr<string> oppositeInterfaceId{};
  shared_ptr<string> oppositeRouterId{};
  shared_ptr<string> oppositeRouterType{};
  shared_ptr<string> oppositeInterfaceOwnerId{};
  shared_ptr<string> healthCheckSourceIp{};
  shared_ptr<string> healthCheckTargetIp{};
  shared_ptr<string> accessPointId{};
  shared_ptr<string> oppositeAccessPointId{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<long> period{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<bool> autoPay{};
  shared_ptr<string> pricingCycle{};
  shared_ptr<string> clientToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> userCidr{};

  CreateRouterInterfaceRequest() {}

  explicit CreateRouterInterfaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (oppositeRegionId) {
      res["OppositeRegionId"] = boost::any(*oppositeRegionId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (routerType) {
      res["RouterType"] = boost::any(*routerType);
    }
    if (routerId) {
      res["RouterId"] = boost::any(*routerId);
    }
    if (oppositeInterfaceId) {
      res["OppositeInterfaceId"] = boost::any(*oppositeInterfaceId);
    }
    if (oppositeRouterId) {
      res["OppositeRouterId"] = boost::any(*oppositeRouterId);
    }
    if (oppositeRouterType) {
      res["OppositeRouterType"] = boost::any(*oppositeRouterType);
    }
    if (oppositeInterfaceOwnerId) {
      res["OppositeInterfaceOwnerId"] = boost::any(*oppositeInterfaceOwnerId);
    }
    if (healthCheckSourceIp) {
      res["HealthCheckSourceIp"] = boost::any(*healthCheckSourceIp);
    }
    if (healthCheckTargetIp) {
      res["HealthCheckTargetIp"] = boost::any(*healthCheckTargetIp);
    }
    if (accessPointId) {
      res["AccessPointId"] = boost::any(*accessPointId);
    }
    if (oppositeAccessPointId) {
      res["OppositeAccessPointId"] = boost::any(*oppositeAccessPointId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (pricingCycle) {
      res["PricingCycle"] = boost::any(*pricingCycle);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (userCidr) {
      res["UserCidr"] = boost::any(*userCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("OppositeRegionId") != m.end() && !m["OppositeRegionId"].empty()) {
      oppositeRegionId = make_shared<string>(boost::any_cast<string>(m["OppositeRegionId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("RouterType") != m.end() && !m["RouterType"].empty()) {
      routerType = make_shared<string>(boost::any_cast<string>(m["RouterType"]));
    }
    if (m.find("RouterId") != m.end() && !m["RouterId"].empty()) {
      routerId = make_shared<string>(boost::any_cast<string>(m["RouterId"]));
    }
    if (m.find("OppositeInterfaceId") != m.end() && !m["OppositeInterfaceId"].empty()) {
      oppositeInterfaceId = make_shared<string>(boost::any_cast<string>(m["OppositeInterfaceId"]));
    }
    if (m.find("OppositeRouterId") != m.end() && !m["OppositeRouterId"].empty()) {
      oppositeRouterId = make_shared<string>(boost::any_cast<string>(m["OppositeRouterId"]));
    }
    if (m.find("OppositeRouterType") != m.end() && !m["OppositeRouterType"].empty()) {
      oppositeRouterType = make_shared<string>(boost::any_cast<string>(m["OppositeRouterType"]));
    }
    if (m.find("OppositeInterfaceOwnerId") != m.end() && !m["OppositeInterfaceOwnerId"].empty()) {
      oppositeInterfaceOwnerId = make_shared<string>(boost::any_cast<string>(m["OppositeInterfaceOwnerId"]));
    }
    if (m.find("HealthCheckSourceIp") != m.end() && !m["HealthCheckSourceIp"].empty()) {
      healthCheckSourceIp = make_shared<string>(boost::any_cast<string>(m["HealthCheckSourceIp"]));
    }
    if (m.find("HealthCheckTargetIp") != m.end() && !m["HealthCheckTargetIp"].empty()) {
      healthCheckTargetIp = make_shared<string>(boost::any_cast<string>(m["HealthCheckTargetIp"]));
    }
    if (m.find("AccessPointId") != m.end() && !m["AccessPointId"].empty()) {
      accessPointId = make_shared<string>(boost::any_cast<string>(m["AccessPointId"]));
    }
    if (m.find("OppositeAccessPointId") != m.end() && !m["OppositeAccessPointId"].empty()) {
      oppositeAccessPointId = make_shared<string>(boost::any_cast<string>(m["OppositeAccessPointId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("PricingCycle") != m.end() && !m["PricingCycle"].empty()) {
      pricingCycle = make_shared<string>(boost::any_cast<string>(m["PricingCycle"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("UserCidr") != m.end() && !m["UserCidr"].empty()) {
      userCidr = make_shared<string>(boost::any_cast<string>(m["UserCidr"]));
    }
  }


  virtual ~CreateRouterInterfaceRequest() = default;
};
class CreateRouterInterfaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> orderId{};
  shared_ptr<string> routerInterfaceId{};

  CreateRouterInterfaceResponseBody() {}

  explicit CreateRouterInterfaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (routerInterfaceId) {
      res["RouterInterfaceId"] = boost::any(*routerInterfaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("RouterInterfaceId") != m.end() && !m["RouterInterfaceId"].empty()) {
      routerInterfaceId = make_shared<string>(boost::any_cast<string>(m["RouterInterfaceId"]));
    }
  }


  virtual ~CreateRouterInterfaceResponseBody() = default;
};
class CreateRouterInterfaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateRouterInterfaceResponseBody> body{};

  CreateRouterInterfaceResponse() {}

  explicit CreateRouterInterfaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRouterInterfaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRouterInterfaceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRouterInterfaceResponse() = default;
};
class CreateSecurityGroupRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateSecurityGroupRequestTag() {}

  explicit CreateSecurityGroupRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateSecurityGroupRequestTag() = default;
};
class CreateSecurityGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> description{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> securityGroupName{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> securityGroupType{};
  shared_ptr<bool> serviceManaged{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<CreateSecurityGroupRequestTag>> tag{};

  CreateSecurityGroupRequest() {}

  explicit CreateSecurityGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (securityGroupType) {
      res["SecurityGroupType"] = boost::any(*securityGroupType);
    }
    if (serviceManaged) {
      res["ServiceManaged"] = boost::any(*serviceManaged);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("SecurityGroupType") != m.end() && !m["SecurityGroupType"].empty()) {
      securityGroupType = make_shared<string>(boost::any_cast<string>(m["SecurityGroupType"]));
    }
    if (m.find("ServiceManaged") != m.end() && !m["ServiceManaged"].empty()) {
      serviceManaged = make_shared<bool>(boost::any_cast<bool>(m["ServiceManaged"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateSecurityGroupRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSecurityGroupRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateSecurityGroupRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateSecurityGroupRequest() = default;
};
class CreateSecurityGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> requestId{};

  CreateSecurityGroupResponseBody() {}

  explicit CreateSecurityGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateSecurityGroupResponseBody() = default;
};
class CreateSecurityGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateSecurityGroupResponseBody> body{};

  CreateSecurityGroupResponse() {}

  explicit CreateSecurityGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSecurityGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSecurityGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSecurityGroupResponse() = default;
};
class CreateSimulatedSystemEventsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<string> eventType{};
  shared_ptr<string> notBefore{};

  CreateSimulatedSystemEventsRequest() {}

  explicit CreateSimulatedSystemEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (notBefore) {
      res["NotBefore"] = boost::any(*notBefore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("NotBefore") != m.end() && !m["NotBefore"].empty()) {
      notBefore = make_shared<string>(boost::any_cast<string>(m["NotBefore"]));
    }
  }


  virtual ~CreateSimulatedSystemEventsRequest() = default;
};
class CreateSimulatedSystemEventsResponseBodyEventIdSet : public Darabonba::Model {
public:
  shared_ptr<vector<string>> eventId{};

  CreateSimulatedSystemEventsResponseBodyEventIdSet() {}

  explicit CreateSimulatedSystemEventsResponseBodyEventIdSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EventId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EventId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eventId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateSimulatedSystemEventsResponseBodyEventIdSet() = default;
};
class CreateSimulatedSystemEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateSimulatedSystemEventsResponseBodyEventIdSet> eventIdSet{};

  CreateSimulatedSystemEventsResponseBody() {}

  explicit CreateSimulatedSystemEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (eventIdSet) {
      res["EventIdSet"] = eventIdSet ? boost::any(eventIdSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("EventIdSet") != m.end() && !m["EventIdSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventIdSet"].type()) {
        CreateSimulatedSystemEventsResponseBodyEventIdSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventIdSet"]));
        eventIdSet = make_shared<CreateSimulatedSystemEventsResponseBodyEventIdSet>(model1);
      }
    }
  }


  virtual ~CreateSimulatedSystemEventsResponseBody() = default;
};
class CreateSimulatedSystemEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateSimulatedSystemEventsResponseBody> body{};

  CreateSimulatedSystemEventsResponse() {}

  explicit CreateSimulatedSystemEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSimulatedSystemEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSimulatedSystemEventsResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSimulatedSystemEventsResponse() = default;
};
class CreateSnapshotRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateSnapshotRequestTag() {}

  explicit CreateSnapshotRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateSnapshotRequestTag() = default;
};
class CreateSnapshotRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> diskId{};
  shared_ptr<string> snapshotName{};
  shared_ptr<string> description{};
  shared_ptr<long> retentionDays{};
  shared_ptr<string> category{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> instantAccess{};
  shared_ptr<long> instantAccessRetentionDays{};
  shared_ptr<vector<CreateSnapshotRequestTag>> tag{};

  CreateSnapshotRequest() {}

  explicit CreateSnapshotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (snapshotName) {
      res["SnapshotName"] = boost::any(*snapshotName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (retentionDays) {
      res["RetentionDays"] = boost::any(*retentionDays);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (instantAccess) {
      res["InstantAccess"] = boost::any(*instantAccess);
    }
    if (instantAccessRetentionDays) {
      res["InstantAccessRetentionDays"] = boost::any(*instantAccessRetentionDays);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("SnapshotName") != m.end() && !m["SnapshotName"].empty()) {
      snapshotName = make_shared<string>(boost::any_cast<string>(m["SnapshotName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RetentionDays") != m.end() && !m["RetentionDays"].empty()) {
      retentionDays = make_shared<long>(boost::any_cast<long>(m["RetentionDays"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("InstantAccess") != m.end() && !m["InstantAccess"].empty()) {
      instantAccess = make_shared<bool>(boost::any_cast<bool>(m["InstantAccess"]));
    }
    if (m.find("InstantAccessRetentionDays") != m.end() && !m["InstantAccessRetentionDays"].empty()) {
      instantAccessRetentionDays = make_shared<long>(boost::any_cast<long>(m["InstantAccessRetentionDays"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateSnapshotRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSnapshotRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateSnapshotRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateSnapshotRequest() = default;
};
class CreateSnapshotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> snapshotId{};
  shared_ptr<string> requestId{};

  CreateSnapshotResponseBody() {}

  explicit CreateSnapshotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateSnapshotResponseBody() = default;
};
class CreateSnapshotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateSnapshotResponseBody> body{};

  CreateSnapshotResponse() {}

  explicit CreateSnapshotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSnapshotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSnapshotResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSnapshotResponse() = default;
};
class CreateSnapshotGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> instantAccess{};
  shared_ptr<long> instantAccessRetentionDays{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<vector<string>> excludeDiskId{};

  CreateSnapshotGroupRequest() {}

  explicit CreateSnapshotGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instantAccess) {
      res["InstantAccess"] = boost::any(*instantAccess);
    }
    if (instantAccessRetentionDays) {
      res["InstantAccessRetentionDays"] = boost::any(*instantAccessRetentionDays);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (excludeDiskId) {
      res["ExcludeDiskId"] = boost::any(*excludeDiskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstantAccess") != m.end() && !m["InstantAccess"].empty()) {
      instantAccess = make_shared<bool>(boost::any_cast<bool>(m["InstantAccess"]));
    }
    if (m.find("InstantAccessRetentionDays") != m.end() && !m["InstantAccessRetentionDays"].empty()) {
      instantAccessRetentionDays = make_shared<long>(boost::any_cast<long>(m["InstantAccessRetentionDays"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExcludeDiskId") != m.end() && !m["ExcludeDiskId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeDiskId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeDiskId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeDiskId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateSnapshotGroupRequest() = default;
};
class CreateSnapshotGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> snapshotGroupId{};
  shared_ptr<string> requestId{};

  CreateSnapshotGroupResponseBody() {}

  explicit CreateSnapshotGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshotGroupId) {
      res["SnapshotGroupId"] = boost::any(*snapshotGroupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnapshotGroupId") != m.end() && !m["SnapshotGroupId"].empty()) {
      snapshotGroupId = make_shared<string>(boost::any_cast<string>(m["SnapshotGroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateSnapshotGroupResponseBody() = default;
};
class CreateSnapshotGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateSnapshotGroupResponseBody> body{};

  CreateSnapshotGroupResponse() {}

  explicit CreateSnapshotGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSnapshotGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSnapshotGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSnapshotGroupResponse() = default;
};
class CreateStorageSetRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> storageSetName{};
  shared_ptr<string> description{};
  shared_ptr<long> maxPartitionNumber{};

  CreateStorageSetRequest() {}

  explicit CreateStorageSetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (storageSetName) {
      res["StorageSetName"] = boost::any(*storageSetName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (maxPartitionNumber) {
      res["MaxPartitionNumber"] = boost::any(*maxPartitionNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("StorageSetName") != m.end() && !m["StorageSetName"].empty()) {
      storageSetName = make_shared<string>(boost::any_cast<string>(m["StorageSetName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("MaxPartitionNumber") != m.end() && !m["MaxPartitionNumber"].empty()) {
      maxPartitionNumber = make_shared<long>(boost::any_cast<long>(m["MaxPartitionNumber"]));
    }
  }


  virtual ~CreateStorageSetRequest() = default;
};
class CreateStorageSetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> storageSetId{};
  shared_ptr<string> requestId{};

  CreateStorageSetResponseBody() {}

  explicit CreateStorageSetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateStorageSetResponseBody() = default;
};
class CreateStorageSetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateStorageSetResponseBody> body{};

  CreateStorageSetResponse() {}

  explicit CreateStorageSetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateStorageSetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateStorageSetResponseBody>(model1);
      }
    }
  }


  virtual ~CreateStorageSetResponse() = default;
};
class CreateVirtualBorderRouterRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<long> vbrOwnerId{};
  shared_ptr<long> vlanId{};
  shared_ptr<string> circuitCode{};
  shared_ptr<string> localGatewayIp{};
  shared_ptr<string> peerGatewayIp{};
  shared_ptr<string> peeringSubnetMask{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> clientToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> userCidr{};

  CreateVirtualBorderRouterRequest() {}

  explicit CreateVirtualBorderRouterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (vbrOwnerId) {
      res["VbrOwnerId"] = boost::any(*vbrOwnerId);
    }
    if (vlanId) {
      res["VlanId"] = boost::any(*vlanId);
    }
    if (circuitCode) {
      res["CircuitCode"] = boost::any(*circuitCode);
    }
    if (localGatewayIp) {
      res["LocalGatewayIp"] = boost::any(*localGatewayIp);
    }
    if (peerGatewayIp) {
      res["PeerGatewayIp"] = boost::any(*peerGatewayIp);
    }
    if (peeringSubnetMask) {
      res["PeeringSubnetMask"] = boost::any(*peeringSubnetMask);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (userCidr) {
      res["UserCidr"] = boost::any(*userCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("VbrOwnerId") != m.end() && !m["VbrOwnerId"].empty()) {
      vbrOwnerId = make_shared<long>(boost::any_cast<long>(m["VbrOwnerId"]));
    }
    if (m.find("VlanId") != m.end() && !m["VlanId"].empty()) {
      vlanId = make_shared<long>(boost::any_cast<long>(m["VlanId"]));
    }
    if (m.find("CircuitCode") != m.end() && !m["CircuitCode"].empty()) {
      circuitCode = make_shared<string>(boost::any_cast<string>(m["CircuitCode"]));
    }
    if (m.find("LocalGatewayIp") != m.end() && !m["LocalGatewayIp"].empty()) {
      localGatewayIp = make_shared<string>(boost::any_cast<string>(m["LocalGatewayIp"]));
    }
    if (m.find("PeerGatewayIp") != m.end() && !m["PeerGatewayIp"].empty()) {
      peerGatewayIp = make_shared<string>(boost::any_cast<string>(m["PeerGatewayIp"]));
    }
    if (m.find("PeeringSubnetMask") != m.end() && !m["PeeringSubnetMask"].empty()) {
      peeringSubnetMask = make_shared<string>(boost::any_cast<string>(m["PeeringSubnetMask"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("UserCidr") != m.end() && !m["UserCidr"].empty()) {
      userCidr = make_shared<string>(boost::any_cast<string>(m["UserCidr"]));
    }
  }


  virtual ~CreateVirtualBorderRouterRequest() = default;
};
class CreateVirtualBorderRouterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> vbrId{};
  shared_ptr<string> requestId{};

  CreateVirtualBorderRouterResponseBody() {}

  explicit CreateVirtualBorderRouterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vbrId) {
      res["VbrId"] = boost::any(*vbrId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VbrId") != m.end() && !m["VbrId"].empty()) {
      vbrId = make_shared<string>(boost::any_cast<string>(m["VbrId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateVirtualBorderRouterResponseBody() = default;
};
class CreateVirtualBorderRouterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateVirtualBorderRouterResponseBody> body{};

  CreateVirtualBorderRouterResponse() {}

  explicit CreateVirtualBorderRouterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVirtualBorderRouterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVirtualBorderRouterResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVirtualBorderRouterResponse() = default;
};
class CreateVpcRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> vpcName{};
  shared_ptr<string> description{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> userCidr{};

  CreateVpcRequest() {}

  explicit CreateVpcRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (userCidr) {
      res["UserCidr"] = boost::any(*userCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("UserCidr") != m.end() && !m["UserCidr"].empty()) {
      userCidr = make_shared<string>(boost::any_cast<string>(m["UserCidr"]));
    }
  }


  virtual ~CreateVpcRequest() = default;
};
class CreateVpcResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<string> VRouterId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> routeTableId{};

  CreateVpcResponseBody() {}

  explicit CreateVpcResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (VRouterId) {
      res["VRouterId"] = boost::any(*VRouterId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VRouterId") != m.end() && !m["VRouterId"].empty()) {
      VRouterId = make_shared<string>(boost::any_cast<string>(m["VRouterId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
  }


  virtual ~CreateVpcResponseBody() = default;
};
class CreateVpcResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateVpcResponseBody> body{};

  CreateVpcResponse() {}

  explicit CreateVpcResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVpcResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVpcResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVpcResponse() = default;
};
class CreateVSwitchRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> vSwitchName{};
  shared_ptr<string> description{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};

  CreateVSwitchRequest() {}

  explicit CreateVSwitchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vSwitchName) {
      res["VSwitchName"] = boost::any(*vSwitchName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VSwitchName") != m.end() && !m["VSwitchName"].empty()) {
      vSwitchName = make_shared<string>(boost::any_cast<string>(m["VSwitchName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~CreateVSwitchRequest() = default;
};
class CreateVSwitchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> requestId{};

  CreateVSwitchResponseBody() {}

  explicit CreateVSwitchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateVSwitchResponseBody() = default;
};
class CreateVSwitchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateVSwitchResponseBody> body{};

  CreateVSwitchResponse() {}

  explicit CreateVSwitchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVSwitchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVSwitchResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVSwitchResponse() = default;
};
class DeactivateRouterInterfaceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> routerInterfaceId{};

  DeactivateRouterInterfaceRequest() {}

  explicit DeactivateRouterInterfaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (routerInterfaceId) {
      res["RouterInterfaceId"] = boost::any(*routerInterfaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RouterInterfaceId") != m.end() && !m["RouterInterfaceId"].empty()) {
      routerInterfaceId = make_shared<string>(boost::any_cast<string>(m["RouterInterfaceId"]));
    }
  }


  virtual ~DeactivateRouterInterfaceRequest() = default;
};
class DeactivateRouterInterfaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeactivateRouterInterfaceResponseBody() {}

  explicit DeactivateRouterInterfaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeactivateRouterInterfaceResponseBody() = default;
};
class DeactivateRouterInterfaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeactivateRouterInterfaceResponseBody> body{};

  DeactivateRouterInterfaceResponse() {}

  explicit DeactivateRouterInterfaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeactivateRouterInterfaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeactivateRouterInterfaceResponseBody>(model1);
      }
    }
  }


  virtual ~DeactivateRouterInterfaceResponse() = default;
};
class DeleteActivationRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> activationId{};

  DeleteActivationRequest() {}

  explicit DeleteActivationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (activationId) {
      res["ActivationId"] = boost::any(*activationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ActivationId") != m.end() && !m["ActivationId"].empty()) {
      activationId = make_shared<string>(boost::any_cast<string>(m["ActivationId"]));
    }
  }


  virtual ~DeleteActivationRequest() = default;
};
class DeleteActivationResponseBodyActivation : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<long> deregisteredCount{};
  shared_ptr<long> instanceCount{};
  shared_ptr<string> description{};
  shared_ptr<long> registeredCount{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> ipAddressRange{};
  shared_ptr<long> timeToLiveInHours{};
  shared_ptr<string> activationId{};

  DeleteActivationResponseBodyActivation() {}

  explicit DeleteActivationResponseBodyActivation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (deregisteredCount) {
      res["DeregisteredCount"] = boost::any(*deregisteredCount);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (registeredCount) {
      res["RegisteredCount"] = boost::any(*registeredCount);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (ipAddressRange) {
      res["IpAddressRange"] = boost::any(*ipAddressRange);
    }
    if (timeToLiveInHours) {
      res["TimeToLiveInHours"] = boost::any(*timeToLiveInHours);
    }
    if (activationId) {
      res["ActivationId"] = boost::any(*activationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DeregisteredCount") != m.end() && !m["DeregisteredCount"].empty()) {
      deregisteredCount = make_shared<long>(boost::any_cast<long>(m["DeregisteredCount"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RegisteredCount") != m.end() && !m["RegisteredCount"].empty()) {
      registeredCount = make_shared<long>(boost::any_cast<long>(m["RegisteredCount"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("IpAddressRange") != m.end() && !m["IpAddressRange"].empty()) {
      ipAddressRange = make_shared<string>(boost::any_cast<string>(m["IpAddressRange"]));
    }
    if (m.find("TimeToLiveInHours") != m.end() && !m["TimeToLiveInHours"].empty()) {
      timeToLiveInHours = make_shared<long>(boost::any_cast<long>(m["TimeToLiveInHours"]));
    }
    if (m.find("ActivationId") != m.end() && !m["ActivationId"].empty()) {
      activationId = make_shared<string>(boost::any_cast<string>(m["ActivationId"]));
    }
  }


  virtual ~DeleteActivationResponseBodyActivation() = default;
};
class DeleteActivationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DeleteActivationResponseBodyActivation> activation{};

  DeleteActivationResponseBody() {}

  explicit DeleteActivationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (activation) {
      res["Activation"] = activation ? boost::any(activation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Activation") != m.end() && !m["Activation"].empty()) {
      if (typeid(map<string, boost::any>) == m["Activation"].type()) {
        DeleteActivationResponseBodyActivation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Activation"]));
        activation = make_shared<DeleteActivationResponseBodyActivation>(model1);
      }
    }
  }


  virtual ~DeleteActivationResponseBody() = default;
};
class DeleteActivationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteActivationResponseBody> body{};

  DeleteActivationResponse() {}

  explicit DeleteActivationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteActivationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteActivationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteActivationResponse() = default;
};
class DeleteAutoProvisioningGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> autoProvisioningGroupId{};
  shared_ptr<bool> terminateInstances{};

  DeleteAutoProvisioningGroupRequest() {}

  explicit DeleteAutoProvisioningGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (autoProvisioningGroupId) {
      res["AutoProvisioningGroupId"] = boost::any(*autoProvisioningGroupId);
    }
    if (terminateInstances) {
      res["TerminateInstances"] = boost::any(*terminateInstances);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AutoProvisioningGroupId") != m.end() && !m["AutoProvisioningGroupId"].empty()) {
      autoProvisioningGroupId = make_shared<string>(boost::any_cast<string>(m["AutoProvisioningGroupId"]));
    }
    if (m.find("TerminateInstances") != m.end() && !m["TerminateInstances"].empty()) {
      terminateInstances = make_shared<bool>(boost::any_cast<bool>(m["TerminateInstances"]));
    }
  }


  virtual ~DeleteAutoProvisioningGroupRequest() = default;
};
class DeleteAutoProvisioningGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteAutoProvisioningGroupResponseBody() {}

  explicit DeleteAutoProvisioningGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAutoProvisioningGroupResponseBody() = default;
};
class DeleteAutoProvisioningGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteAutoProvisioningGroupResponseBody> body{};

  DeleteAutoProvisioningGroupResponse() {}

  explicit DeleteAutoProvisioningGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAutoProvisioningGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAutoProvisioningGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAutoProvisioningGroupResponse() = default;
};
class DeleteAutoSnapshotPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> autoSnapshotPolicyId{};

  DeleteAutoSnapshotPolicyRequest() {}

  explicit DeleteAutoSnapshotPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["regionId"] = boost::any(*regionId);
    }
    if (autoSnapshotPolicyId) {
      res["autoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("regionId") != m.end() && !m["regionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["regionId"]));
    }
    if (m.find("autoSnapshotPolicyId") != m.end() && !m["autoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["autoSnapshotPolicyId"]));
    }
  }


  virtual ~DeleteAutoSnapshotPolicyRequest() = default;
};
class DeleteAutoSnapshotPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteAutoSnapshotPolicyResponseBody() {}

  explicit DeleteAutoSnapshotPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAutoSnapshotPolicyResponseBody() = default;
};
class DeleteAutoSnapshotPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteAutoSnapshotPolicyResponseBody> body{};

  DeleteAutoSnapshotPolicyResponse() {}

  explicit DeleteAutoSnapshotPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAutoSnapshotPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAutoSnapshotPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAutoSnapshotPolicyResponse() = default;
};
class DeleteBandwidthPackageRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> bandwidthPackageId{};

  DeleteBandwidthPackageRequest() {}

  explicit DeleteBandwidthPackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
  }


  virtual ~DeleteBandwidthPackageRequest() = default;
};
class DeleteBandwidthPackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteBandwidthPackageResponseBody() {}

  explicit DeleteBandwidthPackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteBandwidthPackageResponseBody() = default;
};
class DeleteBandwidthPackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteBandwidthPackageResponseBody> body{};

  DeleteBandwidthPackageResponse() {}

  explicit DeleteBandwidthPackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBandwidthPackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBandwidthPackageResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBandwidthPackageResponse() = default;
};
class DeleteCommandRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> commandId{};

  DeleteCommandRequest() {}

  explicit DeleteCommandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (commandId) {
      res["CommandId"] = boost::any(*commandId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("CommandId") != m.end() && !m["CommandId"].empty()) {
      commandId = make_shared<string>(boost::any_cast<string>(m["CommandId"]));
    }
  }


  virtual ~DeleteCommandRequest() = default;
};
class DeleteCommandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCommandResponseBody() {}

  explicit DeleteCommandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCommandResponseBody() = default;
};
class DeleteCommandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteCommandResponseBody> body{};

  DeleteCommandResponse() {}

  explicit DeleteCommandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCommandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCommandResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCommandResponse() = default;
};
class DeleteDedicatedHostClusterRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> dedicatedHostClusterId{};

  DeleteDedicatedHostClusterRequest() {}

  explicit DeleteDedicatedHostClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
  }


  virtual ~DeleteDedicatedHostClusterRequest() = default;
};
class DeleteDedicatedHostClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDedicatedHostClusterResponseBody() {}

  explicit DeleteDedicatedHostClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDedicatedHostClusterResponseBody() = default;
};
class DeleteDedicatedHostClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDedicatedHostClusterResponseBody> body{};

  DeleteDedicatedHostClusterResponse() {}

  explicit DeleteDedicatedHostClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDedicatedHostClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDedicatedHostClusterResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDedicatedHostClusterResponse() = default;
};
class DeleteDemandRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> demandId{};
  shared_ptr<string> reason{};

  DeleteDemandRequest() {}

  explicit DeleteDemandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (demandId) {
      res["DemandId"] = boost::any(*demandId);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DemandId") != m.end() && !m["DemandId"].empty()) {
      demandId = make_shared<string>(boost::any_cast<string>(m["DemandId"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~DeleteDemandRequest() = default;
};
class DeleteDemandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDemandResponseBody() {}

  explicit DeleteDemandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDemandResponseBody() = default;
};
class DeleteDemandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDemandResponseBody> body{};

  DeleteDemandResponse() {}

  explicit DeleteDemandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDemandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDemandResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDemandResponse() = default;
};
class DeleteDeploymentSetRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> deploymentSetId{};
  shared_ptr<string> ownerAccount{};

  DeleteDeploymentSetRequest() {}

  explicit DeleteDeploymentSetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (deploymentSetId) {
      res["DeploymentSetId"] = boost::any(*deploymentSetId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DeploymentSetId") != m.end() && !m["DeploymentSetId"].empty()) {
      deploymentSetId = make_shared<string>(boost::any_cast<string>(m["DeploymentSetId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DeleteDeploymentSetRequest() = default;
};
class DeleteDeploymentSetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDeploymentSetResponseBody() {}

  explicit DeleteDeploymentSetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDeploymentSetResponseBody() = default;
};
class DeleteDeploymentSetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDeploymentSetResponseBody> body{};

  DeleteDeploymentSetResponse() {}

  explicit DeleteDeploymentSetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDeploymentSetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDeploymentSetResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDeploymentSetResponse() = default;
};
class DeleteDiskRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> diskId{};
  shared_ptr<string> ownerAccount{};

  DeleteDiskRequest() {}

  explicit DeleteDiskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DeleteDiskRequest() = default;
};
class DeleteDiskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDiskResponseBody() {}

  explicit DeleteDiskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDiskResponseBody() = default;
};
class DeleteDiskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDiskResponseBody> body{};

  DeleteDiskResponse() {}

  explicit DeleteDiskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDiskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDiskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDiskResponse() = default;
};
class DeleteDiskReplicaPairRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> replicaPairId{};

  DeleteDiskReplicaPairRequest() {}

  explicit DeleteDiskReplicaPairRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (replicaPairId) {
      res["ReplicaPairId"] = boost::any(*replicaPairId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReplicaPairId") != m.end() && !m["ReplicaPairId"].empty()) {
      replicaPairId = make_shared<string>(boost::any_cast<string>(m["ReplicaPairId"]));
    }
  }


  virtual ~DeleteDiskReplicaPairRequest() = default;
};
class DeleteDiskReplicaPairResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDiskReplicaPairResponseBody() {}

  explicit DeleteDiskReplicaPairResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDiskReplicaPairResponseBody() = default;
};
class DeleteDiskReplicaPairResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDiskReplicaPairResponseBody> body{};

  DeleteDiskReplicaPairResponse() {}

  explicit DeleteDiskReplicaPairResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDiskReplicaPairResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDiskReplicaPairResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDiskReplicaPairResponse() = default;
};
class DeleteForwardEntryRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> forwardTableId{};
  shared_ptr<string> forwardEntryId{};

  DeleteForwardEntryRequest() {}

  explicit DeleteForwardEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (forwardTableId) {
      res["ForwardTableId"] = boost::any(*forwardTableId);
    }
    if (forwardEntryId) {
      res["ForwardEntryId"] = boost::any(*forwardEntryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ForwardTableId") != m.end() && !m["ForwardTableId"].empty()) {
      forwardTableId = make_shared<string>(boost::any_cast<string>(m["ForwardTableId"]));
    }
    if (m.find("ForwardEntryId") != m.end() && !m["ForwardEntryId"].empty()) {
      forwardEntryId = make_shared<string>(boost::any_cast<string>(m["ForwardEntryId"]));
    }
  }


  virtual ~DeleteForwardEntryRequest() = default;
};
class DeleteForwardEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteForwardEntryResponseBody() {}

  explicit DeleteForwardEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteForwardEntryResponseBody() = default;
};
class DeleteForwardEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteForwardEntryResponseBody> body{};

  DeleteForwardEntryResponse() {}

  explicit DeleteForwardEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteForwardEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteForwardEntryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteForwardEntryResponse() = default;
};
class DeleteHaVipRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> haVipId{};

  DeleteHaVipRequest() {}

  explicit DeleteHaVipRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (haVipId) {
      res["HaVipId"] = boost::any(*haVipId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("HaVipId") != m.end() && !m["HaVipId"].empty()) {
      haVipId = make_shared<string>(boost::any_cast<string>(m["HaVipId"]));
    }
  }


  virtual ~DeleteHaVipRequest() = default;
};
class DeleteHaVipResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteHaVipResponseBody() {}

  explicit DeleteHaVipResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteHaVipResponseBody() = default;
};
class DeleteHaVipResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteHaVipResponseBody> body{};

  DeleteHaVipResponse() {}

  explicit DeleteHaVipResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteHaVipResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteHaVipResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteHaVipResponse() = default;
};
class DeleteHpcClusterRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> hpcClusterId{};

  DeleteHpcClusterRequest() {}

  explicit DeleteHpcClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (hpcClusterId) {
      res["HpcClusterId"] = boost::any(*hpcClusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("HpcClusterId") != m.end() && !m["HpcClusterId"].empty()) {
      hpcClusterId = make_shared<string>(boost::any_cast<string>(m["HpcClusterId"]));
    }
  }


  virtual ~DeleteHpcClusterRequest() = default;
};
class DeleteHpcClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteHpcClusterResponseBody() {}

  explicit DeleteHpcClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteHpcClusterResponseBody() = default;
};
class DeleteHpcClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteHpcClusterResponseBody> body{};

  DeleteHpcClusterResponse() {}

  explicit DeleteHpcClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteHpcClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteHpcClusterResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteHpcClusterResponse() = default;
};
class DeleteImageRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> imageId{};
  shared_ptr<bool> force{};
  shared_ptr<string> ownerAccount{};

  DeleteImageRequest() {}

  explicit DeleteImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DeleteImageRequest() = default;
};
class DeleteImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteImageResponseBody() {}

  explicit DeleteImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteImageResponseBody() = default;
};
class DeleteImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteImageResponseBody> body{};

  DeleteImageResponse() {}

  explicit DeleteImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteImageResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteImageResponse() = default;
};
class DeleteImageComponentRequestTemplateTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DeleteImageComponentRequestTemplateTag() {}

  explicit DeleteImageComponentRequestTemplateTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DeleteImageComponentRequestTemplateTag() = default;
};
class DeleteImageComponentRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteImageComponentRequestTemplateTag>> templateTag{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> imageComponentId{};

  DeleteImageComponentRequest() {}

  explicit DeleteImageComponentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateTag) {
      vector<boost::any> temp1;
      for(auto item1:*templateTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TemplateTag"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (imageComponentId) {
      res["ImageComponentId"] = boost::any(*imageComponentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateTag") != m.end() && !m["TemplateTag"].empty()) {
      if (typeid(vector<boost::any>) == m["TemplateTag"].type()) {
        vector<DeleteImageComponentRequestTemplateTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TemplateTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteImageComponentRequestTemplateTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templateTag = make_shared<vector<DeleteImageComponentRequestTemplateTag>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ImageComponentId") != m.end() && !m["ImageComponentId"].empty()) {
      imageComponentId = make_shared<string>(boost::any_cast<string>(m["ImageComponentId"]));
    }
  }


  virtual ~DeleteImageComponentRequest() = default;
};
class DeleteImageComponentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteImageComponentResponseBody() {}

  explicit DeleteImageComponentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteImageComponentResponseBody() = default;
};
class DeleteImageComponentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteImageComponentResponseBody> body{};

  DeleteImageComponentResponse() {}

  explicit DeleteImageComponentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteImageComponentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteImageComponentResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteImageComponentResponse() = default;
};
class DeleteImagePipelineRequestTemplateTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DeleteImagePipelineRequestTemplateTag() {}

  explicit DeleteImagePipelineRequestTemplateTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DeleteImagePipelineRequestTemplateTag() = default;
};
class DeleteImagePipelineRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteImagePipelineRequestTemplateTag>> templateTag{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> imagePipelineId{};

  DeleteImagePipelineRequest() {}

  explicit DeleteImagePipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateTag) {
      vector<boost::any> temp1;
      for(auto item1:*templateTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TemplateTag"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (imagePipelineId) {
      res["ImagePipelineId"] = boost::any(*imagePipelineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateTag") != m.end() && !m["TemplateTag"].empty()) {
      if (typeid(vector<boost::any>) == m["TemplateTag"].type()) {
        vector<DeleteImagePipelineRequestTemplateTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TemplateTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteImagePipelineRequestTemplateTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templateTag = make_shared<vector<DeleteImagePipelineRequestTemplateTag>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ImagePipelineId") != m.end() && !m["ImagePipelineId"].empty()) {
      imagePipelineId = make_shared<string>(boost::any_cast<string>(m["ImagePipelineId"]));
    }
  }


  virtual ~DeleteImagePipelineRequest() = default;
};
class DeleteImagePipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteImagePipelineResponseBody() {}

  explicit DeleteImagePipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteImagePipelineResponseBody() = default;
};
class DeleteImagePipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteImagePipelineResponseBody> body{};

  DeleteImagePipelineResponse() {}

  explicit DeleteImagePipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteImagePipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteImagePipelineResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteImagePipelineResponse() = default;
};
class DeleteInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<bool> force{};
  shared_ptr<bool> terminateSubscription{};

  DeleteInstanceRequest() {}

  explicit DeleteInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (terminateSubscription) {
      res["TerminateSubscription"] = boost::any(*terminateSubscription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
    if (m.find("TerminateSubscription") != m.end() && !m["TerminateSubscription"].empty()) {
      terminateSubscription = make_shared<bool>(boost::any_cast<bool>(m["TerminateSubscription"]));
    }
  }


  virtual ~DeleteInstanceRequest() = default;
};
class DeleteInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteInstanceResponseBody() {}

  explicit DeleteInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteInstanceResponseBody() = default;
};
class DeleteInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteInstanceResponseBody> body{};

  DeleteInstanceResponse() {}

  explicit DeleteInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteInstanceResponse() = default;
};
class DeleteInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<bool> force{};
  shared_ptr<bool> terminateSubscription{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> instanceId{};

  DeleteInstancesRequest() {}

  explicit DeleteInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (terminateSubscription) {
      res["TerminateSubscription"] = boost::any(*terminateSubscription);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
    if (m.find("TerminateSubscription") != m.end() && !m["TerminateSubscription"].empty()) {
      terminateSubscription = make_shared<bool>(boost::any_cast<bool>(m["TerminateSubscription"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteInstancesRequest() = default;
};
class DeleteInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteInstancesResponseBody() {}

  explicit DeleteInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteInstancesResponseBody() = default;
};
class DeleteInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteInstancesResponseBody> body{};

  DeleteInstancesResponse() {}

  explicit DeleteInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteInstancesResponse() = default;
};
class DeleteKeyPairsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> keyPairNames{};

  DeleteKeyPairsRequest() {}

  explicit DeleteKeyPairsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (keyPairNames) {
      res["KeyPairNames"] = boost::any(*keyPairNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("KeyPairNames") != m.end() && !m["KeyPairNames"].empty()) {
      keyPairNames = make_shared<string>(boost::any_cast<string>(m["KeyPairNames"]));
    }
  }


  virtual ~DeleteKeyPairsRequest() = default;
};
class DeleteKeyPairsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteKeyPairsResponseBody() {}

  explicit DeleteKeyPairsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteKeyPairsResponseBody() = default;
};
class DeleteKeyPairsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteKeyPairsResponseBody> body{};

  DeleteKeyPairsResponse() {}

  explicit DeleteKeyPairsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteKeyPairsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteKeyPairsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteKeyPairsResponse() = default;
};
class DeleteLaunchTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> launchTemplateId{};
  shared_ptr<string> launchTemplateName{};

  DeleteLaunchTemplateRequest() {}

  explicit DeleteLaunchTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (launchTemplateId) {
      res["LaunchTemplateId"] = boost::any(*launchTemplateId);
    }
    if (launchTemplateName) {
      res["LaunchTemplateName"] = boost::any(*launchTemplateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("LaunchTemplateId") != m.end() && !m["LaunchTemplateId"].empty()) {
      launchTemplateId = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateId"]));
    }
    if (m.find("LaunchTemplateName") != m.end() && !m["LaunchTemplateName"].empty()) {
      launchTemplateName = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateName"]));
    }
  }


  virtual ~DeleteLaunchTemplateRequest() = default;
};
class DeleteLaunchTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLaunchTemplateResponseBody() {}

  explicit DeleteLaunchTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLaunchTemplateResponseBody() = default;
};
class DeleteLaunchTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteLaunchTemplateResponseBody> body{};

  DeleteLaunchTemplateResponse() {}

  explicit DeleteLaunchTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLaunchTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLaunchTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLaunchTemplateResponse() = default;
};
class DeleteLaunchTemplateVersionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<int>> deleteVersion{};
  shared_ptr<string> launchTemplateId{};
  shared_ptr<string> launchTemplateName{};

  DeleteLaunchTemplateVersionRequest() {}

  explicit DeleteLaunchTemplateVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (deleteVersion) {
      res["DeleteVersion"] = boost::any(*deleteVersion);
    }
    if (launchTemplateId) {
      res["LaunchTemplateId"] = boost::any(*launchTemplateId);
    }
    if (launchTemplateName) {
      res["LaunchTemplateName"] = boost::any(*launchTemplateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DeleteVersion") != m.end() && !m["DeleteVersion"].empty()) {
      vector<int> toVec1;
      if (typeid(vector<boost::any>) == m["DeleteVersion"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeleteVersion"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<int>(item));
        }
      }
      deleteVersion = make_shared<vector<int>>(toVec1);
    }
    if (m.find("LaunchTemplateId") != m.end() && !m["LaunchTemplateId"].empty()) {
      launchTemplateId = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateId"]));
    }
    if (m.find("LaunchTemplateName") != m.end() && !m["LaunchTemplateName"].empty()) {
      launchTemplateName = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateName"]));
    }
  }


  virtual ~DeleteLaunchTemplateVersionRequest() = default;
};
class DeleteLaunchTemplateVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLaunchTemplateVersionResponseBody() {}

  explicit DeleteLaunchTemplateVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLaunchTemplateVersionResponseBody() = default;
};
class DeleteLaunchTemplateVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteLaunchTemplateVersionResponseBody> body{};

  DeleteLaunchTemplateVersionResponse() {}

  explicit DeleteLaunchTemplateVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLaunchTemplateVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLaunchTemplateVersionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLaunchTemplateVersionResponse() = default;
};
class DeleteNatGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> natGatewayId{};

  DeleteNatGatewayRequest() {}

  explicit DeleteNatGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
  }


  virtual ~DeleteNatGatewayRequest() = default;
};
class DeleteNatGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteNatGatewayResponseBody() {}

  explicit DeleteNatGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteNatGatewayResponseBody() = default;
};
class DeleteNatGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteNatGatewayResponseBody> body{};

  DeleteNatGatewayResponse() {}

  explicit DeleteNatGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNatGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNatGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNatGatewayResponse() = default;
};
class DeleteNetworkInterfaceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> networkInterfaceId{};

  DeleteNetworkInterfaceRequest() {}

  explicit DeleteNetworkInterfaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
  }


  virtual ~DeleteNetworkInterfaceRequest() = default;
};
class DeleteNetworkInterfaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteNetworkInterfaceResponseBody() {}

  explicit DeleteNetworkInterfaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteNetworkInterfaceResponseBody() = default;
};
class DeleteNetworkInterfaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteNetworkInterfaceResponseBody> body{};

  DeleteNetworkInterfaceResponse() {}

  explicit DeleteNetworkInterfaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNetworkInterfaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNetworkInterfaceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNetworkInterfaceResponse() = default;
};
class DeleteNetworkInterfacePermissionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> networkInterfacePermissionId{};
  shared_ptr<bool> force{};

  DeleteNetworkInterfacePermissionRequest() {}

  explicit DeleteNetworkInterfacePermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (networkInterfacePermissionId) {
      res["NetworkInterfacePermissionId"] = boost::any(*networkInterfacePermissionId);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("NetworkInterfacePermissionId") != m.end() && !m["NetworkInterfacePermissionId"].empty()) {
      networkInterfacePermissionId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfacePermissionId"]));
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
  }


  virtual ~DeleteNetworkInterfacePermissionRequest() = default;
};
class DeleteNetworkInterfacePermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteNetworkInterfacePermissionResponseBody() {}

  explicit DeleteNetworkInterfacePermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteNetworkInterfacePermissionResponseBody() = default;
};
class DeleteNetworkInterfacePermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteNetworkInterfacePermissionResponseBody> body{};

  DeleteNetworkInterfacePermissionResponse() {}

  explicit DeleteNetworkInterfacePermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNetworkInterfacePermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNetworkInterfacePermissionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNetworkInterfacePermissionResponse() = default;
};
class DeletePhysicalConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};

  DeletePhysicalConnectionRequest() {}

  explicit DeletePhysicalConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DeletePhysicalConnectionRequest() = default;
};
class DeletePhysicalConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeletePhysicalConnectionResponseBody() {}

  explicit DeletePhysicalConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePhysicalConnectionResponseBody() = default;
};
class DeletePhysicalConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeletePhysicalConnectionResponseBody> body{};

  DeletePhysicalConnectionResponse() {}

  explicit DeletePhysicalConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePhysicalConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePhysicalConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePhysicalConnectionResponse() = default;
};
class DeletePrefixListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> prefixListId{};

  DeletePrefixListRequest() {}

  explicit DeletePrefixListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (prefixListId) {
      res["PrefixListId"] = boost::any(*prefixListId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PrefixListId") != m.end() && !m["PrefixListId"].empty()) {
      prefixListId = make_shared<string>(boost::any_cast<string>(m["PrefixListId"]));
    }
  }


  virtual ~DeletePrefixListRequest() = default;
};
class DeletePrefixListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeletePrefixListResponseBody() {}

  explicit DeletePrefixListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePrefixListResponseBody() = default;
};
class DeletePrefixListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeletePrefixListResponseBody> body{};

  DeletePrefixListResponse() {}

  explicit DeletePrefixListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePrefixListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePrefixListResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePrefixListResponse() = default;
};
class DeleteReplicaPairRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> replicaPairId{};

  DeleteReplicaPairRequest() {}

  explicit DeleteReplicaPairRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (replicaPairId) {
      res["ReplicaPairId"] = boost::any(*replicaPairId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReplicaPairId") != m.end() && !m["ReplicaPairId"].empty()) {
      replicaPairId = make_shared<string>(boost::any_cast<string>(m["ReplicaPairId"]));
    }
  }


  virtual ~DeleteReplicaPairRequest() = default;
};
class DeleteReplicaPairResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteReplicaPairResponseBody() {}

  explicit DeleteReplicaPairResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteReplicaPairResponseBody() = default;
};
class DeleteReplicaPairResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteReplicaPairResponseBody> body{};

  DeleteReplicaPairResponse() {}

  explicit DeleteReplicaPairResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteReplicaPairResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteReplicaPairResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteReplicaPairResponse() = default;
};
class DeleteRouteEntryRequestNextHopList : public Darabonba::Model {
public:
  shared_ptr<string> nextHopId{};
  shared_ptr<string> nextHopType{};

  DeleteRouteEntryRequestNextHopList() {}

  explicit DeleteRouteEntryRequestNextHopList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextHopId) {
      res["NextHopId"] = boost::any(*nextHopId);
    }
    if (nextHopType) {
      res["NextHopType"] = boost::any(*nextHopType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextHopId") != m.end() && !m["NextHopId"].empty()) {
      nextHopId = make_shared<string>(boost::any_cast<string>(m["NextHopId"]));
    }
    if (m.find("NextHopType") != m.end() && !m["NextHopType"].empty()) {
      nextHopType = make_shared<string>(boost::any_cast<string>(m["NextHopType"]));
    }
  }


  virtual ~DeleteRouteEntryRequestNextHopList() = default;
};
class DeleteRouteEntryRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> routeTableId{};
  shared_ptr<string> destinationCidrBlock{};
  shared_ptr<string> nextHopId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<vector<DeleteRouteEntryRequestNextHopList>> nextHopList{};

  DeleteRouteEntryRequest() {}

  explicit DeleteRouteEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (destinationCidrBlock) {
      res["DestinationCidrBlock"] = boost::any(*destinationCidrBlock);
    }
    if (nextHopId) {
      res["NextHopId"] = boost::any(*nextHopId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (nextHopList) {
      vector<boost::any> temp1;
      for(auto item1:*nextHopList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NextHopList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("DestinationCidrBlock") != m.end() && !m["DestinationCidrBlock"].empty()) {
      destinationCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestinationCidrBlock"]));
    }
    if (m.find("NextHopId") != m.end() && !m["NextHopId"].empty()) {
      nextHopId = make_shared<string>(boost::any_cast<string>(m["NextHopId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("NextHopList") != m.end() && !m["NextHopList"].empty()) {
      if (typeid(vector<boost::any>) == m["NextHopList"].type()) {
        vector<DeleteRouteEntryRequestNextHopList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NextHopList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteRouteEntryRequestNextHopList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nextHopList = make_shared<vector<DeleteRouteEntryRequestNextHopList>>(expect1);
      }
    }
  }


  virtual ~DeleteRouteEntryRequest() = default;
};
class DeleteRouteEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteRouteEntryResponseBody() {}

  explicit DeleteRouteEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRouteEntryResponseBody() = default;
};
class DeleteRouteEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteRouteEntryResponseBody> body{};

  DeleteRouteEntryResponse() {}

  explicit DeleteRouteEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRouteEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRouteEntryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRouteEntryResponse() = default;
};
class DeleteRouterInterfaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> routerInterfaceId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> userCidr{};

  DeleteRouterInterfaceRequest() {}

  explicit DeleteRouterInterfaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (routerInterfaceId) {
      res["RouterInterfaceId"] = boost::any(*routerInterfaceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (userCidr) {
      res["UserCidr"] = boost::any(*userCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RouterInterfaceId") != m.end() && !m["RouterInterfaceId"].empty()) {
      routerInterfaceId = make_shared<string>(boost::any_cast<string>(m["RouterInterfaceId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("UserCidr") != m.end() && !m["UserCidr"].empty()) {
      userCidr = make_shared<string>(boost::any_cast<string>(m["UserCidr"]));
    }
  }


  virtual ~DeleteRouterInterfaceRequest() = default;
};
class DeleteRouterInterfaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteRouterInterfaceResponseBody() {}

  explicit DeleteRouterInterfaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRouterInterfaceResponseBody() = default;
};
class DeleteRouterInterfaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteRouterInterfaceResponseBody> body{};

  DeleteRouterInterfaceResponse() {}

  explicit DeleteRouterInterfaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRouterInterfaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRouterInterfaceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRouterInterfaceResponse() = default;
};
class DeleteSecurityGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> ownerAccount{};

  DeleteSecurityGroupRequest() {}

  explicit DeleteSecurityGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DeleteSecurityGroupRequest() = default;
};
class DeleteSecurityGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSecurityGroupResponseBody() {}

  explicit DeleteSecurityGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSecurityGroupResponseBody() = default;
};
class DeleteSecurityGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteSecurityGroupResponseBody> body{};

  DeleteSecurityGroupResponse() {}

  explicit DeleteSecurityGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSecurityGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSecurityGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSecurityGroupResponse() = default;
};
class DeleteSnapshotRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> snapshotId{};
  shared_ptr<bool> force{};
  shared_ptr<string> ownerAccount{};

  DeleteSnapshotRequest() {}

  explicit DeleteSnapshotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DeleteSnapshotRequest() = default;
};
class DeleteSnapshotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSnapshotResponseBody() {}

  explicit DeleteSnapshotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSnapshotResponseBody() = default;
};
class DeleteSnapshotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteSnapshotResponseBody> body{};

  DeleteSnapshotResponse() {}

  explicit DeleteSnapshotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSnapshotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSnapshotResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSnapshotResponse() = default;
};
class DeleteSnapshotGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> snapshotGroupId{};

  DeleteSnapshotGroupRequest() {}

  explicit DeleteSnapshotGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (snapshotGroupId) {
      res["SnapshotGroupId"] = boost::any(*snapshotGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SnapshotGroupId") != m.end() && !m["SnapshotGroupId"].empty()) {
      snapshotGroupId = make_shared<string>(boost::any_cast<string>(m["SnapshotGroupId"]));
    }
  }


  virtual ~DeleteSnapshotGroupRequest() = default;
};
class DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem() {}

  explicit DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem() = default;
};
class DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgressRelatedItemSet : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem>> relatedItem{};

  DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgressRelatedItemSet() {}

  explicit DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgressRelatedItemSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (relatedItem) {
      vector<boost::any> temp1;
      for(auto item1:*relatedItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RelatedItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RelatedItem") != m.end() && !m["RelatedItem"].empty()) {
      if (typeid(vector<boost::any>) == m["RelatedItem"].type()) {
        vector<DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RelatedItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relatedItem = make_shared<vector<DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem>>(expect1);
      }
    }
  }


  virtual ~DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgressRelatedItemSet() = default;
};
class DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgress : public Darabonba::Model {
public:
  shared_ptr<string> errorMsg{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> operationStatus{};
  shared_ptr<DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgressRelatedItemSet> relatedItemSet{};

  DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgress() {}

  explicit DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (operationStatus) {
      res["OperationStatus"] = boost::any(*operationStatus);
    }
    if (relatedItemSet) {
      res["RelatedItemSet"] = relatedItemSet ? boost::any(relatedItemSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("OperationStatus") != m.end() && !m["OperationStatus"].empty()) {
      operationStatus = make_shared<string>(boost::any_cast<string>(m["OperationStatus"]));
    }
    if (m.find("RelatedItemSet") != m.end() && !m["RelatedItemSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["RelatedItemSet"].type()) {
        DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgressRelatedItemSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RelatedItemSet"]));
        relatedItemSet = make_shared<DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgressRelatedItemSet>(model1);
      }
    }
  }


  virtual ~DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgress() = default;
};
class DeleteSnapshotGroupResponseBodyOperationProgressSet : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgress>> operationProgress{};

  DeleteSnapshotGroupResponseBodyOperationProgressSet() {}

  explicit DeleteSnapshotGroupResponseBodyOperationProgressSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationProgress) {
      vector<boost::any> temp1;
      for(auto item1:*operationProgress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperationProgress"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationProgress") != m.end() && !m["OperationProgress"].empty()) {
      if (typeid(vector<boost::any>) == m["OperationProgress"].type()) {
        vector<DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperationProgress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operationProgress = make_shared<vector<DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgress>>(expect1);
      }
    }
  }


  virtual ~DeleteSnapshotGroupResponseBodyOperationProgressSet() = default;
};
class DeleteSnapshotGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DeleteSnapshotGroupResponseBodyOperationProgressSet> operationProgressSet{};

  DeleteSnapshotGroupResponseBody() {}

  explicit DeleteSnapshotGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (operationProgressSet) {
      res["OperationProgressSet"] = operationProgressSet ? boost::any(operationProgressSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OperationProgressSet") != m.end() && !m["OperationProgressSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperationProgressSet"].type()) {
        DeleteSnapshotGroupResponseBodyOperationProgressSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperationProgressSet"]));
        operationProgressSet = make_shared<DeleteSnapshotGroupResponseBodyOperationProgressSet>(model1);
      }
    }
  }


  virtual ~DeleteSnapshotGroupResponseBody() = default;
};
class DeleteSnapshotGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteSnapshotGroupResponseBody> body{};

  DeleteSnapshotGroupResponse() {}

  explicit DeleteSnapshotGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSnapshotGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSnapshotGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSnapshotGroupResponse() = default;
};
class DeleteStorageSetRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> storageSetId{};

  DeleteStorageSetRequest() {}

  explicit DeleteStorageSetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
  }


  virtual ~DeleteStorageSetRequest() = default;
};
class DeleteStorageSetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteStorageSetResponseBody() {}

  explicit DeleteStorageSetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteStorageSetResponseBody() = default;
};
class DeleteStorageSetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteStorageSetResponseBody> body{};

  DeleteStorageSetResponse() {}

  explicit DeleteStorageSetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteStorageSetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteStorageSetResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteStorageSetResponse() = default;
};
class DeleteVirtualBorderRouterRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> vbrId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> userCidr{};

  DeleteVirtualBorderRouterRequest() {}

  explicit DeleteVirtualBorderRouterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vbrId) {
      res["VbrId"] = boost::any(*vbrId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (userCidr) {
      res["UserCidr"] = boost::any(*userCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VbrId") != m.end() && !m["VbrId"].empty()) {
      vbrId = make_shared<string>(boost::any_cast<string>(m["VbrId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("UserCidr") != m.end() && !m["UserCidr"].empty()) {
      userCidr = make_shared<string>(boost::any_cast<string>(m["UserCidr"]));
    }
  }


  virtual ~DeleteVirtualBorderRouterRequest() = default;
};
class DeleteVirtualBorderRouterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVirtualBorderRouterResponseBody() {}

  explicit DeleteVirtualBorderRouterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVirtualBorderRouterResponseBody() = default;
};
class DeleteVirtualBorderRouterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteVirtualBorderRouterResponseBody> body{};

  DeleteVirtualBorderRouterResponse() {}

  explicit DeleteVirtualBorderRouterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVirtualBorderRouterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVirtualBorderRouterResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVirtualBorderRouterResponse() = default;
};
class DeleteVpcRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ownerAccount{};

  DeleteVpcRequest() {}

  explicit DeleteVpcRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DeleteVpcRequest() = default;
};
class DeleteVpcResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVpcResponseBody() {}

  explicit DeleteVpcResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVpcResponseBody() = default;
};
class DeleteVpcResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteVpcResponseBody> body{};

  DeleteVpcResponse() {}

  explicit DeleteVpcResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVpcResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVpcResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVpcResponse() = default;
};
class DeleteVSwitchRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ownerAccount{};

  DeleteVSwitchRequest() {}

  explicit DeleteVSwitchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DeleteVSwitchRequest() = default;
};
class DeleteVSwitchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVSwitchResponseBody() {}

  explicit DeleteVSwitchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVSwitchResponseBody() = default;
};
class DeleteVSwitchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteVSwitchResponseBody> body{};

  DeleteVSwitchResponse() {}

  explicit DeleteVSwitchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVSwitchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVSwitchResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVSwitchResponse() = default;
};
class DeregisterManagedInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceId{};

  DeregisterManagedInstanceRequest() {}

  explicit DeregisterManagedInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeregisterManagedInstanceRequest() = default;
};
class DeregisterManagedInstanceResponseBodyInstance : public Darabonba::Model {
public:
  shared_ptr<string> lastInvokedTime{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> hostname{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> activationId{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> agentVersion{};
  shared_ptr<string> registrationTime{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> osType{};
  shared_ptr<string> osVersion{};
  shared_ptr<long> invocationCount{};
  shared_ptr<string> machineId{};

  DeregisterManagedInstanceResponseBodyInstance() {}

  explicit DeregisterManagedInstanceResponseBodyInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lastInvokedTime) {
      res["LastInvokedTime"] = boost::any(*lastInvokedTime);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (hostname) {
      res["Hostname"] = boost::any(*hostname);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (activationId) {
      res["ActivationId"] = boost::any(*activationId);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (agentVersion) {
      res["AgentVersion"] = boost::any(*agentVersion);
    }
    if (registrationTime) {
      res["RegistrationTime"] = boost::any(*registrationTime);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (osVersion) {
      res["OsVersion"] = boost::any(*osVersion);
    }
    if (invocationCount) {
      res["InvocationCount"] = boost::any(*invocationCount);
    }
    if (machineId) {
      res["MachineId"] = boost::any(*machineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LastInvokedTime") != m.end() && !m["LastInvokedTime"].empty()) {
      lastInvokedTime = make_shared<string>(boost::any_cast<string>(m["LastInvokedTime"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("Hostname") != m.end() && !m["Hostname"].empty()) {
      hostname = make_shared<string>(boost::any_cast<string>(m["Hostname"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ActivationId") != m.end() && !m["ActivationId"].empty()) {
      activationId = make_shared<string>(boost::any_cast<string>(m["ActivationId"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("AgentVersion") != m.end() && !m["AgentVersion"].empty()) {
      agentVersion = make_shared<string>(boost::any_cast<string>(m["AgentVersion"]));
    }
    if (m.find("RegistrationTime") != m.end() && !m["RegistrationTime"].empty()) {
      registrationTime = make_shared<string>(boost::any_cast<string>(m["RegistrationTime"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("OsVersion") != m.end() && !m["OsVersion"].empty()) {
      osVersion = make_shared<string>(boost::any_cast<string>(m["OsVersion"]));
    }
    if (m.find("InvocationCount") != m.end() && !m["InvocationCount"].empty()) {
      invocationCount = make_shared<long>(boost::any_cast<long>(m["InvocationCount"]));
    }
    if (m.find("MachineId") != m.end() && !m["MachineId"].empty()) {
      machineId = make_shared<string>(boost::any_cast<string>(m["MachineId"]));
    }
  }


  virtual ~DeregisterManagedInstanceResponseBodyInstance() = default;
};
class DeregisterManagedInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DeregisterManagedInstanceResponseBodyInstance> instance{};

  DeregisterManagedInstanceResponseBody() {}

  explicit DeregisterManagedInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instance) {
      res["Instance"] = instance ? boost::any(instance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instance"].type()) {
        DeregisterManagedInstanceResponseBodyInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instance"]));
        instance = make_shared<DeregisterManagedInstanceResponseBodyInstance>(model1);
      }
    }
  }


  virtual ~DeregisterManagedInstanceResponseBody() = default;
};
class DeregisterManagedInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeregisterManagedInstanceResponseBody> body{};

  DeregisterManagedInstanceResponse() {}

  explicit DeregisterManagedInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeregisterManagedInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeregisterManagedInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DeregisterManagedInstanceResponse() = default;
};
class DescribeAccessPointsRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<string>> value{};

  DescribeAccessPointsRequestFilter() {}

  explicit DescribeAccessPointsRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Value"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      value = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAccessPointsRequestFilter() = default;
};
class DescribeAccessPointsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeAccessPointsRequestFilter>> filter{};

  DescribeAccessPointsRequest() {}

  explicit DescribeAccessPointsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<DescribeAccessPointsRequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAccessPointsRequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<DescribeAccessPointsRequestFilter>>(expect1);
      }
    }
  }


  virtual ~DescribeAccessPointsRequest() = default;
};
class DescribeAccessPointsResponseBodyAccessPointSetAccessPointType : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> hostOperator{};
  shared_ptr<string> description{};
  shared_ptr<string> attachedRegionNo{};
  shared_ptr<string> name{};
  shared_ptr<string> accessPointId{};
  shared_ptr<string> location{};

  DescribeAccessPointsResponseBodyAccessPointSetAccessPointType() {}

  explicit DescribeAccessPointsResponseBodyAccessPointSetAccessPointType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (hostOperator) {
      res["HostOperator"] = boost::any(*hostOperator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (attachedRegionNo) {
      res["AttachedRegionNo"] = boost::any(*attachedRegionNo);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (accessPointId) {
      res["AccessPointId"] = boost::any(*accessPointId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("HostOperator") != m.end() && !m["HostOperator"].empty()) {
      hostOperator = make_shared<string>(boost::any_cast<string>(m["HostOperator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("AttachedRegionNo") != m.end() && !m["AttachedRegionNo"].empty()) {
      attachedRegionNo = make_shared<string>(boost::any_cast<string>(m["AttachedRegionNo"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("AccessPointId") != m.end() && !m["AccessPointId"].empty()) {
      accessPointId = make_shared<string>(boost::any_cast<string>(m["AccessPointId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
  }


  virtual ~DescribeAccessPointsResponseBodyAccessPointSetAccessPointType() = default;
};
class DescribeAccessPointsResponseBodyAccessPointSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAccessPointsResponseBodyAccessPointSetAccessPointType>> accessPointType{};

  DescribeAccessPointsResponseBodyAccessPointSet() {}

  explicit DescribeAccessPointsResponseBodyAccessPointSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessPointType) {
      vector<boost::any> temp1;
      for(auto item1:*accessPointType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccessPointType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessPointType") != m.end() && !m["AccessPointType"].empty()) {
      if (typeid(vector<boost::any>) == m["AccessPointType"].type()) {
        vector<DescribeAccessPointsResponseBodyAccessPointSetAccessPointType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccessPointType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAccessPointsResponseBodyAccessPointSetAccessPointType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accessPointType = make_shared<vector<DescribeAccessPointsResponseBodyAccessPointSetAccessPointType>>(expect1);
      }
    }
  }


  virtual ~DescribeAccessPointsResponseBodyAccessPointSet() = default;
};
class DescribeAccessPointsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeAccessPointsResponseBodyAccessPointSet> accessPointSet{};

  DescribeAccessPointsResponseBody() {}

  explicit DescribeAccessPointsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (accessPointSet) {
      res["AccessPointSet"] = accessPointSet ? boost::any(accessPointSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("AccessPointSet") != m.end() && !m["AccessPointSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccessPointSet"].type()) {
        DescribeAccessPointsResponseBodyAccessPointSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccessPointSet"]));
        accessPointSet = make_shared<DescribeAccessPointsResponseBodyAccessPointSet>(model1);
      }
    }
  }


  virtual ~DescribeAccessPointsResponseBody() = default;
};
class DescribeAccessPointsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAccessPointsResponseBody> body{};

  DescribeAccessPointsResponse() {}

  explicit DescribeAccessPointsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAccessPointsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAccessPointsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAccessPointsResponse() = default;
};
class DescribeAccountAttributesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<string>> attributeName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> zoneId{};

  DescribeAccountAttributesRequest() {}

  explicit DescribeAccountAttributesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (attributeName) {
      res["AttributeName"] = boost::any(*attributeName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("AttributeName") != m.end() && !m["AttributeName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AttributeName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AttributeName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      attributeName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeAccountAttributesRequest() = default;
};
class DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValuesValueItem : public Darabonba::Model {
public:
  shared_ptr<string> diskCategory{};
  shared_ptr<string> value{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> count{};
  shared_ptr<string> instanceChargeType{};

  DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValuesValueItem() {}

  explicit DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValuesValueItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskCategory) {
      res["DiskCategory"] = boost::any(*diskCategory);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskCategory") != m.end() && !m["DiskCategory"].empty()) {
      diskCategory = make_shared<string>(boost::any_cast<string>(m["DiskCategory"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
  }


  virtual ~DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValuesValueItem() = default;
};
class DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValues : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValuesValueItem>> valueItem{};

  DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValues() {}

  explicit DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValues(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (valueItem) {
      vector<boost::any> temp1;
      for(auto item1:*valueItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ValueItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ValueItem") != m.end() && !m["ValueItem"].empty()) {
      if (typeid(vector<boost::any>) == m["ValueItem"].type()) {
        vector<DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValuesValueItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ValueItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValuesValueItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        valueItem = make_shared<vector<DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValuesValueItem>>(expect1);
      }
    }
  }


  virtual ~DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValues() = default;
};
class DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItem : public Darabonba::Model {
public:
  shared_ptr<string> attributeName{};
  shared_ptr<DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValues> attributeValues{};

  DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItem() {}

  explicit DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeName) {
      res["AttributeName"] = boost::any(*attributeName);
    }
    if (attributeValues) {
      res["AttributeValues"] = attributeValues ? boost::any(attributeValues->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeName") != m.end() && !m["AttributeName"].empty()) {
      attributeName = make_shared<string>(boost::any_cast<string>(m["AttributeName"]));
    }
    if (m.find("AttributeValues") != m.end() && !m["AttributeValues"].empty()) {
      if (typeid(map<string, boost::any>) == m["AttributeValues"].type()) {
        DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValues model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AttributeValues"]));
        attributeValues = make_shared<DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValues>(model1);
      }
    }
  }


  virtual ~DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItem() = default;
};
class DescribeAccountAttributesResponseBodyAccountAttributeItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItem>> accountAttributeItem{};

  DescribeAccountAttributesResponseBodyAccountAttributeItems() {}

  explicit DescribeAccountAttributesResponseBodyAccountAttributeItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountAttributeItem) {
      vector<boost::any> temp1;
      for(auto item1:*accountAttributeItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccountAttributeItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountAttributeItem") != m.end() && !m["AccountAttributeItem"].empty()) {
      if (typeid(vector<boost::any>) == m["AccountAttributeItem"].type()) {
        vector<DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccountAttributeItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accountAttributeItem = make_shared<vector<DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItem>>(expect1);
      }
    }
  }


  virtual ~DescribeAccountAttributesResponseBodyAccountAttributeItems() = default;
};
class DescribeAccountAttributesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAccountAttributesResponseBodyAccountAttributeItems> accountAttributeItems{};

  DescribeAccountAttributesResponseBody() {}

  explicit DescribeAccountAttributesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (accountAttributeItems) {
      res["AccountAttributeItems"] = accountAttributeItems ? boost::any(accountAttributeItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("AccountAttributeItems") != m.end() && !m["AccountAttributeItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountAttributeItems"].type()) {
        DescribeAccountAttributesResponseBodyAccountAttributeItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountAttributeItems"]));
        accountAttributeItems = make_shared<DescribeAccountAttributesResponseBodyAccountAttributeItems>(model1);
      }
    }
  }


  virtual ~DescribeAccountAttributesResponseBody() = default;
};
class DescribeAccountAttributesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAccountAttributesResponseBody> body{};

  DescribeAccountAttributesResponse() {}

  explicit DescribeAccountAttributesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAccountAttributesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAccountAttributesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAccountAttributesResponse() = default;
};
class DescribeActivationsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> activationId{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeActivationsRequest() {}

  explicit DescribeActivationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (activationId) {
      res["ActivationId"] = boost::any(*activationId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ActivationId") != m.end() && !m["ActivationId"].empty()) {
      activationId = make_shared<string>(boost::any_cast<string>(m["ActivationId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeActivationsRequest() = default;
};
class DescribeActivationsResponseBodyActivationList : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<long> deregisteredCount{};
  shared_ptr<long> instanceCount{};
  shared_ptr<string> description{};
  shared_ptr<long> registeredCount{};
  shared_ptr<string> instanceName{};
  shared_ptr<bool> disabled{};
  shared_ptr<string> ipAddressRange{};
  shared_ptr<long> timeToLiveInHours{};
  shared_ptr<string> activationId{};

  DescribeActivationsResponseBodyActivationList() {}

  explicit DescribeActivationsResponseBodyActivationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (deregisteredCount) {
      res["DeregisteredCount"] = boost::any(*deregisteredCount);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (registeredCount) {
      res["RegisteredCount"] = boost::any(*registeredCount);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (disabled) {
      res["Disabled"] = boost::any(*disabled);
    }
    if (ipAddressRange) {
      res["IpAddressRange"] = boost::any(*ipAddressRange);
    }
    if (timeToLiveInHours) {
      res["TimeToLiveInHours"] = boost::any(*timeToLiveInHours);
    }
    if (activationId) {
      res["ActivationId"] = boost::any(*activationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DeregisteredCount") != m.end() && !m["DeregisteredCount"].empty()) {
      deregisteredCount = make_shared<long>(boost::any_cast<long>(m["DeregisteredCount"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RegisteredCount") != m.end() && !m["RegisteredCount"].empty()) {
      registeredCount = make_shared<long>(boost::any_cast<long>(m["RegisteredCount"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Disabled") != m.end() && !m["Disabled"].empty()) {
      disabled = make_shared<bool>(boost::any_cast<bool>(m["Disabled"]));
    }
    if (m.find("IpAddressRange") != m.end() && !m["IpAddressRange"].empty()) {
      ipAddressRange = make_shared<string>(boost::any_cast<string>(m["IpAddressRange"]));
    }
    if (m.find("TimeToLiveInHours") != m.end() && !m["TimeToLiveInHours"].empty()) {
      timeToLiveInHours = make_shared<long>(boost::any_cast<long>(m["TimeToLiveInHours"]));
    }
    if (m.find("ActivationId") != m.end() && !m["ActivationId"].empty()) {
      activationId = make_shared<string>(boost::any_cast<string>(m["ActivationId"]));
    }
  }


  virtual ~DescribeActivationsResponseBodyActivationList() = default;
};
class DescribeActivationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DescribeActivationsResponseBodyActivationList>> activationList{};

  DescribeActivationsResponseBody() {}

  explicit DescribeActivationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (activationList) {
      vector<boost::any> temp1;
      for(auto item1:*activationList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ActivationList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("ActivationList") != m.end() && !m["ActivationList"].empty()) {
      if (typeid(vector<boost::any>) == m["ActivationList"].type()) {
        vector<DescribeActivationsResponseBodyActivationList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ActivationList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeActivationsResponseBodyActivationList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        activationList = make_shared<vector<DescribeActivationsResponseBodyActivationList>>(expect1);
      }
    }
  }


  virtual ~DescribeActivationsResponseBody() = default;
};
class DescribeActivationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeActivationsResponseBody> body{};

  DescribeActivationsResponse() {}

  explicit DescribeActivationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeActivationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeActivationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeActivationsResponse() = default;
};
class DescribeAutoProvisioningGroupHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> autoProvisioningGroupId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  DescribeAutoProvisioningGroupHistoryRequest() {}

  explicit DescribeAutoProvisioningGroupHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (autoProvisioningGroupId) {
      res["AutoProvisioningGroupId"] = boost::any(*autoProvisioningGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("AutoProvisioningGroupId") != m.end() && !m["AutoProvisioningGroupId"].empty()) {
      autoProvisioningGroupId = make_shared<string>(boost::any_cast<string>(m["AutoProvisioningGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~DescribeAutoProvisioningGroupHistoryRequest() = default;
};
class DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistoryActivityDetailsActivityDetail : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> detail{};

  DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistoryActivityDetailsActivityDetail() {}

  explicit DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistoryActivityDetailsActivityDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
  }


  virtual ~DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistoryActivityDetailsActivityDetail() = default;
};
class DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistoryActivityDetails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistoryActivityDetailsActivityDetail>> activityDetail{};

  DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistoryActivityDetails() {}

  explicit DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistoryActivityDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityDetail) {
      vector<boost::any> temp1;
      for(auto item1:*activityDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ActivityDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityDetail") != m.end() && !m["ActivityDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["ActivityDetail"].type()) {
        vector<DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistoryActivityDetailsActivityDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ActivityDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistoryActivityDetailsActivityDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        activityDetail = make_shared<vector<DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistoryActivityDetailsActivityDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistoryActivityDetails() = default;
};
class DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistory : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> startTime{};
  shared_ptr<string> taskId{};
  shared_ptr<string> lastEventTime{};
  shared_ptr<DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistoryActivityDetails> activityDetails{};

  DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistory() {}

  explicit DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (lastEventTime) {
      res["LastEventTime"] = boost::any(*lastEventTime);
    }
    if (activityDetails) {
      res["ActivityDetails"] = activityDetails ? boost::any(activityDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("LastEventTime") != m.end() && !m["LastEventTime"].empty()) {
      lastEventTime = make_shared<string>(boost::any_cast<string>(m["LastEventTime"]));
    }
    if (m.find("ActivityDetails") != m.end() && !m["ActivityDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["ActivityDetails"].type()) {
        DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistoryActivityDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ActivityDetails"]));
        activityDetails = make_shared<DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistoryActivityDetails>(model1);
      }
    }
  }


  virtual ~DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistory() = default;
};
class DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistories : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistory>> autoProvisioningGroupHistory{};

  DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistories() {}

  explicit DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoProvisioningGroupHistory) {
      vector<boost::any> temp1;
      for(auto item1:*autoProvisioningGroupHistory){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AutoProvisioningGroupHistory"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoProvisioningGroupHistory") != m.end() && !m["AutoProvisioningGroupHistory"].empty()) {
      if (typeid(vector<boost::any>) == m["AutoProvisioningGroupHistory"].type()) {
        vector<DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AutoProvisioningGroupHistory"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        autoProvisioningGroupHistory = make_shared<vector<DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistory>>(expect1);
      }
    }
  }


  virtual ~DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistories() = default;
};
class DescribeAutoProvisioningGroupHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistories> autoProvisioningGroupHistories{};

  DescribeAutoProvisioningGroupHistoryResponseBody() {}

  explicit DescribeAutoProvisioningGroupHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (autoProvisioningGroupHistories) {
      res["AutoProvisioningGroupHistories"] = autoProvisioningGroupHistories ? boost::any(autoProvisioningGroupHistories->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("AutoProvisioningGroupHistories") != m.end() && !m["AutoProvisioningGroupHistories"].empty()) {
      if (typeid(map<string, boost::any>) == m["AutoProvisioningGroupHistories"].type()) {
        DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistories model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AutoProvisioningGroupHistories"]));
        autoProvisioningGroupHistories = make_shared<DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistories>(model1);
      }
    }
  }


  virtual ~DescribeAutoProvisioningGroupHistoryResponseBody() = default;
};
class DescribeAutoProvisioningGroupHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAutoProvisioningGroupHistoryResponseBody> body{};

  DescribeAutoProvisioningGroupHistoryResponse() {}

  explicit DescribeAutoProvisioningGroupHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAutoProvisioningGroupHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAutoProvisioningGroupHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAutoProvisioningGroupHistoryResponse() = default;
};
class DescribeAutoProvisioningGroupInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> autoProvisioningGroupId{};

  DescribeAutoProvisioningGroupInstancesRequest() {}

  explicit DescribeAutoProvisioningGroupInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (autoProvisioningGroupId) {
      res["AutoProvisioningGroupId"] = boost::any(*autoProvisioningGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("AutoProvisioningGroupId") != m.end() && !m["AutoProvisioningGroupId"].empty()) {
      autoProvisioningGroupId = make_shared<string>(boost::any_cast<string>(m["AutoProvisioningGroupId"]));
    }
  }


  virtual ~DescribeAutoProvisioningGroupInstancesRequest() = default;
};
class DescribeAutoProvisioningGroupInstancesResponseBodyInstancesInstance : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> creationTime{};
  shared_ptr<bool> isSpot{};
  shared_ptr<long> CPU{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkType{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> ioOptimized{};
  shared_ptr<string> osType{};
  shared_ptr<string> zoneId{};
  shared_ptr<long> memory{};

  DescribeAutoProvisioningGroupInstancesResponseBodyInstancesInstance() {}

  explicit DescribeAutoProvisioningGroupInstancesResponseBodyInstancesInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (isSpot) {
      res["IsSpot"] = boost::any(*isSpot);
    }
    if (CPU) {
      res["CPU"] = boost::any(*CPU);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("IsSpot") != m.end() && !m["IsSpot"].empty()) {
      isSpot = make_shared<bool>(boost::any_cast<bool>(m["IsSpot"]));
    }
    if (m.find("CPU") != m.end() && !m["CPU"].empty()) {
      CPU = make_shared<long>(boost::any_cast<long>(m["CPU"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<bool>(boost::any_cast<bool>(m["IoOptimized"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
  }


  virtual ~DescribeAutoProvisioningGroupInstancesResponseBodyInstancesInstance() = default;
};
class DescribeAutoProvisioningGroupInstancesResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAutoProvisioningGroupInstancesResponseBodyInstancesInstance>> instance{};

  DescribeAutoProvisioningGroupInstancesResponseBodyInstances() {}

  explicit DescribeAutoProvisioningGroupInstancesResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      vector<boost::any> temp1;
      for(auto item1:*instance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(vector<boost::any>) == m["Instance"].type()) {
        vector<DescribeAutoProvisioningGroupInstancesResponseBodyInstancesInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAutoProvisioningGroupInstancesResponseBodyInstancesInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instance = make_shared<vector<DescribeAutoProvisioningGroupInstancesResponseBodyInstancesInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeAutoProvisioningGroupInstancesResponseBodyInstances() = default;
};
class DescribeAutoProvisioningGroupInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeAutoProvisioningGroupInstancesResponseBodyInstances> instances{};

  DescribeAutoProvisioningGroupInstancesResponseBody() {}

  explicit DescribeAutoProvisioningGroupInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (instances) {
      res["Instances"] = instances ? boost::any(instances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instances"].type()) {
        DescribeAutoProvisioningGroupInstancesResponseBodyInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instances"]));
        instances = make_shared<DescribeAutoProvisioningGroupInstancesResponseBodyInstances>(model1);
      }
    }
  }


  virtual ~DescribeAutoProvisioningGroupInstancesResponseBody() = default;
};
class DescribeAutoProvisioningGroupInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAutoProvisioningGroupInstancesResponseBody> body{};

  DescribeAutoProvisioningGroupInstancesResponse() {}

  explicit DescribeAutoProvisioningGroupInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAutoProvisioningGroupInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAutoProvisioningGroupInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAutoProvisioningGroupInstancesResponse() = default;
};
class DescribeAutoProvisioningGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> autoProvisioningGroupId{};
  shared_ptr<vector<string>> autoProvisioningGroupStatus{};
  shared_ptr<string> autoProvisioningGroupName{};

  DescribeAutoProvisioningGroupsRequest() {}

  explicit DescribeAutoProvisioningGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (autoProvisioningGroupId) {
      res["AutoProvisioningGroupId"] = boost::any(*autoProvisioningGroupId);
    }
    if (autoProvisioningGroupStatus) {
      res["AutoProvisioningGroupStatus"] = boost::any(*autoProvisioningGroupStatus);
    }
    if (autoProvisioningGroupName) {
      res["AutoProvisioningGroupName"] = boost::any(*autoProvisioningGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("AutoProvisioningGroupId") != m.end() && !m["AutoProvisioningGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AutoProvisioningGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AutoProvisioningGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      autoProvisioningGroupId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AutoProvisioningGroupStatus") != m.end() && !m["AutoProvisioningGroupStatus"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AutoProvisioningGroupStatus"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AutoProvisioningGroupStatus"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      autoProvisioningGroupStatus = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AutoProvisioningGroupName") != m.end() && !m["AutoProvisioningGroupName"].empty()) {
      autoProvisioningGroupName = make_shared<string>(boost::any_cast<string>(m["AutoProvisioningGroupName"]));
    }
  }


  virtual ~DescribeAutoProvisioningGroupsRequest() = default;
};
class DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupLaunchTemplateConfigsLaunchTemplateConfig : public Darabonba::Model {
public:
  shared_ptr<double> maxPrice{};
  shared_ptr<double> priority{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<double> weightedCapacity{};
  shared_ptr<string> instanceType{};

  DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupLaunchTemplateConfigsLaunchTemplateConfig() {}

  explicit DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupLaunchTemplateConfigsLaunchTemplateConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxPrice) {
      res["MaxPrice"] = boost::any(*maxPrice);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (weightedCapacity) {
      res["WeightedCapacity"] = boost::any(*weightedCapacity);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxPrice") != m.end() && !m["MaxPrice"].empty()) {
      maxPrice = make_shared<double>(boost::any_cast<double>(m["MaxPrice"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<double>(boost::any_cast<double>(m["Priority"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("WeightedCapacity") != m.end() && !m["WeightedCapacity"].empty()) {
      weightedCapacity = make_shared<double>(boost::any_cast<double>(m["WeightedCapacity"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
  }


  virtual ~DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupLaunchTemplateConfigsLaunchTemplateConfig() = default;
};
class DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupLaunchTemplateConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupLaunchTemplateConfigsLaunchTemplateConfig>> launchTemplateConfig{};

  DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupLaunchTemplateConfigs() {}

  explicit DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupLaunchTemplateConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (launchTemplateConfig) {
      vector<boost::any> temp1;
      for(auto item1:*launchTemplateConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LaunchTemplateConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LaunchTemplateConfig") != m.end() && !m["LaunchTemplateConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["LaunchTemplateConfig"].type()) {
        vector<DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupLaunchTemplateConfigsLaunchTemplateConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LaunchTemplateConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupLaunchTemplateConfigsLaunchTemplateConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        launchTemplateConfig = make_shared<vector<DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupLaunchTemplateConfigsLaunchTemplateConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupLaunchTemplateConfigs() = default;
};
class DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupSpotOptions : public Darabonba::Model {
public:
  shared_ptr<long> instancePoolsToUseCount{};
  shared_ptr<string> allocationStrategy{};
  shared_ptr<string> instanceInterruptionBehavior{};

  DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupSpotOptions() {}

  explicit DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupSpotOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instancePoolsToUseCount) {
      res["InstancePoolsToUseCount"] = boost::any(*instancePoolsToUseCount);
    }
    if (allocationStrategy) {
      res["AllocationStrategy"] = boost::any(*allocationStrategy);
    }
    if (instanceInterruptionBehavior) {
      res["InstanceInterruptionBehavior"] = boost::any(*instanceInterruptionBehavior);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstancePoolsToUseCount") != m.end() && !m["InstancePoolsToUseCount"].empty()) {
      instancePoolsToUseCount = make_shared<long>(boost::any_cast<long>(m["InstancePoolsToUseCount"]));
    }
    if (m.find("AllocationStrategy") != m.end() && !m["AllocationStrategy"].empty()) {
      allocationStrategy = make_shared<string>(boost::any_cast<string>(m["AllocationStrategy"]));
    }
    if (m.find("InstanceInterruptionBehavior") != m.end() && !m["InstanceInterruptionBehavior"].empty()) {
      instanceInterruptionBehavior = make_shared<string>(boost::any_cast<string>(m["InstanceInterruptionBehavior"]));
    }
  }


  virtual ~DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupSpotOptions() = default;
};
class DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupPayAsYouGoOptions : public Darabonba::Model {
public:
  shared_ptr<string> allocationStrategy{};

  DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupPayAsYouGoOptions() {}

  explicit DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupPayAsYouGoOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationStrategy) {
      res["AllocationStrategy"] = boost::any(*allocationStrategy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationStrategy") != m.end() && !m["AllocationStrategy"].empty()) {
      allocationStrategy = make_shared<string>(boost::any_cast<string>(m["AllocationStrategy"]));
    }
  }


  virtual ~DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupPayAsYouGoOptions() = default;
};
class DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupTargetCapacitySpecification : public Darabonba::Model {
public:
  shared_ptr<double> spotTargetCapacity{};
  shared_ptr<double> payAsYouGoTargetCapacity{};
  shared_ptr<string> defaultTargetCapacityType{};
  shared_ptr<double> totalTargetCapacity{};

  DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupTargetCapacitySpecification() {}

  explicit DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupTargetCapacitySpecification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (spotTargetCapacity) {
      res["SpotTargetCapacity"] = boost::any(*spotTargetCapacity);
    }
    if (payAsYouGoTargetCapacity) {
      res["PayAsYouGoTargetCapacity"] = boost::any(*payAsYouGoTargetCapacity);
    }
    if (defaultTargetCapacityType) {
      res["DefaultTargetCapacityType"] = boost::any(*defaultTargetCapacityType);
    }
    if (totalTargetCapacity) {
      res["TotalTargetCapacity"] = boost::any(*totalTargetCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpotTargetCapacity") != m.end() && !m["SpotTargetCapacity"].empty()) {
      spotTargetCapacity = make_shared<double>(boost::any_cast<double>(m["SpotTargetCapacity"]));
    }
    if (m.find("PayAsYouGoTargetCapacity") != m.end() && !m["PayAsYouGoTargetCapacity"].empty()) {
      payAsYouGoTargetCapacity = make_shared<double>(boost::any_cast<double>(m["PayAsYouGoTargetCapacity"]));
    }
    if (m.find("DefaultTargetCapacityType") != m.end() && !m["DefaultTargetCapacityType"].empty()) {
      defaultTargetCapacityType = make_shared<string>(boost::any_cast<string>(m["DefaultTargetCapacityType"]));
    }
    if (m.find("TotalTargetCapacity") != m.end() && !m["TotalTargetCapacity"].empty()) {
      totalTargetCapacity = make_shared<double>(boost::any_cast<double>(m["TotalTargetCapacity"]));
    }
  }


  virtual ~DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupTargetCapacitySpecification() = default;
};
class DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroup : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> autoProvisioningGroupName{};
  shared_ptr<string> status{};
  shared_ptr<bool> terminateInstances{};
  shared_ptr<double> maxSpotPrice{};
  shared_ptr<string> state{};
  shared_ptr<string> launchTemplateId{};
  shared_ptr<string> validFrom{};
  shared_ptr<string> launchTemplateVersion{};
  shared_ptr<bool> terminateInstancesWithExpiration{};
  shared_ptr<string> regionId{};
  shared_ptr<string> validUntil{};
  shared_ptr<string> autoProvisioningGroupType{};
  shared_ptr<string> autoProvisioningGroupId{};
  shared_ptr<string> excessCapacityTerminationPolicy{};
  shared_ptr<DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupLaunchTemplateConfigs> launchTemplateConfigs{};
  shared_ptr<DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupSpotOptions> spotOptions{};
  shared_ptr<DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupPayAsYouGoOptions> payAsYouGoOptions{};
  shared_ptr<DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupTargetCapacitySpecification> targetCapacitySpecification{};

  DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroup() {}

  explicit DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (autoProvisioningGroupName) {
      res["AutoProvisioningGroupName"] = boost::any(*autoProvisioningGroupName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (terminateInstances) {
      res["TerminateInstances"] = boost::any(*terminateInstances);
    }
    if (maxSpotPrice) {
      res["MaxSpotPrice"] = boost::any(*maxSpotPrice);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (launchTemplateId) {
      res["LaunchTemplateId"] = boost::any(*launchTemplateId);
    }
    if (validFrom) {
      res["ValidFrom"] = boost::any(*validFrom);
    }
    if (launchTemplateVersion) {
      res["LaunchTemplateVersion"] = boost::any(*launchTemplateVersion);
    }
    if (terminateInstancesWithExpiration) {
      res["TerminateInstancesWithExpiration"] = boost::any(*terminateInstancesWithExpiration);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (validUntil) {
      res["ValidUntil"] = boost::any(*validUntil);
    }
    if (autoProvisioningGroupType) {
      res["AutoProvisioningGroupType"] = boost::any(*autoProvisioningGroupType);
    }
    if (autoProvisioningGroupId) {
      res["AutoProvisioningGroupId"] = boost::any(*autoProvisioningGroupId);
    }
    if (excessCapacityTerminationPolicy) {
      res["ExcessCapacityTerminationPolicy"] = boost::any(*excessCapacityTerminationPolicy);
    }
    if (launchTemplateConfigs) {
      res["LaunchTemplateConfigs"] = launchTemplateConfigs ? boost::any(launchTemplateConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spotOptions) {
      res["SpotOptions"] = spotOptions ? boost::any(spotOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payAsYouGoOptions) {
      res["PayAsYouGoOptions"] = payAsYouGoOptions ? boost::any(payAsYouGoOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (targetCapacitySpecification) {
      res["TargetCapacitySpecification"] = targetCapacitySpecification ? boost::any(targetCapacitySpecification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("AutoProvisioningGroupName") != m.end() && !m["AutoProvisioningGroupName"].empty()) {
      autoProvisioningGroupName = make_shared<string>(boost::any_cast<string>(m["AutoProvisioningGroupName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TerminateInstances") != m.end() && !m["TerminateInstances"].empty()) {
      terminateInstances = make_shared<bool>(boost::any_cast<bool>(m["TerminateInstances"]));
    }
    if (m.find("MaxSpotPrice") != m.end() && !m["MaxSpotPrice"].empty()) {
      maxSpotPrice = make_shared<double>(boost::any_cast<double>(m["MaxSpotPrice"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("LaunchTemplateId") != m.end() && !m["LaunchTemplateId"].empty()) {
      launchTemplateId = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateId"]));
    }
    if (m.find("ValidFrom") != m.end() && !m["ValidFrom"].empty()) {
      validFrom = make_shared<string>(boost::any_cast<string>(m["ValidFrom"]));
    }
    if (m.find("LaunchTemplateVersion") != m.end() && !m["LaunchTemplateVersion"].empty()) {
      launchTemplateVersion = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateVersion"]));
    }
    if (m.find("TerminateInstancesWithExpiration") != m.end() && !m["TerminateInstancesWithExpiration"].empty()) {
      terminateInstancesWithExpiration = make_shared<bool>(boost::any_cast<bool>(m["TerminateInstancesWithExpiration"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ValidUntil") != m.end() && !m["ValidUntil"].empty()) {
      validUntil = make_shared<string>(boost::any_cast<string>(m["ValidUntil"]));
    }
    if (m.find("AutoProvisioningGroupType") != m.end() && !m["AutoProvisioningGroupType"].empty()) {
      autoProvisioningGroupType = make_shared<string>(boost::any_cast<string>(m["AutoProvisioningGroupType"]));
    }
    if (m.find("AutoProvisioningGroupId") != m.end() && !m["AutoProvisioningGroupId"].empty()) {
      autoProvisioningGroupId = make_shared<string>(boost::any_cast<string>(m["AutoProvisioningGroupId"]));
    }
    if (m.find("ExcessCapacityTerminationPolicy") != m.end() && !m["ExcessCapacityTerminationPolicy"].empty()) {
      excessCapacityTerminationPolicy = make_shared<string>(boost::any_cast<string>(m["ExcessCapacityTerminationPolicy"]));
    }
    if (m.find("LaunchTemplateConfigs") != m.end() && !m["LaunchTemplateConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["LaunchTemplateConfigs"].type()) {
        DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupLaunchTemplateConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LaunchTemplateConfigs"]));
        launchTemplateConfigs = make_shared<DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupLaunchTemplateConfigs>(model1);
      }
    }
    if (m.find("SpotOptions") != m.end() && !m["SpotOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["SpotOptions"].type()) {
        DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupSpotOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SpotOptions"]));
        spotOptions = make_shared<DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupSpotOptions>(model1);
      }
    }
    if (m.find("PayAsYouGoOptions") != m.end() && !m["PayAsYouGoOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PayAsYouGoOptions"].type()) {
        DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupPayAsYouGoOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PayAsYouGoOptions"]));
        payAsYouGoOptions = make_shared<DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupPayAsYouGoOptions>(model1);
      }
    }
    if (m.find("TargetCapacitySpecification") != m.end() && !m["TargetCapacitySpecification"].empty()) {
      if (typeid(map<string, boost::any>) == m["TargetCapacitySpecification"].type()) {
        DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupTargetCapacitySpecification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TargetCapacitySpecification"]));
        targetCapacitySpecification = make_shared<DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupTargetCapacitySpecification>(model1);
      }
    }
  }


  virtual ~DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroup() = default;
};
class DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroups : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroup>> autoProvisioningGroup{};

  DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroups() {}

  explicit DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoProvisioningGroup) {
      vector<boost::any> temp1;
      for(auto item1:*autoProvisioningGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AutoProvisioningGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoProvisioningGroup") != m.end() && !m["AutoProvisioningGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["AutoProvisioningGroup"].type()) {
        vector<DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AutoProvisioningGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        autoProvisioningGroup = make_shared<vector<DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroup>>(expect1);
      }
    }
  }


  virtual ~DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroups() = default;
};
class DescribeAutoProvisioningGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroups> autoProvisioningGroups{};

  DescribeAutoProvisioningGroupsResponseBody() {}

  explicit DescribeAutoProvisioningGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (autoProvisioningGroups) {
      res["AutoProvisioningGroups"] = autoProvisioningGroups ? boost::any(autoProvisioningGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("AutoProvisioningGroups") != m.end() && !m["AutoProvisioningGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["AutoProvisioningGroups"].type()) {
        DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AutoProvisioningGroups"]));
        autoProvisioningGroups = make_shared<DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroups>(model1);
      }
    }
  }


  virtual ~DescribeAutoProvisioningGroupsResponseBody() = default;
};
class DescribeAutoProvisioningGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAutoProvisioningGroupsResponseBody> body{};

  DescribeAutoProvisioningGroupsResponse() {}

  explicit DescribeAutoProvisioningGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAutoProvisioningGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAutoProvisioningGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAutoProvisioningGroupsResponse() = default;
};
class DescribeAutoSnapshotPolicyExRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeAutoSnapshotPolicyExRequestTag() {}

  explicit DescribeAutoSnapshotPolicyExRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeAutoSnapshotPolicyExRequestTag() = default;
};
class DescribeAutoSnapshotPolicyExRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeAutoSnapshotPolicyExRequestTag>> tag{};

  DescribeAutoSnapshotPolicyExRequest() {}

  explicit DescribeAutoSnapshotPolicyExRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (autoSnapshotPolicyId) {
      res["AutoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AutoSnapshotPolicyId") != m.end() && !m["AutoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["AutoSnapshotPolicyId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeAutoSnapshotPolicyExRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAutoSnapshotPolicyExRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeAutoSnapshotPolicyExRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeAutoSnapshotPolicyExRequest() = default;
};
class DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicyTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicyTagsTag() {}

  explicit DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicyTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicyTagsTag() = default;
};
class DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicyTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicyTagsTag>> tag{};

  DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicyTags() {}

  explicit DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicyTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicyTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicyTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicyTags() = default;
};
class DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy : public Darabonba::Model {
public:
  shared_ptr<string> timePoints{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> status{};
  shared_ptr<string> autoSnapshotPolicyName{};
  shared_ptr<string> targetCopyRegions{};
  shared_ptr<long> copiedSnapshotsRetentionDays{};
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<long> retentionDays{};
  shared_ptr<string> regionId{};
  shared_ptr<long> diskNums{};
  shared_ptr<bool> enableCrossRegionCopy{};
  shared_ptr<string> repeatWeekdays{};
  shared_ptr<long> volumeNums{};
  shared_ptr<DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicyTags> tags{};

  DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy() {}

  explicit DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timePoints) {
      res["TimePoints"] = boost::any(*timePoints);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (autoSnapshotPolicyName) {
      res["AutoSnapshotPolicyName"] = boost::any(*autoSnapshotPolicyName);
    }
    if (targetCopyRegions) {
      res["TargetCopyRegions"] = boost::any(*targetCopyRegions);
    }
    if (copiedSnapshotsRetentionDays) {
      res["CopiedSnapshotsRetentionDays"] = boost::any(*copiedSnapshotsRetentionDays);
    }
    if (autoSnapshotPolicyId) {
      res["AutoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    if (retentionDays) {
      res["RetentionDays"] = boost::any(*retentionDays);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (diskNums) {
      res["DiskNums"] = boost::any(*diskNums);
    }
    if (enableCrossRegionCopy) {
      res["EnableCrossRegionCopy"] = boost::any(*enableCrossRegionCopy);
    }
    if (repeatWeekdays) {
      res["RepeatWeekdays"] = boost::any(*repeatWeekdays);
    }
    if (volumeNums) {
      res["VolumeNums"] = boost::any(*volumeNums);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimePoints") != m.end() && !m["TimePoints"].empty()) {
      timePoints = make_shared<string>(boost::any_cast<string>(m["TimePoints"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("AutoSnapshotPolicyName") != m.end() && !m["AutoSnapshotPolicyName"].empty()) {
      autoSnapshotPolicyName = make_shared<string>(boost::any_cast<string>(m["AutoSnapshotPolicyName"]));
    }
    if (m.find("TargetCopyRegions") != m.end() && !m["TargetCopyRegions"].empty()) {
      targetCopyRegions = make_shared<string>(boost::any_cast<string>(m["TargetCopyRegions"]));
    }
    if (m.find("CopiedSnapshotsRetentionDays") != m.end() && !m["CopiedSnapshotsRetentionDays"].empty()) {
      copiedSnapshotsRetentionDays = make_shared<long>(boost::any_cast<long>(m["CopiedSnapshotsRetentionDays"]));
    }
    if (m.find("AutoSnapshotPolicyId") != m.end() && !m["AutoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["AutoSnapshotPolicyId"]));
    }
    if (m.find("RetentionDays") != m.end() && !m["RetentionDays"].empty()) {
      retentionDays = make_shared<long>(boost::any_cast<long>(m["RetentionDays"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DiskNums") != m.end() && !m["DiskNums"].empty()) {
      diskNums = make_shared<long>(boost::any_cast<long>(m["DiskNums"]));
    }
    if (m.find("EnableCrossRegionCopy") != m.end() && !m["EnableCrossRegionCopy"].empty()) {
      enableCrossRegionCopy = make_shared<bool>(boost::any_cast<bool>(m["EnableCrossRegionCopy"]));
    }
    if (m.find("RepeatWeekdays") != m.end() && !m["RepeatWeekdays"].empty()) {
      repeatWeekdays = make_shared<string>(boost::any_cast<string>(m["RepeatWeekdays"]));
    }
    if (m.find("VolumeNums") != m.end() && !m["VolumeNums"].empty()) {
      volumeNums = make_shared<long>(boost::any_cast<long>(m["VolumeNums"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicyTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicyTags>(model1);
      }
    }
  }


  virtual ~DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy() = default;
};
class DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPolicies : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy>> autoSnapshotPolicy{};

  DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPolicies() {}

  explicit DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoSnapshotPolicy) {
      vector<boost::any> temp1;
      for(auto item1:*autoSnapshotPolicy){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AutoSnapshotPolicy"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoSnapshotPolicy") != m.end() && !m["AutoSnapshotPolicy"].empty()) {
      if (typeid(vector<boost::any>) == m["AutoSnapshotPolicy"].type()) {
        vector<DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AutoSnapshotPolicy"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        autoSnapshotPolicy = make_shared<vector<DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy>>(expect1);
      }
    }
  }


  virtual ~DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPolicies() = default;
};
class DescribeAutoSnapshotPolicyExResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPolicies> autoSnapshotPolicies{};

  DescribeAutoSnapshotPolicyExResponseBody() {}

  explicit DescribeAutoSnapshotPolicyExResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (autoSnapshotPolicies) {
      res["AutoSnapshotPolicies"] = autoSnapshotPolicies ? boost::any(autoSnapshotPolicies->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("AutoSnapshotPolicies") != m.end() && !m["AutoSnapshotPolicies"].empty()) {
      if (typeid(map<string, boost::any>) == m["AutoSnapshotPolicies"].type()) {
        DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPolicies model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AutoSnapshotPolicies"]));
        autoSnapshotPolicies = make_shared<DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPolicies>(model1);
      }
    }
  }


  virtual ~DescribeAutoSnapshotPolicyExResponseBody() = default;
};
class DescribeAutoSnapshotPolicyExResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAutoSnapshotPolicyExResponseBody> body{};

  DescribeAutoSnapshotPolicyExResponse() {}

  explicit DescribeAutoSnapshotPolicyExResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAutoSnapshotPolicyExResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAutoSnapshotPolicyExResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAutoSnapshotPolicyExResponse() = default;
};
class DescribeAvailableResourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<long> spotDuration{};
  shared_ptr<string> destinationResource{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> ioOptimized{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> systemDiskCategory{};
  shared_ptr<string> dataDiskCategory{};
  shared_ptr<string> networkCategory{};
  shared_ptr<long> cores{};
  shared_ptr<double> memory{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> scope{};

  DescribeAvailableResourceRequest() {}

  explicit DescribeAvailableResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (spotDuration) {
      res["SpotDuration"] = boost::any(*spotDuration);
    }
    if (destinationResource) {
      res["DestinationResource"] = boost::any(*destinationResource);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (systemDiskCategory) {
      res["SystemDiskCategory"] = boost::any(*systemDiskCategory);
    }
    if (dataDiskCategory) {
      res["DataDiskCategory"] = boost::any(*dataDiskCategory);
    }
    if (networkCategory) {
      res["NetworkCategory"] = boost::any(*networkCategory);
    }
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("SpotDuration") != m.end() && !m["SpotDuration"].empty()) {
      spotDuration = make_shared<long>(boost::any_cast<long>(m["SpotDuration"]));
    }
    if (m.find("DestinationResource") != m.end() && !m["DestinationResource"].empty()) {
      destinationResource = make_shared<string>(boost::any_cast<string>(m["DestinationResource"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("SystemDiskCategory") != m.end() && !m["SystemDiskCategory"].empty()) {
      systemDiskCategory = make_shared<string>(boost::any_cast<string>(m["SystemDiskCategory"]));
    }
    if (m.find("DataDiskCategory") != m.end() && !m["DataDiskCategory"].empty()) {
      dataDiskCategory = make_shared<string>(boost::any_cast<string>(m["DataDiskCategory"]));
    }
    if (m.find("NetworkCategory") != m.end() && !m["NetworkCategory"].empty()) {
      networkCategory = make_shared<string>(boost::any_cast<string>(m["NetworkCategory"]));
    }
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
  }


  virtual ~DescribeAvailableResourceRequest() = default;
};
class DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResourcesSupportedResource : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> value{};
  shared_ptr<long> max{};
  shared_ptr<string> unit{};
  shared_ptr<string> statusCategory{};
  shared_ptr<long> min{};

  DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResourcesSupportedResource() {}

  explicit DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResourcesSupportedResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (statusCategory) {
      res["StatusCategory"] = boost::any(*statusCategory);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<long>(boost::any_cast<long>(m["Max"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("StatusCategory") != m.end() && !m["StatusCategory"].empty()) {
      statusCategory = make_shared<string>(boost::any_cast<string>(m["StatusCategory"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<long>(boost::any_cast<long>(m["Min"]));
    }
  }


  virtual ~DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResourcesSupportedResource() = default;
};
class DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResourcesSupportedResource>> supportedResource{};

  DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResources() {}

  explicit DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportedResource) {
      vector<boost::any> temp1;
      for(auto item1:*supportedResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SupportedResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportedResource") != m.end() && !m["SupportedResource"].empty()) {
      if (typeid(vector<boost::any>) == m["SupportedResource"].type()) {
        vector<DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResourcesSupportedResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SupportedResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResourcesSupportedResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supportedResource = make_shared<vector<DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResourcesSupportedResource>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResources() = default;
};
class DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResource : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResources> supportedResources{};

  DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResource() {}

  explicit DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (supportedResources) {
      res["SupportedResources"] = supportedResources ? boost::any(supportedResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("SupportedResources") != m.end() && !m["SupportedResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportedResources"].type()) {
        DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportedResources"]));
        supportedResources = make_shared<DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResources>(model1);
      }
    }
  }


  virtual ~DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResource() = default;
};
class DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResource>> availableResource{};

  DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResources() {}

  explicit DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableResource) {
      vector<boost::any> temp1;
      for(auto item1:*availableResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvailableResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableResource") != m.end() && !m["AvailableResource"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableResource"].type()) {
        vector<DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        availableResource = make_shared<vector<DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResource>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResources() = default;
};
class DescribeAvailableResourceResponseBodyAvailableZonesAvailableZone : public Darabonba::Model {
public:
  shared_ptr<string> zoneId{};
  shared_ptr<string> status{};
  shared_ptr<string> statusCategory{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResources> availableResources{};

  DescribeAvailableResourceResponseBodyAvailableZonesAvailableZone() {}

  explicit DescribeAvailableResourceResponseBodyAvailableZonesAvailableZone(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusCategory) {
      res["StatusCategory"] = boost::any(*statusCategory);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (availableResources) {
      res["AvailableResources"] = availableResources ? boost::any(availableResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StatusCategory") != m.end() && !m["StatusCategory"].empty()) {
      statusCategory = make_shared<string>(boost::any_cast<string>(m["StatusCategory"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AvailableResources") != m.end() && !m["AvailableResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvailableResources"].type()) {
        DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvailableResources"]));
        availableResources = make_shared<DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResources>(model1);
      }
    }
  }


  virtual ~DescribeAvailableResourceResponseBodyAvailableZonesAvailableZone() = default;
};
class DescribeAvailableResourceResponseBodyAvailableZones : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAvailableResourceResponseBodyAvailableZonesAvailableZone>> availableZone{};

  DescribeAvailableResourceResponseBodyAvailableZones() {}

  explicit DescribeAvailableResourceResponseBodyAvailableZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableZone) {
      vector<boost::any> temp1;
      for(auto item1:*availableZone){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvailableZone"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableZone") != m.end() && !m["AvailableZone"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableZone"].type()) {
        vector<DescribeAvailableResourceResponseBodyAvailableZonesAvailableZone> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableZone"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableResourceResponseBodyAvailableZonesAvailableZone model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        availableZone = make_shared<vector<DescribeAvailableResourceResponseBodyAvailableZonesAvailableZone>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableResourceResponseBodyAvailableZones() = default;
};
class DescribeAvailableResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAvailableResourceResponseBodyAvailableZones> availableZones{};

  DescribeAvailableResourceResponseBody() {}

  explicit DescribeAvailableResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (availableZones) {
      res["AvailableZones"] = availableZones ? boost::any(availableZones->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("AvailableZones") != m.end() && !m["AvailableZones"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvailableZones"].type()) {
        DescribeAvailableResourceResponseBodyAvailableZones model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvailableZones"]));
        availableZones = make_shared<DescribeAvailableResourceResponseBodyAvailableZones>(model1);
      }
    }
  }


  virtual ~DescribeAvailableResourceResponseBody() = default;
};
class DescribeAvailableResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAvailableResourceResponseBody> body{};

  DescribeAvailableResourceResponse() {}

  explicit DescribeAvailableResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAvailableResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAvailableResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAvailableResourceResponse() = default;
};
class DescribeBandwidthLimitationRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> operationType{};

  DescribeBandwidthLimitationRequest() {}

  explicit DescribeBandwidthLimitationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (operationType) {
      res["OperationType"] = boost::any(*operationType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("OperationType") != m.end() && !m["OperationType"].empty()) {
      operationType = make_shared<string>(boost::any_cast<string>(m["OperationType"]));
    }
  }


  virtual ~DescribeBandwidthLimitationRequest() = default;
};
class DescribeBandwidthLimitationResponseBodyBandwidthsBandwidth : public Darabonba::Model {
public:
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> max{};
  shared_ptr<long> min{};
  shared_ptr<string> unit{};

  DescribeBandwidthLimitationResponseBodyBandwidthsBandwidth() {}

  explicit DescribeBandwidthLimitationResponseBodyBandwidthsBandwidth(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<long>(boost::any_cast<long>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<long>(boost::any_cast<long>(m["Min"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
  }


  virtual ~DescribeBandwidthLimitationResponseBodyBandwidthsBandwidth() = default;
};
class DescribeBandwidthLimitationResponseBodyBandwidths : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBandwidthLimitationResponseBodyBandwidthsBandwidth>> bandwidth{};

  DescribeBandwidthLimitationResponseBodyBandwidths() {}

  explicit DescribeBandwidthLimitationResponseBodyBandwidths(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      vector<boost::any> temp1;
      for(auto item1:*bandwidth){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Bandwidth"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      if (typeid(vector<boost::any>) == m["Bandwidth"].type()) {
        vector<DescribeBandwidthLimitationResponseBodyBandwidthsBandwidth> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Bandwidth"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBandwidthLimitationResponseBodyBandwidthsBandwidth model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bandwidth = make_shared<vector<DescribeBandwidthLimitationResponseBodyBandwidthsBandwidth>>(expect1);
      }
    }
  }


  virtual ~DescribeBandwidthLimitationResponseBodyBandwidths() = default;
};
class DescribeBandwidthLimitationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeBandwidthLimitationResponseBodyBandwidths> bandwidths{};

  DescribeBandwidthLimitationResponseBody() {}

  explicit DescribeBandwidthLimitationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (bandwidths) {
      res["Bandwidths"] = bandwidths ? boost::any(bandwidths->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Bandwidths") != m.end() && !m["Bandwidths"].empty()) {
      if (typeid(map<string, boost::any>) == m["Bandwidths"].type()) {
        DescribeBandwidthLimitationResponseBodyBandwidths model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Bandwidths"]));
        bandwidths = make_shared<DescribeBandwidthLimitationResponseBodyBandwidths>(model1);
      }
    }
  }


  virtual ~DescribeBandwidthLimitationResponseBody() = default;
};
class DescribeBandwidthLimitationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeBandwidthLimitationResponseBody> body{};

  DescribeBandwidthLimitationResponse() {}

  explicit DescribeBandwidthLimitationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBandwidthLimitationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBandwidthLimitationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBandwidthLimitationResponse() = default;
};
class DescribeBandwidthPackagesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeBandwidthPackagesRequest() {}

  explicit DescribeBandwidthPackagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeBandwidthPackagesRequest() = default;
};
class DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackagePublicIpAddressesPublicIpAddresse : public Darabonba::Model {
public:
  shared_ptr<string> ipAddress{};
  shared_ptr<string> allocationId{};

  DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackagePublicIpAddressesPublicIpAddresse() {}

  explicit DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackagePublicIpAddressesPublicIpAddresse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
  }


  virtual ~DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackagePublicIpAddressesPublicIpAddresse() = default;
};
class DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackagePublicIpAddresses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackagePublicIpAddressesPublicIpAddresse>> publicIpAddresse{};

  DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackagePublicIpAddresses() {}

  explicit DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackagePublicIpAddresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (publicIpAddresse) {
      vector<boost::any> temp1;
      for(auto item1:*publicIpAddresse){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PublicIpAddresse"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PublicIpAddresse") != m.end() && !m["PublicIpAddresse"].empty()) {
      if (typeid(vector<boost::any>) == m["PublicIpAddresse"].type()) {
        vector<DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackagePublicIpAddressesPublicIpAddresse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PublicIpAddresse"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackagePublicIpAddressesPublicIpAddresse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        publicIpAddresse = make_shared<vector<DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackagePublicIpAddressesPublicIpAddresse>>(expect1);
      }
    }
  }


  virtual ~DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackagePublicIpAddresses() = default;
};
class DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackage : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> ipCount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> description{};
  shared_ptr<string> bandwidth{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> businessStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> ISP{};
  shared_ptr<DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackagePublicIpAddresses> publicIpAddresses{};

  DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackage() {}

  explicit DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (ipCount) {
      res["IpCount"] = boost::any(*ipCount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ISP) {
      res["ISP"] = boost::any(*ISP);
    }
    if (publicIpAddresses) {
      res["PublicIpAddresses"] = publicIpAddresses ? boost::any(publicIpAddresses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("IpCount") != m.end() && !m["IpCount"].empty()) {
      ipCount = make_shared<string>(boost::any_cast<string>(m["IpCount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<string>(boost::any_cast<string>(m["Bandwidth"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ISP") != m.end() && !m["ISP"].empty()) {
      ISP = make_shared<string>(boost::any_cast<string>(m["ISP"]));
    }
    if (m.find("PublicIpAddresses") != m.end() && !m["PublicIpAddresses"].empty()) {
      if (typeid(map<string, boost::any>) == m["PublicIpAddresses"].type()) {
        DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackagePublicIpAddresses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PublicIpAddresses"]));
        publicIpAddresses = make_shared<DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackagePublicIpAddresses>(model1);
      }
    }
  }


  virtual ~DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackage() = default;
};
class DescribeBandwidthPackagesResponseBodyBandwidthPackages : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackage>> bandwidthPackage{};

  DescribeBandwidthPackagesResponseBodyBandwidthPackages() {}

  explicit DescribeBandwidthPackagesResponseBodyBandwidthPackages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthPackage) {
      vector<boost::any> temp1;
      for(auto item1:*bandwidthPackage){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BandwidthPackage"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthPackage") != m.end() && !m["BandwidthPackage"].empty()) {
      if (typeid(vector<boost::any>) == m["BandwidthPackage"].type()) {
        vector<DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BandwidthPackage"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bandwidthPackage = make_shared<vector<DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackage>>(expect1);
      }
    }
  }


  virtual ~DescribeBandwidthPackagesResponseBodyBandwidthPackages() = default;
};
class DescribeBandwidthPackagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeBandwidthPackagesResponseBodyBandwidthPackages> bandwidthPackages{};

  DescribeBandwidthPackagesResponseBody() {}

  explicit DescribeBandwidthPackagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (bandwidthPackages) {
      res["BandwidthPackages"] = bandwidthPackages ? boost::any(bandwidthPackages->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("BandwidthPackages") != m.end() && !m["BandwidthPackages"].empty()) {
      if (typeid(map<string, boost::any>) == m["BandwidthPackages"].type()) {
        DescribeBandwidthPackagesResponseBodyBandwidthPackages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BandwidthPackages"]));
        bandwidthPackages = make_shared<DescribeBandwidthPackagesResponseBodyBandwidthPackages>(model1);
      }
    }
  }


  virtual ~DescribeBandwidthPackagesResponseBody() = default;
};
class DescribeBandwidthPackagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeBandwidthPackagesResponseBody> body{};

  DescribeBandwidthPackagesResponse() {}

  explicit DescribeBandwidthPackagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBandwidthPackagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBandwidthPackagesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBandwidthPackagesResponse() = default;
};
class DescribeCapacityReservationInstancesRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  DescribeCapacityReservationInstancesRequestPrivatePoolOptions() {}

  explicit DescribeCapacityReservationInstancesRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DescribeCapacityReservationInstancesRequestPrivatePoolOptions() = default;
};
class DescribeCapacityReservationInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<DescribeCapacityReservationInstancesRequestPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  DescribeCapacityReservationInstancesRequest() {}

  explicit DescribeCapacityReservationInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privatePoolOptions) {
      res["PrivatePoolOptions"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolOptions"].type()) {
        DescribeCapacityReservationInstancesRequestPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolOptions"]));
        privatePoolOptions = make_shared<DescribeCapacityReservationInstancesRequestPrivatePoolOptions>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~DescribeCapacityReservationInstancesRequest() = default;
};
class DescribeCapacityReservationInstancesResponseBodyCapacityReservationItemInstanceIdSet : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  DescribeCapacityReservationInstancesResponseBodyCapacityReservationItemInstanceIdSet() {}

  explicit DescribeCapacityReservationInstancesResponseBodyCapacityReservationItemInstanceIdSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeCapacityReservationInstancesResponseBodyCapacityReservationItemInstanceIdSet() = default;
};
class DescribeCapacityReservationInstancesResponseBodyCapacityReservationItem : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCapacityReservationInstancesResponseBodyCapacityReservationItemInstanceIdSet>> instanceIdSet{};

  DescribeCapacityReservationInstancesResponseBodyCapacityReservationItem() {}

  explicit DescribeCapacityReservationInstancesResponseBodyCapacityReservationItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIdSet) {
      vector<boost::any> temp1;
      for(auto item1:*instanceIdSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceIdSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIdSet") != m.end() && !m["InstanceIdSet"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceIdSet"].type()) {
        vector<DescribeCapacityReservationInstancesResponseBodyCapacityReservationItemInstanceIdSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceIdSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCapacityReservationInstancesResponseBodyCapacityReservationItemInstanceIdSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceIdSet = make_shared<vector<DescribeCapacityReservationInstancesResponseBodyCapacityReservationItemInstanceIdSet>>(expect1);
      }
    }
  }


  virtual ~DescribeCapacityReservationInstancesResponseBodyCapacityReservationItem() = default;
};
class DescribeCapacityReservationInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> maxResults{};
  shared_ptr<DescribeCapacityReservationInstancesResponseBodyCapacityReservationItem> capacityReservationItem{};

  DescribeCapacityReservationInstancesResponseBody() {}

  explicit DescribeCapacityReservationInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (capacityReservationItem) {
      res["CapacityReservationItem"] = capacityReservationItem ? boost::any(capacityReservationItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("CapacityReservationItem") != m.end() && !m["CapacityReservationItem"].empty()) {
      if (typeid(map<string, boost::any>) == m["CapacityReservationItem"].type()) {
        DescribeCapacityReservationInstancesResponseBodyCapacityReservationItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CapacityReservationItem"]));
        capacityReservationItem = make_shared<DescribeCapacityReservationInstancesResponseBodyCapacityReservationItem>(model1);
      }
    }
  }


  virtual ~DescribeCapacityReservationInstancesResponseBody() = default;
};
class DescribeCapacityReservationInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeCapacityReservationInstancesResponseBody> body{};

  DescribeCapacityReservationInstancesResponse() {}

  explicit DescribeCapacityReservationInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCapacityReservationInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCapacityReservationInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCapacityReservationInstancesResponse() = default;
};
class DescribeCapacityReservationsRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> ids{};

  DescribeCapacityReservationsRequestPrivatePoolOptions() {}

  explicit DescribeCapacityReservationsRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      ids = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
  }


  virtual ~DescribeCapacityReservationsRequestPrivatePoolOptions() = default;
};
class DescribeCapacityReservationsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeCapacityReservationsRequestTag() {}

  explicit DescribeCapacityReservationsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeCapacityReservationsRequestTag() = default;
};
class DescribeCapacityReservationsRequest : public Darabonba::Model {
public:
  shared_ptr<DescribeCapacityReservationsRequestPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<DescribeCapacityReservationsRequestTag>> tag{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> platform{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> status{};

  DescribeCapacityReservationsRequest() {}

  explicit DescribeCapacityReservationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privatePoolOptions) {
      res["PrivatePoolOptions"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolOptions"].type()) {
        DescribeCapacityReservationsRequestPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolOptions"]));
        privatePoolOptions = make_shared<DescribeCapacityReservationsRequestPrivatePoolOptions>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeCapacityReservationsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCapacityReservationsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeCapacityReservationsRequestTag>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeCapacityReservationsRequest() = default;
};
class DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemAllocatedResourcesAllocatedResource : public Darabonba::Model {
public:
  shared_ptr<long> usedAmount{};
  shared_ptr<long> totalAmount{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> instanceType{};

  DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemAllocatedResourcesAllocatedResource() {}

  explicit DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemAllocatedResourcesAllocatedResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usedAmount) {
      res["UsedAmount"] = boost::any(*usedAmount);
    }
    if (totalAmount) {
      res["TotalAmount"] = boost::any(*totalAmount);
    }
    if (zoneId) {
      res["zoneId"] = boost::any(*zoneId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsedAmount") != m.end() && !m["UsedAmount"].empty()) {
      usedAmount = make_shared<long>(boost::any_cast<long>(m["UsedAmount"]));
    }
    if (m.find("TotalAmount") != m.end() && !m["TotalAmount"].empty()) {
      totalAmount = make_shared<long>(boost::any_cast<long>(m["TotalAmount"]));
    }
    if (m.find("zoneId") != m.end() && !m["zoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["zoneId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
  }


  virtual ~DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemAllocatedResourcesAllocatedResource() = default;
};
class DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemAllocatedResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemAllocatedResourcesAllocatedResource>> allocatedResource{};

  DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemAllocatedResources() {}

  explicit DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemAllocatedResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocatedResource) {
      vector<boost::any> temp1;
      for(auto item1:*allocatedResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AllocatedResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocatedResource") != m.end() && !m["AllocatedResource"].empty()) {
      if (typeid(vector<boost::any>) == m["AllocatedResource"].type()) {
        vector<DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemAllocatedResourcesAllocatedResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AllocatedResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemAllocatedResourcesAllocatedResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        allocatedResource = make_shared<vector<DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemAllocatedResourcesAllocatedResource>>(expect1);
      }
    }
  }


  virtual ~DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemAllocatedResources() = default;
};
class DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemTagsTag() {}

  explicit DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemTagsTag() = default;
};
class DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemTagsTag>> tag{};

  DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemTags() {}

  explicit DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemTags() = default;
};
class DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItem : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> timeSlot{};
  shared_ptr<string> privatePoolOptionsMatchCriteria{};
  shared_ptr<string> privatePoolOptionsId{};
  shared_ptr<string> privatePoolOptionsName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> description{};
  shared_ptr<string> endTimeType{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> platform{};
  shared_ptr<DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemAllocatedResources> allocatedResources{};
  shared_ptr<DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemTags> tags{};

  DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItem() {}

  explicit DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (timeSlot) {
      res["TimeSlot"] = boost::any(*timeSlot);
    }
    if (privatePoolOptionsMatchCriteria) {
      res["PrivatePoolOptionsMatchCriteria"] = boost::any(*privatePoolOptionsMatchCriteria);
    }
    if (privatePoolOptionsId) {
      res["PrivatePoolOptionsId"] = boost::any(*privatePoolOptionsId);
    }
    if (privatePoolOptionsName) {
      res["PrivatePoolOptionsName"] = boost::any(*privatePoolOptionsName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTimeType) {
      res["EndTimeType"] = boost::any(*endTimeType);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (allocatedResources) {
      res["AllocatedResources"] = allocatedResources ? boost::any(allocatedResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TimeSlot") != m.end() && !m["TimeSlot"].empty()) {
      timeSlot = make_shared<string>(boost::any_cast<string>(m["TimeSlot"]));
    }
    if (m.find("PrivatePoolOptionsMatchCriteria") != m.end() && !m["PrivatePoolOptionsMatchCriteria"].empty()) {
      privatePoolOptionsMatchCriteria = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptionsMatchCriteria"]));
    }
    if (m.find("PrivatePoolOptionsId") != m.end() && !m["PrivatePoolOptionsId"].empty()) {
      privatePoolOptionsId = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptionsId"]));
    }
    if (m.find("PrivatePoolOptionsName") != m.end() && !m["PrivatePoolOptionsName"].empty()) {
      privatePoolOptionsName = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptionsName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTimeType") != m.end() && !m["EndTimeType"].empty()) {
      endTimeType = make_shared<string>(boost::any_cast<string>(m["EndTimeType"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("AllocatedResources") != m.end() && !m["AllocatedResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["AllocatedResources"].type()) {
        DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemAllocatedResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AllocatedResources"]));
        allocatedResources = make_shared<DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemAllocatedResources>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemTags>(model1);
      }
    }
  }


  virtual ~DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItem() = default;
};
class DescribeCapacityReservationsResponseBodyCapacityReservationSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItem>> capacityReservationItem{};

  DescribeCapacityReservationsResponseBodyCapacityReservationSet() {}

  explicit DescribeCapacityReservationsResponseBodyCapacityReservationSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacityReservationItem) {
      vector<boost::any> temp1;
      for(auto item1:*capacityReservationItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CapacityReservationItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CapacityReservationItem") != m.end() && !m["CapacityReservationItem"].empty()) {
      if (typeid(vector<boost::any>) == m["CapacityReservationItem"].type()) {
        vector<DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CapacityReservationItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        capacityReservationItem = make_shared<vector<DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItem>>(expect1);
      }
    }
  }


  virtual ~DescribeCapacityReservationsResponseBodyCapacityReservationSet() = default;
};
class DescribeCapacityReservationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> maxResults{};
  shared_ptr<DescribeCapacityReservationsResponseBodyCapacityReservationSet> capacityReservationSet{};

  DescribeCapacityReservationsResponseBody() {}

  explicit DescribeCapacityReservationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (capacityReservationSet) {
      res["CapacityReservationSet"] = capacityReservationSet ? boost::any(capacityReservationSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("CapacityReservationSet") != m.end() && !m["CapacityReservationSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["CapacityReservationSet"].type()) {
        DescribeCapacityReservationsResponseBodyCapacityReservationSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CapacityReservationSet"]));
        capacityReservationSet = make_shared<DescribeCapacityReservationsResponseBodyCapacityReservationSet>(model1);
      }
    }
  }


  virtual ~DescribeCapacityReservationsResponseBody() = default;
};
class DescribeCapacityReservationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeCapacityReservationsResponseBody> body{};

  DescribeCapacityReservationsResponse() {}

  explicit DescribeCapacityReservationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCapacityReservationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCapacityReservationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCapacityReservationsResponse() = default;
};
class DescribeClassicLinkInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};

  DescribeClassicLinkInstancesRequest() {}

  explicit DescribeClassicLinkInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
  }


  virtual ~DescribeClassicLinkInstancesRequest() = default;
};
class DescribeClassicLinkInstancesResponseBodyLinksLink : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<string> instanceId{};

  DescribeClassicLinkInstancesResponseBodyLinksLink() {}

  explicit DescribeClassicLinkInstancesResponseBodyLinksLink(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeClassicLinkInstancesResponseBodyLinksLink() = default;
};
class DescribeClassicLinkInstancesResponseBodyLinks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClassicLinkInstancesResponseBodyLinksLink>> link{};

  DescribeClassicLinkInstancesResponseBodyLinks() {}

  explicit DescribeClassicLinkInstancesResponseBodyLinks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (link) {
      vector<boost::any> temp1;
      for(auto item1:*link){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Link"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Link") != m.end() && !m["Link"].empty()) {
      if (typeid(vector<boost::any>) == m["Link"].type()) {
        vector<DescribeClassicLinkInstancesResponseBodyLinksLink> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Link"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClassicLinkInstancesResponseBodyLinksLink model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        link = make_shared<vector<DescribeClassicLinkInstancesResponseBodyLinksLink>>(expect1);
      }
    }
  }


  virtual ~DescribeClassicLinkInstancesResponseBodyLinks() = default;
};
class DescribeClassicLinkInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeClassicLinkInstancesResponseBodyLinks> links{};

  DescribeClassicLinkInstancesResponseBody() {}

  explicit DescribeClassicLinkInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (links) {
      res["Links"] = links ? boost::any(links->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Links") != m.end() && !m["Links"].empty()) {
      if (typeid(map<string, boost::any>) == m["Links"].type()) {
        DescribeClassicLinkInstancesResponseBodyLinks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Links"]));
        links = make_shared<DescribeClassicLinkInstancesResponseBodyLinks>(model1);
      }
    }
  }


  virtual ~DescribeClassicLinkInstancesResponseBody() = default;
};
class DescribeClassicLinkInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeClassicLinkInstancesResponseBody> body{};

  DescribeClassicLinkInstancesResponse() {}

  explicit DescribeClassicLinkInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClassicLinkInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClassicLinkInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClassicLinkInstancesResponse() = default;
};
class DescribeCloudAssistantStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> OSType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> instanceId{};

  DescribeCloudAssistantStatusRequest() {}

  explicit DescribeCloudAssistantStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (OSType) {
      res["OSType"] = boost::any(*OSType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("OSType") != m.end() && !m["OSType"].empty()) {
      OSType = make_shared<string>(boost::any_cast<string>(m["OSType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCloudAssistantStatusRequest() = default;
};
class DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSetInstanceCloudAssistantStatus : public Darabonba::Model {
public:
  shared_ptr<string> cloudAssistantStatus{};
  shared_ptr<string> lastInvokedTime{};
  shared_ptr<string> cloudAssistantVersion{};
  shared_ptr<long> activeTaskCount{};
  shared_ptr<long> invocationCount{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> lastHeartbeatTime{};
  shared_ptr<string> OSType{};
  shared_ptr<bool> supportSessionManager{};

  DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSetInstanceCloudAssistantStatus() {}

  explicit DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSetInstanceCloudAssistantStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudAssistantStatus) {
      res["CloudAssistantStatus"] = boost::any(*cloudAssistantStatus);
    }
    if (lastInvokedTime) {
      res["LastInvokedTime"] = boost::any(*lastInvokedTime);
    }
    if (cloudAssistantVersion) {
      res["CloudAssistantVersion"] = boost::any(*cloudAssistantVersion);
    }
    if (activeTaskCount) {
      res["ActiveTaskCount"] = boost::any(*activeTaskCount);
    }
    if (invocationCount) {
      res["InvocationCount"] = boost::any(*invocationCount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lastHeartbeatTime) {
      res["LastHeartbeatTime"] = boost::any(*lastHeartbeatTime);
    }
    if (OSType) {
      res["OSType"] = boost::any(*OSType);
    }
    if (supportSessionManager) {
      res["SupportSessionManager"] = boost::any(*supportSessionManager);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloudAssistantStatus") != m.end() && !m["CloudAssistantStatus"].empty()) {
      cloudAssistantStatus = make_shared<string>(boost::any_cast<string>(m["CloudAssistantStatus"]));
    }
    if (m.find("LastInvokedTime") != m.end() && !m["LastInvokedTime"].empty()) {
      lastInvokedTime = make_shared<string>(boost::any_cast<string>(m["LastInvokedTime"]));
    }
    if (m.find("CloudAssistantVersion") != m.end() && !m["CloudAssistantVersion"].empty()) {
      cloudAssistantVersion = make_shared<string>(boost::any_cast<string>(m["CloudAssistantVersion"]));
    }
    if (m.find("ActiveTaskCount") != m.end() && !m["ActiveTaskCount"].empty()) {
      activeTaskCount = make_shared<long>(boost::any_cast<long>(m["ActiveTaskCount"]));
    }
    if (m.find("InvocationCount") != m.end() && !m["InvocationCount"].empty()) {
      invocationCount = make_shared<long>(boost::any_cast<long>(m["InvocationCount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LastHeartbeatTime") != m.end() && !m["LastHeartbeatTime"].empty()) {
      lastHeartbeatTime = make_shared<string>(boost::any_cast<string>(m["LastHeartbeatTime"]));
    }
    if (m.find("OSType") != m.end() && !m["OSType"].empty()) {
      OSType = make_shared<string>(boost::any_cast<string>(m["OSType"]));
    }
    if (m.find("SupportSessionManager") != m.end() && !m["SupportSessionManager"].empty()) {
      supportSessionManager = make_shared<bool>(boost::any_cast<bool>(m["SupportSessionManager"]));
    }
  }


  virtual ~DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSetInstanceCloudAssistantStatus() = default;
};
class DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSetInstanceCloudAssistantStatus>> instanceCloudAssistantStatus{};

  DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSet() {}

  explicit DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceCloudAssistantStatus) {
      vector<boost::any> temp1;
      for(auto item1:*instanceCloudAssistantStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceCloudAssistantStatus"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceCloudAssistantStatus") != m.end() && !m["InstanceCloudAssistantStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceCloudAssistantStatus"].type()) {
        vector<DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSetInstanceCloudAssistantStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceCloudAssistantStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSetInstanceCloudAssistantStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceCloudAssistantStatus = make_shared<vector<DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSetInstanceCloudAssistantStatus>>(expect1);
      }
    }
  }


  virtual ~DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSet() = default;
};
class DescribeCloudAssistantStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSet> instanceCloudAssistantStatusSet{};

  DescribeCloudAssistantStatusResponseBody() {}

  explicit DescribeCloudAssistantStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (instanceCloudAssistantStatusSet) {
      res["InstanceCloudAssistantStatusSet"] = instanceCloudAssistantStatusSet ? boost::any(instanceCloudAssistantStatusSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("InstanceCloudAssistantStatusSet") != m.end() && !m["InstanceCloudAssistantStatusSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceCloudAssistantStatusSet"].type()) {
        DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceCloudAssistantStatusSet"]));
        instanceCloudAssistantStatusSet = make_shared<DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSet>(model1);
      }
    }
  }


  virtual ~DescribeCloudAssistantStatusResponseBody() = default;
};
class DescribeCloudAssistantStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeCloudAssistantStatusResponseBody> body{};

  DescribeCloudAssistantStatusResponse() {}

  explicit DescribeCloudAssistantStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudAssistantStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudAssistantStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudAssistantStatusResponse() = default;
};
class DescribeClustersRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ownerAccount{};

  DescribeClustersRequest() {}

  explicit DescribeClustersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeClustersRequest() = default;
};
class DescribeClustersResponseBodyClustersCluster : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};

  DescribeClustersResponseBodyClustersCluster() {}

  explicit DescribeClustersResponseBodyClustersCluster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~DescribeClustersResponseBodyClustersCluster() = default;
};
class DescribeClustersResponseBodyClusters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClustersResponseBodyClustersCluster>> cluster{};

  DescribeClustersResponseBodyClusters() {}

  explicit DescribeClustersResponseBodyClusters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cluster) {
      vector<boost::any> temp1;
      for(auto item1:*cluster){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Cluster"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cluster") != m.end() && !m["Cluster"].empty()) {
      if (typeid(vector<boost::any>) == m["Cluster"].type()) {
        vector<DescribeClustersResponseBodyClustersCluster> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Cluster"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClustersResponseBodyClustersCluster model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cluster = make_shared<vector<DescribeClustersResponseBodyClustersCluster>>(expect1);
      }
    }
  }


  virtual ~DescribeClustersResponseBodyClusters() = default;
};
class DescribeClustersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeClustersResponseBodyClusters> clusters{};

  DescribeClustersResponseBody() {}

  explicit DescribeClustersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (clusters) {
      res["Clusters"] = clusters ? boost::any(clusters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Clusters") != m.end() && !m["Clusters"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clusters"].type()) {
        DescribeClustersResponseBodyClusters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clusters"]));
        clusters = make_shared<DescribeClustersResponseBodyClusters>(model1);
      }
    }
  }


  virtual ~DescribeClustersResponseBody() = default;
};
class DescribeClustersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeClustersResponseBody> body{};

  DescribeClustersResponse() {}

  explicit DescribeClustersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClustersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClustersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClustersResponse() = default;
};
class DescribeCommandsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> provider{};
  shared_ptr<string> commandId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> type{};
  shared_ptr<string> contentEncoding{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeCommandsRequest() {}

  explicit DescribeCommandsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (provider) {
      res["Provider"] = boost::any(*provider);
    }
    if (commandId) {
      res["CommandId"] = boost::any(*commandId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (contentEncoding) {
      res["ContentEncoding"] = boost::any(*contentEncoding);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Provider") != m.end() && !m["Provider"].empty()) {
      provider = make_shared<string>(boost::any_cast<string>(m["Provider"]));
    }
    if (m.find("CommandId") != m.end() && !m["CommandId"].empty()) {
      commandId = make_shared<string>(boost::any_cast<string>(m["CommandId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ContentEncoding") != m.end() && !m["ContentEncoding"].empty()) {
      contentEncoding = make_shared<string>(boost::any_cast<string>(m["ContentEncoding"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeCommandsRequest() = default;
};
class DescribeCommandsResponseBodyCommandsCommandParameterNames : public Darabonba::Model {
public:
  shared_ptr<vector<string>> parameterName{};

  DescribeCommandsResponseBodyCommandsCommandParameterNames() {}

  explicit DescribeCommandsResponseBodyCommandsCommandParameterNames(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ParameterName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ParameterName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parameterName = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCommandsResponseBodyCommandsCommandParameterNames() = default;
};
class DescribeCommandsResponseBodyCommandsCommand : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> type{};
  shared_ptr<long> timeout{};
  shared_ptr<long> invokeTimes{};
  shared_ptr<string> commandId{};
  shared_ptr<string> workingDir{};
  shared_ptr<string> description{};
  shared_ptr<long> version{};
  shared_ptr<string> provider{};
  shared_ptr<string> commandContent{};
  shared_ptr<string> category{};
  shared_ptr<bool> latest{};
  shared_ptr<string> name{};
  shared_ptr<bool> enableParameter{};
  shared_ptr<DescribeCommandsResponseBodyCommandsCommandParameterNames> parameterNames{};

  DescribeCommandsResponseBodyCommandsCommand() {}

  explicit DescribeCommandsResponseBodyCommandsCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (invokeTimes) {
      res["InvokeTimes"] = boost::any(*invokeTimes);
    }
    if (commandId) {
      res["CommandId"] = boost::any(*commandId);
    }
    if (workingDir) {
      res["WorkingDir"] = boost::any(*workingDir);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (provider) {
      res["Provider"] = boost::any(*provider);
    }
    if (commandContent) {
      res["CommandContent"] = boost::any(*commandContent);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (latest) {
      res["Latest"] = boost::any(*latest);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (enableParameter) {
      res["EnableParameter"] = boost::any(*enableParameter);
    }
    if (parameterNames) {
      res["ParameterNames"] = parameterNames ? boost::any(parameterNames->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("InvokeTimes") != m.end() && !m["InvokeTimes"].empty()) {
      invokeTimes = make_shared<long>(boost::any_cast<long>(m["InvokeTimes"]));
    }
    if (m.find("CommandId") != m.end() && !m["CommandId"].empty()) {
      commandId = make_shared<string>(boost::any_cast<string>(m["CommandId"]));
    }
    if (m.find("WorkingDir") != m.end() && !m["WorkingDir"].empty()) {
      workingDir = make_shared<string>(boost::any_cast<string>(m["WorkingDir"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
    if (m.find("Provider") != m.end() && !m["Provider"].empty()) {
      provider = make_shared<string>(boost::any_cast<string>(m["Provider"]));
    }
    if (m.find("CommandContent") != m.end() && !m["CommandContent"].empty()) {
      commandContent = make_shared<string>(boost::any_cast<string>(m["CommandContent"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Latest") != m.end() && !m["Latest"].empty()) {
      latest = make_shared<bool>(boost::any_cast<bool>(m["Latest"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("EnableParameter") != m.end() && !m["EnableParameter"].empty()) {
      enableParameter = make_shared<bool>(boost::any_cast<bool>(m["EnableParameter"]));
    }
    if (m.find("ParameterNames") != m.end() && !m["ParameterNames"].empty()) {
      if (typeid(map<string, boost::any>) == m["ParameterNames"].type()) {
        DescribeCommandsResponseBodyCommandsCommandParameterNames model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ParameterNames"]));
        parameterNames = make_shared<DescribeCommandsResponseBodyCommandsCommandParameterNames>(model1);
      }
    }
  }


  virtual ~DescribeCommandsResponseBodyCommandsCommand() = default;
};
class DescribeCommandsResponseBodyCommands : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCommandsResponseBodyCommandsCommand>> command{};

  DescribeCommandsResponseBodyCommands() {}

  explicit DescribeCommandsResponseBodyCommands(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      vector<boost::any> temp1;
      for(auto item1:*command){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Command"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      if (typeid(vector<boost::any>) == m["Command"].type()) {
        vector<DescribeCommandsResponseBodyCommandsCommand> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Command"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCommandsResponseBodyCommandsCommand model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        command = make_shared<vector<DescribeCommandsResponseBodyCommandsCommand>>(expect1);
      }
    }
  }


  virtual ~DescribeCommandsResponseBodyCommands() = default;
};
class DescribeCommandsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeCommandsResponseBodyCommands> commands{};

  DescribeCommandsResponseBody() {}

  explicit DescribeCommandsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (commands) {
      res["Commands"] = commands ? boost::any(commands->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Commands") != m.end() && !m["Commands"].empty()) {
      if (typeid(map<string, boost::any>) == m["Commands"].type()) {
        DescribeCommandsResponseBodyCommands model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Commands"]));
        commands = make_shared<DescribeCommandsResponseBodyCommands>(model1);
      }
    }
  }


  virtual ~DescribeCommandsResponseBody() = default;
};
class DescribeCommandsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeCommandsResponseBody> body{};

  DescribeCommandsResponse() {}

  explicit DescribeCommandsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCommandsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCommandsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCommandsResponse() = default;
};
class DescribeDedicatedBlockStorageClustersRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> dedicatedBlockStorageClusterId{};
  shared_ptr<vector<string>> status{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> category{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> maxResults{};

  DescribeDedicatedBlockStorageClustersRequest() {}

  explicit DescribeDedicatedBlockStorageClustersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dedicatedBlockStorageClusterId) {
      res["DedicatedBlockStorageClusterId"] = boost::any(*dedicatedBlockStorageClusterId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DedicatedBlockStorageClusterId") != m.end() && !m["DedicatedBlockStorageClusterId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DedicatedBlockStorageClusterId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DedicatedBlockStorageClusterId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dedicatedBlockStorageClusterId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Status"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Status"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      status = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
  }


  virtual ~DescribeDedicatedBlockStorageClustersRequest() = default;
};
class DescribeDedicatedBlockStorageClustersResponseBodyDedicatedBlockStorageClustersDedicatedBlockStorageClusterDedicatedBlockStorageClusterCapacity : public Darabonba::Model {
public:
  shared_ptr<long> totalCapacity{};
  shared_ptr<long> availableCapacity{};

  DescribeDedicatedBlockStorageClustersResponseBodyDedicatedBlockStorageClustersDedicatedBlockStorageClusterDedicatedBlockStorageClusterCapacity() {}

  explicit DescribeDedicatedBlockStorageClustersResponseBodyDedicatedBlockStorageClustersDedicatedBlockStorageClusterDedicatedBlockStorageClusterCapacity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCapacity) {
      res["TotalCapacity"] = boost::any(*totalCapacity);
    }
    if (availableCapacity) {
      res["AvailableCapacity"] = boost::any(*availableCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCapacity") != m.end() && !m["TotalCapacity"].empty()) {
      totalCapacity = make_shared<long>(boost::any_cast<long>(m["TotalCapacity"]));
    }
    if (m.find("AvailableCapacity") != m.end() && !m["AvailableCapacity"].empty()) {
      availableCapacity = make_shared<long>(boost::any_cast<long>(m["AvailableCapacity"]));
    }
  }


  virtual ~DescribeDedicatedBlockStorageClustersResponseBodyDedicatedBlockStorageClustersDedicatedBlockStorageClusterDedicatedBlockStorageClusterCapacity() = default;
};
class DescribeDedicatedBlockStorageClustersResponseBodyDedicatedBlockStorageClustersDedicatedBlockStorageCluster : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<string> description{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> createTime{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> category{};
  shared_ptr<string> dedicatedBlockStorageClusterName{};
  shared_ptr<string> dedicatedBlockStorageClusterId{};
  shared_ptr<DescribeDedicatedBlockStorageClustersResponseBodyDedicatedBlockStorageClustersDedicatedBlockStorageClusterDedicatedBlockStorageClusterCapacity> dedicatedBlockStorageClusterCapacity{};

  DescribeDedicatedBlockStorageClustersResponseBodyDedicatedBlockStorageClustersDedicatedBlockStorageCluster() {}

  explicit DescribeDedicatedBlockStorageClustersResponseBodyDedicatedBlockStorageClustersDedicatedBlockStorageCluster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (dedicatedBlockStorageClusterName) {
      res["DedicatedBlockStorageClusterName"] = boost::any(*dedicatedBlockStorageClusterName);
    }
    if (dedicatedBlockStorageClusterId) {
      res["DedicatedBlockStorageClusterId"] = boost::any(*dedicatedBlockStorageClusterId);
    }
    if (dedicatedBlockStorageClusterCapacity) {
      res["DedicatedBlockStorageClusterCapacity"] = dedicatedBlockStorageClusterCapacity ? boost::any(dedicatedBlockStorageClusterCapacity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DedicatedBlockStorageClusterName") != m.end() && !m["DedicatedBlockStorageClusterName"].empty()) {
      dedicatedBlockStorageClusterName = make_shared<string>(boost::any_cast<string>(m["DedicatedBlockStorageClusterName"]));
    }
    if (m.find("DedicatedBlockStorageClusterId") != m.end() && !m["DedicatedBlockStorageClusterId"].empty()) {
      dedicatedBlockStorageClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedBlockStorageClusterId"]));
    }
    if (m.find("DedicatedBlockStorageClusterCapacity") != m.end() && !m["DedicatedBlockStorageClusterCapacity"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedBlockStorageClusterCapacity"].type()) {
        DescribeDedicatedBlockStorageClustersResponseBodyDedicatedBlockStorageClustersDedicatedBlockStorageClusterDedicatedBlockStorageClusterCapacity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedBlockStorageClusterCapacity"]));
        dedicatedBlockStorageClusterCapacity = make_shared<DescribeDedicatedBlockStorageClustersResponseBodyDedicatedBlockStorageClustersDedicatedBlockStorageClusterDedicatedBlockStorageClusterCapacity>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedBlockStorageClustersResponseBodyDedicatedBlockStorageClustersDedicatedBlockStorageCluster() = default;
};
class DescribeDedicatedBlockStorageClustersResponseBodyDedicatedBlockStorageClusters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedBlockStorageClustersResponseBodyDedicatedBlockStorageClustersDedicatedBlockStorageCluster>> dedicatedBlockStorageCluster{};

  DescribeDedicatedBlockStorageClustersResponseBodyDedicatedBlockStorageClusters() {}

  explicit DescribeDedicatedBlockStorageClustersResponseBodyDedicatedBlockStorageClusters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedBlockStorageCluster) {
      vector<boost::any> temp1;
      for(auto item1:*dedicatedBlockStorageCluster){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DedicatedBlockStorageCluster"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedBlockStorageCluster") != m.end() && !m["DedicatedBlockStorageCluster"].empty()) {
      if (typeid(vector<boost::any>) == m["DedicatedBlockStorageCluster"].type()) {
        vector<DescribeDedicatedBlockStorageClustersResponseBodyDedicatedBlockStorageClustersDedicatedBlockStorageCluster> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DedicatedBlockStorageCluster"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedBlockStorageClustersResponseBodyDedicatedBlockStorageClustersDedicatedBlockStorageCluster model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dedicatedBlockStorageCluster = make_shared<vector<DescribeDedicatedBlockStorageClustersResponseBodyDedicatedBlockStorageClustersDedicatedBlockStorageCluster>>(expect1);
      }
    }
  }


  virtual ~DescribeDedicatedBlockStorageClustersResponseBodyDedicatedBlockStorageClusters() = default;
};
class DescribeDedicatedBlockStorageClustersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDedicatedBlockStorageClustersResponseBodyDedicatedBlockStorageClusters> dedicatedBlockStorageClusters{};

  DescribeDedicatedBlockStorageClustersResponseBody() {}

  explicit DescribeDedicatedBlockStorageClustersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (dedicatedBlockStorageClusters) {
      res["DedicatedBlockStorageClusters"] = dedicatedBlockStorageClusters ? boost::any(dedicatedBlockStorageClusters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DedicatedBlockStorageClusters") != m.end() && !m["DedicatedBlockStorageClusters"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedBlockStorageClusters"].type()) {
        DescribeDedicatedBlockStorageClustersResponseBodyDedicatedBlockStorageClusters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedBlockStorageClusters"]));
        dedicatedBlockStorageClusters = make_shared<DescribeDedicatedBlockStorageClustersResponseBodyDedicatedBlockStorageClusters>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedBlockStorageClustersResponseBody() = default;
};
class DescribeDedicatedBlockStorageClustersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDedicatedBlockStorageClustersResponseBody> body{};

  DescribeDedicatedBlockStorageClustersResponse() {}

  explicit DescribeDedicatedBlockStorageClustersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDedicatedBlockStorageClustersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDedicatedBlockStorageClustersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedBlockStorageClustersResponse() = default;
};
class DescribeDedicatedHostAutoRenewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> dedicatedHostIds{};
  shared_ptr<string> regionId{};

  DescribeDedicatedHostAutoRenewRequest() {}

  explicit DescribeDedicatedHostAutoRenewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (dedicatedHostIds) {
      res["DedicatedHostIds"] = boost::any(*dedicatedHostIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DedicatedHostIds") != m.end() && !m["DedicatedHostIds"].empty()) {
      dedicatedHostIds = make_shared<string>(boost::any_cast<string>(m["DedicatedHostIds"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeDedicatedHostAutoRenewRequest() = default;
};
class DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributesDedicatedHostRenewAttribute : public Darabonba::Model {
public:
  shared_ptr<string> periodUnit{};
  shared_ptr<long> duration{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> renewalStatus{};
  shared_ptr<bool> autoRenewEnabled{};

  DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributesDedicatedHostRenewAttribute() {}

  explicit DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributesDedicatedHostRenewAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (renewalStatus) {
      res["RenewalStatus"] = boost::any(*renewalStatus);
    }
    if (autoRenewEnabled) {
      res["AutoRenewEnabled"] = boost::any(*autoRenewEnabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("RenewalStatus") != m.end() && !m["RenewalStatus"].empty()) {
      renewalStatus = make_shared<string>(boost::any_cast<string>(m["RenewalStatus"]));
    }
    if (m.find("AutoRenewEnabled") != m.end() && !m["AutoRenewEnabled"].empty()) {
      autoRenewEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoRenewEnabled"]));
    }
  }


  virtual ~DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributesDedicatedHostRenewAttribute() = default;
};
class DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributesDedicatedHostRenewAttribute>> dedicatedHostRenewAttribute{};

  DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributes() {}

  explicit DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostRenewAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*dedicatedHostRenewAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DedicatedHostRenewAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostRenewAttribute") != m.end() && !m["DedicatedHostRenewAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["DedicatedHostRenewAttribute"].type()) {
        vector<DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributesDedicatedHostRenewAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DedicatedHostRenewAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributesDedicatedHostRenewAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dedicatedHostRenewAttribute = make_shared<vector<DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributesDedicatedHostRenewAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributes() = default;
};
class DescribeDedicatedHostAutoRenewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributes> dedicatedHostRenewAttributes{};

  DescribeDedicatedHostAutoRenewResponseBody() {}

  explicit DescribeDedicatedHostAutoRenewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (dedicatedHostRenewAttributes) {
      res["DedicatedHostRenewAttributes"] = dedicatedHostRenewAttributes ? boost::any(dedicatedHostRenewAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DedicatedHostRenewAttributes") != m.end() && !m["DedicatedHostRenewAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedHostRenewAttributes"].type()) {
        DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedHostRenewAttributes"]));
        dedicatedHostRenewAttributes = make_shared<DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributes>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedHostAutoRenewResponseBody() = default;
};
class DescribeDedicatedHostAutoRenewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDedicatedHostAutoRenewResponseBody> body{};

  DescribeDedicatedHostAutoRenewResponse() {}

  explicit DescribeDedicatedHostAutoRenewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDedicatedHostAutoRenewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDedicatedHostAutoRenewResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedHostAutoRenewResponse() = default;
};
class DescribeDedicatedHostClustersRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDedicatedHostClustersRequestTag() {}

  explicit DescribeDedicatedHostClustersRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDedicatedHostClustersRequestTag() = default;
};
class DescribeDedicatedHostClustersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedHostClustersRequestTag>> tag{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};
  shared_ptr<string> lockReason{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> dedicatedHostClusterIds{};
  shared_ptr<string> dedicatedHostClusterName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeDedicatedHostClustersRequest() {}

  explicit DescribeDedicatedHostClustersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (dedicatedHostClusterIds) {
      res["DedicatedHostClusterIds"] = boost::any(*dedicatedHostClusterIds);
    }
    if (dedicatedHostClusterName) {
      res["DedicatedHostClusterName"] = boost::any(*dedicatedHostClusterName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDedicatedHostClustersRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostClustersRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDedicatedHostClustersRequestTag>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("DedicatedHostClusterIds") != m.end() && !m["DedicatedHostClusterIds"].empty()) {
      dedicatedHostClusterIds = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterIds"]));
    }
    if (m.find("DedicatedHostClusterName") != m.end() && !m["DedicatedHostClusterName"].empty()) {
      dedicatedHostClusterName = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeDedicatedHostClustersRequest() = default;
};
class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTagsTag() {}

  explicit DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTagsTag() = default;
};
class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTagsTag>> tag{};

  DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTags() {}

  explicit DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTags() = default;
};
class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dedicatedHostId{};

  DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostIds() {}

  explicit DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DedicatedHostId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DedicatedHostId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dedicatedHostId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostIds() = default;
};
class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacitiesLocalStorageCapacity : public Darabonba::Model {
public:
  shared_ptr<string> dataDiskCategory{};
  shared_ptr<long> availableDisk{};
  shared_ptr<long> totalDisk{};

  DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacitiesLocalStorageCapacity() {}

  explicit DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacitiesLocalStorageCapacity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDiskCategory) {
      res["DataDiskCategory"] = boost::any(*dataDiskCategory);
    }
    if (availableDisk) {
      res["AvailableDisk"] = boost::any(*availableDisk);
    }
    if (totalDisk) {
      res["TotalDisk"] = boost::any(*totalDisk);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDiskCategory") != m.end() && !m["DataDiskCategory"].empty()) {
      dataDiskCategory = make_shared<string>(boost::any_cast<string>(m["DataDiskCategory"]));
    }
    if (m.find("AvailableDisk") != m.end() && !m["AvailableDisk"].empty()) {
      availableDisk = make_shared<long>(boost::any_cast<long>(m["AvailableDisk"]));
    }
    if (m.find("TotalDisk") != m.end() && !m["TotalDisk"].empty()) {
      totalDisk = make_shared<long>(boost::any_cast<long>(m["TotalDisk"]));
    }
  }


  virtual ~DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacitiesLocalStorageCapacity() = default;
};
class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacities : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacitiesLocalStorageCapacity>> localStorageCapacity{};

  DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacities() {}

  explicit DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localStorageCapacity) {
      vector<boost::any> temp1;
      for(auto item1:*localStorageCapacity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LocalStorageCapacity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalStorageCapacity") != m.end() && !m["LocalStorageCapacity"].empty()) {
      if (typeid(vector<boost::any>) == m["LocalStorageCapacity"].type()) {
        vector<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacitiesLocalStorageCapacity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LocalStorageCapacity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacitiesLocalStorageCapacity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        localStorageCapacity = make_shared<vector<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacitiesLocalStorageCapacity>>(expect1);
      }
    }
  }


  virtual ~DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacities() = default;
};
class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypesAvailableInstanceType : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<long> availableInstanceCapacity{};

  DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypesAvailableInstanceType() {}

  explicit DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypesAvailableInstanceType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (availableInstanceCapacity) {
      res["AvailableInstanceCapacity"] = boost::any(*availableInstanceCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("AvailableInstanceCapacity") != m.end() && !m["AvailableInstanceCapacity"].empty()) {
      availableInstanceCapacity = make_shared<long>(boost::any_cast<long>(m["AvailableInstanceCapacity"]));
    }
  }


  virtual ~DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypesAvailableInstanceType() = default;
};
class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypesAvailableInstanceType>> availableInstanceType{};

  DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypes() {}

  explicit DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableInstanceType) {
      vector<boost::any> temp1;
      for(auto item1:*availableInstanceType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvailableInstanceType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableInstanceType") != m.end() && !m["AvailableInstanceType"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableInstanceType"].type()) {
        vector<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypesAvailableInstanceType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableInstanceType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypesAvailableInstanceType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        availableInstanceType = make_shared<vector<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypesAvailableInstanceType>>(expect1);
      }
    }
  }


  virtual ~DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypes() = default;
};
class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacity : public Darabonba::Model {
public:
  shared_ptr<long> availableVcpus{};
  shared_ptr<long> availableMemory{};
  shared_ptr<long> totalMemory{};
  shared_ptr<long> totalVcpus{};
  shared_ptr<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacities> localStorageCapacities{};
  shared_ptr<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypes> availableInstanceTypes{};

  DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacity() {}

  explicit DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableVcpus) {
      res["AvailableVcpus"] = boost::any(*availableVcpus);
    }
    if (availableMemory) {
      res["AvailableMemory"] = boost::any(*availableMemory);
    }
    if (totalMemory) {
      res["TotalMemory"] = boost::any(*totalMemory);
    }
    if (totalVcpus) {
      res["TotalVcpus"] = boost::any(*totalVcpus);
    }
    if (localStorageCapacities) {
      res["LocalStorageCapacities"] = localStorageCapacities ? boost::any(localStorageCapacities->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (availableInstanceTypes) {
      res["AvailableInstanceTypes"] = availableInstanceTypes ? boost::any(availableInstanceTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableVcpus") != m.end() && !m["AvailableVcpus"].empty()) {
      availableVcpus = make_shared<long>(boost::any_cast<long>(m["AvailableVcpus"]));
    }
    if (m.find("AvailableMemory") != m.end() && !m["AvailableMemory"].empty()) {
      availableMemory = make_shared<long>(boost::any_cast<long>(m["AvailableMemory"]));
    }
    if (m.find("TotalMemory") != m.end() && !m["TotalMemory"].empty()) {
      totalMemory = make_shared<long>(boost::any_cast<long>(m["TotalMemory"]));
    }
    if (m.find("TotalVcpus") != m.end() && !m["TotalVcpus"].empty()) {
      totalVcpus = make_shared<long>(boost::any_cast<long>(m["TotalVcpus"]));
    }
    if (m.find("LocalStorageCapacities") != m.end() && !m["LocalStorageCapacities"].empty()) {
      if (typeid(map<string, boost::any>) == m["LocalStorageCapacities"].type()) {
        DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacities model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LocalStorageCapacities"]));
        localStorageCapacities = make_shared<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacities>(model1);
      }
    }
    if (m.find("AvailableInstanceTypes") != m.end() && !m["AvailableInstanceTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvailableInstanceTypes"].type()) {
        DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvailableInstanceTypes"]));
        availableInstanceTypes = make_shared<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypes>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacity() = default;
};
class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostCluster : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> dedicatedHostClusterId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> dedicatedHostClusterName{};
  shared_ptr<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTags> tags{};
  shared_ptr<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostIds> dedicatedHostIds{};
  shared_ptr<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacity> dedicatedHostClusterCapacity{};

  DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostCluster() {}

  explicit DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostCluster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dedicatedHostClusterName) {
      res["DedicatedHostClusterName"] = boost::any(*dedicatedHostClusterName);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dedicatedHostIds) {
      res["DedicatedHostIds"] = dedicatedHostIds ? boost::any(dedicatedHostIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dedicatedHostClusterCapacity) {
      res["DedicatedHostClusterCapacity"] = dedicatedHostClusterCapacity ? boost::any(dedicatedHostClusterCapacity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DedicatedHostClusterName") != m.end() && !m["DedicatedHostClusterName"].empty()) {
      dedicatedHostClusterName = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterName"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTags>(model1);
      }
    }
    if (m.find("DedicatedHostIds") != m.end() && !m["DedicatedHostIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedHostIds"].type()) {
        DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedHostIds"]));
        dedicatedHostIds = make_shared<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostIds>(model1);
      }
    }
    if (m.find("DedicatedHostClusterCapacity") != m.end() && !m["DedicatedHostClusterCapacity"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedHostClusterCapacity"].type()) {
        DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedHostClusterCapacity"]));
        dedicatedHostClusterCapacity = make_shared<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacity>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostCluster() = default;
};
class DescribeDedicatedHostClustersResponseBodyDedicatedHostClusters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostCluster>> dedicatedHostCluster{};

  DescribeDedicatedHostClustersResponseBodyDedicatedHostClusters() {}

  explicit DescribeDedicatedHostClustersResponseBodyDedicatedHostClusters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostCluster) {
      vector<boost::any> temp1;
      for(auto item1:*dedicatedHostCluster){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DedicatedHostCluster"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostCluster") != m.end() && !m["DedicatedHostCluster"].empty()) {
      if (typeid(vector<boost::any>) == m["DedicatedHostCluster"].type()) {
        vector<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostCluster> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DedicatedHostCluster"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostCluster model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dedicatedHostCluster = make_shared<vector<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostCluster>>(expect1);
      }
    }
  }


  virtual ~DescribeDedicatedHostClustersResponseBodyDedicatedHostClusters() = default;
};
class DescribeDedicatedHostClustersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeDedicatedHostClustersResponseBodyDedicatedHostClusters> dedicatedHostClusters{};

  DescribeDedicatedHostClustersResponseBody() {}

  explicit DescribeDedicatedHostClustersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (dedicatedHostClusters) {
      res["DedicatedHostClusters"] = dedicatedHostClusters ? boost::any(dedicatedHostClusters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("DedicatedHostClusters") != m.end() && !m["DedicatedHostClusters"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedHostClusters"].type()) {
        DescribeDedicatedHostClustersResponseBodyDedicatedHostClusters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedHostClusters"]));
        dedicatedHostClusters = make_shared<DescribeDedicatedHostClustersResponseBodyDedicatedHostClusters>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedHostClustersResponseBody() = default;
};
class DescribeDedicatedHostClustersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDedicatedHostClustersResponseBody> body{};

  DescribeDedicatedHostClustersResponse() {}

  explicit DescribeDedicatedHostClustersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDedicatedHostClustersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDedicatedHostClustersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedHostClustersResponse() = default;
};
class DescribeDedicatedHostsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDedicatedHostsRequestTag() {}

  explicit DescribeDedicatedHostsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDedicatedHostsRequestTag() = default;
};
class DescribeDedicatedHostsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> dedicatedHostIds{};
  shared_ptr<string> dedicatedHostName{};
  shared_ptr<string> status{};
  shared_ptr<string> dedicatedHostType{};
  shared_ptr<string> lockReason{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<DescribeDedicatedHostsRequestTag>> tag{};
  shared_ptr<string> dedicatedHostClusterId{};

  DescribeDedicatedHostsRequest() {}

  explicit DescribeDedicatedHostsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (dedicatedHostIds) {
      res["DedicatedHostIds"] = boost::any(*dedicatedHostIds);
    }
    if (dedicatedHostName) {
      res["DedicatedHostName"] = boost::any(*dedicatedHostName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (dedicatedHostType) {
      res["DedicatedHostType"] = boost::any(*dedicatedHostType);
    }
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("DedicatedHostIds") != m.end() && !m["DedicatedHostIds"].empty()) {
      dedicatedHostIds = make_shared<string>(boost::any_cast<string>(m["DedicatedHostIds"]));
    }
    if (m.find("DedicatedHostName") != m.end() && !m["DedicatedHostName"].empty()) {
      dedicatedHostName = make_shared<string>(boost::any_cast<string>(m["DedicatedHostName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("DedicatedHostType") != m.end() && !m["DedicatedHostType"].empty()) {
      dedicatedHostType = make_shared<string>(boost::any_cast<string>(m["DedicatedHostType"]));
    }
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDedicatedHostsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDedicatedHostsRequestTag>>(expect1);
      }
    }
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
  }


  virtual ~DescribeDedicatedHostsRequest() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstancesInstance : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<string> instanceId{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstancesInstance() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstancesInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstancesInstance() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstancesInstance>> instance{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstances() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      vector<boost::any> temp1;
      for(auto item1:*instance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(vector<boost::any>) == m["Instance"].type()) {
        vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstancesInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstancesInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instance = make_shared<vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstancesInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstances() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocksOperationLock : public Darabonba::Model {
public:
  shared_ptr<string> lockReason{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocksOperationLock() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocksOperationLock(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocksOperationLock() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocksOperationLock>> operationLock{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocks() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationLock) {
      vector<boost::any> temp1;
      for(auto item1:*operationLock){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperationLock"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationLock") != m.end() && !m["OperationLock"].empty()) {
      if (typeid(vector<boost::any>) == m["OperationLock"].type()) {
        vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocksOperationLock> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperationLock"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocksOperationLock model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operationLock = make_shared<vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocksOperationLock>>(expect1);
      }
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocks() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTagsTag() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTagsTag() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTagsTag>> tag{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTags() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTags() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedInstanceTypeFamilies : public Darabonba::Model {
public:
  shared_ptr<vector<string>> supportedInstanceTypeFamily{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedInstanceTypeFamilies() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedInstanceTypeFamilies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportedInstanceTypeFamily) {
      res["SupportedInstanceTypeFamily"] = boost::any(*supportedInstanceTypeFamily);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportedInstanceTypeFamily") != m.end() && !m["SupportedInstanceTypeFamily"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportedInstanceTypeFamily"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportedInstanceTypeFamily"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportedInstanceTypeFamily = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedInstanceTypeFamilies() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedCustomInstanceTypeFamilies : public Darabonba::Model {
public:
  shared_ptr<vector<string>> supportedCustomInstanceTypeFamily{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedCustomInstanceTypeFamilies() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedCustomInstanceTypeFamilies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportedCustomInstanceTypeFamily) {
      res["SupportedCustomInstanceTypeFamily"] = boost::any(*supportedCustomInstanceTypeFamily);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportedCustomInstanceTypeFamily") != m.end() && !m["SupportedCustomInstanceTypeFamily"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportedCustomInstanceTypeFamily"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportedCustomInstanceTypeFamily"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportedCustomInstanceTypeFamily = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedCustomInstanceTypeFamilies() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedInstanceTypesList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> supportedInstanceTypesList{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedInstanceTypesList() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedInstanceTypesList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportedInstanceTypesList) {
      res["SupportedInstanceTypesList"] = boost::any(*supportedInstanceTypesList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportedInstanceTypesList") != m.end() && !m["SupportedInstanceTypesList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportedInstanceTypesList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportedInstanceTypesList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportedInstanceTypesList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedInstanceTypesList() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostCapacity : public Darabonba::Model {
public:
  shared_ptr<double> availableMemory{};
  shared_ptr<string> localStorageCategory{};
  shared_ptr<double> totalMemory{};
  shared_ptr<long> totalLocalStorage{};
  shared_ptr<long> totalVcpus{};
  shared_ptr<long> totalVgpus{};
  shared_ptr<long> availableLocalStorage{};
  shared_ptr<long> availableVcpus{};
  shared_ptr<long> availableVgpus{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostCapacity() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostCapacity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableMemory) {
      res["AvailableMemory"] = boost::any(*availableMemory);
    }
    if (localStorageCategory) {
      res["LocalStorageCategory"] = boost::any(*localStorageCategory);
    }
    if (totalMemory) {
      res["TotalMemory"] = boost::any(*totalMemory);
    }
    if (totalLocalStorage) {
      res["TotalLocalStorage"] = boost::any(*totalLocalStorage);
    }
    if (totalVcpus) {
      res["TotalVcpus"] = boost::any(*totalVcpus);
    }
    if (totalVgpus) {
      res["TotalVgpus"] = boost::any(*totalVgpus);
    }
    if (availableLocalStorage) {
      res["AvailableLocalStorage"] = boost::any(*availableLocalStorage);
    }
    if (availableVcpus) {
      res["AvailableVcpus"] = boost::any(*availableVcpus);
    }
    if (availableVgpus) {
      res["AvailableVgpus"] = boost::any(*availableVgpus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableMemory") != m.end() && !m["AvailableMemory"].empty()) {
      availableMemory = make_shared<double>(boost::any_cast<double>(m["AvailableMemory"]));
    }
    if (m.find("LocalStorageCategory") != m.end() && !m["LocalStorageCategory"].empty()) {
      localStorageCategory = make_shared<string>(boost::any_cast<string>(m["LocalStorageCategory"]));
    }
    if (m.find("TotalMemory") != m.end() && !m["TotalMemory"].empty()) {
      totalMemory = make_shared<double>(boost::any_cast<double>(m["TotalMemory"]));
    }
    if (m.find("TotalLocalStorage") != m.end() && !m["TotalLocalStorage"].empty()) {
      totalLocalStorage = make_shared<long>(boost::any_cast<long>(m["TotalLocalStorage"]));
    }
    if (m.find("TotalVcpus") != m.end() && !m["TotalVcpus"].empty()) {
      totalVcpus = make_shared<long>(boost::any_cast<long>(m["TotalVcpus"]));
    }
    if (m.find("TotalVgpus") != m.end() && !m["TotalVgpus"].empty()) {
      totalVgpus = make_shared<long>(boost::any_cast<long>(m["TotalVgpus"]));
    }
    if (m.find("AvailableLocalStorage") != m.end() && !m["AvailableLocalStorage"].empty()) {
      availableLocalStorage = make_shared<long>(boost::any_cast<long>(m["AvailableLocalStorage"]));
    }
    if (m.find("AvailableVcpus") != m.end() && !m["AvailableVcpus"].empty()) {
      availableVcpus = make_shared<long>(boost::any_cast<long>(m["AvailableVcpus"]));
    }
    if (m.find("AvailableVgpus") != m.end() && !m["AvailableVgpus"].empty()) {
      availableVgpus = make_shared<long>(boost::any_cast<long>(m["AvailableVgpus"]));
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostCapacity() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostNetworkAttributes : public Darabonba::Model {
public:
  shared_ptr<long> udpTimeout{};
  shared_ptr<long> slbUdpTimeout{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostNetworkAttributes() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostNetworkAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (udpTimeout) {
      res["UdpTimeout"] = boost::any(*udpTimeout);
    }
    if (slbUdpTimeout) {
      res["SlbUdpTimeout"] = boost::any(*slbUdpTimeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UdpTimeout") != m.end() && !m["UdpTimeout"].empty()) {
      udpTimeout = make_shared<long>(boost::any_cast<long>(m["UdpTimeout"]));
    }
    if (m.find("SlbUdpTimeout") != m.end() && !m["SlbUdpTimeout"].empty()) {
      slbUdpTimeout = make_shared<long>(boost::any_cast<long>(m["SlbUdpTimeout"]));
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostNetworkAttributes() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostHostDetailInfo : public Darabonba::Model {
public:
  shared_ptr<string> serialNumber{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostHostDetailInfo() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostHostDetailInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostHostDetailInfo() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHost : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> status{};
  shared_ptr<long> cores{};
  shared_ptr<string> autoPlacement{};
  shared_ptr<string> GPUSpec{};
  shared_ptr<string> autoReleaseTime{};
  shared_ptr<string> chargeType{};
  shared_ptr<double> cpuOverCommitRatio{};
  shared_ptr<string> actionOnMaintenance{};
  shared_ptr<string> saleCycle{};
  shared_ptr<long> physicalGpus{};
  shared_ptr<string> regionId{};
  shared_ptr<string> dedicatedHostName{};
  shared_ptr<string> description{};
  shared_ptr<string> dedicatedHostClusterId{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> dedicatedHostType{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<long> sockets{};
  shared_ptr<string> machineId{};
  shared_ptr<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstances> instances{};
  shared_ptr<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocks> operationLocks{};
  shared_ptr<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTags> tags{};
  shared_ptr<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedInstanceTypeFamilies> supportedInstanceTypeFamilies{};
  shared_ptr<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedCustomInstanceTypeFamilies> supportedCustomInstanceTypeFamilies{};
  shared_ptr<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedInstanceTypesList> supportedInstanceTypesList{};
  shared_ptr<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostCapacity> capacity{};
  shared_ptr<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostNetworkAttributes> networkAttributes{};
  shared_ptr<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostHostDetailInfo> hostDetailInfo{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHost() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (autoPlacement) {
      res["AutoPlacement"] = boost::any(*autoPlacement);
    }
    if (GPUSpec) {
      res["GPUSpec"] = boost::any(*GPUSpec);
    }
    if (autoReleaseTime) {
      res["AutoReleaseTime"] = boost::any(*autoReleaseTime);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (cpuOverCommitRatio) {
      res["CpuOverCommitRatio"] = boost::any(*cpuOverCommitRatio);
    }
    if (actionOnMaintenance) {
      res["ActionOnMaintenance"] = boost::any(*actionOnMaintenance);
    }
    if (saleCycle) {
      res["SaleCycle"] = boost::any(*saleCycle);
    }
    if (physicalGpus) {
      res["PhysicalGpus"] = boost::any(*physicalGpus);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dedicatedHostName) {
      res["DedicatedHostName"] = boost::any(*dedicatedHostName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (dedicatedHostType) {
      res["DedicatedHostType"] = boost::any(*dedicatedHostType);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (sockets) {
      res["Sockets"] = boost::any(*sockets);
    }
    if (machineId) {
      res["MachineId"] = boost::any(*machineId);
    }
    if (instances) {
      res["Instances"] = instances ? boost::any(instances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (operationLocks) {
      res["OperationLocks"] = operationLocks ? boost::any(operationLocks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (supportedInstanceTypeFamilies) {
      res["SupportedInstanceTypeFamilies"] = supportedInstanceTypeFamilies ? boost::any(supportedInstanceTypeFamilies->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (supportedCustomInstanceTypeFamilies) {
      res["SupportedCustomInstanceTypeFamilies"] = supportedCustomInstanceTypeFamilies ? boost::any(supportedCustomInstanceTypeFamilies->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (supportedInstanceTypesList) {
      res["SupportedInstanceTypesList"] = supportedInstanceTypesList ? boost::any(supportedInstanceTypesList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (capacity) {
      res["Capacity"] = capacity ? boost::any(capacity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkAttributes) {
      res["NetworkAttributes"] = networkAttributes ? boost::any(networkAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hostDetailInfo) {
      res["HostDetailInfo"] = hostDetailInfo ? boost::any(hostDetailInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("AutoPlacement") != m.end() && !m["AutoPlacement"].empty()) {
      autoPlacement = make_shared<string>(boost::any_cast<string>(m["AutoPlacement"]));
    }
    if (m.find("GPUSpec") != m.end() && !m["GPUSpec"].empty()) {
      GPUSpec = make_shared<string>(boost::any_cast<string>(m["GPUSpec"]));
    }
    if (m.find("AutoReleaseTime") != m.end() && !m["AutoReleaseTime"].empty()) {
      autoReleaseTime = make_shared<string>(boost::any_cast<string>(m["AutoReleaseTime"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("CpuOverCommitRatio") != m.end() && !m["CpuOverCommitRatio"].empty()) {
      cpuOverCommitRatio = make_shared<double>(boost::any_cast<double>(m["CpuOverCommitRatio"]));
    }
    if (m.find("ActionOnMaintenance") != m.end() && !m["ActionOnMaintenance"].empty()) {
      actionOnMaintenance = make_shared<string>(boost::any_cast<string>(m["ActionOnMaintenance"]));
    }
    if (m.find("SaleCycle") != m.end() && !m["SaleCycle"].empty()) {
      saleCycle = make_shared<string>(boost::any_cast<string>(m["SaleCycle"]));
    }
    if (m.find("PhysicalGpus") != m.end() && !m["PhysicalGpus"].empty()) {
      physicalGpus = make_shared<long>(boost::any_cast<long>(m["PhysicalGpus"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DedicatedHostName") != m.end() && !m["DedicatedHostName"].empty()) {
      dedicatedHostName = make_shared<string>(boost::any_cast<string>(m["DedicatedHostName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("DedicatedHostType") != m.end() && !m["DedicatedHostType"].empty()) {
      dedicatedHostType = make_shared<string>(boost::any_cast<string>(m["DedicatedHostType"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("Sockets") != m.end() && !m["Sockets"].empty()) {
      sockets = make_shared<long>(boost::any_cast<long>(m["Sockets"]));
    }
    if (m.find("MachineId") != m.end() && !m["MachineId"].empty()) {
      machineId = make_shared<string>(boost::any_cast<string>(m["MachineId"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instances"].type()) {
        DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instances"]));
        instances = make_shared<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstances>(model1);
      }
    }
    if (m.find("OperationLocks") != m.end() && !m["OperationLocks"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperationLocks"].type()) {
        DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperationLocks"]));
        operationLocks = make_shared<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocks>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTags>(model1);
      }
    }
    if (m.find("SupportedInstanceTypeFamilies") != m.end() && !m["SupportedInstanceTypeFamilies"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportedInstanceTypeFamilies"].type()) {
        DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedInstanceTypeFamilies model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportedInstanceTypeFamilies"]));
        supportedInstanceTypeFamilies = make_shared<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedInstanceTypeFamilies>(model1);
      }
    }
    if (m.find("SupportedCustomInstanceTypeFamilies") != m.end() && !m["SupportedCustomInstanceTypeFamilies"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportedCustomInstanceTypeFamilies"].type()) {
        DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedCustomInstanceTypeFamilies model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportedCustomInstanceTypeFamilies"]));
        supportedCustomInstanceTypeFamilies = make_shared<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedCustomInstanceTypeFamilies>(model1);
      }
    }
    if (m.find("SupportedInstanceTypesList") != m.end() && !m["SupportedInstanceTypesList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportedInstanceTypesList"].type()) {
        DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedInstanceTypesList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportedInstanceTypesList"]));
        supportedInstanceTypesList = make_shared<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedInstanceTypesList>(model1);
      }
    }
    if (m.find("Capacity") != m.end() && !m["Capacity"].empty()) {
      if (typeid(map<string, boost::any>) == m["Capacity"].type()) {
        DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostCapacity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Capacity"]));
        capacity = make_shared<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostCapacity>(model1);
      }
    }
    if (m.find("NetworkAttributes") != m.end() && !m["NetworkAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkAttributes"].type()) {
        DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostNetworkAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkAttributes"]));
        networkAttributes = make_shared<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostNetworkAttributes>(model1);
      }
    }
    if (m.find("HostDetailInfo") != m.end() && !m["HostDetailInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostDetailInfo"].type()) {
        DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostHostDetailInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostDetailInfo"]));
        hostDetailInfo = make_shared<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostHostDetailInfo>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHost() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHosts : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHost>> dedicatedHost{};

  DescribeDedicatedHostsResponseBodyDedicatedHosts() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHosts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHost) {
      vector<boost::any> temp1;
      for(auto item1:*dedicatedHost){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DedicatedHost"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHost") != m.end() && !m["DedicatedHost"].empty()) {
      if (typeid(vector<boost::any>) == m["DedicatedHost"].type()) {
        vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHost> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DedicatedHost"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHost model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dedicatedHost = make_shared<vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHost>>(expect1);
      }
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHosts() = default;
};
class DescribeDedicatedHostsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeDedicatedHostsResponseBodyDedicatedHosts> dedicatedHosts{};

  DescribeDedicatedHostsResponseBody() {}

  explicit DescribeDedicatedHostsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (dedicatedHosts) {
      res["DedicatedHosts"] = dedicatedHosts ? boost::any(dedicatedHosts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("DedicatedHosts") != m.end() && !m["DedicatedHosts"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedHosts"].type()) {
        DescribeDedicatedHostsResponseBodyDedicatedHosts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedHosts"]));
        dedicatedHosts = make_shared<DescribeDedicatedHostsResponseBodyDedicatedHosts>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedHostsResponseBody() = default;
};
class DescribeDedicatedHostsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDedicatedHostsResponseBody> body{};

  DescribeDedicatedHostsResponse() {}

  explicit DescribeDedicatedHostsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDedicatedHostsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDedicatedHostsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedHostsResponse() = default;
};
class DescribeDedicatedHostTypesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> dedicatedHostType{};
  shared_ptr<string> supportedInstanceTypeFamily{};

  DescribeDedicatedHostTypesRequest() {}

  explicit DescribeDedicatedHostTypesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dedicatedHostType) {
      res["DedicatedHostType"] = boost::any(*dedicatedHostType);
    }
    if (supportedInstanceTypeFamily) {
      res["SupportedInstanceTypeFamily"] = boost::any(*supportedInstanceTypeFamily);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DedicatedHostType") != m.end() && !m["DedicatedHostType"].empty()) {
      dedicatedHostType = make_shared<string>(boost::any_cast<string>(m["DedicatedHostType"]));
    }
    if (m.find("SupportedInstanceTypeFamily") != m.end() && !m["SupportedInstanceTypeFamily"].empty()) {
      supportedInstanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["SupportedInstanceTypeFamily"]));
    }
  }


  virtual ~DescribeDedicatedHostTypesRequest() = default;
};
class DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportedInstanceTypeFamilies : public Darabonba::Model {
public:
  shared_ptr<vector<string>> supportedInstanceTypeFamily{};

  DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportedInstanceTypeFamilies() {}

  explicit DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportedInstanceTypeFamilies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportedInstanceTypeFamily) {
      res["SupportedInstanceTypeFamily"] = boost::any(*supportedInstanceTypeFamily);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportedInstanceTypeFamily") != m.end() && !m["SupportedInstanceTypeFamily"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportedInstanceTypeFamily"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportedInstanceTypeFamily"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportedInstanceTypeFamily = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportedInstanceTypeFamilies() = default;
};
class DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportedInstanceTypesList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> supportedInstanceTypesList{};

  DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportedInstanceTypesList() {}

  explicit DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportedInstanceTypesList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportedInstanceTypesList) {
      res["SupportedInstanceTypesList"] = boost::any(*supportedInstanceTypesList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportedInstanceTypesList") != m.end() && !m["SupportedInstanceTypesList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportedInstanceTypesList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportedInstanceTypesList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportedInstanceTypesList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportedInstanceTypesList() = default;
};
class DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostType : public Darabonba::Model {
public:
  shared_ptr<long> cores{};
  shared_ptr<string> localStorageCategory{};
  shared_ptr<string> GPUSpec{};
  shared_ptr<long> totalVcpus{};
  shared_ptr<string> cpuOverCommitRatioRange{};
  shared_ptr<long> physicalGpus{};
  shared_ptr<double> memorySize{};
  shared_ptr<bool> supportCpuOverCommitRatio{};
  shared_ptr<long> localStorageCapacity{};
  shared_ptr<string> dedicatedHostType{};
  shared_ptr<long> localStorageAmount{};
  shared_ptr<long> totalVgpus{};
  shared_ptr<long> sockets{};
  shared_ptr<DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportedInstanceTypeFamilies> supportedInstanceTypeFamilies{};
  shared_ptr<DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportedInstanceTypesList> supportedInstanceTypesList{};

  DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostType() {}

  explicit DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (localStorageCategory) {
      res["LocalStorageCategory"] = boost::any(*localStorageCategory);
    }
    if (GPUSpec) {
      res["GPUSpec"] = boost::any(*GPUSpec);
    }
    if (totalVcpus) {
      res["TotalVcpus"] = boost::any(*totalVcpus);
    }
    if (cpuOverCommitRatioRange) {
      res["CpuOverCommitRatioRange"] = boost::any(*cpuOverCommitRatioRange);
    }
    if (physicalGpus) {
      res["PhysicalGpus"] = boost::any(*physicalGpus);
    }
    if (memorySize) {
      res["MemorySize"] = boost::any(*memorySize);
    }
    if (supportCpuOverCommitRatio) {
      res["SupportCpuOverCommitRatio"] = boost::any(*supportCpuOverCommitRatio);
    }
    if (localStorageCapacity) {
      res["LocalStorageCapacity"] = boost::any(*localStorageCapacity);
    }
    if (dedicatedHostType) {
      res["DedicatedHostType"] = boost::any(*dedicatedHostType);
    }
    if (localStorageAmount) {
      res["LocalStorageAmount"] = boost::any(*localStorageAmount);
    }
    if (totalVgpus) {
      res["TotalVgpus"] = boost::any(*totalVgpus);
    }
    if (sockets) {
      res["Sockets"] = boost::any(*sockets);
    }
    if (supportedInstanceTypeFamilies) {
      res["SupportedInstanceTypeFamilies"] = supportedInstanceTypeFamilies ? boost::any(supportedInstanceTypeFamilies->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (supportedInstanceTypesList) {
      res["SupportedInstanceTypesList"] = supportedInstanceTypesList ? boost::any(supportedInstanceTypesList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("LocalStorageCategory") != m.end() && !m["LocalStorageCategory"].empty()) {
      localStorageCategory = make_shared<string>(boost::any_cast<string>(m["LocalStorageCategory"]));
    }
    if (m.find("GPUSpec") != m.end() && !m["GPUSpec"].empty()) {
      GPUSpec = make_shared<string>(boost::any_cast<string>(m["GPUSpec"]));
    }
    if (m.find("TotalVcpus") != m.end() && !m["TotalVcpus"].empty()) {
      totalVcpus = make_shared<long>(boost::any_cast<long>(m["TotalVcpus"]));
    }
    if (m.find("CpuOverCommitRatioRange") != m.end() && !m["CpuOverCommitRatioRange"].empty()) {
      cpuOverCommitRatioRange = make_shared<string>(boost::any_cast<string>(m["CpuOverCommitRatioRange"]));
    }
    if (m.find("PhysicalGpus") != m.end() && !m["PhysicalGpus"].empty()) {
      physicalGpus = make_shared<long>(boost::any_cast<long>(m["PhysicalGpus"]));
    }
    if (m.find("MemorySize") != m.end() && !m["MemorySize"].empty()) {
      memorySize = make_shared<double>(boost::any_cast<double>(m["MemorySize"]));
    }
    if (m.find("SupportCpuOverCommitRatio") != m.end() && !m["SupportCpuOverCommitRatio"].empty()) {
      supportCpuOverCommitRatio = make_shared<bool>(boost::any_cast<bool>(m["SupportCpuOverCommitRatio"]));
    }
    if (m.find("LocalStorageCapacity") != m.end() && !m["LocalStorageCapacity"].empty()) {
      localStorageCapacity = make_shared<long>(boost::any_cast<long>(m["LocalStorageCapacity"]));
    }
    if (m.find("DedicatedHostType") != m.end() && !m["DedicatedHostType"].empty()) {
      dedicatedHostType = make_shared<string>(boost::any_cast<string>(m["DedicatedHostType"]));
    }
    if (m.find("LocalStorageAmount") != m.end() && !m["LocalStorageAmount"].empty()) {
      localStorageAmount = make_shared<long>(boost::any_cast<long>(m["LocalStorageAmount"]));
    }
    if (m.find("TotalVgpus") != m.end() && !m["TotalVgpus"].empty()) {
      totalVgpus = make_shared<long>(boost::any_cast<long>(m["TotalVgpus"]));
    }
    if (m.find("Sockets") != m.end() && !m["Sockets"].empty()) {
      sockets = make_shared<long>(boost::any_cast<long>(m["Sockets"]));
    }
    if (m.find("SupportedInstanceTypeFamilies") != m.end() && !m["SupportedInstanceTypeFamilies"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportedInstanceTypeFamilies"].type()) {
        DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportedInstanceTypeFamilies model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportedInstanceTypeFamilies"]));
        supportedInstanceTypeFamilies = make_shared<DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportedInstanceTypeFamilies>(model1);
      }
    }
    if (m.find("SupportedInstanceTypesList") != m.end() && !m["SupportedInstanceTypesList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportedInstanceTypesList"].type()) {
        DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportedInstanceTypesList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportedInstanceTypesList"]));
        supportedInstanceTypesList = make_shared<DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportedInstanceTypesList>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostType() = default;
};
class DescribeDedicatedHostTypesResponseBodyDedicatedHostTypes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostType>> dedicatedHostType{};

  DescribeDedicatedHostTypesResponseBodyDedicatedHostTypes() {}

  explicit DescribeDedicatedHostTypesResponseBodyDedicatedHostTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostType) {
      vector<boost::any> temp1;
      for(auto item1:*dedicatedHostType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DedicatedHostType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostType") != m.end() && !m["DedicatedHostType"].empty()) {
      if (typeid(vector<boost::any>) == m["DedicatedHostType"].type()) {
        vector<DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DedicatedHostType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dedicatedHostType = make_shared<vector<DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostType>>(expect1);
      }
    }
  }


  virtual ~DescribeDedicatedHostTypesResponseBodyDedicatedHostTypes() = default;
};
class DescribeDedicatedHostTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDedicatedHostTypesResponseBodyDedicatedHostTypes> dedicatedHostTypes{};

  DescribeDedicatedHostTypesResponseBody() {}

  explicit DescribeDedicatedHostTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (dedicatedHostTypes) {
      res["DedicatedHostTypes"] = dedicatedHostTypes ? boost::any(dedicatedHostTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DedicatedHostTypes") != m.end() && !m["DedicatedHostTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedHostTypes"].type()) {
        DescribeDedicatedHostTypesResponseBodyDedicatedHostTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedHostTypes"]));
        dedicatedHostTypes = make_shared<DescribeDedicatedHostTypesResponseBodyDedicatedHostTypes>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedHostTypesResponseBody() = default;
};
class DescribeDedicatedHostTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDedicatedHostTypesResponseBody> body{};

  DescribeDedicatedHostTypesResponse() {}

  explicit DescribeDedicatedHostTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDedicatedHostTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDedicatedHostTypesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedHostTypesResponse() = default;
};
class DescribeDemandsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDemandsRequestTag() {}

  explicit DescribeDemandsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDemandsRequestTag() = default;
};
class DescribeDemandsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDemandsRequestTag>> tag{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> dryRun{};
  shared_ptr<vector<string>> demandStatus{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> demandId{};
  shared_ptr<string> instanceTypeFamily{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> demandType{};

  DescribeDemandsRequest() {}

  explicit DescribeDemandsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (demandStatus) {
      res["DemandStatus"] = boost::any(*demandStatus);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (demandId) {
      res["DemandId"] = boost::any(*demandId);
    }
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (demandType) {
      res["DemandType"] = boost::any(*demandType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDemandsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDemandsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDemandsRequestTag>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("DemandStatus") != m.end() && !m["DemandStatus"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DemandStatus"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DemandStatus"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      demandStatus = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("DemandId") != m.end() && !m["DemandId"].empty()) {
      demandId = make_shared<string>(boost::any_cast<string>(m["DemandId"]));
    }
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      instanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamily"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("DemandType") != m.end() && !m["DemandType"].empty()) {
      demandType = make_shared<string>(boost::any_cast<string>(m["DemandType"]));
    }
  }


  virtual ~DescribeDemandsRequest() = default;
};
class DescribeDemandsResponseBodyDemandsDemandSupplyInfosSupplyInfo : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<string> supplyStatus{};
  shared_ptr<string> supplyStartTime{};
  shared_ptr<string> supplyEndTime{};

  DescribeDemandsResponseBodyDemandsDemandSupplyInfosSupplyInfo() {}

  explicit DescribeDemandsResponseBodyDemandsDemandSupplyInfosSupplyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (supplyStatus) {
      res["SupplyStatus"] = boost::any(*supplyStatus);
    }
    if (supplyStartTime) {
      res["SupplyStartTime"] = boost::any(*supplyStartTime);
    }
    if (supplyEndTime) {
      res["SupplyEndTime"] = boost::any(*supplyEndTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("SupplyStatus") != m.end() && !m["SupplyStatus"].empty()) {
      supplyStatus = make_shared<string>(boost::any_cast<string>(m["SupplyStatus"]));
    }
    if (m.find("SupplyStartTime") != m.end() && !m["SupplyStartTime"].empty()) {
      supplyStartTime = make_shared<string>(boost::any_cast<string>(m["SupplyStartTime"]));
    }
    if (m.find("SupplyEndTime") != m.end() && !m["SupplyEndTime"].empty()) {
      supplyEndTime = make_shared<string>(boost::any_cast<string>(m["SupplyEndTime"]));
    }
  }


  virtual ~DescribeDemandsResponseBodyDemandsDemandSupplyInfosSupplyInfo() = default;
};
class DescribeDemandsResponseBodyDemandsDemandSupplyInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDemandsResponseBodyDemandsDemandSupplyInfosSupplyInfo>> supplyInfo{};

  DescribeDemandsResponseBodyDemandsDemandSupplyInfos() {}

  explicit DescribeDemandsResponseBodyDemandsDemandSupplyInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supplyInfo) {
      vector<boost::any> temp1;
      for(auto item1:*supplyInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SupplyInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupplyInfo") != m.end() && !m["SupplyInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SupplyInfo"].type()) {
        vector<DescribeDemandsResponseBodyDemandsDemandSupplyInfosSupplyInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SupplyInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDemandsResponseBodyDemandsDemandSupplyInfosSupplyInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supplyInfo = make_shared<vector<DescribeDemandsResponseBodyDemandsDemandSupplyInfosSupplyInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeDemandsResponseBodyDemandsDemandSupplyInfos() = default;
};
class DescribeDemandsResponseBodyDemandsDemand : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> demandDescription{};
  shared_ptr<string> demandId{};
  shared_ptr<string> demandTime{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> demandName{};
  shared_ptr<long> period{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<long> availableAmount{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> zoneId{};
  shared_ptr<long> usedAmount{};
  shared_ptr<long> totalAmount{};
  shared_ptr<long> deliveringAmount{};
  shared_ptr<string> instanceTypeFamily{};
  shared_ptr<string> demandStatus{};
  shared_ptr<DescribeDemandsResponseBodyDemandsDemandSupplyInfos> supplyInfos{};

  DescribeDemandsResponseBodyDemandsDemand() {}

  explicit DescribeDemandsResponseBodyDemandsDemand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (demandDescription) {
      res["DemandDescription"] = boost::any(*demandDescription);
    }
    if (demandId) {
      res["DemandId"] = boost::any(*demandId);
    }
    if (demandTime) {
      res["DemandTime"] = boost::any(*demandTime);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (demandName) {
      res["DemandName"] = boost::any(*demandName);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (availableAmount) {
      res["AvailableAmount"] = boost::any(*availableAmount);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (usedAmount) {
      res["UsedAmount"] = boost::any(*usedAmount);
    }
    if (totalAmount) {
      res["TotalAmount"] = boost::any(*totalAmount);
    }
    if (deliveringAmount) {
      res["DeliveringAmount"] = boost::any(*deliveringAmount);
    }
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    if (demandStatus) {
      res["DemandStatus"] = boost::any(*demandStatus);
    }
    if (supplyInfos) {
      res["SupplyInfos"] = supplyInfos ? boost::any(supplyInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("DemandDescription") != m.end() && !m["DemandDescription"].empty()) {
      demandDescription = make_shared<string>(boost::any_cast<string>(m["DemandDescription"]));
    }
    if (m.find("DemandId") != m.end() && !m["DemandId"].empty()) {
      demandId = make_shared<string>(boost::any_cast<string>(m["DemandId"]));
    }
    if (m.find("DemandTime") != m.end() && !m["DemandTime"].empty()) {
      demandTime = make_shared<string>(boost::any_cast<string>(m["DemandTime"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("DemandName") != m.end() && !m["DemandName"].empty()) {
      demandName = make_shared<string>(boost::any_cast<string>(m["DemandName"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("AvailableAmount") != m.end() && !m["AvailableAmount"].empty()) {
      availableAmount = make_shared<long>(boost::any_cast<long>(m["AvailableAmount"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("UsedAmount") != m.end() && !m["UsedAmount"].empty()) {
      usedAmount = make_shared<long>(boost::any_cast<long>(m["UsedAmount"]));
    }
    if (m.find("TotalAmount") != m.end() && !m["TotalAmount"].empty()) {
      totalAmount = make_shared<long>(boost::any_cast<long>(m["TotalAmount"]));
    }
    if (m.find("DeliveringAmount") != m.end() && !m["DeliveringAmount"].empty()) {
      deliveringAmount = make_shared<long>(boost::any_cast<long>(m["DeliveringAmount"]));
    }
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      instanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamily"]));
    }
    if (m.find("DemandStatus") != m.end() && !m["DemandStatus"].empty()) {
      demandStatus = make_shared<string>(boost::any_cast<string>(m["DemandStatus"]));
    }
    if (m.find("SupplyInfos") != m.end() && !m["SupplyInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupplyInfos"].type()) {
        DescribeDemandsResponseBodyDemandsDemandSupplyInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupplyInfos"]));
        supplyInfos = make_shared<DescribeDemandsResponseBodyDemandsDemandSupplyInfos>(model1);
      }
    }
  }


  virtual ~DescribeDemandsResponseBodyDemandsDemand() = default;
};
class DescribeDemandsResponseBodyDemands : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDemandsResponseBodyDemandsDemand>> demand{};

  DescribeDemandsResponseBodyDemands() {}

  explicit DescribeDemandsResponseBodyDemands(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demand) {
      vector<boost::any> temp1;
      for(auto item1:*demand){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Demand"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Demand") != m.end() && !m["Demand"].empty()) {
      if (typeid(vector<boost::any>) == m["Demand"].type()) {
        vector<DescribeDemandsResponseBodyDemandsDemand> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Demand"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDemandsResponseBodyDemandsDemand model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        demand = make_shared<vector<DescribeDemandsResponseBodyDemandsDemand>>(expect1);
      }
    }
  }


  virtual ~DescribeDemandsResponseBodyDemands() = default;
};
class DescribeDemandsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeDemandsResponseBodyDemands> demands{};

  DescribeDemandsResponseBody() {}

  explicit DescribeDemandsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (demands) {
      res["Demands"] = demands ? boost::any(demands->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Demands") != m.end() && !m["Demands"].empty()) {
      if (typeid(map<string, boost::any>) == m["Demands"].type()) {
        DescribeDemandsResponseBodyDemands model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Demands"]));
        demands = make_shared<DescribeDemandsResponseBodyDemands>(model1);
      }
    }
  }


  virtual ~DescribeDemandsResponseBody() = default;
};
class DescribeDemandsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDemandsResponseBody> body{};

  DescribeDemandsResponse() {}

  explicit DescribeDemandsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDemandsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDemandsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDemandsResponse() = default;
};
class DescribeDeploymentSetsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> deploymentSetIds{};
  shared_ptr<string> networkType{};
  shared_ptr<string> strategy{};
  shared_ptr<string> deploymentSetName{};
  shared_ptr<string> granularity{};
  shared_ptr<string> domain{};

  DescribeDeploymentSetsRequest() {}

  explicit DescribeDeploymentSetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (deploymentSetIds) {
      res["DeploymentSetIds"] = boost::any(*deploymentSetIds);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (strategy) {
      res["Strategy"] = boost::any(*strategy);
    }
    if (deploymentSetName) {
      res["DeploymentSetName"] = boost::any(*deploymentSetName);
    }
    if (granularity) {
      res["Granularity"] = boost::any(*granularity);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DeploymentSetIds") != m.end() && !m["DeploymentSetIds"].empty()) {
      deploymentSetIds = make_shared<string>(boost::any_cast<string>(m["DeploymentSetIds"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      strategy = make_shared<string>(boost::any_cast<string>(m["Strategy"]));
    }
    if (m.find("DeploymentSetName") != m.end() && !m["DeploymentSetName"].empty()) {
      deploymentSetName = make_shared<string>(boost::any_cast<string>(m["DeploymentSetName"]));
    }
    if (m.find("Granularity") != m.end() && !m["Granularity"].empty()) {
      granularity = make_shared<string>(boost::any_cast<string>(m["Granularity"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
  }


  virtual ~DescribeDeploymentSetsRequest() = default;
};
class DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSetInstanceIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceId{};

  DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSetInstanceIds() {}

  explicit DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSetInstanceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSetInstanceIds() = default;
};
class DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSet : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> strategy{};
  shared_ptr<string> deploymentSetId{};
  shared_ptr<string> deploymentStrategy{};
  shared_ptr<string> deploymentSetDescription{};
  shared_ptr<string> domain{};
  shared_ptr<long> groupCount{};
  shared_ptr<string> granularity{};
  shared_ptr<string> deploymentSetName{};
  shared_ptr<long> instanceAmount{};
  shared_ptr<DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSetInstanceIds> instanceIds{};

  DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSet() {}

  explicit DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (strategy) {
      res["Strategy"] = boost::any(*strategy);
    }
    if (deploymentSetId) {
      res["DeploymentSetId"] = boost::any(*deploymentSetId);
    }
    if (deploymentStrategy) {
      res["DeploymentStrategy"] = boost::any(*deploymentStrategy);
    }
    if (deploymentSetDescription) {
      res["DeploymentSetDescription"] = boost::any(*deploymentSetDescription);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (groupCount) {
      res["GroupCount"] = boost::any(*groupCount);
    }
    if (granularity) {
      res["Granularity"] = boost::any(*granularity);
    }
    if (deploymentSetName) {
      res["DeploymentSetName"] = boost::any(*deploymentSetName);
    }
    if (instanceAmount) {
      res["InstanceAmount"] = boost::any(*instanceAmount);
    }
    if (instanceIds) {
      res["InstanceIds"] = instanceIds ? boost::any(instanceIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      strategy = make_shared<string>(boost::any_cast<string>(m["Strategy"]));
    }
    if (m.find("DeploymentSetId") != m.end() && !m["DeploymentSetId"].empty()) {
      deploymentSetId = make_shared<string>(boost::any_cast<string>(m["DeploymentSetId"]));
    }
    if (m.find("DeploymentStrategy") != m.end() && !m["DeploymentStrategy"].empty()) {
      deploymentStrategy = make_shared<string>(boost::any_cast<string>(m["DeploymentStrategy"]));
    }
    if (m.find("DeploymentSetDescription") != m.end() && !m["DeploymentSetDescription"].empty()) {
      deploymentSetDescription = make_shared<string>(boost::any_cast<string>(m["DeploymentSetDescription"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("GroupCount") != m.end() && !m["GroupCount"].empty()) {
      groupCount = make_shared<long>(boost::any_cast<long>(m["GroupCount"]));
    }
    if (m.find("Granularity") != m.end() && !m["Granularity"].empty()) {
      granularity = make_shared<string>(boost::any_cast<string>(m["Granularity"]));
    }
    if (m.find("DeploymentSetName") != m.end() && !m["DeploymentSetName"].empty()) {
      deploymentSetName = make_shared<string>(boost::any_cast<string>(m["DeploymentSetName"]));
    }
    if (m.find("InstanceAmount") != m.end() && !m["InstanceAmount"].empty()) {
      instanceAmount = make_shared<long>(boost::any_cast<long>(m["InstanceAmount"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceIds"].type()) {
        DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSetInstanceIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceIds"]));
        instanceIds = make_shared<DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSetInstanceIds>(model1);
      }
    }
  }


  virtual ~DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSet() = default;
};
class DescribeDeploymentSetsResponseBodyDeploymentSets : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSet>> deploymentSet{};

  DescribeDeploymentSetsResponseBodyDeploymentSets() {}

  explicit DescribeDeploymentSetsResponseBodyDeploymentSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deploymentSet) {
      vector<boost::any> temp1;
      for(auto item1:*deploymentSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeploymentSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeploymentSet") != m.end() && !m["DeploymentSet"].empty()) {
      if (typeid(vector<boost::any>) == m["DeploymentSet"].type()) {
        vector<DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeploymentSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deploymentSet = make_shared<vector<DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSet>>(expect1);
      }
    }
  }


  virtual ~DescribeDeploymentSetsResponseBodyDeploymentSets() = default;
};
class DescribeDeploymentSetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeDeploymentSetsResponseBodyDeploymentSets> deploymentSets{};

  DescribeDeploymentSetsResponseBody() {}

  explicit DescribeDeploymentSetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (deploymentSets) {
      res["DeploymentSets"] = deploymentSets ? boost::any(deploymentSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DeploymentSets") != m.end() && !m["DeploymentSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeploymentSets"].type()) {
        DescribeDeploymentSetsResponseBodyDeploymentSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeploymentSets"]));
        deploymentSets = make_shared<DescribeDeploymentSetsResponseBodyDeploymentSets>(model1);
      }
    }
  }


  virtual ~DescribeDeploymentSetsResponseBody() = default;
};
class DescribeDeploymentSetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDeploymentSetsResponseBody> body{};

  DescribeDeploymentSetsResponse() {}

  explicit DescribeDeploymentSetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeploymentSetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeploymentSetsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeploymentSetsResponse() = default;
};
class DescribeDeploymentSetSupportedInstanceTypeFamilyRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ownerAccount{};

  DescribeDeploymentSetSupportedInstanceTypeFamilyRequest() {}

  explicit DescribeDeploymentSetSupportedInstanceTypeFamilyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeDeploymentSetSupportedInstanceTypeFamilyRequest() = default;
};
class DescribeDeploymentSetSupportedInstanceTypeFamilyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> instanceTypeFamilies{};
  shared_ptr<string> requestId{};

  DescribeDeploymentSetSupportedInstanceTypeFamilyResponseBody() {}

  explicit DescribeDeploymentSetSupportedInstanceTypeFamilyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceTypeFamilies) {
      res["InstanceTypeFamilies"] = boost::any(*instanceTypeFamilies);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceTypeFamilies") != m.end() && !m["InstanceTypeFamilies"].empty()) {
      instanceTypeFamilies = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamilies"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDeploymentSetSupportedInstanceTypeFamilyResponseBody() = default;
};
class DescribeDeploymentSetSupportedInstanceTypeFamilyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDeploymentSetSupportedInstanceTypeFamilyResponseBody> body{};

  DescribeDeploymentSetSupportedInstanceTypeFamilyResponse() {}

  explicit DescribeDeploymentSetSupportedInstanceTypeFamilyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeploymentSetSupportedInstanceTypeFamilyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeploymentSetSupportedInstanceTypeFamilyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeploymentSetSupportedInstanceTypeFamilyResponse() = default;
};
class DescribeDiskMonitorDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> diskId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> period{};

  DescribeDiskMonitorDataRequest() {}

  explicit DescribeDiskMonitorDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
  }


  virtual ~DescribeDiskMonitorDataRequest() = default;
};
class DescribeDiskMonitorDataResponseBodyMonitorDataDiskMonitorData : public Darabonba::Model {
public:
  shared_ptr<long> BPSRead{};
  shared_ptr<long> IOPSRead{};
  shared_ptr<long> latencyRead{};
  shared_ptr<long> BPSTotal{};
  shared_ptr<long> IOPSTotal{};
  shared_ptr<string> timeStamp{};
  shared_ptr<long> latencyWrite{};
  shared_ptr<long> IOPSWrite{};
  shared_ptr<string> diskId{};
  shared_ptr<long> BPSWrite{};

  DescribeDiskMonitorDataResponseBodyMonitorDataDiskMonitorData() {}

  explicit DescribeDiskMonitorDataResponseBodyMonitorDataDiskMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (BPSRead) {
      res["BPSRead"] = boost::any(*BPSRead);
    }
    if (IOPSRead) {
      res["IOPSRead"] = boost::any(*IOPSRead);
    }
    if (latencyRead) {
      res["LatencyRead"] = boost::any(*latencyRead);
    }
    if (BPSTotal) {
      res["BPSTotal"] = boost::any(*BPSTotal);
    }
    if (IOPSTotal) {
      res["IOPSTotal"] = boost::any(*IOPSTotal);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (latencyWrite) {
      res["LatencyWrite"] = boost::any(*latencyWrite);
    }
    if (IOPSWrite) {
      res["IOPSWrite"] = boost::any(*IOPSWrite);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (BPSWrite) {
      res["BPSWrite"] = boost::any(*BPSWrite);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BPSRead") != m.end() && !m["BPSRead"].empty()) {
      BPSRead = make_shared<long>(boost::any_cast<long>(m["BPSRead"]));
    }
    if (m.find("IOPSRead") != m.end() && !m["IOPSRead"].empty()) {
      IOPSRead = make_shared<long>(boost::any_cast<long>(m["IOPSRead"]));
    }
    if (m.find("LatencyRead") != m.end() && !m["LatencyRead"].empty()) {
      latencyRead = make_shared<long>(boost::any_cast<long>(m["LatencyRead"]));
    }
    if (m.find("BPSTotal") != m.end() && !m["BPSTotal"].empty()) {
      BPSTotal = make_shared<long>(boost::any_cast<long>(m["BPSTotal"]));
    }
    if (m.find("IOPSTotal") != m.end() && !m["IOPSTotal"].empty()) {
      IOPSTotal = make_shared<long>(boost::any_cast<long>(m["IOPSTotal"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("LatencyWrite") != m.end() && !m["LatencyWrite"].empty()) {
      latencyWrite = make_shared<long>(boost::any_cast<long>(m["LatencyWrite"]));
    }
    if (m.find("IOPSWrite") != m.end() && !m["IOPSWrite"].empty()) {
      IOPSWrite = make_shared<long>(boost::any_cast<long>(m["IOPSWrite"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("BPSWrite") != m.end() && !m["BPSWrite"].empty()) {
      BPSWrite = make_shared<long>(boost::any_cast<long>(m["BPSWrite"]));
    }
  }


  virtual ~DescribeDiskMonitorDataResponseBodyMonitorDataDiskMonitorData() = default;
};
class DescribeDiskMonitorDataResponseBodyMonitorData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDiskMonitorDataResponseBodyMonitorDataDiskMonitorData>> diskMonitorData{};

  DescribeDiskMonitorDataResponseBodyMonitorData() {}

  explicit DescribeDiskMonitorDataResponseBodyMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskMonitorData) {
      vector<boost::any> temp1;
      for(auto item1:*diskMonitorData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiskMonitorData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskMonitorData") != m.end() && !m["DiskMonitorData"].empty()) {
      if (typeid(vector<boost::any>) == m["DiskMonitorData"].type()) {
        vector<DescribeDiskMonitorDataResponseBodyMonitorDataDiskMonitorData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiskMonitorData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDiskMonitorDataResponseBodyMonitorDataDiskMonitorData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diskMonitorData = make_shared<vector<DescribeDiskMonitorDataResponseBodyMonitorDataDiskMonitorData>>(expect1);
      }
    }
  }


  virtual ~DescribeDiskMonitorDataResponseBodyMonitorData() = default;
};
class DescribeDiskMonitorDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDiskMonitorDataResponseBodyMonitorData> monitorData{};

  DescribeDiskMonitorDataResponseBody() {}

  explicit DescribeDiskMonitorDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (monitorData) {
      res["MonitorData"] = monitorData ? boost::any(monitorData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("MonitorData") != m.end() && !m["MonitorData"].empty()) {
      if (typeid(map<string, boost::any>) == m["MonitorData"].type()) {
        DescribeDiskMonitorDataResponseBodyMonitorData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MonitorData"]));
        monitorData = make_shared<DescribeDiskMonitorDataResponseBodyMonitorData>(model1);
      }
    }
  }


  virtual ~DescribeDiskMonitorDataResponseBody() = default;
};
class DescribeDiskMonitorDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDiskMonitorDataResponseBody> body{};

  DescribeDiskMonitorDataResponse() {}

  explicit DescribeDiskMonitorDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDiskMonitorDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDiskMonitorDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDiskMonitorDataResponse() = default;
};
class DescribeDiskReplicaPairsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  DescribeDiskReplicaPairsRequest() {}

  explicit DescribeDiskReplicaPairsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~DescribeDiskReplicaPairsRequest() = default;
};
class DescribeDiskReplicaPairsResponseBodyDiskReplicaPairsDiskReplicaPair : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> sourceDiskId{};
  shared_ptr<string> replicaPairId{};
  shared_ptr<string> description{};
  shared_ptr<string> destinationRegion{};
  shared_ptr<string> pairName{};
  shared_ptr<string> sourceRegion{};
  shared_ptr<string> destinationDiskId{};

  DescribeDiskReplicaPairsResponseBodyDiskReplicaPairsDiskReplicaPair() {}

  explicit DescribeDiskReplicaPairsResponseBodyDiskReplicaPairsDiskReplicaPair(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (sourceDiskId) {
      res["SourceDiskId"] = boost::any(*sourceDiskId);
    }
    if (replicaPairId) {
      res["ReplicaPairId"] = boost::any(*replicaPairId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationRegion) {
      res["DestinationRegion"] = boost::any(*destinationRegion);
    }
    if (pairName) {
      res["PairName"] = boost::any(*pairName);
    }
    if (sourceRegion) {
      res["SourceRegion"] = boost::any(*sourceRegion);
    }
    if (destinationDiskId) {
      res["DestinationDiskId"] = boost::any(*destinationDiskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SourceDiskId") != m.end() && !m["SourceDiskId"].empty()) {
      sourceDiskId = make_shared<string>(boost::any_cast<string>(m["SourceDiskId"]));
    }
    if (m.find("ReplicaPairId") != m.end() && !m["ReplicaPairId"].empty()) {
      replicaPairId = make_shared<string>(boost::any_cast<string>(m["ReplicaPairId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationRegion") != m.end() && !m["DestinationRegion"].empty()) {
      destinationRegion = make_shared<string>(boost::any_cast<string>(m["DestinationRegion"]));
    }
    if (m.find("PairName") != m.end() && !m["PairName"].empty()) {
      pairName = make_shared<string>(boost::any_cast<string>(m["PairName"]));
    }
    if (m.find("SourceRegion") != m.end() && !m["SourceRegion"].empty()) {
      sourceRegion = make_shared<string>(boost::any_cast<string>(m["SourceRegion"]));
    }
    if (m.find("DestinationDiskId") != m.end() && !m["DestinationDiskId"].empty()) {
      destinationDiskId = make_shared<string>(boost::any_cast<string>(m["DestinationDiskId"]));
    }
  }


  virtual ~DescribeDiskReplicaPairsResponseBodyDiskReplicaPairsDiskReplicaPair() = default;
};
class DescribeDiskReplicaPairsResponseBodyDiskReplicaPairs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDiskReplicaPairsResponseBodyDiskReplicaPairsDiskReplicaPair>> diskReplicaPair{};

  DescribeDiskReplicaPairsResponseBodyDiskReplicaPairs() {}

  explicit DescribeDiskReplicaPairsResponseBodyDiskReplicaPairs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskReplicaPair) {
      vector<boost::any> temp1;
      for(auto item1:*diskReplicaPair){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiskReplicaPair"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskReplicaPair") != m.end() && !m["DiskReplicaPair"].empty()) {
      if (typeid(vector<boost::any>) == m["DiskReplicaPair"].type()) {
        vector<DescribeDiskReplicaPairsResponseBodyDiskReplicaPairsDiskReplicaPair> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiskReplicaPair"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDiskReplicaPairsResponseBodyDiskReplicaPairsDiskReplicaPair model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diskReplicaPair = make_shared<vector<DescribeDiskReplicaPairsResponseBodyDiskReplicaPairsDiskReplicaPair>>(expect1);
      }
    }
  }


  virtual ~DescribeDiskReplicaPairsResponseBodyDiskReplicaPairs() = default;
};
class DescribeDiskReplicaPairsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDiskReplicaPairsResponseBodyDiskReplicaPairs> diskReplicaPairs{};

  DescribeDiskReplicaPairsResponseBody() {}

  explicit DescribeDiskReplicaPairsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (diskReplicaPairs) {
      res["DiskReplicaPairs"] = diskReplicaPairs ? boost::any(diskReplicaPairs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DiskReplicaPairs") != m.end() && !m["DiskReplicaPairs"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskReplicaPairs"].type()) {
        DescribeDiskReplicaPairsResponseBodyDiskReplicaPairs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskReplicaPairs"]));
        diskReplicaPairs = make_shared<DescribeDiskReplicaPairsResponseBodyDiskReplicaPairs>(model1);
      }
    }
  }


  virtual ~DescribeDiskReplicaPairsResponseBody() = default;
};
class DescribeDiskReplicaPairsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDiskReplicaPairsResponseBody> body{};

  DescribeDiskReplicaPairsResponse() {}

  explicit DescribeDiskReplicaPairsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDiskReplicaPairsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDiskReplicaPairsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDiskReplicaPairsResponse() = default;
};
class DescribeDisksRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDisksRequestFilter() {}

  explicit DescribeDisksRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDisksRequestFilter() = default;
};
class DescribeDisksRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDisksRequestTag() {}

  explicit DescribeDisksRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDisksRequestTag() = default;
};
class DescribeDisksRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDisksRequestFilter>> filter{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> diskIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> diskType{};
  shared_ptr<string> category{};
  shared_ptr<string> status{};
  shared_ptr<string> snapshotId{};
  shared_ptr<bool> portable{};
  shared_ptr<bool> deleteWithInstance{};
  shared_ptr<bool> deleteAutoSnapshot{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> diskName{};
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<bool> enableAutoSnapshot{};
  shared_ptr<bool> enableAutomatedSnapshotPolicy{};
  shared_ptr<string> diskChargeType{};
  shared_ptr<string> lockReason{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> enableShared{};
  shared_ptr<bool> encrypted{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> KMSKeyId{};
  shared_ptr<string> multiAttach{};
  shared_ptr<vector<DescribeDisksRequestTag>> tag{};
  shared_ptr<vector<string>> additionalAttributes{};

  DescribeDisksRequest() {}

  explicit DescribeDisksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (diskIds) {
      res["DiskIds"] = boost::any(*diskIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (portable) {
      res["Portable"] = boost::any(*portable);
    }
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    if (deleteAutoSnapshot) {
      res["DeleteAutoSnapshot"] = boost::any(*deleteAutoSnapshot);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (autoSnapshotPolicyId) {
      res["AutoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    if (enableAutoSnapshot) {
      res["EnableAutoSnapshot"] = boost::any(*enableAutoSnapshot);
    }
    if (enableAutomatedSnapshotPolicy) {
      res["EnableAutomatedSnapshotPolicy"] = boost::any(*enableAutomatedSnapshotPolicy);
    }
    if (diskChargeType) {
      res["DiskChargeType"] = boost::any(*diskChargeType);
    }
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (enableShared) {
      res["EnableShared"] = boost::any(*enableShared);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (multiAttach) {
      res["MultiAttach"] = boost::any(*multiAttach);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (additionalAttributes) {
      res["AdditionalAttributes"] = boost::any(*additionalAttributes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<DescribeDisksRequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDisksRequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<DescribeDisksRequestFilter>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("DiskIds") != m.end() && !m["DiskIds"].empty()) {
      diskIds = make_shared<string>(boost::any_cast<string>(m["DiskIds"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("Portable") != m.end() && !m["Portable"].empty()) {
      portable = make_shared<bool>(boost::any_cast<bool>(m["Portable"]));
    }
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<bool>(boost::any_cast<bool>(m["DeleteWithInstance"]));
    }
    if (m.find("DeleteAutoSnapshot") != m.end() && !m["DeleteAutoSnapshot"].empty()) {
      deleteAutoSnapshot = make_shared<bool>(boost::any_cast<bool>(m["DeleteAutoSnapshot"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("AutoSnapshotPolicyId") != m.end() && !m["AutoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["AutoSnapshotPolicyId"]));
    }
    if (m.find("EnableAutoSnapshot") != m.end() && !m["EnableAutoSnapshot"].empty()) {
      enableAutoSnapshot = make_shared<bool>(boost::any_cast<bool>(m["EnableAutoSnapshot"]));
    }
    if (m.find("EnableAutomatedSnapshotPolicy") != m.end() && !m["EnableAutomatedSnapshotPolicy"].empty()) {
      enableAutomatedSnapshotPolicy = make_shared<bool>(boost::any_cast<bool>(m["EnableAutomatedSnapshotPolicy"]));
    }
    if (m.find("DiskChargeType") != m.end() && !m["DiskChargeType"].empty()) {
      diskChargeType = make_shared<string>(boost::any_cast<string>(m["DiskChargeType"]));
    }
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("EnableShared") != m.end() && !m["EnableShared"].empty()) {
      enableShared = make_shared<bool>(boost::any_cast<bool>(m["EnableShared"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<bool>(boost::any_cast<bool>(m["Encrypted"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("MultiAttach") != m.end() && !m["MultiAttach"].empty()) {
      multiAttach = make_shared<string>(boost::any_cast<string>(m["MultiAttach"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDisksRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDisksRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDisksRequestTag>>(expect1);
      }
    }
    if (m.find("AdditionalAttributes") != m.end() && !m["AdditionalAttributes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AdditionalAttributes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AdditionalAttributes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      additionalAttributes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDisksRequest() = default;
};
class DescribeDisksResponseBodyDisksDiskOperationLocksOperationLock : public Darabonba::Model {
public:
  shared_ptr<string> lockReason{};

  DescribeDisksResponseBodyDisksDiskOperationLocksOperationLock() {}

  explicit DescribeDisksResponseBodyDisksDiskOperationLocksOperationLock(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
  }


  virtual ~DescribeDisksResponseBodyDisksDiskOperationLocksOperationLock() = default;
};
class DescribeDisksResponseBodyDisksDiskOperationLocks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDisksResponseBodyDisksDiskOperationLocksOperationLock>> operationLock{};

  DescribeDisksResponseBodyDisksDiskOperationLocks() {}

  explicit DescribeDisksResponseBodyDisksDiskOperationLocks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationLock) {
      vector<boost::any> temp1;
      for(auto item1:*operationLock){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperationLock"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationLock") != m.end() && !m["OperationLock"].empty()) {
      if (typeid(vector<boost::any>) == m["OperationLock"].type()) {
        vector<DescribeDisksResponseBodyDisksDiskOperationLocksOperationLock> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperationLock"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDisksResponseBodyDisksDiskOperationLocksOperationLock model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operationLock = make_shared<vector<DescribeDisksResponseBodyDisksDiskOperationLocksOperationLock>>(expect1);
      }
    }
  }


  virtual ~DescribeDisksResponseBodyDisksDiskOperationLocks() = default;
};
class DescribeDisksResponseBodyDisksDiskMountInstancesMountInstance : public Darabonba::Model {
public:
  shared_ptr<string> attachedTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> device{};

  DescribeDisksResponseBodyDisksDiskMountInstancesMountInstance() {}

  explicit DescribeDisksResponseBodyDisksDiskMountInstancesMountInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachedTime) {
      res["AttachedTime"] = boost::any(*attachedTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachedTime") != m.end() && !m["AttachedTime"].empty()) {
      attachedTime = make_shared<string>(boost::any_cast<string>(m["AttachedTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
  }


  virtual ~DescribeDisksResponseBodyDisksDiskMountInstancesMountInstance() = default;
};
class DescribeDisksResponseBodyDisksDiskMountInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDisksResponseBodyDisksDiskMountInstancesMountInstance>> mountInstance{};

  DescribeDisksResponseBodyDisksDiskMountInstances() {}

  explicit DescribeDisksResponseBodyDisksDiskMountInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountInstance) {
      vector<boost::any> temp1;
      for(auto item1:*mountInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MountInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MountInstance") != m.end() && !m["MountInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["MountInstance"].type()) {
        vector<DescribeDisksResponseBodyDisksDiskMountInstancesMountInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MountInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDisksResponseBodyDisksDiskMountInstancesMountInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mountInstance = make_shared<vector<DescribeDisksResponseBodyDisksDiskMountInstancesMountInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeDisksResponseBodyDisksDiskMountInstances() = default;
};
class DescribeDisksResponseBodyDisksDiskTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  DescribeDisksResponseBodyDisksDiskTagsTag() {}

  explicit DescribeDisksResponseBodyDisksDiskTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~DescribeDisksResponseBodyDisksDiskTagsTag() = default;
};
class DescribeDisksResponseBodyDisksDiskTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDisksResponseBodyDisksDiskTagsTag>> tag{};

  DescribeDisksResponseBodyDisksDiskTags() {}

  explicit DescribeDisksResponseBodyDisksDiskTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDisksResponseBodyDisksDiskTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDisksResponseBodyDisksDiskTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDisksResponseBodyDisksDiskTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeDisksResponseBodyDisksDiskTags() = default;
};
class DescribeDisksResponseBodyDisksDiskAttachmentsAttachment : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> device{};
  shared_ptr<string> attachedTime{};

  DescribeDisksResponseBodyDisksDiskAttachmentsAttachment() {}

  explicit DescribeDisksResponseBodyDisksDiskAttachmentsAttachment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (attachedTime) {
      res["AttachedTime"] = boost::any(*attachedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("AttachedTime") != m.end() && !m["AttachedTime"].empty()) {
      attachedTime = make_shared<string>(boost::any_cast<string>(m["AttachedTime"]));
    }
  }


  virtual ~DescribeDisksResponseBodyDisksDiskAttachmentsAttachment() = default;
};
class DescribeDisksResponseBodyDisksDiskAttachments : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDisksResponseBodyDisksDiskAttachmentsAttachment>> attachment{};

  DescribeDisksResponseBodyDisksDiskAttachments() {}

  explicit DescribeDisksResponseBodyDisksDiskAttachments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachment) {
      vector<boost::any> temp1;
      for(auto item1:*attachment){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Attachment"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attachment") != m.end() && !m["Attachment"].empty()) {
      if (typeid(vector<boost::any>) == m["Attachment"].type()) {
        vector<DescribeDisksResponseBodyDisksDiskAttachmentsAttachment> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Attachment"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDisksResponseBodyDisksDiskAttachmentsAttachment model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attachment = make_shared<vector<DescribeDisksResponseBodyDisksDiskAttachmentsAttachment>>(expect1);
      }
    }
  }


  virtual ~DescribeDisksResponseBodyDisksDiskAttachments() = default;
};
class DescribeDisksResponseBodyDisksDisk : public Darabonba::Model {
public:
  shared_ptr<string> serialNumber{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<string> bdfId{};
  shared_ptr<bool> enableAutoSnapshot{};
  shared_ptr<string> storageSetId{};
  shared_ptr<long> storageSetPartitionNumber{};
  shared_ptr<string> diskId{};
  shared_ptr<bool> deleteAutoSnapshot{};
  shared_ptr<string> dedicatedBlockStorageClusterId{};
  shared_ptr<bool> encrypted{};
  shared_ptr<long> IOPSRead{};
  shared_ptr<long> mountInstanceNum{};
  shared_ptr<string> description{};
  shared_ptr<string> device{};
  shared_ptr<string> diskName{};
  shared_ptr<bool> portable{};
  shared_ptr<string> imageId{};
  shared_ptr<string> KMSKeyId{};
  shared_ptr<bool> deleteWithInstance{};
  shared_ptr<string> detachedTime{};
  shared_ptr<string> sourceSnapshotId{};
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<bool> enableAutomatedSnapshotPolicy{};
  shared_ptr<long> IOPSWrite{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> IOPS{};
  shared_ptr<string> regionId{};
  shared_ptr<string> expiredTime{};
  shared_ptr<long> size{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> diskChargeType{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> attachedTime{};
  shared_ptr<string> category{};
  shared_ptr<string> productCode{};
  shared_ptr<string> multiAttach{};
  shared_ptr<DescribeDisksResponseBodyDisksDiskOperationLocks> operationLocks{};
  shared_ptr<DescribeDisksResponseBodyDisksDiskMountInstances> mountInstances{};
  shared_ptr<DescribeDisksResponseBodyDisksDiskTags> tags{};
  shared_ptr<DescribeDisksResponseBodyDisksDiskAttachments> attachments{};

  DescribeDisksResponseBodyDisksDisk() {}

  explicit DescribeDisksResponseBodyDisksDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (bdfId) {
      res["BdfId"] = boost::any(*bdfId);
    }
    if (enableAutoSnapshot) {
      res["EnableAutoSnapshot"] = boost::any(*enableAutoSnapshot);
    }
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    if (storageSetPartitionNumber) {
      res["StorageSetPartitionNumber"] = boost::any(*storageSetPartitionNumber);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (deleteAutoSnapshot) {
      res["DeleteAutoSnapshot"] = boost::any(*deleteAutoSnapshot);
    }
    if (dedicatedBlockStorageClusterId) {
      res["DedicatedBlockStorageClusterId"] = boost::any(*dedicatedBlockStorageClusterId);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (IOPSRead) {
      res["IOPSRead"] = boost::any(*IOPSRead);
    }
    if (mountInstanceNum) {
      res["MountInstanceNum"] = boost::any(*mountInstanceNum);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (portable) {
      res["Portable"] = boost::any(*portable);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    if (detachedTime) {
      res["DetachedTime"] = boost::any(*detachedTime);
    }
    if (sourceSnapshotId) {
      res["SourceSnapshotId"] = boost::any(*sourceSnapshotId);
    }
    if (autoSnapshotPolicyId) {
      res["AutoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    if (enableAutomatedSnapshotPolicy) {
      res["EnableAutomatedSnapshotPolicy"] = boost::any(*enableAutomatedSnapshotPolicy);
    }
    if (IOPSWrite) {
      res["IOPSWrite"] = boost::any(*IOPSWrite);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (IOPS) {
      res["IOPS"] = boost::any(*IOPS);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (diskChargeType) {
      res["DiskChargeType"] = boost::any(*diskChargeType);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (attachedTime) {
      res["AttachedTime"] = boost::any(*attachedTime);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (multiAttach) {
      res["MultiAttach"] = boost::any(*multiAttach);
    }
    if (operationLocks) {
      res["OperationLocks"] = operationLocks ? boost::any(operationLocks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mountInstances) {
      res["MountInstances"] = mountInstances ? boost::any(mountInstances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (attachments) {
      res["Attachments"] = attachments ? boost::any(attachments->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("BdfId") != m.end() && !m["BdfId"].empty()) {
      bdfId = make_shared<string>(boost::any_cast<string>(m["BdfId"]));
    }
    if (m.find("EnableAutoSnapshot") != m.end() && !m["EnableAutoSnapshot"].empty()) {
      enableAutoSnapshot = make_shared<bool>(boost::any_cast<bool>(m["EnableAutoSnapshot"]));
    }
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
    if (m.find("StorageSetPartitionNumber") != m.end() && !m["StorageSetPartitionNumber"].empty()) {
      storageSetPartitionNumber = make_shared<long>(boost::any_cast<long>(m["StorageSetPartitionNumber"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("DeleteAutoSnapshot") != m.end() && !m["DeleteAutoSnapshot"].empty()) {
      deleteAutoSnapshot = make_shared<bool>(boost::any_cast<bool>(m["DeleteAutoSnapshot"]));
    }
    if (m.find("DedicatedBlockStorageClusterId") != m.end() && !m["DedicatedBlockStorageClusterId"].empty()) {
      dedicatedBlockStorageClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedBlockStorageClusterId"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<bool>(boost::any_cast<bool>(m["Encrypted"]));
    }
    if (m.find("IOPSRead") != m.end() && !m["IOPSRead"].empty()) {
      IOPSRead = make_shared<long>(boost::any_cast<long>(m["IOPSRead"]));
    }
    if (m.find("MountInstanceNum") != m.end() && !m["MountInstanceNum"].empty()) {
      mountInstanceNum = make_shared<long>(boost::any_cast<long>(m["MountInstanceNum"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Portable") != m.end() && !m["Portable"].empty()) {
      portable = make_shared<bool>(boost::any_cast<bool>(m["Portable"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<bool>(boost::any_cast<bool>(m["DeleteWithInstance"]));
    }
    if (m.find("DetachedTime") != m.end() && !m["DetachedTime"].empty()) {
      detachedTime = make_shared<string>(boost::any_cast<string>(m["DetachedTime"]));
    }
    if (m.find("SourceSnapshotId") != m.end() && !m["SourceSnapshotId"].empty()) {
      sourceSnapshotId = make_shared<string>(boost::any_cast<string>(m["SourceSnapshotId"]));
    }
    if (m.find("AutoSnapshotPolicyId") != m.end() && !m["AutoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["AutoSnapshotPolicyId"]));
    }
    if (m.find("EnableAutomatedSnapshotPolicy") != m.end() && !m["EnableAutomatedSnapshotPolicy"].empty()) {
      enableAutomatedSnapshotPolicy = make_shared<bool>(boost::any_cast<bool>(m["EnableAutomatedSnapshotPolicy"]));
    }
    if (m.find("IOPSWrite") != m.end() && !m["IOPSWrite"].empty()) {
      IOPSWrite = make_shared<long>(boost::any_cast<long>(m["IOPSWrite"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IOPS") != m.end() && !m["IOPS"].empty()) {
      IOPS = make_shared<long>(boost::any_cast<long>(m["IOPS"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("DiskChargeType") != m.end() && !m["DiskChargeType"].empty()) {
      diskChargeType = make_shared<string>(boost::any_cast<string>(m["DiskChargeType"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("AttachedTime") != m.end() && !m["AttachedTime"].empty()) {
      attachedTime = make_shared<string>(boost::any_cast<string>(m["AttachedTime"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("MultiAttach") != m.end() && !m["MultiAttach"].empty()) {
      multiAttach = make_shared<string>(boost::any_cast<string>(m["MultiAttach"]));
    }
    if (m.find("OperationLocks") != m.end() && !m["OperationLocks"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperationLocks"].type()) {
        DescribeDisksResponseBodyDisksDiskOperationLocks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperationLocks"]));
        operationLocks = make_shared<DescribeDisksResponseBodyDisksDiskOperationLocks>(model1);
      }
    }
    if (m.find("MountInstances") != m.end() && !m["MountInstances"].empty()) {
      if (typeid(map<string, boost::any>) == m["MountInstances"].type()) {
        DescribeDisksResponseBodyDisksDiskMountInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MountInstances"]));
        mountInstances = make_shared<DescribeDisksResponseBodyDisksDiskMountInstances>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeDisksResponseBodyDisksDiskTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeDisksResponseBodyDisksDiskTags>(model1);
      }
    }
    if (m.find("Attachments") != m.end() && !m["Attachments"].empty()) {
      if (typeid(map<string, boost::any>) == m["Attachments"].type()) {
        DescribeDisksResponseBodyDisksDiskAttachments model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Attachments"]));
        attachments = make_shared<DescribeDisksResponseBodyDisksDiskAttachments>(model1);
      }
    }
  }


  virtual ~DescribeDisksResponseBodyDisksDisk() = default;
};
class DescribeDisksResponseBodyDisks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDisksResponseBodyDisksDisk>> disk{};

  DescribeDisksResponseBodyDisks() {}

  explicit DescribeDisksResponseBodyDisks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disk) {
      vector<boost::any> temp1;
      for(auto item1:*disk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Disk"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Disk") != m.end() && !m["Disk"].empty()) {
      if (typeid(vector<boost::any>) == m["Disk"].type()) {
        vector<DescribeDisksResponseBodyDisksDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Disk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDisksResponseBodyDisksDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        disk = make_shared<vector<DescribeDisksResponseBodyDisksDisk>>(expect1);
      }
    }
  }


  virtual ~DescribeDisksResponseBodyDisks() = default;
};
class DescribeDisksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeDisksResponseBodyDisks> disks{};

  DescribeDisksResponseBody() {}

  explicit DescribeDisksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (disks) {
      res["Disks"] = disks ? boost::any(disks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Disks") != m.end() && !m["Disks"].empty()) {
      if (typeid(map<string, boost::any>) == m["Disks"].type()) {
        DescribeDisksResponseBodyDisks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Disks"]));
        disks = make_shared<DescribeDisksResponseBodyDisks>(model1);
      }
    }
  }


  virtual ~DescribeDisksResponseBody() = default;
};
class DescribeDisksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDisksResponseBody> body{};

  DescribeDisksResponse() {}

  explicit DescribeDisksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDisksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDisksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDisksResponse() = default;
};
class DescribeDisksFullStatusRequestEventTime : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> end{};

  DescribeDisksFullStatusRequestEventTime() {}

  explicit DescribeDisksFullStatusRequestEventTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<string>(boost::any_cast<string>(m["End"]));
    }
  }


  virtual ~DescribeDisksFullStatusRequestEventTime() = default;
};
class DescribeDisksFullStatusRequest : public Darabonba::Model {
public:
  shared_ptr<DescribeDisksFullStatusRequestEventTime> eventTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> diskId{};
  shared_ptr<vector<string>> eventId{};
  shared_ptr<string> status{};
  shared_ptr<string> healthStatus{};
  shared_ptr<string> eventType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeDisksFullStatusRequest() {}

  explicit DescribeDisksFullStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventTime) {
      res["EventTime"] = eventTime ? boost::any(eventTime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventTime") != m.end() && !m["EventTime"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventTime"].type()) {
        DescribeDisksFullStatusRequestEventTime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventTime"]));
        eventTime = make_shared<DescribeDisksFullStatusRequestEventTime>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DiskId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DiskId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      diskId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EventId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EventId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eventId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeDisksFullStatusRequest() = default;
};
class DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSetDiskEventTypeEventType : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> code{};

  DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSetDiskEventTypeEventType() {}

  explicit DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSetDiskEventTypeEventType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSetDiskEventTypeEventType() = default;
};
class DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSetDiskEventType : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> eventEndTime{};
  shared_ptr<string> eventTime{};
  shared_ptr<string> impactLevel{};
  shared_ptr<DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSetDiskEventTypeEventType> eventType{};

  DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSetDiskEventType() {}

  explicit DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSetDiskEventType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (eventEndTime) {
      res["EventEndTime"] = boost::any(*eventEndTime);
    }
    if (eventTime) {
      res["EventTime"] = boost::any(*eventTime);
    }
    if (impactLevel) {
      res["ImpactLevel"] = boost::any(*impactLevel);
    }
    if (eventType) {
      res["EventType"] = eventType ? boost::any(eventType->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("EventEndTime") != m.end() && !m["EventEndTime"].empty()) {
      eventEndTime = make_shared<string>(boost::any_cast<string>(m["EventEndTime"]));
    }
    if (m.find("EventTime") != m.end() && !m["EventTime"].empty()) {
      eventTime = make_shared<string>(boost::any_cast<string>(m["EventTime"]));
    }
    if (m.find("ImpactLevel") != m.end() && !m["ImpactLevel"].empty()) {
      impactLevel = make_shared<string>(boost::any_cast<string>(m["ImpactLevel"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventType"].type()) {
        DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSetDiskEventTypeEventType model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventType"]));
        eventType = make_shared<DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSetDiskEventTypeEventType>(model1);
      }
    }
  }


  virtual ~DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSetDiskEventType() = default;
};
class DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSetDiskEventType>> diskEventType{};

  DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSet() {}

  explicit DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskEventType) {
      vector<boost::any> temp1;
      for(auto item1:*diskEventType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiskEventType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskEventType") != m.end() && !m["DiskEventType"].empty()) {
      if (typeid(vector<boost::any>) == m["DiskEventType"].type()) {
        vector<DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSetDiskEventType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiskEventType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSetDiskEventType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diskEventType = make_shared<vector<DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSetDiskEventType>>(expect1);
      }
    }
  }


  virtual ~DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSet() = default;
};
class DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeStatus : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> code{};

  DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeStatus() {}

  explicit DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeStatus() = default;
};
class DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeHealthStatus : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> code{};

  DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeHealthStatus() {}

  explicit DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeHealthStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeHealthStatus() = default;
};
class DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusType : public Darabonba::Model {
public:
  shared_ptr<string> diskId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> device{};
  shared_ptr<DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSet> diskEventSet{};
  shared_ptr<DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeStatus> status{};
  shared_ptr<DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeHealthStatus> healthStatus{};

  DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusType() {}

  explicit DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (diskEventSet) {
      res["DiskEventSet"] = diskEventSet ? boost::any(diskEventSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = status ? boost::any(status->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (healthStatus) {
      res["HealthStatus"] = healthStatus ? boost::any(healthStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("DiskEventSet") != m.end() && !m["DiskEventSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskEventSet"].type()) {
        DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskEventSet"]));
        diskEventSet = make_shared<DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSet>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      if (typeid(map<string, boost::any>) == m["Status"].type()) {
        DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Status"]));
        status = make_shared<DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeStatus>(model1);
      }
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["HealthStatus"].type()) {
        DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeHealthStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HealthStatus"]));
        healthStatus = make_shared<DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeHealthStatus>(model1);
      }
    }
  }


  virtual ~DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusType() = default;
};
class DescribeDisksFullStatusResponseBodyDiskFullStatusSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusType>> diskFullStatusType{};

  DescribeDisksFullStatusResponseBodyDiskFullStatusSet() {}

  explicit DescribeDisksFullStatusResponseBodyDiskFullStatusSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskFullStatusType) {
      vector<boost::any> temp1;
      for(auto item1:*diskFullStatusType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiskFullStatusType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskFullStatusType") != m.end() && !m["DiskFullStatusType"].empty()) {
      if (typeid(vector<boost::any>) == m["DiskFullStatusType"].type()) {
        vector<DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiskFullStatusType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diskFullStatusType = make_shared<vector<DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusType>>(expect1);
      }
    }
  }


  virtual ~DescribeDisksFullStatusResponseBodyDiskFullStatusSet() = default;
};
class DescribeDisksFullStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeDisksFullStatusResponseBodyDiskFullStatusSet> diskFullStatusSet{};

  DescribeDisksFullStatusResponseBody() {}

  explicit DescribeDisksFullStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (diskFullStatusSet) {
      res["DiskFullStatusSet"] = diskFullStatusSet ? boost::any(diskFullStatusSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("DiskFullStatusSet") != m.end() && !m["DiskFullStatusSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskFullStatusSet"].type()) {
        DescribeDisksFullStatusResponseBodyDiskFullStatusSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskFullStatusSet"]));
        diskFullStatusSet = make_shared<DescribeDisksFullStatusResponseBodyDiskFullStatusSet>(model1);
      }
    }
  }


  virtual ~DescribeDisksFullStatusResponseBody() = default;
};
class DescribeDisksFullStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDisksFullStatusResponseBody> body{};

  DescribeDisksFullStatusResponse() {}

  explicit DescribeDisksFullStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDisksFullStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDisksFullStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDisksFullStatusResponse() = default;
};
class DescribeEipAddressesRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeEipAddressesRequestFilter() {}

  explicit DescribeEipAddressesRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeEipAddressesRequestFilter() = default;
};
class DescribeEipAddressesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEipAddressesRequestFilter>> filter{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};
  shared_ptr<string> eipAddress{};
  shared_ptr<string> allocationId{};
  shared_ptr<string> ISP{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> lockReason{};
  shared_ptr<string> associatedInstanceType{};
  shared_ptr<string> associatedInstanceId{};
  shared_ptr<string> chargeType{};

  DescribeEipAddressesRequest() {}

  explicit DescribeEipAddressesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (eipAddress) {
      res["EipAddress"] = boost::any(*eipAddress);
    }
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (ISP) {
      res["ISP"] = boost::any(*ISP);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    if (associatedInstanceType) {
      res["AssociatedInstanceType"] = boost::any(*associatedInstanceType);
    }
    if (associatedInstanceId) {
      res["AssociatedInstanceId"] = boost::any(*associatedInstanceId);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<DescribeEipAddressesRequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEipAddressesRequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<DescribeEipAddressesRequestFilter>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("EipAddress") != m.end() && !m["EipAddress"].empty()) {
      eipAddress = make_shared<string>(boost::any_cast<string>(m["EipAddress"]));
    }
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("ISP") != m.end() && !m["ISP"].empty()) {
      ISP = make_shared<string>(boost::any_cast<string>(m["ISP"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
    if (m.find("AssociatedInstanceType") != m.end() && !m["AssociatedInstanceType"].empty()) {
      associatedInstanceType = make_shared<string>(boost::any_cast<string>(m["AssociatedInstanceType"]));
    }
    if (m.find("AssociatedInstanceId") != m.end() && !m["AssociatedInstanceId"].empty()) {
      associatedInstanceId = make_shared<string>(boost::any_cast<string>(m["AssociatedInstanceId"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
  }


  virtual ~DescribeEipAddressesRequest() = default;
};
class DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason : public Darabonba::Model {
public:
  shared_ptr<string> lockReason{};

  DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason() {}

  explicit DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
  }


  virtual ~DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason() = default;
};
class DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason>> lockReason{};

  DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks() {}

  explicit DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockReason) {
      vector<boost::any> temp1;
      for(auto item1:*lockReason){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LockReason"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      if (typeid(vector<boost::any>) == m["LockReason"].type()) {
        vector<DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LockReason"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lockReason = make_shared<vector<DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason>>(expect1);
      }
    }
  }


  virtual ~DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks() = default;
};
class DescribeEipAddressesResponseBodyEipAddressesEipAddress : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> allocationTime{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> bandwidth{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> allocationId{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> eipBandwidth{};
  shared_ptr<DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks> operationLocks{};

  DescribeEipAddressesResponseBodyEipAddressesEipAddress() {}

  explicit DescribeEipAddressesResponseBodyEipAddressesEipAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (allocationTime) {
      res["AllocationTime"] = boost::any(*allocationTime);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (eipBandwidth) {
      res["EipBandwidth"] = boost::any(*eipBandwidth);
    }
    if (operationLocks) {
      res["OperationLocks"] = operationLocks ? boost::any(operationLocks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("AllocationTime") != m.end() && !m["AllocationTime"].empty()) {
      allocationTime = make_shared<string>(boost::any_cast<string>(m["AllocationTime"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<string>(boost::any_cast<string>(m["Bandwidth"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("EipBandwidth") != m.end() && !m["EipBandwidth"].empty()) {
      eipBandwidth = make_shared<string>(boost::any_cast<string>(m["EipBandwidth"]));
    }
    if (m.find("OperationLocks") != m.end() && !m["OperationLocks"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperationLocks"].type()) {
        DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperationLocks"]));
        operationLocks = make_shared<DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks>(model1);
      }
    }
  }


  virtual ~DescribeEipAddressesResponseBodyEipAddressesEipAddress() = default;
};
class DescribeEipAddressesResponseBodyEipAddresses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEipAddressesResponseBodyEipAddressesEipAddress>> eipAddress{};

  DescribeEipAddressesResponseBodyEipAddresses() {}

  explicit DescribeEipAddressesResponseBodyEipAddresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipAddress) {
      vector<boost::any> temp1;
      for(auto item1:*eipAddress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EipAddress"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipAddress") != m.end() && !m["EipAddress"].empty()) {
      if (typeid(vector<boost::any>) == m["EipAddress"].type()) {
        vector<DescribeEipAddressesResponseBodyEipAddressesEipAddress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EipAddress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEipAddressesResponseBodyEipAddressesEipAddress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eipAddress = make_shared<vector<DescribeEipAddressesResponseBodyEipAddressesEipAddress>>(expect1);
      }
    }
  }


  virtual ~DescribeEipAddressesResponseBodyEipAddresses() = default;
};
class DescribeEipAddressesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeEipAddressesResponseBodyEipAddresses> eipAddresses{};

  DescribeEipAddressesResponseBody() {}

  explicit DescribeEipAddressesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (eipAddresses) {
      res["EipAddresses"] = eipAddresses ? boost::any(eipAddresses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("EipAddresses") != m.end() && !m["EipAddresses"].empty()) {
      if (typeid(map<string, boost::any>) == m["EipAddresses"].type()) {
        DescribeEipAddressesResponseBodyEipAddresses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EipAddresses"]));
        eipAddresses = make_shared<DescribeEipAddressesResponseBodyEipAddresses>(model1);
      }
    }
  }


  virtual ~DescribeEipAddressesResponseBody() = default;
};
class DescribeEipAddressesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeEipAddressesResponseBody> body{};

  DescribeEipAddressesResponse() {}

  explicit DescribeEipAddressesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEipAddressesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEipAddressesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEipAddressesResponse() = default;
};
class DescribeEipMonitorDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> allocationId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> period{};
  shared_ptr<string> ownerAccount{};

  DescribeEipMonitorDataRequest() {}

  explicit DescribeEipMonitorDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeEipMonitorDataRequest() = default;
};
class DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData : public Darabonba::Model {
public:
  shared_ptr<long> eipTX{};
  shared_ptr<long> eipPackets{};
  shared_ptr<long> eipBandwidth{};
  shared_ptr<string> timeStamp{};
  shared_ptr<long> eipFlow{};
  shared_ptr<long> eipRX{};

  DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData() {}

  explicit DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipTX) {
      res["EipTX"] = boost::any(*eipTX);
    }
    if (eipPackets) {
      res["EipPackets"] = boost::any(*eipPackets);
    }
    if (eipBandwidth) {
      res["EipBandwidth"] = boost::any(*eipBandwidth);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (eipFlow) {
      res["EipFlow"] = boost::any(*eipFlow);
    }
    if (eipRX) {
      res["EipRX"] = boost::any(*eipRX);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipTX") != m.end() && !m["EipTX"].empty()) {
      eipTX = make_shared<long>(boost::any_cast<long>(m["EipTX"]));
    }
    if (m.find("EipPackets") != m.end() && !m["EipPackets"].empty()) {
      eipPackets = make_shared<long>(boost::any_cast<long>(m["EipPackets"]));
    }
    if (m.find("EipBandwidth") != m.end() && !m["EipBandwidth"].empty()) {
      eipBandwidth = make_shared<long>(boost::any_cast<long>(m["EipBandwidth"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("EipFlow") != m.end() && !m["EipFlow"].empty()) {
      eipFlow = make_shared<long>(boost::any_cast<long>(m["EipFlow"]));
    }
    if (m.find("EipRX") != m.end() && !m["EipRX"].empty()) {
      eipRX = make_shared<long>(boost::any_cast<long>(m["EipRX"]));
    }
  }


  virtual ~DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData() = default;
};
class DescribeEipMonitorDataResponseBodyEipMonitorDatas : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData>> eipMonitorData{};

  DescribeEipMonitorDataResponseBodyEipMonitorDatas() {}

  explicit DescribeEipMonitorDataResponseBodyEipMonitorDatas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipMonitorData) {
      vector<boost::any> temp1;
      for(auto item1:*eipMonitorData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EipMonitorData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipMonitorData") != m.end() && !m["EipMonitorData"].empty()) {
      if (typeid(vector<boost::any>) == m["EipMonitorData"].type()) {
        vector<DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EipMonitorData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eipMonitorData = make_shared<vector<DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData>>(expect1);
      }
    }
  }


  virtual ~DescribeEipMonitorDataResponseBodyEipMonitorDatas() = default;
};
class DescribeEipMonitorDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeEipMonitorDataResponseBodyEipMonitorDatas> eipMonitorDatas{};

  DescribeEipMonitorDataResponseBody() {}

  explicit DescribeEipMonitorDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (eipMonitorDatas) {
      res["EipMonitorDatas"] = eipMonitorDatas ? boost::any(eipMonitorDatas->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("EipMonitorDatas") != m.end() && !m["EipMonitorDatas"].empty()) {
      if (typeid(map<string, boost::any>) == m["EipMonitorDatas"].type()) {
        DescribeEipMonitorDataResponseBodyEipMonitorDatas model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EipMonitorDatas"]));
        eipMonitorDatas = make_shared<DescribeEipMonitorDataResponseBodyEipMonitorDatas>(model1);
      }
    }
  }


  virtual ~DescribeEipMonitorDataResponseBody() = default;
};
class DescribeEipMonitorDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeEipMonitorDataResponseBody> body{};

  DescribeEipMonitorDataResponse() {}

  explicit DescribeEipMonitorDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEipMonitorDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEipMonitorDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEipMonitorDataResponse() = default;
};
class DescribeElasticityAssuranceInstancesRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  DescribeElasticityAssuranceInstancesRequestPrivatePoolOptions() {}

  explicit DescribeElasticityAssuranceInstancesRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DescribeElasticityAssuranceInstancesRequestPrivatePoolOptions() = default;
};
class DescribeElasticityAssuranceInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<DescribeElasticityAssuranceInstancesRequestPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  DescribeElasticityAssuranceInstancesRequest() {}

  explicit DescribeElasticityAssuranceInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privatePoolOptions) {
      res["PrivatePoolOptions"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolOptions"].type()) {
        DescribeElasticityAssuranceInstancesRequestPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolOptions"]));
        privatePoolOptions = make_shared<DescribeElasticityAssuranceInstancesRequestPrivatePoolOptions>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~DescribeElasticityAssuranceInstancesRequest() = default;
};
class DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItemInstanceIdSet : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItemInstanceIdSet() {}

  explicit DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItemInstanceIdSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItemInstanceIdSet() = default;
};
class DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItem : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItemInstanceIdSet>> instanceIdSet{};

  DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItem() {}

  explicit DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIdSet) {
      vector<boost::any> temp1;
      for(auto item1:*instanceIdSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceIdSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIdSet") != m.end() && !m["InstanceIdSet"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceIdSet"].type()) {
        vector<DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItemInstanceIdSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceIdSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItemInstanceIdSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceIdSet = make_shared<vector<DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItemInstanceIdSet>>(expect1);
      }
    }
  }


  virtual ~DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItem() = default;
};
class DescribeElasticityAssuranceInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> maxResults{};
  shared_ptr<DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItem> elasticityAssuranceItem{};

  DescribeElasticityAssuranceInstancesResponseBody() {}

  explicit DescribeElasticityAssuranceInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (elasticityAssuranceItem) {
      res["ElasticityAssuranceItem"] = elasticityAssuranceItem ? boost::any(elasticityAssuranceItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("ElasticityAssuranceItem") != m.end() && !m["ElasticityAssuranceItem"].empty()) {
      if (typeid(map<string, boost::any>) == m["ElasticityAssuranceItem"].type()) {
        DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ElasticityAssuranceItem"]));
        elasticityAssuranceItem = make_shared<DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItem>(model1);
      }
    }
  }


  virtual ~DescribeElasticityAssuranceInstancesResponseBody() = default;
};
class DescribeElasticityAssuranceInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeElasticityAssuranceInstancesResponseBody> body{};

  DescribeElasticityAssuranceInstancesResponse() {}

  explicit DescribeElasticityAssuranceInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeElasticityAssuranceInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeElasticityAssuranceInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeElasticityAssuranceInstancesResponse() = default;
};
class DescribeElasticityAssurancesRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> ids{};

  DescribeElasticityAssurancesRequestPrivatePoolOptions() {}

  explicit DescribeElasticityAssurancesRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      ids = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
  }


  virtual ~DescribeElasticityAssurancesRequestPrivatePoolOptions() = default;
};
class DescribeElasticityAssurancesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeElasticityAssurancesRequestTag() {}

  explicit DescribeElasticityAssurancesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeElasticityAssurancesRequestTag() = default;
};
class DescribeElasticityAssurancesRequest : public Darabonba::Model {
public:
  shared_ptr<DescribeElasticityAssurancesRequestPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<vector<DescribeElasticityAssurancesRequestTag>> tag{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> platform{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> status{};

  DescribeElasticityAssurancesRequest() {}

  explicit DescribeElasticityAssurancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privatePoolOptions) {
      res["PrivatePoolOptions"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolOptions"].type()) {
        DescribeElasticityAssurancesRequestPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolOptions"]));
        privatePoolOptions = make_shared<DescribeElasticityAssurancesRequestPrivatePoolOptions>(model1);
      }
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeElasticityAssurancesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeElasticityAssurancesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeElasticityAssurancesRequestTag>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeElasticityAssurancesRequest() = default;
};
class DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemAllocatedResourcesAllocatedResource : public Darabonba::Model {
public:
  shared_ptr<long> usedAmount{};
  shared_ptr<long> totalAmount{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> instanceType{};

  DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemAllocatedResourcesAllocatedResource() {}

  explicit DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemAllocatedResourcesAllocatedResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usedAmount) {
      res["UsedAmount"] = boost::any(*usedAmount);
    }
    if (totalAmount) {
      res["TotalAmount"] = boost::any(*totalAmount);
    }
    if (zoneId) {
      res["zoneId"] = boost::any(*zoneId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsedAmount") != m.end() && !m["UsedAmount"].empty()) {
      usedAmount = make_shared<long>(boost::any_cast<long>(m["UsedAmount"]));
    }
    if (m.find("TotalAmount") != m.end() && !m["TotalAmount"].empty()) {
      totalAmount = make_shared<long>(boost::any_cast<long>(m["TotalAmount"]));
    }
    if (m.find("zoneId") != m.end() && !m["zoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["zoneId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
  }


  virtual ~DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemAllocatedResourcesAllocatedResource() = default;
};
class DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemAllocatedResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemAllocatedResourcesAllocatedResource>> allocatedResource{};

  DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemAllocatedResources() {}

  explicit DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemAllocatedResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocatedResource) {
      vector<boost::any> temp1;
      for(auto item1:*allocatedResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AllocatedResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocatedResource") != m.end() && !m["AllocatedResource"].empty()) {
      if (typeid(vector<boost::any>) == m["AllocatedResource"].type()) {
        vector<DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemAllocatedResourcesAllocatedResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AllocatedResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemAllocatedResourcesAllocatedResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        allocatedResource = make_shared<vector<DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemAllocatedResourcesAllocatedResource>>(expect1);
      }
    }
  }


  virtual ~DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemAllocatedResources() = default;
};
class DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemTagsTag() {}

  explicit DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemTagsTag() = default;
};
class DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemTagsTag>> tag{};

  DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemTags() {}

  explicit DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemTags() = default;
};
class DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItem : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> privatePoolOptionsMatchCriteria{};
  shared_ptr<string> privatePoolOptionsId{};
  shared_ptr<long> usedAssuranceTimes{};
  shared_ptr<string> latestStartTime{};
  shared_ptr<string> privatePoolOptionsName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> description{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> totalAssuranceTimes{};
  shared_ptr<DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemAllocatedResources> allocatedResources{};
  shared_ptr<DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemTags> tags{};

  DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItem() {}

  explicit DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (privatePoolOptionsMatchCriteria) {
      res["PrivatePoolOptionsMatchCriteria"] = boost::any(*privatePoolOptionsMatchCriteria);
    }
    if (privatePoolOptionsId) {
      res["PrivatePoolOptionsId"] = boost::any(*privatePoolOptionsId);
    }
    if (usedAssuranceTimes) {
      res["UsedAssuranceTimes"] = boost::any(*usedAssuranceTimes);
    }
    if (latestStartTime) {
      res["LatestStartTime"] = boost::any(*latestStartTime);
    }
    if (privatePoolOptionsName) {
      res["PrivatePoolOptionsName"] = boost::any(*privatePoolOptionsName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (totalAssuranceTimes) {
      res["TotalAssuranceTimes"] = boost::any(*totalAssuranceTimes);
    }
    if (allocatedResources) {
      res["AllocatedResources"] = allocatedResources ? boost::any(allocatedResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PrivatePoolOptionsMatchCriteria") != m.end() && !m["PrivatePoolOptionsMatchCriteria"].empty()) {
      privatePoolOptionsMatchCriteria = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptionsMatchCriteria"]));
    }
    if (m.find("PrivatePoolOptionsId") != m.end() && !m["PrivatePoolOptionsId"].empty()) {
      privatePoolOptionsId = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptionsId"]));
    }
    if (m.find("UsedAssuranceTimes") != m.end() && !m["UsedAssuranceTimes"].empty()) {
      usedAssuranceTimes = make_shared<long>(boost::any_cast<long>(m["UsedAssuranceTimes"]));
    }
    if (m.find("LatestStartTime") != m.end() && !m["LatestStartTime"].empty()) {
      latestStartTime = make_shared<string>(boost::any_cast<string>(m["LatestStartTime"]));
    }
    if (m.find("PrivatePoolOptionsName") != m.end() && !m["PrivatePoolOptionsName"].empty()) {
      privatePoolOptionsName = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptionsName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("TotalAssuranceTimes") != m.end() && !m["TotalAssuranceTimes"].empty()) {
      totalAssuranceTimes = make_shared<string>(boost::any_cast<string>(m["TotalAssuranceTimes"]));
    }
    if (m.find("AllocatedResources") != m.end() && !m["AllocatedResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["AllocatedResources"].type()) {
        DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemAllocatedResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AllocatedResources"]));
        allocatedResources = make_shared<DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemAllocatedResources>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemTags>(model1);
      }
    }
  }


  virtual ~DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItem() = default;
};
class DescribeElasticityAssurancesResponseBodyElasticityAssuranceSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItem>> elasticityAssuranceItem{};

  DescribeElasticityAssurancesResponseBodyElasticityAssuranceSet() {}

  explicit DescribeElasticityAssurancesResponseBodyElasticityAssuranceSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (elasticityAssuranceItem) {
      vector<boost::any> temp1;
      for(auto item1:*elasticityAssuranceItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ElasticityAssuranceItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ElasticityAssuranceItem") != m.end() && !m["ElasticityAssuranceItem"].empty()) {
      if (typeid(vector<boost::any>) == m["ElasticityAssuranceItem"].type()) {
        vector<DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ElasticityAssuranceItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        elasticityAssuranceItem = make_shared<vector<DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItem>>(expect1);
      }
    }
  }


  virtual ~DescribeElasticityAssurancesResponseBodyElasticityAssuranceSet() = default;
};
class DescribeElasticityAssurancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> maxResults{};
  shared_ptr<DescribeElasticityAssurancesResponseBodyElasticityAssuranceSet> elasticityAssuranceSet{};

  DescribeElasticityAssurancesResponseBody() {}

  explicit DescribeElasticityAssurancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (elasticityAssuranceSet) {
      res["ElasticityAssuranceSet"] = elasticityAssuranceSet ? boost::any(elasticityAssuranceSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("ElasticityAssuranceSet") != m.end() && !m["ElasticityAssuranceSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["ElasticityAssuranceSet"].type()) {
        DescribeElasticityAssurancesResponseBodyElasticityAssuranceSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ElasticityAssuranceSet"]));
        elasticityAssuranceSet = make_shared<DescribeElasticityAssurancesResponseBodyElasticityAssuranceSet>(model1);
      }
    }
  }


  virtual ~DescribeElasticityAssurancesResponseBody() = default;
};
class DescribeElasticityAssurancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeElasticityAssurancesResponseBody> body{};

  DescribeElasticityAssurancesResponse() {}

  explicit DescribeElasticityAssurancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeElasticityAssurancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeElasticityAssurancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeElasticityAssurancesResponse() = default;
};
class DescribeEniMonitorDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> eniId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> period{};

  DescribeEniMonitorDataRequest() {}

  explicit DescribeEniMonitorDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (eniId) {
      res["EniId"] = boost::any(*eniId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("EniId") != m.end() && !m["EniId"].empty()) {
      eniId = make_shared<string>(boost::any_cast<string>(m["EniId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
  }


  virtual ~DescribeEniMonitorDataRequest() = default;
};
class DescribeEniMonitorDataResponseBodyMonitorDataEniMonitorData : public Darabonba::Model {
public:
  shared_ptr<string> packetRx{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> dropPacketRx{};
  shared_ptr<string> eniId{};
  shared_ptr<string> dropPacketTx{};
  shared_ptr<string> packetTx{};
  shared_ptr<string> intranetTx{};
  shared_ptr<string> intranetRx{};

  DescribeEniMonitorDataResponseBodyMonitorDataEniMonitorData() {}

  explicit DescribeEniMonitorDataResponseBodyMonitorDataEniMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (packetRx) {
      res["PacketRx"] = boost::any(*packetRx);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (dropPacketRx) {
      res["DropPacketRx"] = boost::any(*dropPacketRx);
    }
    if (eniId) {
      res["EniId"] = boost::any(*eniId);
    }
    if (dropPacketTx) {
      res["DropPacketTx"] = boost::any(*dropPacketTx);
    }
    if (packetTx) {
      res["PacketTx"] = boost::any(*packetTx);
    }
    if (intranetTx) {
      res["IntranetTx"] = boost::any(*intranetTx);
    }
    if (intranetRx) {
      res["IntranetRx"] = boost::any(*intranetRx);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PacketRx") != m.end() && !m["PacketRx"].empty()) {
      packetRx = make_shared<string>(boost::any_cast<string>(m["PacketRx"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("DropPacketRx") != m.end() && !m["DropPacketRx"].empty()) {
      dropPacketRx = make_shared<string>(boost::any_cast<string>(m["DropPacketRx"]));
    }
    if (m.find("EniId") != m.end() && !m["EniId"].empty()) {
      eniId = make_shared<string>(boost::any_cast<string>(m["EniId"]));
    }
    if (m.find("DropPacketTx") != m.end() && !m["DropPacketTx"].empty()) {
      dropPacketTx = make_shared<string>(boost::any_cast<string>(m["DropPacketTx"]));
    }
    if (m.find("PacketTx") != m.end() && !m["PacketTx"].empty()) {
      packetTx = make_shared<string>(boost::any_cast<string>(m["PacketTx"]));
    }
    if (m.find("IntranetTx") != m.end() && !m["IntranetTx"].empty()) {
      intranetTx = make_shared<string>(boost::any_cast<string>(m["IntranetTx"]));
    }
    if (m.find("IntranetRx") != m.end() && !m["IntranetRx"].empty()) {
      intranetRx = make_shared<string>(boost::any_cast<string>(m["IntranetRx"]));
    }
  }


  virtual ~DescribeEniMonitorDataResponseBodyMonitorDataEniMonitorData() = default;
};
class DescribeEniMonitorDataResponseBodyMonitorData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEniMonitorDataResponseBodyMonitorDataEniMonitorData>> eniMonitorData{};

  DescribeEniMonitorDataResponseBodyMonitorData() {}

  explicit DescribeEniMonitorDataResponseBodyMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eniMonitorData) {
      vector<boost::any> temp1;
      for(auto item1:*eniMonitorData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EniMonitorData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EniMonitorData") != m.end() && !m["EniMonitorData"].empty()) {
      if (typeid(vector<boost::any>) == m["EniMonitorData"].type()) {
        vector<DescribeEniMonitorDataResponseBodyMonitorDataEniMonitorData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EniMonitorData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEniMonitorDataResponseBodyMonitorDataEniMonitorData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eniMonitorData = make_shared<vector<DescribeEniMonitorDataResponseBodyMonitorDataEniMonitorData>>(expect1);
      }
    }
  }


  virtual ~DescribeEniMonitorDataResponseBodyMonitorData() = default;
};
class DescribeEniMonitorDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeEniMonitorDataResponseBodyMonitorData> monitorData{};

  DescribeEniMonitorDataResponseBody() {}

  explicit DescribeEniMonitorDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (monitorData) {
      res["MonitorData"] = monitorData ? boost::any(monitorData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("MonitorData") != m.end() && !m["MonitorData"].empty()) {
      if (typeid(map<string, boost::any>) == m["MonitorData"].type()) {
        DescribeEniMonitorDataResponseBodyMonitorData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MonitorData"]));
        monitorData = make_shared<DescribeEniMonitorDataResponseBodyMonitorData>(model1);
      }
    }
  }


  virtual ~DescribeEniMonitorDataResponseBody() = default;
};
class DescribeEniMonitorDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeEniMonitorDataResponseBody> body{};

  DescribeEniMonitorDataResponse() {}

  explicit DescribeEniMonitorDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEniMonitorDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEniMonitorDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEniMonitorDataResponse() = default;
};
class DescribeForwardTableEntriesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> forwardTableId{};
  shared_ptr<string> forwardEntryId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeForwardTableEntriesRequest() {}

  explicit DescribeForwardTableEntriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (forwardTableId) {
      res["ForwardTableId"] = boost::any(*forwardTableId);
    }
    if (forwardEntryId) {
      res["ForwardEntryId"] = boost::any(*forwardEntryId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ForwardTableId") != m.end() && !m["ForwardTableId"].empty()) {
      forwardTableId = make_shared<string>(boost::any_cast<string>(m["ForwardTableId"]));
    }
    if (m.find("ForwardEntryId") != m.end() && !m["ForwardEntryId"].empty()) {
      forwardEntryId = make_shared<string>(boost::any_cast<string>(m["ForwardEntryId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeForwardTableEntriesRequest() = default;
};
class DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> forwardEntryId{};
  shared_ptr<string> internalIp{};
  shared_ptr<string> internalPort{};
  shared_ptr<string> forwardTableId{};
  shared_ptr<string> externalPort{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> externalIp{};

  DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry() {}

  explicit DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (forwardEntryId) {
      res["ForwardEntryId"] = boost::any(*forwardEntryId);
    }
    if (internalIp) {
      res["InternalIp"] = boost::any(*internalIp);
    }
    if (internalPort) {
      res["InternalPort"] = boost::any(*internalPort);
    }
    if (forwardTableId) {
      res["ForwardTableId"] = boost::any(*forwardTableId);
    }
    if (externalPort) {
      res["ExternalPort"] = boost::any(*externalPort);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (externalIp) {
      res["ExternalIp"] = boost::any(*externalIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ForwardEntryId") != m.end() && !m["ForwardEntryId"].empty()) {
      forwardEntryId = make_shared<string>(boost::any_cast<string>(m["ForwardEntryId"]));
    }
    if (m.find("InternalIp") != m.end() && !m["InternalIp"].empty()) {
      internalIp = make_shared<string>(boost::any_cast<string>(m["InternalIp"]));
    }
    if (m.find("InternalPort") != m.end() && !m["InternalPort"].empty()) {
      internalPort = make_shared<string>(boost::any_cast<string>(m["InternalPort"]));
    }
    if (m.find("ForwardTableId") != m.end() && !m["ForwardTableId"].empty()) {
      forwardTableId = make_shared<string>(boost::any_cast<string>(m["ForwardTableId"]));
    }
    if (m.find("ExternalPort") != m.end() && !m["ExternalPort"].empty()) {
      externalPort = make_shared<string>(boost::any_cast<string>(m["ExternalPort"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("ExternalIp") != m.end() && !m["ExternalIp"].empty()) {
      externalIp = make_shared<string>(boost::any_cast<string>(m["ExternalIp"]));
    }
  }


  virtual ~DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry() = default;
};
class DescribeForwardTableEntriesResponseBodyForwardTableEntries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry>> forwardTableEntry{};

  DescribeForwardTableEntriesResponseBodyForwardTableEntries() {}

  explicit DescribeForwardTableEntriesResponseBodyForwardTableEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardTableEntry) {
      vector<boost::any> temp1;
      for(auto item1:*forwardTableEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ForwardTableEntry"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardTableEntry") != m.end() && !m["ForwardTableEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["ForwardTableEntry"].type()) {
        vector<DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ForwardTableEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        forwardTableEntry = make_shared<vector<DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry>>(expect1);
      }
    }
  }


  virtual ~DescribeForwardTableEntriesResponseBodyForwardTableEntries() = default;
};
class DescribeForwardTableEntriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeForwardTableEntriesResponseBodyForwardTableEntries> forwardTableEntries{};

  DescribeForwardTableEntriesResponseBody() {}

  explicit DescribeForwardTableEntriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (forwardTableEntries) {
      res["ForwardTableEntries"] = forwardTableEntries ? boost::any(forwardTableEntries->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("ForwardTableEntries") != m.end() && !m["ForwardTableEntries"].empty()) {
      if (typeid(map<string, boost::any>) == m["ForwardTableEntries"].type()) {
        DescribeForwardTableEntriesResponseBodyForwardTableEntries model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ForwardTableEntries"]));
        forwardTableEntries = make_shared<DescribeForwardTableEntriesResponseBodyForwardTableEntries>(model1);
      }
    }
  }


  virtual ~DescribeForwardTableEntriesResponseBody() = default;
};
class DescribeForwardTableEntriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeForwardTableEntriesResponseBody> body{};

  DescribeForwardTableEntriesResponse() {}

  explicit DescribeForwardTableEntriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeForwardTableEntriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeForwardTableEntriesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeForwardTableEntriesResponse() = default;
};
class DescribeHaVipsRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<string>> value{};

  DescribeHaVipsRequestFilter() {}

  explicit DescribeHaVipsRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Value"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      value = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeHaVipsRequestFilter() = default;
};
class DescribeHaVipsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeHaVipsRequestFilter>> filter{};

  DescribeHaVipsRequest() {}

  explicit DescribeHaVipsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<DescribeHaVipsRequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHaVipsRequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<DescribeHaVipsRequestFilter>>(expect1);
      }
    }
  }


  virtual ~DescribeHaVipsRequest() = default;
};
class DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses : public Darabonba::Model {
public:
  shared_ptr<vector<string>> associatedEipAddresse{};

  DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses() {}

  explicit DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associatedEipAddresse) {
      res["associatedEipAddresse"] = boost::any(*associatedEipAddresse);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("associatedEipAddresse") != m.end() && !m["associatedEipAddresse"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["associatedEipAddresse"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["associatedEipAddresse"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      associatedEipAddresse = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses() = default;
};
class DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances : public Darabonba::Model {
public:
  shared_ptr<vector<string>> associatedInstance{};

  DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances() {}

  explicit DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associatedInstance) {
      res["associatedInstance"] = boost::any(*associatedInstance);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("associatedInstance") != m.end() && !m["associatedInstance"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["associatedInstance"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["associatedInstance"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      associatedInstance = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances() = default;
};
class DescribeHaVipsResponseBodyHaVipsHaVip : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> description{};
  shared_ptr<string> haVipId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> masterInstanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses> associatedEipAddresses{};
  shared_ptr<DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances> associatedInstances{};

  DescribeHaVipsResponseBodyHaVipsHaVip() {}

  explicit DescribeHaVipsResponseBodyHaVipsHaVip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (haVipId) {
      res["HaVipId"] = boost::any(*haVipId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (masterInstanceId) {
      res["MasterInstanceId"] = boost::any(*masterInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (associatedEipAddresses) {
      res["AssociatedEipAddresses"] = associatedEipAddresses ? boost::any(associatedEipAddresses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (associatedInstances) {
      res["AssociatedInstances"] = associatedInstances ? boost::any(associatedInstances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HaVipId") != m.end() && !m["HaVipId"].empty()) {
      haVipId = make_shared<string>(boost::any_cast<string>(m["HaVipId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("MasterInstanceId") != m.end() && !m["MasterInstanceId"].empty()) {
      masterInstanceId = make_shared<string>(boost::any_cast<string>(m["MasterInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AssociatedEipAddresses") != m.end() && !m["AssociatedEipAddresses"].empty()) {
      if (typeid(map<string, boost::any>) == m["AssociatedEipAddresses"].type()) {
        DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AssociatedEipAddresses"]));
        associatedEipAddresses = make_shared<DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses>(model1);
      }
    }
    if (m.find("AssociatedInstances") != m.end() && !m["AssociatedInstances"].empty()) {
      if (typeid(map<string, boost::any>) == m["AssociatedInstances"].type()) {
        DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AssociatedInstances"]));
        associatedInstances = make_shared<DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances>(model1);
      }
    }
  }


  virtual ~DescribeHaVipsResponseBodyHaVipsHaVip() = default;
};
class DescribeHaVipsResponseBodyHaVips : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHaVipsResponseBodyHaVipsHaVip>> haVip{};

  DescribeHaVipsResponseBodyHaVips() {}

  explicit DescribeHaVipsResponseBodyHaVips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (haVip) {
      vector<boost::any> temp1;
      for(auto item1:*haVip){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HaVip"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HaVip") != m.end() && !m["HaVip"].empty()) {
      if (typeid(vector<boost::any>) == m["HaVip"].type()) {
        vector<DescribeHaVipsResponseBodyHaVipsHaVip> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HaVip"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHaVipsResponseBodyHaVipsHaVip model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        haVip = make_shared<vector<DescribeHaVipsResponseBodyHaVipsHaVip>>(expect1);
      }
    }
  }


  virtual ~DescribeHaVipsResponseBodyHaVips() = default;
};
class DescribeHaVipsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeHaVipsResponseBodyHaVips> haVips{};

  DescribeHaVipsResponseBody() {}

  explicit DescribeHaVipsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (haVips) {
      res["HaVips"] = haVips ? boost::any(haVips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("HaVips") != m.end() && !m["HaVips"].empty()) {
      if (typeid(map<string, boost::any>) == m["HaVips"].type()) {
        DescribeHaVipsResponseBodyHaVips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HaVips"]));
        haVips = make_shared<DescribeHaVipsResponseBodyHaVips>(model1);
      }
    }
  }


  virtual ~DescribeHaVipsResponseBody() = default;
};
class DescribeHaVipsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeHaVipsResponseBody> body{};

  DescribeHaVipsResponse() {}

  explicit DescribeHaVipsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHaVipsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHaVipsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHaVipsResponse() = default;
};
class DescribeHpcClustersRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> hpcClusterIds{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeHpcClustersRequest() {}

  explicit DescribeHpcClustersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (hpcClusterIds) {
      res["HpcClusterIds"] = boost::any(*hpcClusterIds);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("HpcClusterIds") != m.end() && !m["HpcClusterIds"].empty()) {
      hpcClusterIds = make_shared<string>(boost::any_cast<string>(m["HpcClusterIds"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeHpcClustersRequest() = default;
};
class DescribeHpcClustersResponseBodyHpcClustersHpcCluster : public Darabonba::Model {
public:
  shared_ptr<string> hpcClusterId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};

  DescribeHpcClustersResponseBodyHpcClustersHpcCluster() {}

  explicit DescribeHpcClustersResponseBodyHpcClustersHpcCluster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hpcClusterId) {
      res["HpcClusterId"] = boost::any(*hpcClusterId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HpcClusterId") != m.end() && !m["HpcClusterId"].empty()) {
      hpcClusterId = make_shared<string>(boost::any_cast<string>(m["HpcClusterId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~DescribeHpcClustersResponseBodyHpcClustersHpcCluster() = default;
};
class DescribeHpcClustersResponseBodyHpcClusters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHpcClustersResponseBodyHpcClustersHpcCluster>> hpcCluster{};

  DescribeHpcClustersResponseBodyHpcClusters() {}

  explicit DescribeHpcClustersResponseBodyHpcClusters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hpcCluster) {
      vector<boost::any> temp1;
      for(auto item1:*hpcCluster){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HpcCluster"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HpcCluster") != m.end() && !m["HpcCluster"].empty()) {
      if (typeid(vector<boost::any>) == m["HpcCluster"].type()) {
        vector<DescribeHpcClustersResponseBodyHpcClustersHpcCluster> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HpcCluster"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHpcClustersResponseBodyHpcClustersHpcCluster model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hpcCluster = make_shared<vector<DescribeHpcClustersResponseBodyHpcClustersHpcCluster>>(expect1);
      }
    }
  }


  virtual ~DescribeHpcClustersResponseBodyHpcClusters() = default;
};
class DescribeHpcClustersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeHpcClustersResponseBodyHpcClusters> hpcClusters{};

  DescribeHpcClustersResponseBody() {}

  explicit DescribeHpcClustersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (hpcClusters) {
      res["HpcClusters"] = hpcClusters ? boost::any(hpcClusters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("HpcClusters") != m.end() && !m["HpcClusters"].empty()) {
      if (typeid(map<string, boost::any>) == m["HpcClusters"].type()) {
        DescribeHpcClustersResponseBodyHpcClusters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HpcClusters"]));
        hpcClusters = make_shared<DescribeHpcClustersResponseBodyHpcClusters>(model1);
      }
    }
  }


  virtual ~DescribeHpcClustersResponseBody() = default;
};
class DescribeHpcClustersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeHpcClustersResponseBody> body{};

  DescribeHpcClustersResponse() {}

  explicit DescribeHpcClustersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHpcClustersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHpcClustersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHpcClustersResponse() = default;
};
class DescribeImageComponentsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeImageComponentsRequestTag() {}

  explicit DescribeImageComponentsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeImageComponentsRequestTag() = default;
};
class DescribeImageComponentsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageComponentsRequestTag>> tag{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<string>> imageComponentId{};
  shared_ptr<string> name{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> maxResults{};

  DescribeImageComponentsRequest() {}

  explicit DescribeImageComponentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (imageComponentId) {
      res["ImageComponentId"] = boost::any(*imageComponentId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeImageComponentsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageComponentsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeImageComponentsRequestTag>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ImageComponentId") != m.end() && !m["ImageComponentId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ImageComponentId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ImageComponentId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      imageComponentId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
  }


  virtual ~DescribeImageComponentsRequest() = default;
};
class DescribeImageComponentsResponseBodyImageComponentImageComponentSetTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  DescribeImageComponentsResponseBodyImageComponentImageComponentSetTagsTag() {}

  explicit DescribeImageComponentsResponseBodyImageComponentImageComponentSetTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~DescribeImageComponentsResponseBodyImageComponentImageComponentSetTagsTag() = default;
};
class DescribeImageComponentsResponseBodyImageComponentImageComponentSetTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageComponentsResponseBodyImageComponentImageComponentSetTagsTag>> tag{};

  DescribeImageComponentsResponseBodyImageComponentImageComponentSetTags() {}

  explicit DescribeImageComponentsResponseBodyImageComponentImageComponentSetTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeImageComponentsResponseBodyImageComponentImageComponentSetTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageComponentsResponseBodyImageComponentImageComponentSetTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeImageComponentsResponseBodyImageComponentImageComponentSetTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeImageComponentsResponseBodyImageComponentImageComponentSetTags() = default;
};
class DescribeImageComponentsResponseBodyImageComponentImageComponentSet : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> systemType{};
  shared_ptr<string> imageComponentId{};
  shared_ptr<string> componentType{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> name{};
  shared_ptr<string> content{};
  shared_ptr<DescribeImageComponentsResponseBodyImageComponentImageComponentSetTags> tags{};

  DescribeImageComponentsResponseBodyImageComponentImageComponentSet() {}

  explicit DescribeImageComponentsResponseBodyImageComponentImageComponentSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (systemType) {
      res["SystemType"] = boost::any(*systemType);
    }
    if (imageComponentId) {
      res["ImageComponentId"] = boost::any(*imageComponentId);
    }
    if (componentType) {
      res["ComponentType"] = boost::any(*componentType);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SystemType") != m.end() && !m["SystemType"].empty()) {
      systemType = make_shared<string>(boost::any_cast<string>(m["SystemType"]));
    }
    if (m.find("ImageComponentId") != m.end() && !m["ImageComponentId"].empty()) {
      imageComponentId = make_shared<string>(boost::any_cast<string>(m["ImageComponentId"]));
    }
    if (m.find("ComponentType") != m.end() && !m["ComponentType"].empty()) {
      componentType = make_shared<string>(boost::any_cast<string>(m["ComponentType"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeImageComponentsResponseBodyImageComponentImageComponentSetTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeImageComponentsResponseBodyImageComponentImageComponentSetTags>(model1);
      }
    }
  }


  virtual ~DescribeImageComponentsResponseBodyImageComponentImageComponentSet() = default;
};
class DescribeImageComponentsResponseBodyImageComponent : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageComponentsResponseBodyImageComponentImageComponentSet>> imageComponentSet{};

  DescribeImageComponentsResponseBodyImageComponent() {}

  explicit DescribeImageComponentsResponseBodyImageComponent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageComponentSet) {
      vector<boost::any> temp1;
      for(auto item1:*imageComponentSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageComponentSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageComponentSet") != m.end() && !m["ImageComponentSet"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageComponentSet"].type()) {
        vector<DescribeImageComponentsResponseBodyImageComponentImageComponentSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageComponentSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageComponentsResponseBodyImageComponentImageComponentSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageComponentSet = make_shared<vector<DescribeImageComponentsResponseBodyImageComponentImageComponentSet>>(expect1);
      }
    }
  }


  virtual ~DescribeImageComponentsResponseBodyImageComponent() = default;
};
class DescribeImageComponentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> maxResults{};
  shared_ptr<DescribeImageComponentsResponseBodyImageComponent> imageComponent{};

  DescribeImageComponentsResponseBody() {}

  explicit DescribeImageComponentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (imageComponent) {
      res["ImageComponent"] = imageComponent ? boost::any(imageComponent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("ImageComponent") != m.end() && !m["ImageComponent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageComponent"].type()) {
        DescribeImageComponentsResponseBodyImageComponent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageComponent"]));
        imageComponent = make_shared<DescribeImageComponentsResponseBodyImageComponent>(model1);
      }
    }
  }


  virtual ~DescribeImageComponentsResponseBody() = default;
};
class DescribeImageComponentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeImageComponentsResponseBody> body{};

  DescribeImageComponentsResponse() {}

  explicit DescribeImageComponentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageComponentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageComponentsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageComponentsResponse() = default;
};
class DescribeImageFromFamilyRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> imageFamily{};

  DescribeImageFromFamilyRequest() {}

  explicit DescribeImageFromFamilyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (imageFamily) {
      res["ImageFamily"] = boost::any(*imageFamily);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ImageFamily") != m.end() && !m["ImageFamily"].empty()) {
      imageFamily = make_shared<string>(boost::any_cast<string>(m["ImageFamily"]));
    }
  }


  virtual ~DescribeImageFromFamilyRequest() = default;
};
class DescribeImageFromFamilyResponseBodyImageDiskDeviceMappingsDiskDeviceMapping : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> importOSSBucket{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> importOSSObject{};
  shared_ptr<string> size{};
  shared_ptr<string> device{};
  shared_ptr<string> format{};

  DescribeImageFromFamilyResponseBodyImageDiskDeviceMappingsDiskDeviceMapping() {}

  explicit DescribeImageFromFamilyResponseBodyImageDiskDeviceMappingsDiskDeviceMapping(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (importOSSBucket) {
      res["ImportOSSBucket"] = boost::any(*importOSSBucket);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (importOSSObject) {
      res["ImportOSSObject"] = boost::any(*importOSSObject);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ImportOSSBucket") != m.end() && !m["ImportOSSBucket"].empty()) {
      importOSSBucket = make_shared<string>(boost::any_cast<string>(m["ImportOSSBucket"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("ImportOSSObject") != m.end() && !m["ImportOSSObject"].empty()) {
      importOSSObject = make_shared<string>(boost::any_cast<string>(m["ImportOSSObject"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~DescribeImageFromFamilyResponseBodyImageDiskDeviceMappingsDiskDeviceMapping() = default;
};
class DescribeImageFromFamilyResponseBodyImageDiskDeviceMappings : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageFromFamilyResponseBodyImageDiskDeviceMappingsDiskDeviceMapping>> diskDeviceMapping{};

  DescribeImageFromFamilyResponseBodyImageDiskDeviceMappings() {}

  explicit DescribeImageFromFamilyResponseBodyImageDiskDeviceMappings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskDeviceMapping) {
      vector<boost::any> temp1;
      for(auto item1:*diskDeviceMapping){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiskDeviceMapping"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskDeviceMapping") != m.end() && !m["DiskDeviceMapping"].empty()) {
      if (typeid(vector<boost::any>) == m["DiskDeviceMapping"].type()) {
        vector<DescribeImageFromFamilyResponseBodyImageDiskDeviceMappingsDiskDeviceMapping> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiskDeviceMapping"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageFromFamilyResponseBodyImageDiskDeviceMappingsDiskDeviceMapping model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diskDeviceMapping = make_shared<vector<DescribeImageFromFamilyResponseBodyImageDiskDeviceMappingsDiskDeviceMapping>>(expect1);
      }
    }
  }


  virtual ~DescribeImageFromFamilyResponseBodyImageDiskDeviceMappings() = default;
};
class DescribeImageFromFamilyResponseBodyImageTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  DescribeImageFromFamilyResponseBodyImageTagsTag() {}

  explicit DescribeImageFromFamilyResponseBodyImageTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~DescribeImageFromFamilyResponseBodyImageTagsTag() = default;
};
class DescribeImageFromFamilyResponseBodyImageTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageFromFamilyResponseBodyImageTagsTag>> tag{};

  DescribeImageFromFamilyResponseBodyImageTags() {}

  explicit DescribeImageFromFamilyResponseBodyImageTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeImageFromFamilyResponseBodyImageTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageFromFamilyResponseBodyImageTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeImageFromFamilyResponseBodyImageTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeImageFromFamilyResponseBodyImageTags() = default;
};
class DescribeImageFromFamilyResponseBodyImage : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> status{};
  shared_ptr<string> imageFamily{};
  shared_ptr<string> progress{};
  shared_ptr<bool> isCopied{};
  shared_ptr<bool> isSupportIoOptimized{};
  shared_ptr<string> imageOwnerAlias{};
  shared_ptr<bool> isSupportCloudinit{};
  shared_ptr<string> imageVersion{};
  shared_ptr<string> usage{};
  shared_ptr<string> isSelfShared{};
  shared_ptr<string> description{};
  shared_ptr<long> size{};
  shared_ptr<string> platform{};
  shared_ptr<string> imageName{};
  shared_ptr<string> OSName{};
  shared_ptr<string> imageId{};
  shared_ptr<string> OSType{};
  shared_ptr<bool> isSubscribed{};
  shared_ptr<string> productCode{};
  shared_ptr<string> architecture{};
  shared_ptr<DescribeImageFromFamilyResponseBodyImageDiskDeviceMappings> diskDeviceMappings{};
  shared_ptr<DescribeImageFromFamilyResponseBodyImageTags> tags{};

  DescribeImageFromFamilyResponseBodyImage() {}

  explicit DescribeImageFromFamilyResponseBodyImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (imageFamily) {
      res["ImageFamily"] = boost::any(*imageFamily);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (isCopied) {
      res["IsCopied"] = boost::any(*isCopied);
    }
    if (isSupportIoOptimized) {
      res["IsSupportIoOptimized"] = boost::any(*isSupportIoOptimized);
    }
    if (imageOwnerAlias) {
      res["ImageOwnerAlias"] = boost::any(*imageOwnerAlias);
    }
    if (isSupportCloudinit) {
      res["IsSupportCloudinit"] = boost::any(*isSupportCloudinit);
    }
    if (imageVersion) {
      res["ImageVersion"] = boost::any(*imageVersion);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (isSelfShared) {
      res["IsSelfShared"] = boost::any(*isSelfShared);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (OSName) {
      res["OSName"] = boost::any(*OSName);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (OSType) {
      res["OSType"] = boost::any(*OSType);
    }
    if (isSubscribed) {
      res["IsSubscribed"] = boost::any(*isSubscribed);
    }
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (architecture) {
      res["Architecture"] = boost::any(*architecture);
    }
    if (diskDeviceMappings) {
      res["DiskDeviceMappings"] = diskDeviceMappings ? boost::any(diskDeviceMappings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ImageFamily") != m.end() && !m["ImageFamily"].empty()) {
      imageFamily = make_shared<string>(boost::any_cast<string>(m["ImageFamily"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("IsCopied") != m.end() && !m["IsCopied"].empty()) {
      isCopied = make_shared<bool>(boost::any_cast<bool>(m["IsCopied"]));
    }
    if (m.find("IsSupportIoOptimized") != m.end() && !m["IsSupportIoOptimized"].empty()) {
      isSupportIoOptimized = make_shared<bool>(boost::any_cast<bool>(m["IsSupportIoOptimized"]));
    }
    if (m.find("ImageOwnerAlias") != m.end() && !m["ImageOwnerAlias"].empty()) {
      imageOwnerAlias = make_shared<string>(boost::any_cast<string>(m["ImageOwnerAlias"]));
    }
    if (m.find("IsSupportCloudinit") != m.end() && !m["IsSupportCloudinit"].empty()) {
      isSupportCloudinit = make_shared<bool>(boost::any_cast<bool>(m["IsSupportCloudinit"]));
    }
    if (m.find("ImageVersion") != m.end() && !m["ImageVersion"].empty()) {
      imageVersion = make_shared<string>(boost::any_cast<string>(m["ImageVersion"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("IsSelfShared") != m.end() && !m["IsSelfShared"].empty()) {
      isSelfShared = make_shared<string>(boost::any_cast<string>(m["IsSelfShared"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("OSName") != m.end() && !m["OSName"].empty()) {
      OSName = make_shared<string>(boost::any_cast<string>(m["OSName"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("OSType") != m.end() && !m["OSType"].empty()) {
      OSType = make_shared<string>(boost::any_cast<string>(m["OSType"]));
    }
    if (m.find("IsSubscribed") != m.end() && !m["IsSubscribed"].empty()) {
      isSubscribed = make_shared<bool>(boost::any_cast<bool>(m["IsSubscribed"]));
    }
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("Architecture") != m.end() && !m["Architecture"].empty()) {
      architecture = make_shared<string>(boost::any_cast<string>(m["Architecture"]));
    }
    if (m.find("DiskDeviceMappings") != m.end() && !m["DiskDeviceMappings"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskDeviceMappings"].type()) {
        DescribeImageFromFamilyResponseBodyImageDiskDeviceMappings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskDeviceMappings"]));
        diskDeviceMappings = make_shared<DescribeImageFromFamilyResponseBodyImageDiskDeviceMappings>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeImageFromFamilyResponseBodyImageTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeImageFromFamilyResponseBodyImageTags>(model1);
      }
    }
  }


  virtual ~DescribeImageFromFamilyResponseBodyImage() = default;
};
class DescribeImageFromFamilyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeImageFromFamilyResponseBodyImage> image{};

  DescribeImageFromFamilyResponseBody() {}

  explicit DescribeImageFromFamilyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (image) {
      res["Image"] = image ? boost::any(image->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      if (typeid(map<string, boost::any>) == m["Image"].type()) {
        DescribeImageFromFamilyResponseBodyImage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Image"]));
        image = make_shared<DescribeImageFromFamilyResponseBodyImage>(model1);
      }
    }
  }


  virtual ~DescribeImageFromFamilyResponseBody() = default;
};
class DescribeImageFromFamilyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeImageFromFamilyResponseBody> body{};

  DescribeImageFromFamilyResponse() {}

  explicit DescribeImageFromFamilyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageFromFamilyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageFromFamilyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageFromFamilyResponse() = default;
};
class DescribeImagePipelineExecutionsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeImagePipelineExecutionsRequestTag() {}

  explicit DescribeImagePipelineExecutionsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeImagePipelineExecutionsRequestTag() = default;
};
class DescribeImagePipelineExecutionsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImagePipelineExecutionsRequestTag>> tag{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> imagePipelineId{};
  shared_ptr<string> executionId{};
  shared_ptr<string> status{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> maxResults{};

  DescribeImagePipelineExecutionsRequest() {}

  explicit DescribeImagePipelineExecutionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (imagePipelineId) {
      res["ImagePipelineId"] = boost::any(*imagePipelineId);
    }
    if (executionId) {
      res["ExecutionId"] = boost::any(*executionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeImagePipelineExecutionsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImagePipelineExecutionsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeImagePipelineExecutionsRequestTag>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ImagePipelineId") != m.end() && !m["ImagePipelineId"].empty()) {
      imagePipelineId = make_shared<string>(boost::any_cast<string>(m["ImagePipelineId"]));
    }
    if (m.find("ExecutionId") != m.end() && !m["ExecutionId"].empty()) {
      executionId = make_shared<string>(boost::any_cast<string>(m["ExecutionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
  }


  virtual ~DescribeImagePipelineExecutionsRequest() = default;
};
class DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSetTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSetTagsTag() {}

  explicit DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSetTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSetTagsTag() = default;
};
class DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSetTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSetTagsTag>> tag{};

  DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSetTags() {}

  explicit DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSetTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSetTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSetTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSetTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSetTags() = default;
};
class DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSet : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> imagePipelineId{};
  shared_ptr<string> status{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> message{};
  shared_ptr<string> imageId{};
  shared_ptr<string> executionId{};
  shared_ptr<DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSetTags> tags{};

  DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSet() {}

  explicit DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (imagePipelineId) {
      res["ImagePipelineId"] = boost::any(*imagePipelineId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (executionId) {
      res["ExecutionId"] = boost::any(*executionId);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("ImagePipelineId") != m.end() && !m["ImagePipelineId"].empty()) {
      imagePipelineId = make_shared<string>(boost::any_cast<string>(m["ImagePipelineId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ExecutionId") != m.end() && !m["ExecutionId"].empty()) {
      executionId = make_shared<string>(boost::any_cast<string>(m["ExecutionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSetTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSetTags>(model1);
      }
    }
  }


  virtual ~DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSet() = default;
};
class DescribeImagePipelineExecutionsResponseBodyImagePipelineExecution : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSet>> imagePipelineExecutionSet{};

  DescribeImagePipelineExecutionsResponseBodyImagePipelineExecution() {}

  explicit DescribeImagePipelineExecutionsResponseBodyImagePipelineExecution(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imagePipelineExecutionSet) {
      vector<boost::any> temp1;
      for(auto item1:*imagePipelineExecutionSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImagePipelineExecutionSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImagePipelineExecutionSet") != m.end() && !m["ImagePipelineExecutionSet"].empty()) {
      if (typeid(vector<boost::any>) == m["ImagePipelineExecutionSet"].type()) {
        vector<DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImagePipelineExecutionSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imagePipelineExecutionSet = make_shared<vector<DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSet>>(expect1);
      }
    }
  }


  virtual ~DescribeImagePipelineExecutionsResponseBodyImagePipelineExecution() = default;
};
class DescribeImagePipelineExecutionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> maxResults{};
  shared_ptr<DescribeImagePipelineExecutionsResponseBodyImagePipelineExecution> imagePipelineExecution{};

  DescribeImagePipelineExecutionsResponseBody() {}

  explicit DescribeImagePipelineExecutionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (imagePipelineExecution) {
      res["ImagePipelineExecution"] = imagePipelineExecution ? boost::any(imagePipelineExecution->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("ImagePipelineExecution") != m.end() && !m["ImagePipelineExecution"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImagePipelineExecution"].type()) {
        DescribeImagePipelineExecutionsResponseBodyImagePipelineExecution model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImagePipelineExecution"]));
        imagePipelineExecution = make_shared<DescribeImagePipelineExecutionsResponseBodyImagePipelineExecution>(model1);
      }
    }
  }


  virtual ~DescribeImagePipelineExecutionsResponseBody() = default;
};
class DescribeImagePipelineExecutionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeImagePipelineExecutionsResponseBody> body{};

  DescribeImagePipelineExecutionsResponse() {}

  explicit DescribeImagePipelineExecutionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImagePipelineExecutionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImagePipelineExecutionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImagePipelineExecutionsResponse() = default;
};
class DescribeImagePipelinesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeImagePipelinesRequestTag() {}

  explicit DescribeImagePipelinesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeImagePipelinesRequestTag() = default;
};
class DescribeImagePipelinesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImagePipelinesRequestTag>> tag{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<string>> imagePipelineId{};
  shared_ptr<string> name{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> maxResults{};

  DescribeImagePipelinesRequest() {}

  explicit DescribeImagePipelinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (imagePipelineId) {
      res["ImagePipelineId"] = boost::any(*imagePipelineId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeImagePipelinesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImagePipelinesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeImagePipelinesRequestTag>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ImagePipelineId") != m.end() && !m["ImagePipelineId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ImagePipelineId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ImagePipelineId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      imagePipelineId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
  }


  virtual ~DescribeImagePipelinesRequest() = default;
};
class DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetTagsTag() {}

  explicit DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetTagsTag() = default;
};
class DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetTagsTag>> tag{};

  DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetTags() {}

  explicit DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetTags() = default;
};
class DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetToRegionIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> toRegionId{};

  DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetToRegionIds() {}

  explicit DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetToRegionIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (toRegionId) {
      res["ToRegionId"] = boost::any(*toRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ToRegionId") != m.end() && !m["ToRegionId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ToRegionId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ToRegionId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      toRegionId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetToRegionIds() = default;
};
class DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetAddAccounts : public Darabonba::Model {
public:
  shared_ptr<vector<string>> addAccount{};

  DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetAddAccounts() {}

  explicit DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetAddAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addAccount) {
      res["AddAccount"] = boost::any(*addAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddAccount") != m.end() && !m["AddAccount"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AddAccount"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AddAccount"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      addAccount = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetAddAccounts() = default;
};
class DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSet : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<bool> deleteInstanceOnFailure{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> imagePipelineId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<long> systemDiskSize{};
  shared_ptr<string> description{};
  shared_ptr<string> baseImage{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> imageName{};
  shared_ptr<string> baseImageType{};
  shared_ptr<string> name{};
  shared_ptr<string> buildContent{};
  shared_ptr<DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetTags> tags{};
  shared_ptr<DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetToRegionIds> toRegionIds{};
  shared_ptr<DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetAddAccounts> addAccounts{};

  DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSet() {}

  explicit DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (deleteInstanceOnFailure) {
      res["DeleteInstanceOnFailure"] = boost::any(*deleteInstanceOnFailure);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (imagePipelineId) {
      res["ImagePipelineId"] = boost::any(*imagePipelineId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (baseImage) {
      res["BaseImage"] = boost::any(*baseImage);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (baseImageType) {
      res["BaseImageType"] = boost::any(*baseImageType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (buildContent) {
      res["BuildContent"] = boost::any(*buildContent);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (toRegionIds) {
      res["ToRegionIds"] = toRegionIds ? boost::any(toRegionIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (addAccounts) {
      res["AddAccounts"] = addAccounts ? boost::any(addAccounts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DeleteInstanceOnFailure") != m.end() && !m["DeleteInstanceOnFailure"].empty()) {
      deleteInstanceOnFailure = make_shared<bool>(boost::any_cast<bool>(m["DeleteInstanceOnFailure"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("ImagePipelineId") != m.end() && !m["ImagePipelineId"].empty()) {
      imagePipelineId = make_shared<string>(boost::any_cast<string>(m["ImagePipelineId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskSize"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("BaseImage") != m.end() && !m["BaseImage"].empty()) {
      baseImage = make_shared<string>(boost::any_cast<string>(m["BaseImage"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("BaseImageType") != m.end() && !m["BaseImageType"].empty()) {
      baseImageType = make_shared<string>(boost::any_cast<string>(m["BaseImageType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("BuildContent") != m.end() && !m["BuildContent"].empty()) {
      buildContent = make_shared<string>(boost::any_cast<string>(m["BuildContent"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetTags>(model1);
      }
    }
    if (m.find("ToRegionIds") != m.end() && !m["ToRegionIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["ToRegionIds"].type()) {
        DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetToRegionIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ToRegionIds"]));
        toRegionIds = make_shared<DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetToRegionIds>(model1);
      }
    }
    if (m.find("AddAccounts") != m.end() && !m["AddAccounts"].empty()) {
      if (typeid(map<string, boost::any>) == m["AddAccounts"].type()) {
        DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetAddAccounts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AddAccounts"]));
        addAccounts = make_shared<DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetAddAccounts>(model1);
      }
    }
  }


  virtual ~DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSet() = default;
};
class DescribeImagePipelinesResponseBodyImagePipeline : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSet>> imagePipelineSet{};

  DescribeImagePipelinesResponseBodyImagePipeline() {}

  explicit DescribeImagePipelinesResponseBodyImagePipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imagePipelineSet) {
      vector<boost::any> temp1;
      for(auto item1:*imagePipelineSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImagePipelineSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImagePipelineSet") != m.end() && !m["ImagePipelineSet"].empty()) {
      if (typeid(vector<boost::any>) == m["ImagePipelineSet"].type()) {
        vector<DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImagePipelineSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imagePipelineSet = make_shared<vector<DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSet>>(expect1);
      }
    }
  }


  virtual ~DescribeImagePipelinesResponseBodyImagePipeline() = default;
};
class DescribeImagePipelinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> maxResults{};
  shared_ptr<DescribeImagePipelinesResponseBodyImagePipeline> imagePipeline{};

  DescribeImagePipelinesResponseBody() {}

  explicit DescribeImagePipelinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (imagePipeline) {
      res["ImagePipeline"] = imagePipeline ? boost::any(imagePipeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("ImagePipeline") != m.end() && !m["ImagePipeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImagePipeline"].type()) {
        DescribeImagePipelinesResponseBodyImagePipeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImagePipeline"]));
        imagePipeline = make_shared<DescribeImagePipelinesResponseBodyImagePipeline>(model1);
      }
    }
  }


  virtual ~DescribeImagePipelinesResponseBody() = default;
};
class DescribeImagePipelinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeImagePipelinesResponseBody> body{};

  DescribeImagePipelinesResponse() {}

  explicit DescribeImagePipelinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImagePipelinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImagePipelinesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImagePipelinesResponse() = default;
};
class DescribeImagesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeImagesRequestTag() {}

  explicit DescribeImagesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeImagesRequestTag() = default;
};
class DescribeImagesRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeImagesRequestFilter() {}

  explicit DescribeImagesRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeImagesRequestFilter() = default;
};
class DescribeImagesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};
  shared_ptr<string> imageId{};
  shared_ptr<bool> showExpired{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> imageName{};
  shared_ptr<string> imageFamily{};
  shared_ptr<string> imageOwnerAlias{};
  shared_ptr<string> instanceType{};
  shared_ptr<bool> isSupportIoOptimized{};
  shared_ptr<bool> isSupportCloudinit{};
  shared_ptr<string> OSType{};
  shared_ptr<string> architecture{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> usage{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> actionType{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<DescribeImagesRequestTag>> tag{};
  shared_ptr<vector<DescribeImagesRequestFilter>> filter{};
  shared_ptr<bool> isPublic{};
  shared_ptr<long> imageOwnerId{};

  DescribeImagesRequest() {}

  explicit DescribeImagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (showExpired) {
      res["ShowExpired"] = boost::any(*showExpired);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (imageFamily) {
      res["ImageFamily"] = boost::any(*imageFamily);
    }
    if (imageOwnerAlias) {
      res["ImageOwnerAlias"] = boost::any(*imageOwnerAlias);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (isSupportIoOptimized) {
      res["IsSupportIoOptimized"] = boost::any(*isSupportIoOptimized);
    }
    if (isSupportCloudinit) {
      res["IsSupportCloudinit"] = boost::any(*isSupportCloudinit);
    }
    if (OSType) {
      res["OSType"] = boost::any(*OSType);
    }
    if (architecture) {
      res["Architecture"] = boost::any(*architecture);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (actionType) {
      res["ActionType"] = boost::any(*actionType);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    if (isPublic) {
      res["IsPublic"] = boost::any(*isPublic);
    }
    if (imageOwnerId) {
      res["ImageOwnerId"] = boost::any(*imageOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ShowExpired") != m.end() && !m["ShowExpired"].empty()) {
      showExpired = make_shared<bool>(boost::any_cast<bool>(m["ShowExpired"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("ImageFamily") != m.end() && !m["ImageFamily"].empty()) {
      imageFamily = make_shared<string>(boost::any_cast<string>(m["ImageFamily"]));
    }
    if (m.find("ImageOwnerAlias") != m.end() && !m["ImageOwnerAlias"].empty()) {
      imageOwnerAlias = make_shared<string>(boost::any_cast<string>(m["ImageOwnerAlias"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("IsSupportIoOptimized") != m.end() && !m["IsSupportIoOptimized"].empty()) {
      isSupportIoOptimized = make_shared<bool>(boost::any_cast<bool>(m["IsSupportIoOptimized"]));
    }
    if (m.find("IsSupportCloudinit") != m.end() && !m["IsSupportCloudinit"].empty()) {
      isSupportCloudinit = make_shared<bool>(boost::any_cast<bool>(m["IsSupportCloudinit"]));
    }
    if (m.find("OSType") != m.end() && !m["OSType"].empty()) {
      OSType = make_shared<string>(boost::any_cast<string>(m["OSType"]));
    }
    if (m.find("Architecture") != m.end() && !m["Architecture"].empty()) {
      architecture = make_shared<string>(boost::any_cast<string>(m["Architecture"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("ActionType") != m.end() && !m["ActionType"].empty()) {
      actionType = make_shared<string>(boost::any_cast<string>(m["ActionType"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeImagesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImagesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeImagesRequestTag>>(expect1);
      }
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<DescribeImagesRequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImagesRequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<DescribeImagesRequestFilter>>(expect1);
      }
    }
    if (m.find("IsPublic") != m.end() && !m["IsPublic"].empty()) {
      isPublic = make_shared<bool>(boost::any_cast<bool>(m["IsPublic"]));
    }
    if (m.find("ImageOwnerId") != m.end() && !m["ImageOwnerId"].empty()) {
      imageOwnerId = make_shared<long>(boost::any_cast<long>(m["ImageOwnerId"]));
    }
  }


  virtual ~DescribeImagesRequest() = default;
};
class DescribeImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> importOSSBucket{};
  shared_ptr<string> progress{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> importOSSObject{};
  shared_ptr<string> device{};
  shared_ptr<string> size{};
  shared_ptr<long> remainTime{};
  shared_ptr<string> format{};

  DescribeImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping() {}

  explicit DescribeImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (importOSSBucket) {
      res["ImportOSSBucket"] = boost::any(*importOSSBucket);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (importOSSObject) {
      res["ImportOSSObject"] = boost::any(*importOSSObject);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (remainTime) {
      res["RemainTime"] = boost::any(*remainTime);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ImportOSSBucket") != m.end() && !m["ImportOSSBucket"].empty()) {
      importOSSBucket = make_shared<string>(boost::any_cast<string>(m["ImportOSSBucket"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("ImportOSSObject") != m.end() && !m["ImportOSSObject"].empty()) {
      importOSSObject = make_shared<string>(boost::any_cast<string>(m["ImportOSSObject"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("RemainTime") != m.end() && !m["RemainTime"].empty()) {
      remainTime = make_shared<long>(boost::any_cast<long>(m["RemainTime"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~DescribeImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping() = default;
};
class DescribeImagesResponseBodyImagesImageDiskDeviceMappings : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping>> diskDeviceMapping{};

  DescribeImagesResponseBodyImagesImageDiskDeviceMappings() {}

  explicit DescribeImagesResponseBodyImagesImageDiskDeviceMappings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskDeviceMapping) {
      vector<boost::any> temp1;
      for(auto item1:*diskDeviceMapping){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiskDeviceMapping"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskDeviceMapping") != m.end() && !m["DiskDeviceMapping"].empty()) {
      if (typeid(vector<boost::any>) == m["DiskDeviceMapping"].type()) {
        vector<DescribeImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiskDeviceMapping"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diskDeviceMapping = make_shared<vector<DescribeImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping>>(expect1);
      }
    }
  }


  virtual ~DescribeImagesResponseBodyImagesImageDiskDeviceMappings() = default;
};
class DescribeImagesResponseBodyImagesImageTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  DescribeImagesResponseBodyImagesImageTagsTag() {}

  explicit DescribeImagesResponseBodyImagesImageTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~DescribeImagesResponseBodyImagesImageTagsTag() = default;
};
class DescribeImagesResponseBodyImagesImageTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImagesResponseBodyImagesImageTagsTag>> tag{};

  DescribeImagesResponseBodyImagesImageTags() {}

  explicit DescribeImagesResponseBodyImagesImageTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeImagesResponseBodyImagesImageTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImagesResponseBodyImagesImageTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeImagesResponseBodyImagesImageTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeImagesResponseBodyImagesImageTags() = default;
};
class DescribeImagesResponseBodyImagesImage : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> status{};
  shared_ptr<string> imageFamily{};
  shared_ptr<string> progress{};
  shared_ptr<bool> isCopied{};
  shared_ptr<bool> isSupportIoOptimized{};
  shared_ptr<string> imageOwnerAlias{};
  shared_ptr<bool> isSupportCloudinit{};
  shared_ptr<string> imageVersion{};
  shared_ptr<string> usage{};
  shared_ptr<string> isSelfShared{};
  shared_ptr<string> description{};
  shared_ptr<long> size{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> platform{};
  shared_ptr<string> OSNameEn{};
  shared_ptr<string> imageName{};
  shared_ptr<string> OSName{};
  shared_ptr<string> imageId{};
  shared_ptr<string> OSType{};
  shared_ptr<bool> isSubscribed{};
  shared_ptr<string> productCode{};
  shared_ptr<string> architecture{};
  shared_ptr<DescribeImagesResponseBodyImagesImageDiskDeviceMappings> diskDeviceMappings{};
  shared_ptr<DescribeImagesResponseBodyImagesImageTags> tags{};
  shared_ptr<bool> isPublic{};
  shared_ptr<long> imageOwnerId{};

  DescribeImagesResponseBodyImagesImage() {}

  explicit DescribeImagesResponseBodyImagesImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (imageFamily) {
      res["ImageFamily"] = boost::any(*imageFamily);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (isCopied) {
      res["IsCopied"] = boost::any(*isCopied);
    }
    if (isSupportIoOptimized) {
      res["IsSupportIoOptimized"] = boost::any(*isSupportIoOptimized);
    }
    if (imageOwnerAlias) {
      res["ImageOwnerAlias"] = boost::any(*imageOwnerAlias);
    }
    if (isSupportCloudinit) {
      res["IsSupportCloudinit"] = boost::any(*isSupportCloudinit);
    }
    if (imageVersion) {
      res["ImageVersion"] = boost::any(*imageVersion);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (isSelfShared) {
      res["IsSelfShared"] = boost::any(*isSelfShared);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (OSNameEn) {
      res["OSNameEn"] = boost::any(*OSNameEn);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (OSName) {
      res["OSName"] = boost::any(*OSName);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (OSType) {
      res["OSType"] = boost::any(*OSType);
    }
    if (isSubscribed) {
      res["IsSubscribed"] = boost::any(*isSubscribed);
    }
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (architecture) {
      res["Architecture"] = boost::any(*architecture);
    }
    if (diskDeviceMappings) {
      res["DiskDeviceMappings"] = diskDeviceMappings ? boost::any(diskDeviceMappings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isPublic) {
      res["IsPublic"] = boost::any(*isPublic);
    }
    if (imageOwnerId) {
      res["ImageOwnerId"] = boost::any(*imageOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ImageFamily") != m.end() && !m["ImageFamily"].empty()) {
      imageFamily = make_shared<string>(boost::any_cast<string>(m["ImageFamily"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("IsCopied") != m.end() && !m["IsCopied"].empty()) {
      isCopied = make_shared<bool>(boost::any_cast<bool>(m["IsCopied"]));
    }
    if (m.find("IsSupportIoOptimized") != m.end() && !m["IsSupportIoOptimized"].empty()) {
      isSupportIoOptimized = make_shared<bool>(boost::any_cast<bool>(m["IsSupportIoOptimized"]));
    }
    if (m.find("ImageOwnerAlias") != m.end() && !m["ImageOwnerAlias"].empty()) {
      imageOwnerAlias = make_shared<string>(boost::any_cast<string>(m["ImageOwnerAlias"]));
    }
    if (m.find("IsSupportCloudinit") != m.end() && !m["IsSupportCloudinit"].empty()) {
      isSupportCloudinit = make_shared<bool>(boost::any_cast<bool>(m["IsSupportCloudinit"]));
    }
    if (m.find("ImageVersion") != m.end() && !m["ImageVersion"].empty()) {
      imageVersion = make_shared<string>(boost::any_cast<string>(m["ImageVersion"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("IsSelfShared") != m.end() && !m["IsSelfShared"].empty()) {
      isSelfShared = make_shared<string>(boost::any_cast<string>(m["IsSelfShared"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("OSNameEn") != m.end() && !m["OSNameEn"].empty()) {
      OSNameEn = make_shared<string>(boost::any_cast<string>(m["OSNameEn"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("OSName") != m.end() && !m["OSName"].empty()) {
      OSName = make_shared<string>(boost::any_cast<string>(m["OSName"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("OSType") != m.end() && !m["OSType"].empty()) {
      OSType = make_shared<string>(boost::any_cast<string>(m["OSType"]));
    }
    if (m.find("IsSubscribed") != m.end() && !m["IsSubscribed"].empty()) {
      isSubscribed = make_shared<bool>(boost::any_cast<bool>(m["IsSubscribed"]));
    }
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("Architecture") != m.end() && !m["Architecture"].empty()) {
      architecture = make_shared<string>(boost::any_cast<string>(m["Architecture"]));
    }
    if (m.find("DiskDeviceMappings") != m.end() && !m["DiskDeviceMappings"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskDeviceMappings"].type()) {
        DescribeImagesResponseBodyImagesImageDiskDeviceMappings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskDeviceMappings"]));
        diskDeviceMappings = make_shared<DescribeImagesResponseBodyImagesImageDiskDeviceMappings>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeImagesResponseBodyImagesImageTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeImagesResponseBodyImagesImageTags>(model1);
      }
    }
    if (m.find("IsPublic") != m.end() && !m["IsPublic"].empty()) {
      isPublic = make_shared<bool>(boost::any_cast<bool>(m["IsPublic"]));
    }
    if (m.find("ImageOwnerId") != m.end() && !m["ImageOwnerId"].empty()) {
      imageOwnerId = make_shared<long>(boost::any_cast<long>(m["ImageOwnerId"]));
    }
  }


  virtual ~DescribeImagesResponseBodyImagesImage() = default;
};
class DescribeImagesResponseBodyImages : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImagesResponseBodyImagesImage>> image{};

  DescribeImagesResponseBodyImages() {}

  explicit DescribeImagesResponseBodyImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      vector<boost::any> temp1;
      for(auto item1:*image){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Image"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      if (typeid(vector<boost::any>) == m["Image"].type()) {
        vector<DescribeImagesResponseBodyImagesImage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Image"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImagesResponseBodyImagesImage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        image = make_shared<vector<DescribeImagesResponseBodyImagesImage>>(expect1);
      }
    }
  }


  virtual ~DescribeImagesResponseBodyImages() = default;
};
class DescribeImagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeImagesResponseBodyImages> images{};

  DescribeImagesResponseBody() {}

  explicit DescribeImagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (images) {
      res["Images"] = images ? boost::any(images->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      if (typeid(map<string, boost::any>) == m["Images"].type()) {
        DescribeImagesResponseBodyImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Images"]));
        images = make_shared<DescribeImagesResponseBodyImages>(model1);
      }
    }
  }


  virtual ~DescribeImagesResponseBody() = default;
};
class DescribeImagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeImagesResponseBody> body{};

  DescribeImagesResponse() {}

  explicit DescribeImagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImagesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImagesResponse() = default;
};
class DescribeImageSharePermissionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> imageId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ownerAccount{};

  DescribeImageSharePermissionRequest() {}

  explicit DescribeImageSharePermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeImageSharePermissionRequest() = default;
};
class DescribeImageSharePermissionResponseBodyShareGroupsShareGroup : public Darabonba::Model {
public:
  shared_ptr<string> group{};

  DescribeImageSharePermissionResponseBodyShareGroupsShareGroup() {}

  explicit DescribeImageSharePermissionResponseBodyShareGroupsShareGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (group) {
      res["Group"] = boost::any(*group);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
  }


  virtual ~DescribeImageSharePermissionResponseBodyShareGroupsShareGroup() = default;
};
class DescribeImageSharePermissionResponseBodyShareGroups : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageSharePermissionResponseBodyShareGroupsShareGroup>> shareGroup{};

  DescribeImageSharePermissionResponseBodyShareGroups() {}

  explicit DescribeImageSharePermissionResponseBodyShareGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (shareGroup) {
      vector<boost::any> temp1;
      for(auto item1:*shareGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ShareGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ShareGroup") != m.end() && !m["ShareGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["ShareGroup"].type()) {
        vector<DescribeImageSharePermissionResponseBodyShareGroupsShareGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ShareGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageSharePermissionResponseBodyShareGroupsShareGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        shareGroup = make_shared<vector<DescribeImageSharePermissionResponseBodyShareGroupsShareGroup>>(expect1);
      }
    }
  }


  virtual ~DescribeImageSharePermissionResponseBodyShareGroups() = default;
};
class DescribeImageSharePermissionResponseBodyAccountsAccount : public Darabonba::Model {
public:
  shared_ptr<string> aliyunId{};

  DescribeImageSharePermissionResponseBodyAccountsAccount() {}

  explicit DescribeImageSharePermissionResponseBodyAccountsAccount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunId) {
      res["AliyunId"] = boost::any(*aliyunId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunId") != m.end() && !m["AliyunId"].empty()) {
      aliyunId = make_shared<string>(boost::any_cast<string>(m["AliyunId"]));
    }
  }


  virtual ~DescribeImageSharePermissionResponseBodyAccountsAccount() = default;
};
class DescribeImageSharePermissionResponseBodyAccounts : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageSharePermissionResponseBodyAccountsAccount>> account{};

  DescribeImageSharePermissionResponseBodyAccounts() {}

  explicit DescribeImageSharePermissionResponseBodyAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      vector<boost::any> temp1;
      for(auto item1:*account){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Account"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      if (typeid(vector<boost::any>) == m["Account"].type()) {
        vector<DescribeImageSharePermissionResponseBodyAccountsAccount> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Account"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageSharePermissionResponseBodyAccountsAccount model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        account = make_shared<vector<DescribeImageSharePermissionResponseBodyAccountsAccount>>(expect1);
      }
    }
  }


  virtual ~DescribeImageSharePermissionResponseBodyAccounts() = default;
};
class DescribeImageSharePermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> imageId{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeImageSharePermissionResponseBodyShareGroups> shareGroups{};
  shared_ptr<DescribeImageSharePermissionResponseBodyAccounts> accounts{};

  DescribeImageSharePermissionResponseBody() {}

  explicit DescribeImageSharePermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (shareGroups) {
      res["ShareGroups"] = shareGroups ? boost::any(shareGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (accounts) {
      res["Accounts"] = accounts ? boost::any(accounts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ShareGroups") != m.end() && !m["ShareGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["ShareGroups"].type()) {
        DescribeImageSharePermissionResponseBodyShareGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ShareGroups"]));
        shareGroups = make_shared<DescribeImageSharePermissionResponseBodyShareGroups>(model1);
      }
    }
    if (m.find("Accounts") != m.end() && !m["Accounts"].empty()) {
      if (typeid(map<string, boost::any>) == m["Accounts"].type()) {
        DescribeImageSharePermissionResponseBodyAccounts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Accounts"]));
        accounts = make_shared<DescribeImageSharePermissionResponseBodyAccounts>(model1);
      }
    }
  }


  virtual ~DescribeImageSharePermissionResponseBody() = default;
};
class DescribeImageSharePermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeImageSharePermissionResponseBody> body{};

  DescribeImageSharePermissionResponse() {}

  explicit DescribeImageSharePermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageSharePermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageSharePermissionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageSharePermissionResponse() = default;
};
class DescribeImageSupportInstanceTypesRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeImageSupportInstanceTypesRequestFilter() {}

  explicit DescribeImageSupportInstanceTypesRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeImageSupportInstanceTypesRequestFilter() = default;
};
class DescribeImageSupportInstanceTypesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> actionType{};
  shared_ptr<vector<DescribeImageSupportInstanceTypesRequestFilter>> filter{};

  DescribeImageSupportInstanceTypesRequest() {}

  explicit DescribeImageSupportInstanceTypesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (actionType) {
      res["ActionType"] = boost::any(*actionType);
    }
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ActionType") != m.end() && !m["ActionType"].empty()) {
      actionType = make_shared<string>(boost::any_cast<string>(m["ActionType"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<DescribeImageSupportInstanceTypesRequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageSupportInstanceTypesRequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<DescribeImageSupportInstanceTypesRequestFilter>>(expect1);
      }
    }
  }


  virtual ~DescribeImageSupportInstanceTypesRequest() = default;
};
class DescribeImageSupportInstanceTypesResponseBodyInstanceTypesInstanceType : public Darabonba::Model {
public:
  shared_ptr<string> instanceTypeId{};
  shared_ptr<string> instanceTypeFamily{};
  shared_ptr<long> cpuCoreCount{};
  shared_ptr<double> memorySize{};

  DescribeImageSupportInstanceTypesResponseBodyInstanceTypesInstanceType() {}

  explicit DescribeImageSupportInstanceTypesResponseBodyInstanceTypesInstanceType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceTypeId) {
      res["InstanceTypeId"] = boost::any(*instanceTypeId);
    }
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    if (cpuCoreCount) {
      res["CpuCoreCount"] = boost::any(*cpuCoreCount);
    }
    if (memorySize) {
      res["MemorySize"] = boost::any(*memorySize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceTypeId") != m.end() && !m["InstanceTypeId"].empty()) {
      instanceTypeId = make_shared<string>(boost::any_cast<string>(m["InstanceTypeId"]));
    }
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      instanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamily"]));
    }
    if (m.find("CpuCoreCount") != m.end() && !m["CpuCoreCount"].empty()) {
      cpuCoreCount = make_shared<long>(boost::any_cast<long>(m["CpuCoreCount"]));
    }
    if (m.find("MemorySize") != m.end() && !m["MemorySize"].empty()) {
      memorySize = make_shared<double>(boost::any_cast<double>(m["MemorySize"]));
    }
  }


  virtual ~DescribeImageSupportInstanceTypesResponseBodyInstanceTypesInstanceType() = default;
};
class DescribeImageSupportInstanceTypesResponseBodyInstanceTypes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageSupportInstanceTypesResponseBodyInstanceTypesInstanceType>> instanceType{};

  DescribeImageSupportInstanceTypesResponseBodyInstanceTypes() {}

  explicit DescribeImageSupportInstanceTypesResponseBodyInstanceTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      vector<boost::any> temp1;
      for(auto item1:*instanceType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceType"].type()) {
        vector<DescribeImageSupportInstanceTypesResponseBodyInstanceTypesInstanceType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageSupportInstanceTypesResponseBodyInstanceTypesInstanceType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceType = make_shared<vector<DescribeImageSupportInstanceTypesResponseBodyInstanceTypesInstanceType>>(expect1);
      }
    }
  }


  virtual ~DescribeImageSupportInstanceTypesResponseBodyInstanceTypes() = default;
};
class DescribeImageSupportInstanceTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeImageSupportInstanceTypesResponseBodyInstanceTypes> instanceTypes{};

  DescribeImageSupportInstanceTypesResponseBody() {}

  explicit DescribeImageSupportInstanceTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = instanceTypes ? boost::any(instanceTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTypes"].type()) {
        DescribeImageSupportInstanceTypesResponseBodyInstanceTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTypes"]));
        instanceTypes = make_shared<DescribeImageSupportInstanceTypesResponseBodyInstanceTypes>(model1);
      }
    }
  }


  virtual ~DescribeImageSupportInstanceTypesResponseBody() = default;
};
class DescribeImageSupportInstanceTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeImageSupportInstanceTypesResponseBody> body{};

  DescribeImageSupportInstanceTypesResponse() {}

  explicit DescribeImageSupportInstanceTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageSupportInstanceTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageSupportInstanceTypesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageSupportInstanceTypesResponse() = default;
};
class DescribeInstanceAttachmentAttributesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceIds{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeInstanceAttachmentAttributesRequest() {}

  explicit DescribeInstanceAttachmentAttributesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeInstanceAttachmentAttributesRequest() = default;
};
class DescribeInstanceAttachmentAttributesResponseBodyInstancesInstance : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> privatePoolOptionsMatchCriteria{};
  shared_ptr<string> privatePoolOptionsId{};

  DescribeInstanceAttachmentAttributesResponseBodyInstancesInstance() {}

  explicit DescribeInstanceAttachmentAttributesResponseBodyInstancesInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (privatePoolOptionsMatchCriteria) {
      res["PrivatePoolOptionsMatchCriteria"] = boost::any(*privatePoolOptionsMatchCriteria);
    }
    if (privatePoolOptionsId) {
      res["PrivatePoolOptionsId"] = boost::any(*privatePoolOptionsId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PrivatePoolOptionsMatchCriteria") != m.end() && !m["PrivatePoolOptionsMatchCriteria"].empty()) {
      privatePoolOptionsMatchCriteria = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptionsMatchCriteria"]));
    }
    if (m.find("PrivatePoolOptionsId") != m.end() && !m["PrivatePoolOptionsId"].empty()) {
      privatePoolOptionsId = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptionsId"]));
    }
  }


  virtual ~DescribeInstanceAttachmentAttributesResponseBodyInstancesInstance() = default;
};
class DescribeInstanceAttachmentAttributesResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceAttachmentAttributesResponseBodyInstancesInstance>> instance{};

  DescribeInstanceAttachmentAttributesResponseBodyInstances() {}

  explicit DescribeInstanceAttachmentAttributesResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      vector<boost::any> temp1;
      for(auto item1:*instance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(vector<boost::any>) == m["Instance"].type()) {
        vector<DescribeInstanceAttachmentAttributesResponseBodyInstancesInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceAttachmentAttributesResponseBodyInstancesInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instance = make_shared<vector<DescribeInstanceAttachmentAttributesResponseBodyInstancesInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceAttachmentAttributesResponseBodyInstances() = default;
};
class DescribeInstanceAttachmentAttributesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeInstanceAttachmentAttributesResponseBodyInstances> instances{};

  DescribeInstanceAttachmentAttributesResponseBody() {}

  explicit DescribeInstanceAttachmentAttributesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (instances) {
      res["Instances"] = instances ? boost::any(instances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instances"].type()) {
        DescribeInstanceAttachmentAttributesResponseBodyInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instances"]));
        instances = make_shared<DescribeInstanceAttachmentAttributesResponseBodyInstances>(model1);
      }
    }
  }


  virtual ~DescribeInstanceAttachmentAttributesResponseBody() = default;
};
class DescribeInstanceAttachmentAttributesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstanceAttachmentAttributesResponseBody> body{};

  DescribeInstanceAttachmentAttributesResponse() {}

  explicit DescribeInstanceAttachmentAttributesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceAttachmentAttributesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceAttachmentAttributesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceAttachmentAttributesResponse() = default;
};
class DescribeInstanceAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ownerAccount{};

  DescribeInstanceAttributeRequest() {}

  explicit DescribeInstanceAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeInstanceAttributeRequest() = default;
};
class DescribeInstanceAttributeResponseBodySecurityGroupIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> securityGroupId{};

  DescribeInstanceAttributeResponseBodySecurityGroupIds() {}

  explicit DescribeInstanceAttributeResponseBodySecurityGroupIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstanceAttributeResponseBodySecurityGroupIds() = default;
};
class DescribeInstanceAttributeResponseBodyPublicIpAddress : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ipAddress{};

  DescribeInstanceAttributeResponseBodyPublicIpAddress() {}

  explicit DescribeInstanceAttributeResponseBodyPublicIpAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipAddress = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstanceAttributeResponseBodyPublicIpAddress() = default;
};
class DescribeInstanceAttributeResponseBodyInnerIpAddress : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ipAddress{};

  DescribeInstanceAttributeResponseBodyInnerIpAddress() {}

  explicit DescribeInstanceAttributeResponseBodyInnerIpAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipAddress = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstanceAttributeResponseBodyInnerIpAddress() = default;
};
class DescribeInstanceAttributeResponseBodyVpcAttributesPrivateIpAddress : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ipAddress{};

  DescribeInstanceAttributeResponseBodyVpcAttributesPrivateIpAddress() {}

  explicit DescribeInstanceAttributeResponseBodyVpcAttributesPrivateIpAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipAddress = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstanceAttributeResponseBodyVpcAttributesPrivateIpAddress() = default;
};
class DescribeInstanceAttributeResponseBodyVpcAttributes : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<string> natIpAddress{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<DescribeInstanceAttributeResponseBodyVpcAttributesPrivateIpAddress> privateIpAddress{};

  DescribeInstanceAttributeResponseBodyVpcAttributes() {}

  explicit DescribeInstanceAttributeResponseBodyVpcAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (natIpAddress) {
      res["NatIpAddress"] = boost::any(*natIpAddress);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = privateIpAddress ? boost::any(privateIpAddress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("NatIpAddress") != m.end() && !m["NatIpAddress"].empty()) {
      natIpAddress = make_shared<string>(boost::any_cast<string>(m["NatIpAddress"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivateIpAddress"].type()) {
        DescribeInstanceAttributeResponseBodyVpcAttributesPrivateIpAddress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivateIpAddress"]));
        privateIpAddress = make_shared<DescribeInstanceAttributeResponseBodyVpcAttributesPrivateIpAddress>(model1);
      }
    }
  }


  virtual ~DescribeInstanceAttributeResponseBodyVpcAttributes() = default;
};
class DescribeInstanceAttributeResponseBodyEipAddress : public Darabonba::Model {
public:
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> ipAddress{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> allocationId{};

  DescribeInstanceAttributeResponseBodyEipAddress() {}

  explicit DescribeInstanceAttributeResponseBodyEipAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
  }


  virtual ~DescribeInstanceAttributeResponseBodyEipAddress() = default;
};
class DescribeInstanceAttributeResponseBodyDedicatedHostAttribute : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedHostName{};
  shared_ptr<string> dedicatedHostId{};

  DescribeInstanceAttributeResponseBodyDedicatedHostAttribute() {}

  explicit DescribeInstanceAttributeResponseBodyDedicatedHostAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostName) {
      res["DedicatedHostName"] = boost::any(*dedicatedHostName);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostName") != m.end() && !m["DedicatedHostName"].empty()) {
      dedicatedHostName = make_shared<string>(boost::any_cast<string>(m["DedicatedHostName"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
  }


  virtual ~DescribeInstanceAttributeResponseBodyDedicatedHostAttribute() = default;
};
class DescribeInstanceAttributeResponseBodyOperationLocksLockReason : public Darabonba::Model {
public:
  shared_ptr<string> lockReason{};

  DescribeInstanceAttributeResponseBodyOperationLocksLockReason() {}

  explicit DescribeInstanceAttributeResponseBodyOperationLocksLockReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
  }


  virtual ~DescribeInstanceAttributeResponseBodyOperationLocksLockReason() = default;
};
class DescribeInstanceAttributeResponseBodyOperationLocks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceAttributeResponseBodyOperationLocksLockReason>> lockReason{};

  DescribeInstanceAttributeResponseBodyOperationLocks() {}

  explicit DescribeInstanceAttributeResponseBodyOperationLocks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockReason) {
      vector<boost::any> temp1;
      for(auto item1:*lockReason){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LockReason"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      if (typeid(vector<boost::any>) == m["LockReason"].type()) {
        vector<DescribeInstanceAttributeResponseBodyOperationLocksLockReason> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LockReason"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceAttributeResponseBodyOperationLocksLockReason model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lockReason = make_shared<vector<DescribeInstanceAttributeResponseBodyOperationLocksLockReason>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceAttributeResponseBodyOperationLocks() = default;
};
class DescribeInstanceAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceNetworkType{};
  shared_ptr<long> memory{};
  shared_ptr<string> imageId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> vlanId{};
  shared_ptr<string> stoppedMode{};
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> internetMaxBandwidthIn{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> ioOptimized{};
  shared_ptr<long> cpu{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> creditSpecification{};
  shared_ptr<DescribeInstanceAttributeResponseBodySecurityGroupIds> securityGroupIds{};
  shared_ptr<DescribeInstanceAttributeResponseBodyPublicIpAddress> publicIpAddress{};
  shared_ptr<DescribeInstanceAttributeResponseBodyInnerIpAddress> innerIpAddress{};
  shared_ptr<DescribeInstanceAttributeResponseBodyVpcAttributes> vpcAttributes{};
  shared_ptr<DescribeInstanceAttributeResponseBodyEipAddress> eipAddress{};
  shared_ptr<DescribeInstanceAttributeResponseBodyDedicatedHostAttribute> dedicatedHostAttribute{};
  shared_ptr<DescribeInstanceAttributeResponseBodyOperationLocks> operationLocks{};

  DescribeInstanceAttributeResponseBody() {}

  explicit DescribeInstanceAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceNetworkType) {
      res["InstanceNetworkType"] = boost::any(*instanceNetworkType);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (vlanId) {
      res["VlanId"] = boost::any(*vlanId);
    }
    if (stoppedMode) {
      res["StoppedMode"] = boost::any(*stoppedMode);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (internetMaxBandwidthIn) {
      res["InternetMaxBandwidthIn"] = boost::any(*internetMaxBandwidthIn);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (creditSpecification) {
      res["CreditSpecification"] = boost::any(*creditSpecification);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = securityGroupIds ? boost::any(securityGroupIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (publicIpAddress) {
      res["PublicIpAddress"] = publicIpAddress ? boost::any(publicIpAddress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (innerIpAddress) {
      res["InnerIpAddress"] = innerIpAddress ? boost::any(innerIpAddress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcAttributes) {
      res["VpcAttributes"] = vpcAttributes ? boost::any(vpcAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (eipAddress) {
      res["EipAddress"] = eipAddress ? boost::any(eipAddress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dedicatedHostAttribute) {
      res["DedicatedHostAttribute"] = dedicatedHostAttribute ? boost::any(dedicatedHostAttribute->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (operationLocks) {
      res["OperationLocks"] = operationLocks ? boost::any(operationLocks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceNetworkType") != m.end() && !m["InstanceNetworkType"].empty()) {
      instanceNetworkType = make_shared<string>(boost::any_cast<string>(m["InstanceNetworkType"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("VlanId") != m.end() && !m["VlanId"].empty()) {
      vlanId = make_shared<string>(boost::any_cast<string>(m["VlanId"]));
    }
    if (m.find("StoppedMode") != m.end() && !m["StoppedMode"].empty()) {
      stoppedMode = make_shared<string>(boost::any_cast<string>(m["StoppedMode"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InternetMaxBandwidthIn") != m.end() && !m["InternetMaxBandwidthIn"].empty()) {
      internetMaxBandwidthIn = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthIn"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("CreditSpecification") != m.end() && !m["CreditSpecification"].empty()) {
      creditSpecification = make_shared<string>(boost::any_cast<string>(m["CreditSpecification"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityGroupIds"].type()) {
        DescribeInstanceAttributeResponseBodySecurityGroupIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityGroupIds"]));
        securityGroupIds = make_shared<DescribeInstanceAttributeResponseBodySecurityGroupIds>(model1);
      }
    }
    if (m.find("PublicIpAddress") != m.end() && !m["PublicIpAddress"].empty()) {
      if (typeid(map<string, boost::any>) == m["PublicIpAddress"].type()) {
        DescribeInstanceAttributeResponseBodyPublicIpAddress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PublicIpAddress"]));
        publicIpAddress = make_shared<DescribeInstanceAttributeResponseBodyPublicIpAddress>(model1);
      }
    }
    if (m.find("InnerIpAddress") != m.end() && !m["InnerIpAddress"].empty()) {
      if (typeid(map<string, boost::any>) == m["InnerIpAddress"].type()) {
        DescribeInstanceAttributeResponseBodyInnerIpAddress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InnerIpAddress"]));
        innerIpAddress = make_shared<DescribeInstanceAttributeResponseBodyInnerIpAddress>(model1);
      }
    }
    if (m.find("VpcAttributes") != m.end() && !m["VpcAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpcAttributes"].type()) {
        DescribeInstanceAttributeResponseBodyVpcAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpcAttributes"]));
        vpcAttributes = make_shared<DescribeInstanceAttributeResponseBodyVpcAttributes>(model1);
      }
    }
    if (m.find("EipAddress") != m.end() && !m["EipAddress"].empty()) {
      if (typeid(map<string, boost::any>) == m["EipAddress"].type()) {
        DescribeInstanceAttributeResponseBodyEipAddress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EipAddress"]));
        eipAddress = make_shared<DescribeInstanceAttributeResponseBodyEipAddress>(model1);
      }
    }
    if (m.find("DedicatedHostAttribute") != m.end() && !m["DedicatedHostAttribute"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedHostAttribute"].type()) {
        DescribeInstanceAttributeResponseBodyDedicatedHostAttribute model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedHostAttribute"]));
        dedicatedHostAttribute = make_shared<DescribeInstanceAttributeResponseBodyDedicatedHostAttribute>(model1);
      }
    }
    if (m.find("OperationLocks") != m.end() && !m["OperationLocks"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperationLocks"].type()) {
        DescribeInstanceAttributeResponseBodyOperationLocks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperationLocks"]));
        operationLocks = make_shared<DescribeInstanceAttributeResponseBodyOperationLocks>(model1);
      }
    }
  }


  virtual ~DescribeInstanceAttributeResponseBody() = default;
};
class DescribeInstanceAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstanceAttributeResponseBody> body{};

  DescribeInstanceAttributeResponse() {}

  explicit DescribeInstanceAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceAttributeResponse() = default;
};
class DescribeInstanceAutoRenewAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> renewalStatus{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> pageNumber{};

  DescribeInstanceAutoRenewAttributeRequest() {}

  explicit DescribeInstanceAutoRenewAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (renewalStatus) {
      res["RenewalStatus"] = boost::any(*renewalStatus);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RenewalStatus") != m.end() && !m["RenewalStatus"].empty()) {
      renewalStatus = make_shared<string>(boost::any_cast<string>(m["RenewalStatus"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
  }


  virtual ~DescribeInstanceAutoRenewAttributeRequest() = default;
};
class DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute : public Darabonba::Model {
public:
  shared_ptr<string> periodUnit{};
  shared_ptr<long> duration{};
  shared_ptr<string> renewalStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> autoRenewEnabled{};

  DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute() {}

  explicit DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (renewalStatus) {
      res["RenewalStatus"] = boost::any(*renewalStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (autoRenewEnabled) {
      res["AutoRenewEnabled"] = boost::any(*autoRenewEnabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("RenewalStatus") != m.end() && !m["RenewalStatus"].empty()) {
      renewalStatus = make_shared<string>(boost::any_cast<string>(m["RenewalStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("AutoRenewEnabled") != m.end() && !m["AutoRenewEnabled"].empty()) {
      autoRenewEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoRenewEnabled"]));
    }
  }


  virtual ~DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute() = default;
};
class DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute>> instanceRenewAttribute{};

  DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes() {}

  explicit DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceRenewAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*instanceRenewAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceRenewAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceRenewAttribute") != m.end() && !m["InstanceRenewAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceRenewAttribute"].type()) {
        vector<DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceRenewAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceRenewAttribute = make_shared<vector<DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes() = default;
};
class DescribeInstanceAutoRenewAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes> instanceRenewAttributes{};

  DescribeInstanceAutoRenewAttributeResponseBody() {}

  explicit DescribeInstanceAutoRenewAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (instanceRenewAttributes) {
      res["InstanceRenewAttributes"] = instanceRenewAttributes ? boost::any(instanceRenewAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("InstanceRenewAttributes") != m.end() && !m["InstanceRenewAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceRenewAttributes"].type()) {
        DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceRenewAttributes"]));
        instanceRenewAttributes = make_shared<DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes>(model1);
      }
    }
  }


  virtual ~DescribeInstanceAutoRenewAttributeResponseBody() = default;
};
class DescribeInstanceAutoRenewAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstanceAutoRenewAttributeResponseBody> body{};

  DescribeInstanceAutoRenewAttributeResponse() {}

  explicit DescribeInstanceAutoRenewAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceAutoRenewAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceAutoRenewAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceAutoRenewAttributeResponse() = default;
};
class DescribeInstanceHistoryEventsRequestNotBefore : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> end{};

  DescribeInstanceHistoryEventsRequestNotBefore() {}

  explicit DescribeInstanceHistoryEventsRequestNotBefore(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<string>(boost::any_cast<string>(m["End"]));
    }
  }


  virtual ~DescribeInstanceHistoryEventsRequestNotBefore() = default;
};
class DescribeInstanceHistoryEventsRequestEventPublishTime : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> end{};

  DescribeInstanceHistoryEventsRequestEventPublishTime() {}

  explicit DescribeInstanceHistoryEventsRequestEventPublishTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<string>(boost::any_cast<string>(m["End"]));
    }
  }


  virtual ~DescribeInstanceHistoryEventsRequestEventPublishTime() = default;
};
class DescribeInstanceHistoryEventsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeInstanceHistoryEventsRequestTag() {}

  explicit DescribeInstanceHistoryEventsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeInstanceHistoryEventsRequestTag() = default;
};
class DescribeInstanceHistoryEventsRequest : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceHistoryEventsRequestNotBefore> notBefore{};
  shared_ptr<DescribeInstanceHistoryEventsRequestEventPublishTime> eventPublishTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> eventCycleStatus{};
  shared_ptr<string> eventType{};
  shared_ptr<string> impactLevel{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> eventId{};
  shared_ptr<vector<string>> instanceEventCycleStatus{};
  shared_ptr<vector<string>> instanceEventType{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<vector<DescribeInstanceHistoryEventsRequestTag>> tag{};
  shared_ptr<string> resourceGroupId{};

  DescribeInstanceHistoryEventsRequest() {}

  explicit DescribeInstanceHistoryEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notBefore) {
      res["NotBefore"] = notBefore ? boost::any(notBefore->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (eventPublishTime) {
      res["EventPublishTime"] = eventPublishTime ? boost::any(eventPublishTime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (eventCycleStatus) {
      res["EventCycleStatus"] = boost::any(*eventCycleStatus);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (impactLevel) {
      res["ImpactLevel"] = boost::any(*impactLevel);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (instanceEventCycleStatus) {
      res["InstanceEventCycleStatus"] = boost::any(*instanceEventCycleStatus);
    }
    if (instanceEventType) {
      res["InstanceEventType"] = boost::any(*instanceEventType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotBefore") != m.end() && !m["NotBefore"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotBefore"].type()) {
        DescribeInstanceHistoryEventsRequestNotBefore model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotBefore"]));
        notBefore = make_shared<DescribeInstanceHistoryEventsRequestNotBefore>(model1);
      }
    }
    if (m.find("EventPublishTime") != m.end() && !m["EventPublishTime"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventPublishTime"].type()) {
        DescribeInstanceHistoryEventsRequestEventPublishTime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventPublishTime"]));
        eventPublishTime = make_shared<DescribeInstanceHistoryEventsRequestEventPublishTime>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("EventCycleStatus") != m.end() && !m["EventCycleStatus"].empty()) {
      eventCycleStatus = make_shared<string>(boost::any_cast<string>(m["EventCycleStatus"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("ImpactLevel") != m.end() && !m["ImpactLevel"].empty()) {
      impactLevel = make_shared<string>(boost::any_cast<string>(m["ImpactLevel"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EventId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EventId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eventId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceEventCycleStatus") != m.end() && !m["InstanceEventCycleStatus"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceEventCycleStatus"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceEventCycleStatus"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceEventCycleStatus = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceEventType") != m.end() && !m["InstanceEventType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceEventType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceEventType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceEventType = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeInstanceHistoryEventsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceHistoryEventsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeInstanceHistoryEventsRequestTag>>(expect1);
      }
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeInstanceHistoryEventsRequest() = default;
};
class DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeEventType : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> code{};

  DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeEventType() {}

  explicit DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeEventType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeEventType() = default;
};
class DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeEventCycleStatus : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> code{};

  DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeEventCycleStatus() {}

  explicit DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeEventCycleStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeEventCycleStatus() = default;
};
class DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeInactiveDisksInactiveDisk : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> deviceSize{};
  shared_ptr<string> deviceCategory{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> releaseTime{};

  DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeInactiveDisksInactiveDisk() {}

  explicit DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeInactiveDisksInactiveDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (deviceSize) {
      res["DeviceSize"] = boost::any(*deviceSize);
    }
    if (deviceCategory) {
      res["DeviceCategory"] = boost::any(*deviceCategory);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (releaseTime) {
      res["ReleaseTime"] = boost::any(*releaseTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DeviceSize") != m.end() && !m["DeviceSize"].empty()) {
      deviceSize = make_shared<string>(boost::any_cast<string>(m["DeviceSize"]));
    }
    if (m.find("DeviceCategory") != m.end() && !m["DeviceCategory"].empty()) {
      deviceCategory = make_shared<string>(boost::any_cast<string>(m["DeviceCategory"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("ReleaseTime") != m.end() && !m["ReleaseTime"].empty()) {
      releaseTime = make_shared<string>(boost::any_cast<string>(m["ReleaseTime"]));
    }
  }


  virtual ~DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeInactiveDisksInactiveDisk() = default;
};
class DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeInactiveDisks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeInactiveDisksInactiveDisk>> inactiveDisk{};

  DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeInactiveDisks() {}

  explicit DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeInactiveDisks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inactiveDisk) {
      vector<boost::any> temp1;
      for(auto item1:*inactiveDisk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InactiveDisk"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InactiveDisk") != m.end() && !m["InactiveDisk"].empty()) {
      if (typeid(vector<boost::any>) == m["InactiveDisk"].type()) {
        vector<DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeInactiveDisksInactiveDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InactiveDisk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeInactiveDisksInactiveDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inactiveDisk = make_shared<vector<DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeInactiveDisksInactiveDisk>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeInactiveDisks() = default;
};
class DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttribute : public Darabonba::Model {
public:
  shared_ptr<string> device{};
  shared_ptr<string> diskId{};
  shared_ptr<DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeInactiveDisks> inactiveDisks{};
  shared_ptr<string> hostType{};
  shared_ptr<string> hostId{};

  DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttribute() {}

  explicit DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (inactiveDisks) {
      res["InactiveDisks"] = inactiveDisks ? boost::any(inactiveDisks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hostType) {
      res["HostType"] = boost::any(*hostType);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("InactiveDisks") != m.end() && !m["InactiveDisks"].empty()) {
      if (typeid(map<string, boost::any>) == m["InactiveDisks"].type()) {
        DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeInactiveDisks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InactiveDisks"]));
        inactiveDisks = make_shared<DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeInactiveDisks>(model1);
      }
    }
    if (m.find("HostType") != m.end() && !m["HostType"].empty()) {
      hostType = make_shared<string>(boost::any_cast<string>(m["HostType"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
  }


  virtual ~DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttribute() = default;
};
class DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventType : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> eventPublishTime{};
  shared_ptr<string> eventFinishTime{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> impactLevel{};
  shared_ptr<string> notBefore{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> reason{};
  shared_ptr<DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeEventType> eventType{};
  shared_ptr<DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeEventCycleStatus> eventCycleStatus{};
  shared_ptr<DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttribute> extendedAttribute{};

  DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventType() {}

  explicit DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (eventPublishTime) {
      res["EventPublishTime"] = boost::any(*eventPublishTime);
    }
    if (eventFinishTime) {
      res["EventFinishTime"] = boost::any(*eventFinishTime);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (impactLevel) {
      res["ImpactLevel"] = boost::any(*impactLevel);
    }
    if (notBefore) {
      res["NotBefore"] = boost::any(*notBefore);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (eventType) {
      res["EventType"] = eventType ? boost::any(eventType->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (eventCycleStatus) {
      res["EventCycleStatus"] = eventCycleStatus ? boost::any(eventCycleStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extendedAttribute) {
      res["ExtendedAttribute"] = extendedAttribute ? boost::any(extendedAttribute->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("EventPublishTime") != m.end() && !m["EventPublishTime"].empty()) {
      eventPublishTime = make_shared<string>(boost::any_cast<string>(m["EventPublishTime"]));
    }
    if (m.find("EventFinishTime") != m.end() && !m["EventFinishTime"].empty()) {
      eventFinishTime = make_shared<string>(boost::any_cast<string>(m["EventFinishTime"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ImpactLevel") != m.end() && !m["ImpactLevel"].empty()) {
      impactLevel = make_shared<string>(boost::any_cast<string>(m["ImpactLevel"]));
    }
    if (m.find("NotBefore") != m.end() && !m["NotBefore"].empty()) {
      notBefore = make_shared<string>(boost::any_cast<string>(m["NotBefore"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventType"].type()) {
        DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeEventType model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventType"]));
        eventType = make_shared<DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeEventType>(model1);
      }
    }
    if (m.find("EventCycleStatus") != m.end() && !m["EventCycleStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventCycleStatus"].type()) {
        DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeEventCycleStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventCycleStatus"]));
        eventCycleStatus = make_shared<DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeEventCycleStatus>(model1);
      }
    }
    if (m.find("ExtendedAttribute") != m.end() && !m["ExtendedAttribute"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtendedAttribute"].type()) {
        DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttribute model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtendedAttribute"]));
        extendedAttribute = make_shared<DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttribute>(model1);
      }
    }
  }


  virtual ~DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventType() = default;
};
class DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventType>> instanceSystemEventType{};

  DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSet() {}

  explicit DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceSystemEventType) {
      vector<boost::any> temp1;
      for(auto item1:*instanceSystemEventType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceSystemEventType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceSystemEventType") != m.end() && !m["InstanceSystemEventType"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceSystemEventType"].type()) {
        vector<DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceSystemEventType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceSystemEventType = make_shared<vector<DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventType>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSet() = default;
};
class DescribeInstanceHistoryEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSet> instanceSystemEventSet{};

  DescribeInstanceHistoryEventsResponseBody() {}

  explicit DescribeInstanceHistoryEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (instanceSystemEventSet) {
      res["InstanceSystemEventSet"] = instanceSystemEventSet ? boost::any(instanceSystemEventSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("InstanceSystemEventSet") != m.end() && !m["InstanceSystemEventSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceSystemEventSet"].type()) {
        DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceSystemEventSet"]));
        instanceSystemEventSet = make_shared<DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSet>(model1);
      }
    }
  }


  virtual ~DescribeInstanceHistoryEventsResponseBody() = default;
};
class DescribeInstanceHistoryEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstanceHistoryEventsResponseBody> body{};

  DescribeInstanceHistoryEventsResponse() {}

  explicit DescribeInstanceHistoryEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceHistoryEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceHistoryEventsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceHistoryEventsResponse() = default;
};
class DescribeInstanceMaintenanceAttributesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeInstanceMaintenanceAttributesRequest() {}

  explicit DescribeInstanceMaintenanceAttributesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeInstanceMaintenanceAttributesRequest() = default;
};
class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindowsMaintenanceWindow : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindowsMaintenanceWindow() {}

  explicit DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindowsMaintenanceWindow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindowsMaintenanceWindow() = default;
};
class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindows : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindowsMaintenanceWindow>> maintenanceWindow{};

  DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindows() {}

  explicit DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindows(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maintenanceWindow) {
      vector<boost::any> temp1;
      for(auto item1:*maintenanceWindow){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MaintenanceWindow"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaintenanceWindow") != m.end() && !m["MaintenanceWindow"].empty()) {
      if (typeid(vector<boost::any>) == m["MaintenanceWindow"].type()) {
        vector<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindowsMaintenanceWindow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MaintenanceWindow"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindowsMaintenanceWindow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        maintenanceWindow = make_shared<vector<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindowsMaintenanceWindow>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindows() = default;
};
class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenanceSupportedValues : public Darabonba::Model {
public:
  shared_ptr<vector<string>> supportedValue{};

  DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenanceSupportedValues() {}

  explicit DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenanceSupportedValues(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportedValue) {
      res["SupportedValue"] = boost::any(*supportedValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportedValue") != m.end() && !m["SupportedValue"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportedValue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportedValue"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportedValue = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenanceSupportedValues() = default;
};
class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenance : public Darabonba::Model {
public:
  shared_ptr<string> defaultValue{};
  shared_ptr<string> value{};
  shared_ptr<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenanceSupportedValues> supportedValues{};

  DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenance() {}

  explicit DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (supportedValues) {
      res["SupportedValues"] = supportedValues ? boost::any(supportedValues->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("SupportedValues") != m.end() && !m["SupportedValues"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportedValues"].type()) {
        DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenanceSupportedValues model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportedValues"]));
        supportedValues = make_shared<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenanceSupportedValues>(model1);
      }
    }
  }


  virtual ~DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenance() = default;
};
class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttribute : public Darabonba::Model {
public:
  shared_ptr<bool> notifyOnMaintenance{};
  shared_ptr<string> instanceId{};
  shared_ptr<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindows> maintenanceWindows{};
  shared_ptr<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenance> actionOnMaintenance{};

  DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttribute() {}

  explicit DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notifyOnMaintenance) {
      res["NotifyOnMaintenance"] = boost::any(*notifyOnMaintenance);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maintenanceWindows) {
      res["MaintenanceWindows"] = maintenanceWindows ? boost::any(maintenanceWindows->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (actionOnMaintenance) {
      res["ActionOnMaintenance"] = actionOnMaintenance ? boost::any(actionOnMaintenance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotifyOnMaintenance") != m.end() && !m["NotifyOnMaintenance"].empty()) {
      notifyOnMaintenance = make_shared<bool>(boost::any_cast<bool>(m["NotifyOnMaintenance"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaintenanceWindows") != m.end() && !m["MaintenanceWindows"].empty()) {
      if (typeid(map<string, boost::any>) == m["MaintenanceWindows"].type()) {
        DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindows model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MaintenanceWindows"]));
        maintenanceWindows = make_shared<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindows>(model1);
      }
    }
    if (m.find("ActionOnMaintenance") != m.end() && !m["ActionOnMaintenance"].empty()) {
      if (typeid(map<string, boost::any>) == m["ActionOnMaintenance"].type()) {
        DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ActionOnMaintenance"]));
        actionOnMaintenance = make_shared<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenance>(model1);
      }
    }
  }


  virtual ~DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttribute() = default;
};
class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttribute>> maintenanceAttribute{};

  DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributes() {}

  explicit DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maintenanceAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*maintenanceAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MaintenanceAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaintenanceAttribute") != m.end() && !m["MaintenanceAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["MaintenanceAttribute"].type()) {
        vector<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MaintenanceAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        maintenanceAttribute = make_shared<vector<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributes() = default;
};
class DescribeInstanceMaintenanceAttributesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributes> maintenanceAttributes{};

  DescribeInstanceMaintenanceAttributesResponseBody() {}

  explicit DescribeInstanceMaintenanceAttributesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (maintenanceAttributes) {
      res["MaintenanceAttributes"] = maintenanceAttributes ? boost::any(maintenanceAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("MaintenanceAttributes") != m.end() && !m["MaintenanceAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["MaintenanceAttributes"].type()) {
        DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MaintenanceAttributes"]));
        maintenanceAttributes = make_shared<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributes>(model1);
      }
    }
  }


  virtual ~DescribeInstanceMaintenanceAttributesResponseBody() = default;
};
class DescribeInstanceMaintenanceAttributesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstanceMaintenanceAttributesResponseBody> body{};

  DescribeInstanceMaintenanceAttributesResponse() {}

  explicit DescribeInstanceMaintenanceAttributesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceMaintenanceAttributesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceMaintenanceAttributesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceMaintenanceAttributesResponse() = default;
};
class DescribeInstanceModificationPriceRequestSystemDisk : public Darabonba::Model {
public:
  shared_ptr<string> category{};

  DescribeInstanceModificationPriceRequestSystemDisk() {}

  explicit DescribeInstanceModificationPriceRequestSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
  }


  virtual ~DescribeInstanceModificationPriceRequestSystemDisk() = default;
};
class DescribeInstanceModificationPriceRequestDataDisk : public Darabonba::Model {
public:
  shared_ptr<string> performanceLevel{};
  shared_ptr<long> size{};
  shared_ptr<string> category{};

  DescribeInstanceModificationPriceRequestDataDisk() {}

  explicit DescribeInstanceModificationPriceRequestDataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
  }


  virtual ~DescribeInstanceModificationPriceRequestDataDisk() = default;
};
class DescribeInstanceModificationPriceRequest : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceModificationPriceRequestSystemDisk> systemDisk{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<vector<DescribeInstanceModificationPriceRequestDataDisk>> dataDisk{};

  DescribeInstanceModificationPriceRequest() {}

  explicit DescribeInstanceModificationPriceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (dataDisk) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisk"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        DescribeInstanceModificationPriceRequestSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<DescribeInstanceModificationPriceRequestSystemDisk>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisk"].type()) {
        vector<DescribeInstanceModificationPriceRequestDataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceModificationPriceRequestDataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisk = make_shared<vector<DescribeInstanceModificationPriceRequestDataDisk>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceModificationPriceRequest() = default;
};
class DescribeInstanceModificationPriceResponseBodyPriceInfoRulesRule : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> ruleId{};

  DescribeInstanceModificationPriceResponseBodyPriceInfoRulesRule() {}

  explicit DescribeInstanceModificationPriceResponseBodyPriceInfoRulesRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~DescribeInstanceModificationPriceResponseBodyPriceInfoRulesRule() = default;
};
class DescribeInstanceModificationPriceResponseBodyPriceInfoRules : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceModificationPriceResponseBodyPriceInfoRulesRule>> rule{};

  DescribeInstanceModificationPriceResponseBodyPriceInfoRules() {}

  explicit DescribeInstanceModificationPriceResponseBodyPriceInfoRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rule) {
      vector<boost::any> temp1;
      for(auto item1:*rule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(vector<boost::any>) == m["Rule"].type()) {
        vector<DescribeInstanceModificationPriceResponseBodyPriceInfoRulesRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceModificationPriceResponseBodyPriceInfoRulesRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rule = make_shared<vector<DescribeInstanceModificationPriceResponseBodyPriceInfoRulesRule>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceModificationPriceResponseBodyPriceInfoRules() = default;
};
class DescribeInstanceModificationPriceResponseBodyPriceInfoPrice : public Darabonba::Model {
public:
  shared_ptr<double> originalPrice{};
  shared_ptr<double> discountPrice{};
  shared_ptr<string> currency{};
  shared_ptr<double> tradePrice{};

  DescribeInstanceModificationPriceResponseBodyPriceInfoPrice() {}

  explicit DescribeInstanceModificationPriceResponseBodyPriceInfoPrice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<double>(boost::any_cast<double>(m["DiscountPrice"]));
    }
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
  }


  virtual ~DescribeInstanceModificationPriceResponseBodyPriceInfoPrice() = default;
};
class DescribeInstanceModificationPriceResponseBodyPriceInfo : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceModificationPriceResponseBodyPriceInfoRules> rules{};
  shared_ptr<DescribeInstanceModificationPriceResponseBodyPriceInfoPrice> price{};

  DescribeInstanceModificationPriceResponseBodyPriceInfo() {}

  explicit DescribeInstanceModificationPriceResponseBodyPriceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rules) {
      res["Rules"] = rules ? boost::any(rules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (price) {
      res["Price"] = price ? boost::any(price->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rules"].type()) {
        DescribeInstanceModificationPriceResponseBodyPriceInfoRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rules"]));
        rules = make_shared<DescribeInstanceModificationPriceResponseBodyPriceInfoRules>(model1);
      }
    }
    if (m.find("Price") != m.end() && !m["Price"].empty()) {
      if (typeid(map<string, boost::any>) == m["Price"].type()) {
        DescribeInstanceModificationPriceResponseBodyPriceInfoPrice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Price"]));
        price = make_shared<DescribeInstanceModificationPriceResponseBodyPriceInfoPrice>(model1);
      }
    }
  }


  virtual ~DescribeInstanceModificationPriceResponseBodyPriceInfo() = default;
};
class DescribeInstanceModificationPriceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeInstanceModificationPriceResponseBodyPriceInfo> priceInfo{};

  DescribeInstanceModificationPriceResponseBody() {}

  explicit DescribeInstanceModificationPriceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (priceInfo) {
      res["PriceInfo"] = priceInfo ? boost::any(priceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PriceInfo") != m.end() && !m["PriceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PriceInfo"].type()) {
        DescribeInstanceModificationPriceResponseBodyPriceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PriceInfo"]));
        priceInfo = make_shared<DescribeInstanceModificationPriceResponseBodyPriceInfo>(model1);
      }
    }
  }


  virtual ~DescribeInstanceModificationPriceResponseBody() = default;
};
class DescribeInstanceModificationPriceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstanceModificationPriceResponseBody> body{};

  DescribeInstanceModificationPriceResponse() {}

  explicit DescribeInstanceModificationPriceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceModificationPriceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceModificationPriceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceModificationPriceResponse() = default;
};
class DescribeInstanceMonitorDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> period{};

  DescribeInstanceMonitorDataRequest() {}

  explicit DescribeInstanceMonitorDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
  }


  virtual ~DescribeInstanceMonitorDataRequest() = default;
};
class DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData : public Darabonba::Model {
public:
  shared_ptr<double> CPUCreditBalance{};
  shared_ptr<long> BPSRead{};
  shared_ptr<long> internetTX{};
  shared_ptr<long> CPU{};
  shared_ptr<double> CPUCreditUsage{};
  shared_ptr<long> IOPSWrite{};
  shared_ptr<long> intranetTX{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> BPSWrite{};
  shared_ptr<double> CPUNotpaidSurplusCreditUsage{};
  shared_ptr<double> CPUAdvanceCreditBalance{};
  shared_ptr<long> IOPSRead{};
  shared_ptr<long> internetBandwidth{};
  shared_ptr<long> internetRX{};
  shared_ptr<string> timeStamp{};
  shared_ptr<long> intranetRX{};
  shared_ptr<long> intranetBandwidth{};

  DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData() {}

  explicit DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (CPUCreditBalance) {
      res["CPUCreditBalance"] = boost::any(*CPUCreditBalance);
    }
    if (BPSRead) {
      res["BPSRead"] = boost::any(*BPSRead);
    }
    if (internetTX) {
      res["InternetTX"] = boost::any(*internetTX);
    }
    if (CPU) {
      res["CPU"] = boost::any(*CPU);
    }
    if (CPUCreditUsage) {
      res["CPUCreditUsage"] = boost::any(*CPUCreditUsage);
    }
    if (IOPSWrite) {
      res["IOPSWrite"] = boost::any(*IOPSWrite);
    }
    if (intranetTX) {
      res["IntranetTX"] = boost::any(*intranetTX);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (BPSWrite) {
      res["BPSWrite"] = boost::any(*BPSWrite);
    }
    if (CPUNotpaidSurplusCreditUsage) {
      res["CPUNotpaidSurplusCreditUsage"] = boost::any(*CPUNotpaidSurplusCreditUsage);
    }
    if (CPUAdvanceCreditBalance) {
      res["CPUAdvanceCreditBalance"] = boost::any(*CPUAdvanceCreditBalance);
    }
    if (IOPSRead) {
      res["IOPSRead"] = boost::any(*IOPSRead);
    }
    if (internetBandwidth) {
      res["InternetBandwidth"] = boost::any(*internetBandwidth);
    }
    if (internetRX) {
      res["InternetRX"] = boost::any(*internetRX);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (intranetRX) {
      res["IntranetRX"] = boost::any(*intranetRX);
    }
    if (intranetBandwidth) {
      res["IntranetBandwidth"] = boost::any(*intranetBandwidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CPUCreditBalance") != m.end() && !m["CPUCreditBalance"].empty()) {
      CPUCreditBalance = make_shared<double>(boost::any_cast<double>(m["CPUCreditBalance"]));
    }
    if (m.find("BPSRead") != m.end() && !m["BPSRead"].empty()) {
      BPSRead = make_shared<long>(boost::any_cast<long>(m["BPSRead"]));
    }
    if (m.find("InternetTX") != m.end() && !m["InternetTX"].empty()) {
      internetTX = make_shared<long>(boost::any_cast<long>(m["InternetTX"]));
    }
    if (m.find("CPU") != m.end() && !m["CPU"].empty()) {
      CPU = make_shared<long>(boost::any_cast<long>(m["CPU"]));
    }
    if (m.find("CPUCreditUsage") != m.end() && !m["CPUCreditUsage"].empty()) {
      CPUCreditUsage = make_shared<double>(boost::any_cast<double>(m["CPUCreditUsage"]));
    }
    if (m.find("IOPSWrite") != m.end() && !m["IOPSWrite"].empty()) {
      IOPSWrite = make_shared<long>(boost::any_cast<long>(m["IOPSWrite"]));
    }
    if (m.find("IntranetTX") != m.end() && !m["IntranetTX"].empty()) {
      intranetTX = make_shared<long>(boost::any_cast<long>(m["IntranetTX"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("BPSWrite") != m.end() && !m["BPSWrite"].empty()) {
      BPSWrite = make_shared<long>(boost::any_cast<long>(m["BPSWrite"]));
    }
    if (m.find("CPUNotpaidSurplusCreditUsage") != m.end() && !m["CPUNotpaidSurplusCreditUsage"].empty()) {
      CPUNotpaidSurplusCreditUsage = make_shared<double>(boost::any_cast<double>(m["CPUNotpaidSurplusCreditUsage"]));
    }
    if (m.find("CPUAdvanceCreditBalance") != m.end() && !m["CPUAdvanceCreditBalance"].empty()) {
      CPUAdvanceCreditBalance = make_shared<double>(boost::any_cast<double>(m["CPUAdvanceCreditBalance"]));
    }
    if (m.find("IOPSRead") != m.end() && !m["IOPSRead"].empty()) {
      IOPSRead = make_shared<long>(boost::any_cast<long>(m["IOPSRead"]));
    }
    if (m.find("InternetBandwidth") != m.end() && !m["InternetBandwidth"].empty()) {
      internetBandwidth = make_shared<long>(boost::any_cast<long>(m["InternetBandwidth"]));
    }
    if (m.find("InternetRX") != m.end() && !m["InternetRX"].empty()) {
      internetRX = make_shared<long>(boost::any_cast<long>(m["InternetRX"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("IntranetRX") != m.end() && !m["IntranetRX"].empty()) {
      intranetRX = make_shared<long>(boost::any_cast<long>(m["IntranetRX"]));
    }
    if (m.find("IntranetBandwidth") != m.end() && !m["IntranetBandwidth"].empty()) {
      intranetBandwidth = make_shared<long>(boost::any_cast<long>(m["IntranetBandwidth"]));
    }
  }


  virtual ~DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData() = default;
};
class DescribeInstanceMonitorDataResponseBodyMonitorData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData>> instanceMonitorData{};

  DescribeInstanceMonitorDataResponseBodyMonitorData() {}

  explicit DescribeInstanceMonitorDataResponseBodyMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceMonitorData) {
      vector<boost::any> temp1;
      for(auto item1:*instanceMonitorData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceMonitorData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceMonitorData") != m.end() && !m["InstanceMonitorData"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceMonitorData"].type()) {
        vector<DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceMonitorData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceMonitorData = make_shared<vector<DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceMonitorDataResponseBodyMonitorData() = default;
};
class DescribeInstanceMonitorDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeInstanceMonitorDataResponseBodyMonitorData> monitorData{};

  DescribeInstanceMonitorDataResponseBody() {}

  explicit DescribeInstanceMonitorDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (monitorData) {
      res["MonitorData"] = monitorData ? boost::any(monitorData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("MonitorData") != m.end() && !m["MonitorData"].empty()) {
      if (typeid(map<string, boost::any>) == m["MonitorData"].type()) {
        DescribeInstanceMonitorDataResponseBodyMonitorData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MonitorData"]));
        monitorData = make_shared<DescribeInstanceMonitorDataResponseBodyMonitorData>(model1);
      }
    }
  }


  virtual ~DescribeInstanceMonitorDataResponseBody() = default;
};
class DescribeInstanceMonitorDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstanceMonitorDataResponseBody> body{};

  DescribeInstanceMonitorDataResponse() {}

  explicit DescribeInstanceMonitorDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceMonitorDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceMonitorDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceMonitorDataResponse() = default;
};
class DescribeInstanceRamRoleRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> ramRoleName{};

  DescribeInstanceRamRoleRequest() {}

  explicit DescribeInstanceRamRoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
  }


  virtual ~DescribeInstanceRamRoleRequest() = default;
};
class DescribeInstanceRamRoleResponseBodyInstanceRamRoleSetsInstanceRamRoleSet : public Darabonba::Model {
public:
  shared_ptr<string> ramRoleName{};
  shared_ptr<string> instanceId{};

  DescribeInstanceRamRoleResponseBodyInstanceRamRoleSetsInstanceRamRoleSet() {}

  explicit DescribeInstanceRamRoleResponseBodyInstanceRamRoleSetsInstanceRamRoleSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeInstanceRamRoleResponseBodyInstanceRamRoleSetsInstanceRamRoleSet() = default;
};
class DescribeInstanceRamRoleResponseBodyInstanceRamRoleSets : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceRamRoleResponseBodyInstanceRamRoleSetsInstanceRamRoleSet>> instanceRamRoleSet{};

  DescribeInstanceRamRoleResponseBodyInstanceRamRoleSets() {}

  explicit DescribeInstanceRamRoleResponseBodyInstanceRamRoleSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceRamRoleSet) {
      vector<boost::any> temp1;
      for(auto item1:*instanceRamRoleSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceRamRoleSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceRamRoleSet") != m.end() && !m["InstanceRamRoleSet"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceRamRoleSet"].type()) {
        vector<DescribeInstanceRamRoleResponseBodyInstanceRamRoleSetsInstanceRamRoleSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceRamRoleSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceRamRoleResponseBodyInstanceRamRoleSetsInstanceRamRoleSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceRamRoleSet = make_shared<vector<DescribeInstanceRamRoleResponseBodyInstanceRamRoleSetsInstanceRamRoleSet>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceRamRoleResponseBodyInstanceRamRoleSets() = default;
};
class DescribeInstanceRamRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeInstanceRamRoleResponseBodyInstanceRamRoleSets> instanceRamRoleSets{};

  DescribeInstanceRamRoleResponseBody() {}

  explicit DescribeInstanceRamRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceRamRoleSets) {
      res["InstanceRamRoleSets"] = instanceRamRoleSets ? boost::any(instanceRamRoleSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceRamRoleSets") != m.end() && !m["InstanceRamRoleSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceRamRoleSets"].type()) {
        DescribeInstanceRamRoleResponseBodyInstanceRamRoleSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceRamRoleSets"]));
        instanceRamRoleSets = make_shared<DescribeInstanceRamRoleResponseBodyInstanceRamRoleSets>(model1);
      }
    }
  }


  virtual ~DescribeInstanceRamRoleResponseBody() = default;
};
class DescribeInstanceRamRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstanceRamRoleResponseBody> body{};

  DescribeInstanceRamRoleResponse() {}

  explicit DescribeInstanceRamRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceRamRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceRamRoleResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceRamRoleResponse() = default;
};
class DescribeInstancesRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeInstancesRequestFilter() {}

  explicit DescribeInstancesRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeInstancesRequestFilter() = default;
};
class DescribeInstancesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeInstancesRequestTag() {}

  explicit DescribeInstancesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeInstancesRequestTag() = default;
};
class DescribeInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesRequestFilter>> filter{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> instanceNetworkType{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> instanceIds{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> innerIpAddresses{};
  shared_ptr<string> privateIpAddresses{};
  shared_ptr<string> publicIpAddresses{};
  shared_ptr<string> eipAddresses{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> imageId{};
  shared_ptr<string> status{};
  shared_ptr<string> lockReason{};
  shared_ptr<bool> deviceAvailable{};
  shared_ptr<bool> ioOptimized{};
  shared_ptr<bool> needSaleCycle{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> instanceTypeFamily{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> hpcClusterId{};
  shared_ptr<string> rdmaIpAddresses{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> httpEndpoint{};
  shared_ptr<string> httpTokens{};
  shared_ptr<long> httpPutResponseHopLimit{};
  shared_ptr<vector<string>> ipv6Address{};
  shared_ptr<vector<DescribeInstancesRequestTag>> tag{};
  shared_ptr<vector<string>> additionalAttributes{};

  DescribeInstancesRequest() {}

  explicit DescribeInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (instanceNetworkType) {
      res["InstanceNetworkType"] = boost::any(*instanceNetworkType);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (innerIpAddresses) {
      res["InnerIpAddresses"] = boost::any(*innerIpAddresses);
    }
    if (privateIpAddresses) {
      res["PrivateIpAddresses"] = boost::any(*privateIpAddresses);
    }
    if (publicIpAddresses) {
      res["PublicIpAddresses"] = boost::any(*publicIpAddresses);
    }
    if (eipAddresses) {
      res["EipAddresses"] = boost::any(*eipAddresses);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    if (deviceAvailable) {
      res["DeviceAvailable"] = boost::any(*deviceAvailable);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (needSaleCycle) {
      res["NeedSaleCycle"] = boost::any(*needSaleCycle);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (hpcClusterId) {
      res["HpcClusterId"] = boost::any(*hpcClusterId);
    }
    if (rdmaIpAddresses) {
      res["RdmaIpAddresses"] = boost::any(*rdmaIpAddresses);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (httpEndpoint) {
      res["HttpEndpoint"] = boost::any(*httpEndpoint);
    }
    if (httpTokens) {
      res["HttpTokens"] = boost::any(*httpTokens);
    }
    if (httpPutResponseHopLimit) {
      res["HttpPutResponseHopLimit"] = boost::any(*httpPutResponseHopLimit);
    }
    if (ipv6Address) {
      res["Ipv6Address"] = boost::any(*ipv6Address);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (additionalAttributes) {
      res["AdditionalAttributes"] = boost::any(*additionalAttributes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<DescribeInstancesRequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesRequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<DescribeInstancesRequestFilter>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("InstanceNetworkType") != m.end() && !m["InstanceNetworkType"].empty()) {
      instanceNetworkType = make_shared<string>(boost::any_cast<string>(m["InstanceNetworkType"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("InnerIpAddresses") != m.end() && !m["InnerIpAddresses"].empty()) {
      innerIpAddresses = make_shared<string>(boost::any_cast<string>(m["InnerIpAddresses"]));
    }
    if (m.find("PrivateIpAddresses") != m.end() && !m["PrivateIpAddresses"].empty()) {
      privateIpAddresses = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddresses"]));
    }
    if (m.find("PublicIpAddresses") != m.end() && !m["PublicIpAddresses"].empty()) {
      publicIpAddresses = make_shared<string>(boost::any_cast<string>(m["PublicIpAddresses"]));
    }
    if (m.find("EipAddresses") != m.end() && !m["EipAddresses"].empty()) {
      eipAddresses = make_shared<string>(boost::any_cast<string>(m["EipAddresses"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
    if (m.find("DeviceAvailable") != m.end() && !m["DeviceAvailable"].empty()) {
      deviceAvailable = make_shared<bool>(boost::any_cast<bool>(m["DeviceAvailable"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<bool>(boost::any_cast<bool>(m["IoOptimized"]));
    }
    if (m.find("NeedSaleCycle") != m.end() && !m["NeedSaleCycle"].empty()) {
      needSaleCycle = make_shared<bool>(boost::any_cast<bool>(m["NeedSaleCycle"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      instanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamily"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("HpcClusterId") != m.end() && !m["HpcClusterId"].empty()) {
      hpcClusterId = make_shared<string>(boost::any_cast<string>(m["HpcClusterId"]));
    }
    if (m.find("RdmaIpAddresses") != m.end() && !m["RdmaIpAddresses"].empty()) {
      rdmaIpAddresses = make_shared<string>(boost::any_cast<string>(m["RdmaIpAddresses"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("HttpEndpoint") != m.end() && !m["HttpEndpoint"].empty()) {
      httpEndpoint = make_shared<string>(boost::any_cast<string>(m["HttpEndpoint"]));
    }
    if (m.find("HttpTokens") != m.end() && !m["HttpTokens"].empty()) {
      httpTokens = make_shared<string>(boost::any_cast<string>(m["HttpTokens"]));
    }
    if (m.find("HttpPutResponseHopLimit") != m.end() && !m["HttpPutResponseHopLimit"].empty()) {
      httpPutResponseHopLimit = make_shared<long>(boost::any_cast<long>(m["HttpPutResponseHopLimit"]));
    }
    if (m.find("Ipv6Address") != m.end() && !m["Ipv6Address"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ipv6Address"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ipv6Address"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipv6Address = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeInstancesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeInstancesRequestTag>>(expect1);
      }
    }
    if (m.find("AdditionalAttributes") != m.end() && !m["AdditionalAttributes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AdditionalAttributes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AdditionalAttributes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      additionalAttributes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstancesRequest() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacePrivateIpSetsPrivateIpSet : public Darabonba::Model {
public:
  shared_ptr<string> privateIpAddress{};
  shared_ptr<bool> primary{};

  DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacePrivateIpSetsPrivateIpSet() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacePrivateIpSetsPrivateIpSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (primary) {
      res["Primary"] = boost::any(*primary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("Primary") != m.end() && !m["Primary"].empty()) {
      primary = make_shared<bool>(boost::any_cast<bool>(m["Primary"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacePrivateIpSetsPrivateIpSet() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacePrivateIpSets : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacePrivateIpSetsPrivateIpSet>> privateIpSet{};

  DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacePrivateIpSets() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacePrivateIpSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateIpSet) {
      vector<boost::any> temp1;
      for(auto item1:*privateIpSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrivateIpSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateIpSet") != m.end() && !m["PrivateIpSet"].empty()) {
      if (typeid(vector<boost::any>) == m["PrivateIpSet"].type()) {
        vector<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacePrivateIpSetsPrivateIpSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrivateIpSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacePrivateIpSetsPrivateIpSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        privateIpSet = make_shared<vector<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacePrivateIpSetsPrivateIpSet>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacePrivateIpSets() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6SetsIpv6Set : public Darabonba::Model {
public:
  shared_ptr<string> ipv6Address{};

  DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6SetsIpv6Set() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6SetsIpv6Set(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6Address) {
      res["Ipv6Address"] = boost::any(*ipv6Address);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6Address") != m.end() && !m["Ipv6Address"].empty()) {
      ipv6Address = make_shared<string>(boost::any_cast<string>(m["Ipv6Address"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6SetsIpv6Set() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6Sets : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6SetsIpv6Set>> ipv6Set{};

  DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6Sets() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6Sets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6Set) {
      vector<boost::any> temp1;
      for(auto item1:*ipv6Set){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv6Set"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6Set") != m.end() && !m["Ipv6Set"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv6Set"].type()) {
        vector<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6SetsIpv6Set> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv6Set"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6SetsIpv6Set model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv6Set = make_shared<vector<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6SetsIpv6Set>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6Sets() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterface : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> macAddress{};
  shared_ptr<string> primaryIpAddress{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacePrivateIpSets> privateIpSets{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6Sets> ipv6Sets{};

  DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterface() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterface(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (macAddress) {
      res["MacAddress"] = boost::any(*macAddress);
    }
    if (primaryIpAddress) {
      res["PrimaryIpAddress"] = boost::any(*primaryIpAddress);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (privateIpSets) {
      res["PrivateIpSets"] = privateIpSets ? boost::any(privateIpSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipv6Sets) {
      res["Ipv6Sets"] = ipv6Sets ? boost::any(ipv6Sets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("MacAddress") != m.end() && !m["MacAddress"].empty()) {
      macAddress = make_shared<string>(boost::any_cast<string>(m["MacAddress"]));
    }
    if (m.find("PrimaryIpAddress") != m.end() && !m["PrimaryIpAddress"].empty()) {
      primaryIpAddress = make_shared<string>(boost::any_cast<string>(m["PrimaryIpAddress"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("PrivateIpSets") != m.end() && !m["PrivateIpSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivateIpSets"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacePrivateIpSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivateIpSets"]));
        privateIpSets = make_shared<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacePrivateIpSets>(model1);
      }
    }
    if (m.find("Ipv6Sets") != m.end() && !m["Ipv6Sets"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ipv6Sets"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6Sets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ipv6Sets"]));
        ipv6Sets = make_shared<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6Sets>(model1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterface() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfaces : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterface>> networkInterface{};

  DescribeInstancesResponseBodyInstancesInstanceNetworkInterfaces() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceNetworkInterfaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterface) {
      vector<boost::any> temp1;
      for(auto item1:*networkInterface){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkInterface"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterface") != m.end() && !m["NetworkInterface"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkInterface"].type()) {
        vector<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterface> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkInterface"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterface model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkInterface = make_shared<vector<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterface>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceNetworkInterfaces() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceOperationLocksLockReason : public Darabonba::Model {
public:
  shared_ptr<string> lockMsg{};
  shared_ptr<string> lockReason{};

  DescribeInstancesResponseBodyInstancesInstanceOperationLocksLockReason() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceOperationLocksLockReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockMsg) {
      res["LockMsg"] = boost::any(*lockMsg);
    }
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockMsg") != m.end() && !m["LockMsg"].empty()) {
      lockMsg = make_shared<string>(boost::any_cast<string>(m["LockMsg"]));
    }
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceOperationLocksLockReason() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceOperationLocks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstancesInstanceOperationLocksLockReason>> lockReason{};

  DescribeInstancesResponseBodyInstancesInstanceOperationLocks() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceOperationLocks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockReason) {
      vector<boost::any> temp1;
      for(auto item1:*lockReason){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LockReason"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      if (typeid(vector<boost::any>) == m["LockReason"].type()) {
        vector<DescribeInstancesResponseBodyInstancesInstanceOperationLocksLockReason> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LockReason"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstancesInstanceOperationLocksLockReason model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lockReason = make_shared<vector<DescribeInstancesResponseBodyInstancesInstanceOperationLocksLockReason>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceOperationLocks() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  DescribeInstancesResponseBodyInstancesInstanceTagsTag() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceTagsTag() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstancesInstanceTagsTag>> tag{};

  DescribeInstancesResponseBodyInstancesInstanceTags() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeInstancesResponseBodyInstancesInstanceTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstancesInstanceTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeInstancesResponseBodyInstancesInstanceTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceTags() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceRdmaIpAddress : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ipAddress{};

  DescribeInstancesResponseBodyInstancesInstanceRdmaIpAddress() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceRdmaIpAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipAddress = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceRdmaIpAddress() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> securityGroupId{};

  DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds() = default;
};
class DescribeInstancesResponseBodyInstancesInstancePublicIpAddress : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ipAddress{};

  DescribeInstancesResponseBodyInstancesInstancePublicIpAddress() {}

  explicit DescribeInstancesResponseBodyInstancesInstancePublicIpAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipAddress = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstancePublicIpAddress() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ipAddress{};

  DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipAddress = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceVpcAttributesPrivateIpAddress : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ipAddress{};

  DescribeInstancesResponseBodyInstancesInstanceVpcAttributesPrivateIpAddress() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceVpcAttributesPrivateIpAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipAddress = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceVpcAttributesPrivateIpAddress() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceVpcAttributes : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<string> natIpAddress{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceVpcAttributesPrivateIpAddress> privateIpAddress{};

  DescribeInstancesResponseBodyInstancesInstanceVpcAttributes() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceVpcAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (natIpAddress) {
      res["NatIpAddress"] = boost::any(*natIpAddress);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = privateIpAddress ? boost::any(privateIpAddress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("NatIpAddress") != m.end() && !m["NatIpAddress"].empty()) {
      natIpAddress = make_shared<string>(boost::any_cast<string>(m["NatIpAddress"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivateIpAddress"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceVpcAttributesPrivateIpAddress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivateIpAddress"]));
        privateIpAddress = make_shared<DescribeInstancesResponseBodyInstancesInstanceVpcAttributesPrivateIpAddress>(model1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceVpcAttributes() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceEipAddress : public Darabonba::Model {
public:
  shared_ptr<bool> isSupportUnassociate{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> ipAddress{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> allocationId{};

  DescribeInstancesResponseBodyInstancesInstanceEipAddress() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceEipAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSupportUnassociate) {
      res["IsSupportUnassociate"] = boost::any(*isSupportUnassociate);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSupportUnassociate") != m.end() && !m["IsSupportUnassociate"].empty()) {
      isSupportUnassociate = make_shared<bool>(boost::any_cast<bool>(m["IsSupportUnassociate"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceEipAddress() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceHibernationOptions : public Darabonba::Model {
public:
  shared_ptr<bool> configured{};

  DescribeInstancesResponseBodyInstancesInstanceHibernationOptions() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceHibernationOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configured) {
      res["Configured"] = boost::any(*configured);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configured") != m.end() && !m["Configured"].empty()) {
      configured = make_shared<bool>(boost::any_cast<bool>(m["Configured"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceHibernationOptions() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceDedicatedHostAttribute : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> dedicatedHostName{};
  shared_ptr<string> dedicatedHostClusterId{};

  DescribeInstancesResponseBodyInstancesInstanceDedicatedHostAttribute() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceDedicatedHostAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (dedicatedHostName) {
      res["DedicatedHostName"] = boost::any(*dedicatedHostName);
    }
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("DedicatedHostName") != m.end() && !m["DedicatedHostName"].empty()) {
      dedicatedHostName = make_shared<string>(boost::any_cast<string>(m["DedicatedHostName"]));
    }
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceDedicatedHostAttribute() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceEcsCapacityReservationAttr : public Darabonba::Model {
public:
  shared_ptr<string> capacityReservationPreference{};
  shared_ptr<string> capacityReservationId{};

  DescribeInstancesResponseBodyInstancesInstanceEcsCapacityReservationAttr() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceEcsCapacityReservationAttr(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacityReservationPreference) {
      res["CapacityReservationPreference"] = boost::any(*capacityReservationPreference);
    }
    if (capacityReservationId) {
      res["CapacityReservationId"] = boost::any(*capacityReservationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CapacityReservationPreference") != m.end() && !m["CapacityReservationPreference"].empty()) {
      capacityReservationPreference = make_shared<string>(boost::any_cast<string>(m["CapacityReservationPreference"]));
    }
    if (m.find("CapacityReservationId") != m.end() && !m["CapacityReservationId"].empty()) {
      capacityReservationId = make_shared<string>(boost::any_cast<string>(m["CapacityReservationId"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceEcsCapacityReservationAttr() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceDedicatedInstanceAttribute : public Darabonba::Model {
public:
  shared_ptr<string> affinity{};
  shared_ptr<string> tenancy{};

  DescribeInstancesResponseBodyInstancesInstanceDedicatedInstanceAttribute() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceDedicatedInstanceAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affinity) {
      res["Affinity"] = boost::any(*affinity);
    }
    if (tenancy) {
      res["Tenancy"] = boost::any(*tenancy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Affinity") != m.end() && !m["Affinity"].empty()) {
      affinity = make_shared<string>(boost::any_cast<string>(m["Affinity"]));
    }
    if (m.find("Tenancy") != m.end() && !m["Tenancy"].empty()) {
      tenancy = make_shared<string>(boost::any_cast<string>(m["Tenancy"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceDedicatedInstanceAttribute() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceCpuOptions : public Darabonba::Model {
public:
  shared_ptr<string> numa{};
  shared_ptr<long> coreCount{};
  shared_ptr<long> threadsPerCore{};

  DescribeInstancesResponseBodyInstancesInstanceCpuOptions() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceCpuOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (numa) {
      res["Numa"] = boost::any(*numa);
    }
    if (coreCount) {
      res["CoreCount"] = boost::any(*coreCount);
    }
    if (threadsPerCore) {
      res["ThreadsPerCore"] = boost::any(*threadsPerCore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Numa") != m.end() && !m["Numa"].empty()) {
      numa = make_shared<string>(boost::any_cast<string>(m["Numa"]));
    }
    if (m.find("CoreCount") != m.end() && !m["CoreCount"].empty()) {
      coreCount = make_shared<long>(boost::any_cast<long>(m["CoreCount"]));
    }
    if (m.find("ThreadsPerCore") != m.end() && !m["ThreadsPerCore"].empty()) {
      threadsPerCore = make_shared<long>(boost::any_cast<long>(m["ThreadsPerCore"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceCpuOptions() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceMetadataOptions : public Darabonba::Model {
public:
  shared_ptr<string> httpEndpoint{};
  shared_ptr<long> httpPutResponseHopLimit{};
  shared_ptr<string> httpTokens{};

  DescribeInstancesResponseBodyInstancesInstanceMetadataOptions() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceMetadataOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpEndpoint) {
      res["HttpEndpoint"] = boost::any(*httpEndpoint);
    }
    if (httpPutResponseHopLimit) {
      res["HttpPutResponseHopLimit"] = boost::any(*httpPutResponseHopLimit);
    }
    if (httpTokens) {
      res["HttpTokens"] = boost::any(*httpTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpEndpoint") != m.end() && !m["HttpEndpoint"].empty()) {
      httpEndpoint = make_shared<string>(boost::any_cast<string>(m["HttpEndpoint"]));
    }
    if (m.find("HttpPutResponseHopLimit") != m.end() && !m["HttpPutResponseHopLimit"].empty()) {
      httpPutResponseHopLimit = make_shared<long>(boost::any_cast<long>(m["HttpPutResponseHopLimit"]));
    }
    if (m.find("HttpTokens") != m.end() && !m["HttpTokens"].empty()) {
      httpTokens = make_shared<string>(boost::any_cast<string>(m["HttpTokens"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceMetadataOptions() = default;
};
class DescribeInstancesResponseBodyInstancesInstance : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> status{};
  shared_ptr<string> deploymentSetId{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> saleCycle{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<bool> deviceAvailable{};
  shared_ptr<long> localStorageCapacity{};
  shared_ptr<string> description{};
  shared_ptr<long> spotDuration{};
  shared_ptr<string> instanceNetworkType{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> OSNameEn{};
  shared_ptr<string> hpcClusterId{};
  shared_ptr<double> spotPriceLimit{};
  shared_ptr<long> memory{};
  shared_ptr<string> OSName{};
  shared_ptr<long> deploymentSetGroupNo{};
  shared_ptr<string> imageId{};
  shared_ptr<string> vlanId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> GPUSpec{};
  shared_ptr<string> autoReleaseTime{};
  shared_ptr<bool> deletionProtection{};
  shared_ptr<string> stoppedMode{};
  shared_ptr<long> GPUAmount{};
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<long> internetMaxBandwidthIn{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> ioOptimized{};
  shared_ptr<string> startTime{};
  shared_ptr<long> cpu{};
  shared_ptr<long> localStorageAmount{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> zoneId{};
  shared_ptr<bool> recyclable{};
  shared_ptr<string> ISP{};
  shared_ptr<string> creditSpecification{};
  shared_ptr<string> instanceTypeFamily{};
  shared_ptr<string> OSType{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfaces> networkInterfaces{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceOperationLocks> operationLocks{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceTags> tags{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceRdmaIpAddress> rdmaIpAddress{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds> securityGroupIds{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstancePublicIpAddress> publicIpAddress{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress> innerIpAddress{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceVpcAttributes> vpcAttributes{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceEipAddress> eipAddress{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceHibernationOptions> hibernationOptions{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceDedicatedHostAttribute> dedicatedHostAttribute{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceEcsCapacityReservationAttr> ecsCapacityReservationAttr{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceDedicatedInstanceAttribute> dedicatedInstanceAttribute{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceCpuOptions> cpuOptions{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceMetadataOptions> metadataOptions{};

  DescribeInstancesResponseBodyInstancesInstance() {}

  explicit DescribeInstancesResponseBodyInstancesInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (deploymentSetId) {
      res["DeploymentSetId"] = boost::any(*deploymentSetId);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (saleCycle) {
      res["SaleCycle"] = boost::any(*saleCycle);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (deviceAvailable) {
      res["DeviceAvailable"] = boost::any(*deviceAvailable);
    }
    if (localStorageCapacity) {
      res["LocalStorageCapacity"] = boost::any(*localStorageCapacity);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (spotDuration) {
      res["SpotDuration"] = boost::any(*spotDuration);
    }
    if (instanceNetworkType) {
      res["InstanceNetworkType"] = boost::any(*instanceNetworkType);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (OSNameEn) {
      res["OSNameEn"] = boost::any(*OSNameEn);
    }
    if (hpcClusterId) {
      res["HpcClusterId"] = boost::any(*hpcClusterId);
    }
    if (spotPriceLimit) {
      res["SpotPriceLimit"] = boost::any(*spotPriceLimit);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (OSName) {
      res["OSName"] = boost::any(*OSName);
    }
    if (deploymentSetGroupNo) {
      res["DeploymentSetGroupNo"] = boost::any(*deploymentSetGroupNo);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (vlanId) {
      res["VlanId"] = boost::any(*vlanId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (GPUSpec) {
      res["GPUSpec"] = boost::any(*GPUSpec);
    }
    if (autoReleaseTime) {
      res["AutoReleaseTime"] = boost::any(*autoReleaseTime);
    }
    if (deletionProtection) {
      res["DeletionProtection"] = boost::any(*deletionProtection);
    }
    if (stoppedMode) {
      res["StoppedMode"] = boost::any(*stoppedMode);
    }
    if (GPUAmount) {
      res["GPUAmount"] = boost::any(*GPUAmount);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (internetMaxBandwidthIn) {
      res["InternetMaxBandwidthIn"] = boost::any(*internetMaxBandwidthIn);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (localStorageAmount) {
      res["LocalStorageAmount"] = boost::any(*localStorageAmount);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (recyclable) {
      res["Recyclable"] = boost::any(*recyclable);
    }
    if (ISP) {
      res["ISP"] = boost::any(*ISP);
    }
    if (creditSpecification) {
      res["CreditSpecification"] = boost::any(*creditSpecification);
    }
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    if (OSType) {
      res["OSType"] = boost::any(*OSType);
    }
    if (networkInterfaces) {
      res["NetworkInterfaces"] = networkInterfaces ? boost::any(networkInterfaces->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (operationLocks) {
      res["OperationLocks"] = operationLocks ? boost::any(operationLocks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rdmaIpAddress) {
      res["RdmaIpAddress"] = rdmaIpAddress ? boost::any(rdmaIpAddress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = securityGroupIds ? boost::any(securityGroupIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (publicIpAddress) {
      res["PublicIpAddress"] = publicIpAddress ? boost::any(publicIpAddress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (innerIpAddress) {
      res["InnerIpAddress"] = innerIpAddress ? boost::any(innerIpAddress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcAttributes) {
      res["VpcAttributes"] = vpcAttributes ? boost::any(vpcAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (eipAddress) {
      res["EipAddress"] = eipAddress ? boost::any(eipAddress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hibernationOptions) {
      res["HibernationOptions"] = hibernationOptions ? boost::any(hibernationOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dedicatedHostAttribute) {
      res["DedicatedHostAttribute"] = dedicatedHostAttribute ? boost::any(dedicatedHostAttribute->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ecsCapacityReservationAttr) {
      res["EcsCapacityReservationAttr"] = ecsCapacityReservationAttr ? boost::any(ecsCapacityReservationAttr->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dedicatedInstanceAttribute) {
      res["DedicatedInstanceAttribute"] = dedicatedInstanceAttribute ? boost::any(dedicatedInstanceAttribute->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cpuOptions) {
      res["CpuOptions"] = cpuOptions ? boost::any(cpuOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (metadataOptions) {
      res["MetadataOptions"] = metadataOptions ? boost::any(metadataOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("DeploymentSetId") != m.end() && !m["DeploymentSetId"].empty()) {
      deploymentSetId = make_shared<string>(boost::any_cast<string>(m["DeploymentSetId"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("SaleCycle") != m.end() && !m["SaleCycle"].empty()) {
      saleCycle = make_shared<string>(boost::any_cast<string>(m["SaleCycle"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("DeviceAvailable") != m.end() && !m["DeviceAvailable"].empty()) {
      deviceAvailable = make_shared<bool>(boost::any_cast<bool>(m["DeviceAvailable"]));
    }
    if (m.find("LocalStorageCapacity") != m.end() && !m["LocalStorageCapacity"].empty()) {
      localStorageCapacity = make_shared<long>(boost::any_cast<long>(m["LocalStorageCapacity"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SpotDuration") != m.end() && !m["SpotDuration"].empty()) {
      spotDuration = make_shared<long>(boost::any_cast<long>(m["SpotDuration"]));
    }
    if (m.find("InstanceNetworkType") != m.end() && !m["InstanceNetworkType"].empty()) {
      instanceNetworkType = make_shared<string>(boost::any_cast<string>(m["InstanceNetworkType"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("OSNameEn") != m.end() && !m["OSNameEn"].empty()) {
      OSNameEn = make_shared<string>(boost::any_cast<string>(m["OSNameEn"]));
    }
    if (m.find("HpcClusterId") != m.end() && !m["HpcClusterId"].empty()) {
      hpcClusterId = make_shared<string>(boost::any_cast<string>(m["HpcClusterId"]));
    }
    if (m.find("SpotPriceLimit") != m.end() && !m["SpotPriceLimit"].empty()) {
      spotPriceLimit = make_shared<double>(boost::any_cast<double>(m["SpotPriceLimit"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("OSName") != m.end() && !m["OSName"].empty()) {
      OSName = make_shared<string>(boost::any_cast<string>(m["OSName"]));
    }
    if (m.find("DeploymentSetGroupNo") != m.end() && !m["DeploymentSetGroupNo"].empty()) {
      deploymentSetGroupNo = make_shared<long>(boost::any_cast<long>(m["DeploymentSetGroupNo"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("VlanId") != m.end() && !m["VlanId"].empty()) {
      vlanId = make_shared<string>(boost::any_cast<string>(m["VlanId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("GPUSpec") != m.end() && !m["GPUSpec"].empty()) {
      GPUSpec = make_shared<string>(boost::any_cast<string>(m["GPUSpec"]));
    }
    if (m.find("AutoReleaseTime") != m.end() && !m["AutoReleaseTime"].empty()) {
      autoReleaseTime = make_shared<string>(boost::any_cast<string>(m["AutoReleaseTime"]));
    }
    if (m.find("DeletionProtection") != m.end() && !m["DeletionProtection"].empty()) {
      deletionProtection = make_shared<bool>(boost::any_cast<bool>(m["DeletionProtection"]));
    }
    if (m.find("StoppedMode") != m.end() && !m["StoppedMode"].empty()) {
      stoppedMode = make_shared<string>(boost::any_cast<string>(m["StoppedMode"]));
    }
    if (m.find("GPUAmount") != m.end() && !m["GPUAmount"].empty()) {
      GPUAmount = make_shared<long>(boost::any_cast<long>(m["GPUAmount"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("InternetMaxBandwidthIn") != m.end() && !m["InternetMaxBandwidthIn"].empty()) {
      internetMaxBandwidthIn = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthIn"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<bool>(boost::any_cast<bool>(m["IoOptimized"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("LocalStorageAmount") != m.end() && !m["LocalStorageAmount"].empty()) {
      localStorageAmount = make_shared<long>(boost::any_cast<long>(m["LocalStorageAmount"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("Recyclable") != m.end() && !m["Recyclable"].empty()) {
      recyclable = make_shared<bool>(boost::any_cast<bool>(m["Recyclable"]));
    }
    if (m.find("ISP") != m.end() && !m["ISP"].empty()) {
      ISP = make_shared<string>(boost::any_cast<string>(m["ISP"]));
    }
    if (m.find("CreditSpecification") != m.end() && !m["CreditSpecification"].empty()) {
      creditSpecification = make_shared<string>(boost::any_cast<string>(m["CreditSpecification"]));
    }
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      instanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamily"]));
    }
    if (m.find("OSType") != m.end() && !m["OSType"].empty()) {
      OSType = make_shared<string>(boost::any_cast<string>(m["OSType"]));
    }
    if (m.find("NetworkInterfaces") != m.end() && !m["NetworkInterfaces"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkInterfaces"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceNetworkInterfaces model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkInterfaces"]));
        networkInterfaces = make_shared<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfaces>(model1);
      }
    }
    if (m.find("OperationLocks") != m.end() && !m["OperationLocks"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperationLocks"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceOperationLocks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperationLocks"]));
        operationLocks = make_shared<DescribeInstancesResponseBodyInstancesInstanceOperationLocks>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeInstancesResponseBodyInstancesInstanceTags>(model1);
      }
    }
    if (m.find("RdmaIpAddress") != m.end() && !m["RdmaIpAddress"].empty()) {
      if (typeid(map<string, boost::any>) == m["RdmaIpAddress"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceRdmaIpAddress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RdmaIpAddress"]));
        rdmaIpAddress = make_shared<DescribeInstancesResponseBodyInstancesInstanceRdmaIpAddress>(model1);
      }
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityGroupIds"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityGroupIds"]));
        securityGroupIds = make_shared<DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds>(model1);
      }
    }
    if (m.find("PublicIpAddress") != m.end() && !m["PublicIpAddress"].empty()) {
      if (typeid(map<string, boost::any>) == m["PublicIpAddress"].type()) {
        DescribeInstancesResponseBodyInstancesInstancePublicIpAddress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PublicIpAddress"]));
        publicIpAddress = make_shared<DescribeInstancesResponseBodyInstancesInstancePublicIpAddress>(model1);
      }
    }
    if (m.find("InnerIpAddress") != m.end() && !m["InnerIpAddress"].empty()) {
      if (typeid(map<string, boost::any>) == m["InnerIpAddress"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InnerIpAddress"]));
        innerIpAddress = make_shared<DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress>(model1);
      }
    }
    if (m.find("VpcAttributes") != m.end() && !m["VpcAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpcAttributes"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceVpcAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpcAttributes"]));
        vpcAttributes = make_shared<DescribeInstancesResponseBodyInstancesInstanceVpcAttributes>(model1);
      }
    }
    if (m.find("EipAddress") != m.end() && !m["EipAddress"].empty()) {
      if (typeid(map<string, boost::any>) == m["EipAddress"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceEipAddress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EipAddress"]));
        eipAddress = make_shared<DescribeInstancesResponseBodyInstancesInstanceEipAddress>(model1);
      }
    }
    if (m.find("HibernationOptions") != m.end() && !m["HibernationOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["HibernationOptions"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceHibernationOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HibernationOptions"]));
        hibernationOptions = make_shared<DescribeInstancesResponseBodyInstancesInstanceHibernationOptions>(model1);
      }
    }
    if (m.find("DedicatedHostAttribute") != m.end() && !m["DedicatedHostAttribute"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedHostAttribute"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceDedicatedHostAttribute model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedHostAttribute"]));
        dedicatedHostAttribute = make_shared<DescribeInstancesResponseBodyInstancesInstanceDedicatedHostAttribute>(model1);
      }
    }
    if (m.find("EcsCapacityReservationAttr") != m.end() && !m["EcsCapacityReservationAttr"].empty()) {
      if (typeid(map<string, boost::any>) == m["EcsCapacityReservationAttr"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceEcsCapacityReservationAttr model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EcsCapacityReservationAttr"]));
        ecsCapacityReservationAttr = make_shared<DescribeInstancesResponseBodyInstancesInstanceEcsCapacityReservationAttr>(model1);
      }
    }
    if (m.find("DedicatedInstanceAttribute") != m.end() && !m["DedicatedInstanceAttribute"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedInstanceAttribute"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceDedicatedInstanceAttribute model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedInstanceAttribute"]));
        dedicatedInstanceAttribute = make_shared<DescribeInstancesResponseBodyInstancesInstanceDedicatedInstanceAttribute>(model1);
      }
    }
    if (m.find("CpuOptions") != m.end() && !m["CpuOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["CpuOptions"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceCpuOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CpuOptions"]));
        cpuOptions = make_shared<DescribeInstancesResponseBodyInstancesInstanceCpuOptions>(model1);
      }
    }
    if (m.find("MetadataOptions") != m.end() && !m["MetadataOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["MetadataOptions"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceMetadataOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MetadataOptions"]));
        metadataOptions = make_shared<DescribeInstancesResponseBodyInstancesInstanceMetadataOptions>(model1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstance() = default;
};
class DescribeInstancesResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstancesInstance>> instance{};

  DescribeInstancesResponseBodyInstances() {}

  explicit DescribeInstancesResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      vector<boost::any> temp1;
      for(auto item1:*instance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(vector<boost::any>) == m["Instance"].type()) {
        vector<DescribeInstancesResponseBodyInstancesInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstancesInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instance = make_shared<vector<DescribeInstancesResponseBodyInstancesInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstances() = default;
};
class DescribeInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeInstancesResponseBodyInstances> instances{};

  DescribeInstancesResponseBody() {}

  explicit DescribeInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (instances) {
      res["Instances"] = instances ? boost::any(instances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instances"].type()) {
        DescribeInstancesResponseBodyInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instances"]));
        instances = make_shared<DescribeInstancesResponseBodyInstances>(model1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBody() = default;
};
class DescribeInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstancesResponseBody> body{};

  DescribeInstancesResponse() {}

  explicit DescribeInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstancesResponse() = default;
};
class DescribeInstancesFullStatusRequestNotBefore : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> end{};

  DescribeInstancesFullStatusRequestNotBefore() {}

  explicit DescribeInstancesFullStatusRequestNotBefore(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<string>(boost::any_cast<string>(m["End"]));
    }
  }


  virtual ~DescribeInstancesFullStatusRequestNotBefore() = default;
};
class DescribeInstancesFullStatusRequestEventPublishTime : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> end{};

  DescribeInstancesFullStatusRequestEventPublishTime() {}

  explicit DescribeInstancesFullStatusRequestEventPublishTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<string>(boost::any_cast<string>(m["End"]));
    }
  }


  virtual ~DescribeInstancesFullStatusRequestEventPublishTime() = default;
};
class DescribeInstancesFullStatusRequest : public Darabonba::Model {
public:
  shared_ptr<DescribeInstancesFullStatusRequestNotBefore> notBefore{};
  shared_ptr<DescribeInstancesFullStatusRequestEventPublishTime> eventPublishTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<vector<string>> eventId{};
  shared_ptr<vector<string>> instanceEventType{};
  shared_ptr<string> status{};
  shared_ptr<string> healthStatus{};
  shared_ptr<string> eventType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeInstancesFullStatusRequest() {}

  explicit DescribeInstancesFullStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notBefore) {
      res["NotBefore"] = notBefore ? boost::any(notBefore->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (eventPublishTime) {
      res["EventPublishTime"] = eventPublishTime ? boost::any(eventPublishTime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (instanceEventType) {
      res["InstanceEventType"] = boost::any(*instanceEventType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotBefore") != m.end() && !m["NotBefore"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotBefore"].type()) {
        DescribeInstancesFullStatusRequestNotBefore model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotBefore"]));
        notBefore = make_shared<DescribeInstancesFullStatusRequestNotBefore>(model1);
      }
    }
    if (m.find("EventPublishTime") != m.end() && !m["EventPublishTime"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventPublishTime"].type()) {
        DescribeInstancesFullStatusRequestEventPublishTime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventPublishTime"]));
        eventPublishTime = make_shared<DescribeInstancesFullStatusRequestEventPublishTime>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EventId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EventId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eventId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceEventType") != m.end() && !m["InstanceEventType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceEventType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceEventType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceEventType = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeInstancesFullStatusRequest() = default;
};
class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeEventCycleStatus : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> code{};

  DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeEventCycleStatus() {}

  explicit DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeEventCycleStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeEventCycleStatus() = default;
};
class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeEventType : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> code{};

  DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeEventType() {}

  explicit DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeEventType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeEventType() = default;
};
class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttributeInactiveDisksInactiveDisk : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> deviceSize{};
  shared_ptr<string> deviceCategory{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> releaseTime{};

  DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttributeInactiveDisksInactiveDisk() {}

  explicit DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttributeInactiveDisksInactiveDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (deviceSize) {
      res["DeviceSize"] = boost::any(*deviceSize);
    }
    if (deviceCategory) {
      res["DeviceCategory"] = boost::any(*deviceCategory);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (releaseTime) {
      res["ReleaseTime"] = boost::any(*releaseTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DeviceSize") != m.end() && !m["DeviceSize"].empty()) {
      deviceSize = make_shared<string>(boost::any_cast<string>(m["DeviceSize"]));
    }
    if (m.find("DeviceCategory") != m.end() && !m["DeviceCategory"].empty()) {
      deviceCategory = make_shared<string>(boost::any_cast<string>(m["DeviceCategory"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("ReleaseTime") != m.end() && !m["ReleaseTime"].empty()) {
      releaseTime = make_shared<string>(boost::any_cast<string>(m["ReleaseTime"]));
    }
  }


  virtual ~DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttributeInactiveDisksInactiveDisk() = default;
};
class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttributeInactiveDisks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttributeInactiveDisksInactiveDisk>> inactiveDisk{};

  DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttributeInactiveDisks() {}

  explicit DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttributeInactiveDisks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inactiveDisk) {
      vector<boost::any> temp1;
      for(auto item1:*inactiveDisk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InactiveDisk"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InactiveDisk") != m.end() && !m["InactiveDisk"].empty()) {
      if (typeid(vector<boost::any>) == m["InactiveDisk"].type()) {
        vector<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttributeInactiveDisksInactiveDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InactiveDisk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttributeInactiveDisksInactiveDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inactiveDisk = make_shared<vector<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttributeInactiveDisksInactiveDisk>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttributeInactiveDisks() = default;
};
class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttribute : public Darabonba::Model {
public:
  shared_ptr<string> device{};
  shared_ptr<string> diskId{};
  shared_ptr<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttributeInactiveDisks> inactiveDisks{};

  DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttribute() {}

  explicit DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (inactiveDisks) {
      res["InactiveDisks"] = inactiveDisks ? boost::any(inactiveDisks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("InactiveDisks") != m.end() && !m["InactiveDisks"].empty()) {
      if (typeid(map<string, boost::any>) == m["InactiveDisks"].type()) {
        DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttributeInactiveDisks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InactiveDisks"]));
        inactiveDisks = make_shared<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttributeInactiveDisks>(model1);
      }
    }
  }


  virtual ~DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttribute() = default;
};
class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventType : public Darabonba::Model {
public:
  shared_ptr<string> eventPublishTime{};
  shared_ptr<string> eventId{};
  shared_ptr<string> notBefore{};
  shared_ptr<string> impactLevel{};
  shared_ptr<string> reason{};
  shared_ptr<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeEventCycleStatus> eventCycleStatus{};
  shared_ptr<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeEventType> eventType{};
  shared_ptr<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttribute> extendedAttribute{};

  DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventType() {}

  explicit DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventPublishTime) {
      res["EventPublishTime"] = boost::any(*eventPublishTime);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (notBefore) {
      res["NotBefore"] = boost::any(*notBefore);
    }
    if (impactLevel) {
      res["ImpactLevel"] = boost::any(*impactLevel);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (eventCycleStatus) {
      res["EventCycleStatus"] = eventCycleStatus ? boost::any(eventCycleStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (eventType) {
      res["EventType"] = eventType ? boost::any(eventType->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extendedAttribute) {
      res["ExtendedAttribute"] = extendedAttribute ? boost::any(extendedAttribute->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventPublishTime") != m.end() && !m["EventPublishTime"].empty()) {
      eventPublishTime = make_shared<string>(boost::any_cast<string>(m["EventPublishTime"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("NotBefore") != m.end() && !m["NotBefore"].empty()) {
      notBefore = make_shared<string>(boost::any_cast<string>(m["NotBefore"]));
    }
    if (m.find("ImpactLevel") != m.end() && !m["ImpactLevel"].empty()) {
      impactLevel = make_shared<string>(boost::any_cast<string>(m["ImpactLevel"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("EventCycleStatus") != m.end() && !m["EventCycleStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventCycleStatus"].type()) {
        DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeEventCycleStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventCycleStatus"]));
        eventCycleStatus = make_shared<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeEventCycleStatus>(model1);
      }
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventType"].type()) {
        DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeEventType model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventType"]));
        eventType = make_shared<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeEventType>(model1);
      }
    }
    if (m.find("ExtendedAttribute") != m.end() && !m["ExtendedAttribute"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtendedAttribute"].type()) {
        DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttribute model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtendedAttribute"]));
        extendedAttribute = make_shared<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttribute>(model1);
      }
    }
  }


  virtual ~DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventType() = default;
};
class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventType>> scheduledSystemEventType{};

  DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSet() {}

  explicit DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scheduledSystemEventType) {
      vector<boost::any> temp1;
      for(auto item1:*scheduledSystemEventType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScheduledSystemEventType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScheduledSystemEventType") != m.end() && !m["ScheduledSystemEventType"].empty()) {
      if (typeid(vector<boost::any>) == m["ScheduledSystemEventType"].type()) {
        vector<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScheduledSystemEventType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scheduledSystemEventType = make_shared<vector<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventType>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSet() = default;
};
class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeStatus : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> code{};

  DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeStatus() {}

  explicit DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeStatus() = default;
};
class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeHealthStatus : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> code{};

  DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeHealthStatus() {}

  explicit DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeHealthStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeHealthStatus() = default;
};
class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusType : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSet> scheduledSystemEventSet{};
  shared_ptr<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeStatus> status{};
  shared_ptr<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeHealthStatus> healthStatus{};

  DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusType() {}

  explicit DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scheduledSystemEventSet) {
      res["ScheduledSystemEventSet"] = scheduledSystemEventSet ? boost::any(scheduledSystemEventSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = status ? boost::any(status->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (healthStatus) {
      res["HealthStatus"] = healthStatus ? boost::any(healthStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScheduledSystemEventSet") != m.end() && !m["ScheduledSystemEventSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduledSystemEventSet"].type()) {
        DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduledSystemEventSet"]));
        scheduledSystemEventSet = make_shared<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSet>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      if (typeid(map<string, boost::any>) == m["Status"].type()) {
        DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Status"]));
        status = make_shared<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeStatus>(model1);
      }
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["HealthStatus"].type()) {
        DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeHealthStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HealthStatus"]));
        healthStatus = make_shared<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeHealthStatus>(model1);
      }
    }
  }


  virtual ~DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusType() = default;
};
class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusType>> instanceFullStatusType{};

  DescribeInstancesFullStatusResponseBodyInstanceFullStatusSet() {}

  explicit DescribeInstancesFullStatusResponseBodyInstanceFullStatusSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceFullStatusType) {
      vector<boost::any> temp1;
      for(auto item1:*instanceFullStatusType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceFullStatusType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceFullStatusType") != m.end() && !m["InstanceFullStatusType"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceFullStatusType"].type()) {
        vector<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceFullStatusType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceFullStatusType = make_shared<vector<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusType>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesFullStatusResponseBodyInstanceFullStatusSet() = default;
};
class DescribeInstancesFullStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSet> instanceFullStatusSet{};

  DescribeInstancesFullStatusResponseBody() {}

  explicit DescribeInstancesFullStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (instanceFullStatusSet) {
      res["InstanceFullStatusSet"] = instanceFullStatusSet ? boost::any(instanceFullStatusSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("InstanceFullStatusSet") != m.end() && !m["InstanceFullStatusSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceFullStatusSet"].type()) {
        DescribeInstancesFullStatusResponseBodyInstanceFullStatusSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceFullStatusSet"]));
        instanceFullStatusSet = make_shared<DescribeInstancesFullStatusResponseBodyInstanceFullStatusSet>(model1);
      }
    }
  }


  virtual ~DescribeInstancesFullStatusResponseBody() = default;
};
class DescribeInstancesFullStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstancesFullStatusResponseBody> body{};

  DescribeInstancesFullStatusResponse() {}

  explicit DescribeInstancesFullStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstancesFullStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstancesFullStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstancesFullStatusResponse() = default;
};
class DescribeInstanceStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<vector<string>> instanceId{};

  DescribeInstanceStatusRequest() {}

  explicit DescribeInstanceStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstanceStatusRequest() = default;
};
class DescribeInstanceStatusResponseBodyInstanceStatusesInstanceStatus : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> instanceId{};

  DescribeInstanceStatusResponseBodyInstanceStatusesInstanceStatus() {}

  explicit DescribeInstanceStatusResponseBodyInstanceStatusesInstanceStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeInstanceStatusResponseBodyInstanceStatusesInstanceStatus() = default;
};
class DescribeInstanceStatusResponseBodyInstanceStatuses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceStatusResponseBodyInstanceStatusesInstanceStatus>> instanceStatus{};

  DescribeInstanceStatusResponseBodyInstanceStatuses() {}

  explicit DescribeInstanceStatusResponseBodyInstanceStatuses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceStatus) {
      vector<boost::any> temp1;
      for(auto item1:*instanceStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceStatus"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceStatus") != m.end() && !m["InstanceStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceStatus"].type()) {
        vector<DescribeInstanceStatusResponseBodyInstanceStatusesInstanceStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceStatusResponseBodyInstanceStatusesInstanceStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceStatus = make_shared<vector<DescribeInstanceStatusResponseBodyInstanceStatusesInstanceStatus>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceStatusResponseBodyInstanceStatuses() = default;
};
class DescribeInstanceStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeInstanceStatusResponseBodyInstanceStatuses> instanceStatuses{};

  DescribeInstanceStatusResponseBody() {}

  explicit DescribeInstanceStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (instanceStatuses) {
      res["InstanceStatuses"] = instanceStatuses ? boost::any(instanceStatuses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("InstanceStatuses") != m.end() && !m["InstanceStatuses"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceStatuses"].type()) {
        DescribeInstanceStatusResponseBodyInstanceStatuses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceStatuses"]));
        instanceStatuses = make_shared<DescribeInstanceStatusResponseBodyInstanceStatuses>(model1);
      }
    }
  }


  virtual ~DescribeInstanceStatusResponseBody() = default;
};
class DescribeInstanceStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstanceStatusResponseBody> body{};

  DescribeInstanceStatusResponse() {}

  explicit DescribeInstanceStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceStatusResponse() = default;
};
class DescribeInstanceTopologyRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceIds{};

  DescribeInstanceTopologyRequest() {}

  explicit DescribeInstanceTopologyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
  }


  virtual ~DescribeInstanceTopologyRequest() = default;
};
class DescribeInstanceTopologyResponseBodyTopologysTopology : public Darabonba::Model {
public:
  shared_ptr<string> hostId{};
  shared_ptr<string> instanceId{};

  DescribeInstanceTopologyResponseBodyTopologysTopology() {}

  explicit DescribeInstanceTopologyResponseBodyTopologysTopology(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeInstanceTopologyResponseBodyTopologysTopology() = default;
};
class DescribeInstanceTopologyResponseBodyTopologys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceTopologyResponseBodyTopologysTopology>> topology{};

  DescribeInstanceTopologyResponseBodyTopologys() {}

  explicit DescribeInstanceTopologyResponseBodyTopologys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topology) {
      vector<boost::any> temp1;
      for(auto item1:*topology){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Topology"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      if (typeid(vector<boost::any>) == m["Topology"].type()) {
        vector<DescribeInstanceTopologyResponseBodyTopologysTopology> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Topology"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceTopologyResponseBodyTopologysTopology model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topology = make_shared<vector<DescribeInstanceTopologyResponseBodyTopologysTopology>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceTopologyResponseBodyTopologys() = default;
};
class DescribeInstanceTopologyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeInstanceTopologyResponseBodyTopologys> topologys{};

  DescribeInstanceTopologyResponseBody() {}

  explicit DescribeInstanceTopologyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (topologys) {
      res["Topologys"] = topologys ? boost::any(topologys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Topologys") != m.end() && !m["Topologys"].empty()) {
      if (typeid(map<string, boost::any>) == m["Topologys"].type()) {
        DescribeInstanceTopologyResponseBodyTopologys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Topologys"]));
        topologys = make_shared<DescribeInstanceTopologyResponseBodyTopologys>(model1);
      }
    }
  }


  virtual ~DescribeInstanceTopologyResponseBody() = default;
};
class DescribeInstanceTopologyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstanceTopologyResponseBody> body{};

  DescribeInstanceTopologyResponse() {}

  explicit DescribeInstanceTopologyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceTopologyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceTopologyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceTopologyResponse() = default;
};
class DescribeInstanceTypeFamiliesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> generation{};

  DescribeInstanceTypeFamiliesRequest() {}

  explicit DescribeInstanceTypeFamiliesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (generation) {
      res["Generation"] = boost::any(*generation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Generation") != m.end() && !m["Generation"].empty()) {
      generation = make_shared<string>(boost::any_cast<string>(m["Generation"]));
    }
  }


  virtual ~DescribeInstanceTypeFamiliesRequest() = default;
};
class DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamiliesInstanceTypeFamily : public Darabonba::Model {
public:
  shared_ptr<string> generation{};
  shared_ptr<string> instanceTypeFamilyId{};

  DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamiliesInstanceTypeFamily() {}

  explicit DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamiliesInstanceTypeFamily(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (generation) {
      res["Generation"] = boost::any(*generation);
    }
    if (instanceTypeFamilyId) {
      res["InstanceTypeFamilyId"] = boost::any(*instanceTypeFamilyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Generation") != m.end() && !m["Generation"].empty()) {
      generation = make_shared<string>(boost::any_cast<string>(m["Generation"]));
    }
    if (m.find("InstanceTypeFamilyId") != m.end() && !m["InstanceTypeFamilyId"].empty()) {
      instanceTypeFamilyId = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamilyId"]));
    }
  }


  virtual ~DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamiliesInstanceTypeFamily() = default;
};
class DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamilies : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamiliesInstanceTypeFamily>> instanceTypeFamily{};

  DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamilies() {}

  explicit DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamilies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceTypeFamily) {
      vector<boost::any> temp1;
      for(auto item1:*instanceTypeFamily){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceTypeFamily"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceTypeFamily"].type()) {
        vector<DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamiliesInstanceTypeFamily> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceTypeFamily"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamiliesInstanceTypeFamily model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceTypeFamily = make_shared<vector<DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamiliesInstanceTypeFamily>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamilies() = default;
};
class DescribeInstanceTypeFamiliesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamilies> instanceTypeFamilies{};

  DescribeInstanceTypeFamiliesResponseBody() {}

  explicit DescribeInstanceTypeFamiliesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceTypeFamilies) {
      res["InstanceTypeFamilies"] = instanceTypeFamilies ? boost::any(instanceTypeFamilies->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceTypeFamilies") != m.end() && !m["InstanceTypeFamilies"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTypeFamilies"].type()) {
        DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamilies model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTypeFamilies"]));
        instanceTypeFamilies = make_shared<DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamilies>(model1);
      }
    }
  }


  virtual ~DescribeInstanceTypeFamiliesResponseBody() = default;
};
class DescribeInstanceTypeFamiliesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstanceTypeFamiliesResponseBody> body{};

  DescribeInstanceTypeFamiliesResponse() {}

  explicit DescribeInstanceTypeFamiliesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceTypeFamiliesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceTypeFamiliesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceTypeFamiliesResponse() = default;
};
class DescribeInstanceTypesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> instanceTypeFamily{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  DescribeInstanceTypesRequest() {}

  explicit DescribeInstanceTypesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = boost::any(*instanceTypes);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      instanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamily"]));
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~DescribeInstanceTypesRequest() = default;
};
class DescribeInstanceTypesResponseBodyInstanceTypesInstanceType : public Darabonba::Model {
public:
  shared_ptr<long> eniTotalQuantity{};
  shared_ptr<string> localStorageCategory{};
  shared_ptr<long> primaryEniQueueNumber{};
  shared_ptr<double> memorySize{};
  shared_ptr<long> localStorageCapacity{};
  shared_ptr<string> instanceFamilyLevel{};
  shared_ptr<long> instancePpsRx{};
  shared_ptr<long> eniIpv6AddressQuantity{};
  shared_ptr<long> maximumQueueNumberPerEni{};
  shared_ptr<string> instanceTypeId{};
  shared_ptr<long> instanceBandwidthRx{};
  shared_ptr<long> secondaryEniQueueNumber{};
  shared_ptr<string> GPUSpec{};
  shared_ptr<long> instanceBandwidthTx{};
  shared_ptr<long> queuePairNumber{};
  shared_ptr<long> eriQuantity{};
  shared_ptr<long> GPUAmount{};
  shared_ptr<long> totalEniQueueQuantity{};
  shared_ptr<string> nvmeSupport{};
  shared_ptr<long> diskQuantity{};
  shared_ptr<long> initialCredit{};
  shared_ptr<long> localStorageAmount{};
  shared_ptr<long> baselineCredit{};
  shared_ptr<long> instancePpsTx{};
  shared_ptr<long> eniPrivateIpAddressQuantity{};
  shared_ptr<long> cpuCoreCount{};
  shared_ptr<string> instanceTypeFamily{};
  shared_ptr<long> eniQuantity{};
  shared_ptr<bool> eniTrunkSupported{};

  DescribeInstanceTypesResponseBodyInstanceTypesInstanceType() {}

  explicit DescribeInstanceTypesResponseBodyInstanceTypesInstanceType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eniTotalQuantity) {
      res["EniTotalQuantity"] = boost::any(*eniTotalQuantity);
    }
    if (localStorageCategory) {
      res["LocalStorageCategory"] = boost::any(*localStorageCategory);
    }
    if (primaryEniQueueNumber) {
      res["PrimaryEniQueueNumber"] = boost::any(*primaryEniQueueNumber);
    }
    if (memorySize) {
      res["MemorySize"] = boost::any(*memorySize);
    }
    if (localStorageCapacity) {
      res["LocalStorageCapacity"] = boost::any(*localStorageCapacity);
    }
    if (instanceFamilyLevel) {
      res["InstanceFamilyLevel"] = boost::any(*instanceFamilyLevel);
    }
    if (instancePpsRx) {
      res["InstancePpsRx"] = boost::any(*instancePpsRx);
    }
    if (eniIpv6AddressQuantity) {
      res["EniIpv6AddressQuantity"] = boost::any(*eniIpv6AddressQuantity);
    }
    if (maximumQueueNumberPerEni) {
      res["MaximumQueueNumberPerEni"] = boost::any(*maximumQueueNumberPerEni);
    }
    if (instanceTypeId) {
      res["InstanceTypeId"] = boost::any(*instanceTypeId);
    }
    if (instanceBandwidthRx) {
      res["InstanceBandwidthRx"] = boost::any(*instanceBandwidthRx);
    }
    if (secondaryEniQueueNumber) {
      res["SecondaryEniQueueNumber"] = boost::any(*secondaryEniQueueNumber);
    }
    if (GPUSpec) {
      res["GPUSpec"] = boost::any(*GPUSpec);
    }
    if (instanceBandwidthTx) {
      res["InstanceBandwidthTx"] = boost::any(*instanceBandwidthTx);
    }
    if (queuePairNumber) {
      res["QueuePairNumber"] = boost::any(*queuePairNumber);
    }
    if (eriQuantity) {
      res["EriQuantity"] = boost::any(*eriQuantity);
    }
    if (GPUAmount) {
      res["GPUAmount"] = boost::any(*GPUAmount);
    }
    if (totalEniQueueQuantity) {
      res["TotalEniQueueQuantity"] = boost::any(*totalEniQueueQuantity);
    }
    if (nvmeSupport) {
      res["NvmeSupport"] = boost::any(*nvmeSupport);
    }
    if (diskQuantity) {
      res["DiskQuantity"] = boost::any(*diskQuantity);
    }
    if (initialCredit) {
      res["InitialCredit"] = boost::any(*initialCredit);
    }
    if (localStorageAmount) {
      res["LocalStorageAmount"] = boost::any(*localStorageAmount);
    }
    if (baselineCredit) {
      res["BaselineCredit"] = boost::any(*baselineCredit);
    }
    if (instancePpsTx) {
      res["InstancePpsTx"] = boost::any(*instancePpsTx);
    }
    if (eniPrivateIpAddressQuantity) {
      res["EniPrivateIpAddressQuantity"] = boost::any(*eniPrivateIpAddressQuantity);
    }
    if (cpuCoreCount) {
      res["CpuCoreCount"] = boost::any(*cpuCoreCount);
    }
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    if (eniQuantity) {
      res["EniQuantity"] = boost::any(*eniQuantity);
    }
    if (eniTrunkSupported) {
      res["EniTrunkSupported"] = boost::any(*eniTrunkSupported);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EniTotalQuantity") != m.end() && !m["EniTotalQuantity"].empty()) {
      eniTotalQuantity = make_shared<long>(boost::any_cast<long>(m["EniTotalQuantity"]));
    }
    if (m.find("LocalStorageCategory") != m.end() && !m["LocalStorageCategory"].empty()) {
      localStorageCategory = make_shared<string>(boost::any_cast<string>(m["LocalStorageCategory"]));
    }
    if (m.find("PrimaryEniQueueNumber") != m.end() && !m["PrimaryEniQueueNumber"].empty()) {
      primaryEniQueueNumber = make_shared<long>(boost::any_cast<long>(m["PrimaryEniQueueNumber"]));
    }
    if (m.find("MemorySize") != m.end() && !m["MemorySize"].empty()) {
      memorySize = make_shared<double>(boost::any_cast<double>(m["MemorySize"]));
    }
    if (m.find("LocalStorageCapacity") != m.end() && !m["LocalStorageCapacity"].empty()) {
      localStorageCapacity = make_shared<long>(boost::any_cast<long>(m["LocalStorageCapacity"]));
    }
    if (m.find("InstanceFamilyLevel") != m.end() && !m["InstanceFamilyLevel"].empty()) {
      instanceFamilyLevel = make_shared<string>(boost::any_cast<string>(m["InstanceFamilyLevel"]));
    }
    if (m.find("InstancePpsRx") != m.end() && !m["InstancePpsRx"].empty()) {
      instancePpsRx = make_shared<long>(boost::any_cast<long>(m["InstancePpsRx"]));
    }
    if (m.find("EniIpv6AddressQuantity") != m.end() && !m["EniIpv6AddressQuantity"].empty()) {
      eniIpv6AddressQuantity = make_shared<long>(boost::any_cast<long>(m["EniIpv6AddressQuantity"]));
    }
    if (m.find("MaximumQueueNumberPerEni") != m.end() && !m["MaximumQueueNumberPerEni"].empty()) {
      maximumQueueNumberPerEni = make_shared<long>(boost::any_cast<long>(m["MaximumQueueNumberPerEni"]));
    }
    if (m.find("InstanceTypeId") != m.end() && !m["InstanceTypeId"].empty()) {
      instanceTypeId = make_shared<string>(boost::any_cast<string>(m["InstanceTypeId"]));
    }
    if (m.find("InstanceBandwidthRx") != m.end() && !m["InstanceBandwidthRx"].empty()) {
      instanceBandwidthRx = make_shared<long>(boost::any_cast<long>(m["InstanceBandwidthRx"]));
    }
    if (m.find("SecondaryEniQueueNumber") != m.end() && !m["SecondaryEniQueueNumber"].empty()) {
      secondaryEniQueueNumber = make_shared<long>(boost::any_cast<long>(m["SecondaryEniQueueNumber"]));
    }
    if (m.find("GPUSpec") != m.end() && !m["GPUSpec"].empty()) {
      GPUSpec = make_shared<string>(boost::any_cast<string>(m["GPUSpec"]));
    }
    if (m.find("InstanceBandwidthTx") != m.end() && !m["InstanceBandwidthTx"].empty()) {
      instanceBandwidthTx = make_shared<long>(boost::any_cast<long>(m["InstanceBandwidthTx"]));
    }
    if (m.find("QueuePairNumber") != m.end() && !m["QueuePairNumber"].empty()) {
      queuePairNumber = make_shared<long>(boost::any_cast<long>(m["QueuePairNumber"]));
    }
    if (m.find("EriQuantity") != m.end() && !m["EriQuantity"].empty()) {
      eriQuantity = make_shared<long>(boost::any_cast<long>(m["EriQuantity"]));
    }
    if (m.find("GPUAmount") != m.end() && !m["GPUAmount"].empty()) {
      GPUAmount = make_shared<long>(boost::any_cast<long>(m["GPUAmount"]));
    }
    if (m.find("TotalEniQueueQuantity") != m.end() && !m["TotalEniQueueQuantity"].empty()) {
      totalEniQueueQuantity = make_shared<long>(boost::any_cast<long>(m["TotalEniQueueQuantity"]));
    }
    if (m.find("NvmeSupport") != m.end() && !m["NvmeSupport"].empty()) {
      nvmeSupport = make_shared<string>(boost::any_cast<string>(m["NvmeSupport"]));
    }
    if (m.find("DiskQuantity") != m.end() && !m["DiskQuantity"].empty()) {
      diskQuantity = make_shared<long>(boost::any_cast<long>(m["DiskQuantity"]));
    }
    if (m.find("InitialCredit") != m.end() && !m["InitialCredit"].empty()) {
      initialCredit = make_shared<long>(boost::any_cast<long>(m["InitialCredit"]));
    }
    if (m.find("LocalStorageAmount") != m.end() && !m["LocalStorageAmount"].empty()) {
      localStorageAmount = make_shared<long>(boost::any_cast<long>(m["LocalStorageAmount"]));
    }
    if (m.find("BaselineCredit") != m.end() && !m["BaselineCredit"].empty()) {
      baselineCredit = make_shared<long>(boost::any_cast<long>(m["BaselineCredit"]));
    }
    if (m.find("InstancePpsTx") != m.end() && !m["InstancePpsTx"].empty()) {
      instancePpsTx = make_shared<long>(boost::any_cast<long>(m["InstancePpsTx"]));
    }
    if (m.find("EniPrivateIpAddressQuantity") != m.end() && !m["EniPrivateIpAddressQuantity"].empty()) {
      eniPrivateIpAddressQuantity = make_shared<long>(boost::any_cast<long>(m["EniPrivateIpAddressQuantity"]));
    }
    if (m.find("CpuCoreCount") != m.end() && !m["CpuCoreCount"].empty()) {
      cpuCoreCount = make_shared<long>(boost::any_cast<long>(m["CpuCoreCount"]));
    }
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      instanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamily"]));
    }
    if (m.find("EniQuantity") != m.end() && !m["EniQuantity"].empty()) {
      eniQuantity = make_shared<long>(boost::any_cast<long>(m["EniQuantity"]));
    }
    if (m.find("EniTrunkSupported") != m.end() && !m["EniTrunkSupported"].empty()) {
      eniTrunkSupported = make_shared<bool>(boost::any_cast<bool>(m["EniTrunkSupported"]));
    }
  }


  virtual ~DescribeInstanceTypesResponseBodyInstanceTypesInstanceType() = default;
};
class DescribeInstanceTypesResponseBodyInstanceTypes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceTypesResponseBodyInstanceTypesInstanceType>> instanceType{};

  DescribeInstanceTypesResponseBodyInstanceTypes() {}

  explicit DescribeInstanceTypesResponseBodyInstanceTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      vector<boost::any> temp1;
      for(auto item1:*instanceType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceType"].type()) {
        vector<DescribeInstanceTypesResponseBodyInstanceTypesInstanceType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceTypesResponseBodyInstanceTypesInstanceType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceType = make_shared<vector<DescribeInstanceTypesResponseBodyInstanceTypesInstanceType>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceTypesResponseBodyInstanceTypes() = default;
};
class DescribeInstanceTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeInstanceTypesResponseBodyInstanceTypes> instanceTypes{};
  shared_ptr<string> nextToken{};

  DescribeInstanceTypesResponseBody() {}

  explicit DescribeInstanceTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = instanceTypes ? boost::any(instanceTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTypes"].type()) {
        DescribeInstanceTypesResponseBodyInstanceTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTypes"]));
        instanceTypes = make_shared<DescribeInstanceTypesResponseBodyInstanceTypes>(model1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~DescribeInstanceTypesResponseBody() = default;
};
class DescribeInstanceTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstanceTypesResponseBody> body{};

  DescribeInstanceTypesResponse() {}

  explicit DescribeInstanceTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceTypesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceTypesResponse() = default;
};
class DescribeInstanceVncPasswdRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ownerAccount{};

  DescribeInstanceVncPasswdRequest() {}

  explicit DescribeInstanceVncPasswdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeInstanceVncPasswdRequest() = default;
};
class DescribeInstanceVncPasswdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> vncPasswd{};
  shared_ptr<string> requestId{};

  DescribeInstanceVncPasswdResponseBody() {}

  explicit DescribeInstanceVncPasswdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vncPasswd) {
      res["VncPasswd"] = boost::any(*vncPasswd);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VncPasswd") != m.end() && !m["VncPasswd"].empty()) {
      vncPasswd = make_shared<string>(boost::any_cast<string>(m["VncPasswd"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceVncPasswdResponseBody() = default;
};
class DescribeInstanceVncPasswdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstanceVncPasswdResponseBody> body{};

  DescribeInstanceVncPasswdResponse() {}

  explicit DescribeInstanceVncPasswdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceVncPasswdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceVncPasswdResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceVncPasswdResponse() = default;
};
class DescribeInstanceVncUrlRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ownerAccount{};

  DescribeInstanceVncUrlRequest() {}

  explicit DescribeInstanceVncUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeInstanceVncUrlRequest() = default;
};
class DescribeInstanceVncUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> vncUrl{};
  shared_ptr<string> requestId{};

  DescribeInstanceVncUrlResponseBody() {}

  explicit DescribeInstanceVncUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vncUrl) {
      res["VncUrl"] = boost::any(*vncUrl);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VncUrl") != m.end() && !m["VncUrl"].empty()) {
      vncUrl = make_shared<string>(boost::any_cast<string>(m["VncUrl"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceVncUrlResponseBody() = default;
};
class DescribeInstanceVncUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstanceVncUrlResponseBody> body{};

  DescribeInstanceVncUrlResponse() {}

  explicit DescribeInstanceVncUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceVncUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceVncUrlResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceVncUrlResponse() = default;
};
class DescribeInvocationResultsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> invokeId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> commandId{};
  shared_ptr<string> invokeRecordStatus{};
  shared_ptr<bool> includeHistory{};
  shared_ptr<string> contentEncoding{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeInvocationResultsRequest() {}

  explicit DescribeInvocationResultsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (invokeId) {
      res["InvokeId"] = boost::any(*invokeId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (commandId) {
      res["CommandId"] = boost::any(*commandId);
    }
    if (invokeRecordStatus) {
      res["InvokeRecordStatus"] = boost::any(*invokeRecordStatus);
    }
    if (includeHistory) {
      res["IncludeHistory"] = boost::any(*includeHistory);
    }
    if (contentEncoding) {
      res["ContentEncoding"] = boost::any(*contentEncoding);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InvokeId") != m.end() && !m["InvokeId"].empty()) {
      invokeId = make_shared<string>(boost::any_cast<string>(m["InvokeId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CommandId") != m.end() && !m["CommandId"].empty()) {
      commandId = make_shared<string>(boost::any_cast<string>(m["CommandId"]));
    }
    if (m.find("InvokeRecordStatus") != m.end() && !m["InvokeRecordStatus"].empty()) {
      invokeRecordStatus = make_shared<string>(boost::any_cast<string>(m["InvokeRecordStatus"]));
    }
    if (m.find("IncludeHistory") != m.end() && !m["IncludeHistory"].empty()) {
      includeHistory = make_shared<bool>(boost::any_cast<bool>(m["IncludeHistory"]));
    }
    if (m.find("ContentEncoding") != m.end() && !m["ContentEncoding"].empty()) {
      contentEncoding = make_shared<string>(boost::any_cast<string>(m["ContentEncoding"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeInvocationResultsRequest() = default;
};
class DescribeInvocationResultsResponseBodyInvocationInvocationResultsInvocationResult : public Darabonba::Model {
public:
  shared_ptr<string> invocationStatus{};
  shared_ptr<long> repeats{};
  shared_ptr<string> commandId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> output{};
  shared_ptr<long> dropped{};
  shared_ptr<string> stopTime{};
  shared_ptr<long> exitCode{};
  shared_ptr<string> startTime{};
  shared_ptr<string> errorInfo{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> finishedTime{};
  shared_ptr<string> invokeId{};
  shared_ptr<string> invokeRecordStatus{};
  shared_ptr<string> username{};

  DescribeInvocationResultsResponseBodyInvocationInvocationResultsInvocationResult() {}

  explicit DescribeInvocationResultsResponseBodyInvocationInvocationResultsInvocationResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invocationStatus) {
      res["InvocationStatus"] = boost::any(*invocationStatus);
    }
    if (repeats) {
      res["Repeats"] = boost::any(*repeats);
    }
    if (commandId) {
      res["CommandId"] = boost::any(*commandId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (dropped) {
      res["Dropped"] = boost::any(*dropped);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    if (exitCode) {
      res["ExitCode"] = boost::any(*exitCode);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (errorInfo) {
      res["ErrorInfo"] = boost::any(*errorInfo);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (invokeId) {
      res["InvokeId"] = boost::any(*invokeId);
    }
    if (invokeRecordStatus) {
      res["InvokeRecordStatus"] = boost::any(*invokeRecordStatus);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InvocationStatus") != m.end() && !m["InvocationStatus"].empty()) {
      invocationStatus = make_shared<string>(boost::any_cast<string>(m["InvocationStatus"]));
    }
    if (m.find("Repeats") != m.end() && !m["Repeats"].empty()) {
      repeats = make_shared<long>(boost::any_cast<long>(m["Repeats"]));
    }
    if (m.find("CommandId") != m.end() && !m["CommandId"].empty()) {
      commandId = make_shared<string>(boost::any_cast<string>(m["CommandId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("Dropped") != m.end() && !m["Dropped"].empty()) {
      dropped = make_shared<long>(boost::any_cast<long>(m["Dropped"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<string>(boost::any_cast<string>(m["StopTime"]));
    }
    if (m.find("ExitCode") != m.end() && !m["ExitCode"].empty()) {
      exitCode = make_shared<long>(boost::any_cast<long>(m["ExitCode"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("ErrorInfo") != m.end() && !m["ErrorInfo"].empty()) {
      errorInfo = make_shared<string>(boost::any_cast<string>(m["ErrorInfo"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<string>(boost::any_cast<string>(m["FinishedTime"]));
    }
    if (m.find("InvokeId") != m.end() && !m["InvokeId"].empty()) {
      invokeId = make_shared<string>(boost::any_cast<string>(m["InvokeId"]));
    }
    if (m.find("InvokeRecordStatus") != m.end() && !m["InvokeRecordStatus"].empty()) {
      invokeRecordStatus = make_shared<string>(boost::any_cast<string>(m["InvokeRecordStatus"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~DescribeInvocationResultsResponseBodyInvocationInvocationResultsInvocationResult() = default;
};
class DescribeInvocationResultsResponseBodyInvocationInvocationResults : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInvocationResultsResponseBodyInvocationInvocationResultsInvocationResult>> invocationResult{};

  DescribeInvocationResultsResponseBodyInvocationInvocationResults() {}

  explicit DescribeInvocationResultsResponseBodyInvocationInvocationResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invocationResult) {
      vector<boost::any> temp1;
      for(auto item1:*invocationResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InvocationResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InvocationResult") != m.end() && !m["InvocationResult"].empty()) {
      if (typeid(vector<boost::any>) == m["InvocationResult"].type()) {
        vector<DescribeInvocationResultsResponseBodyInvocationInvocationResultsInvocationResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InvocationResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInvocationResultsResponseBodyInvocationInvocationResultsInvocationResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        invocationResult = make_shared<vector<DescribeInvocationResultsResponseBodyInvocationInvocationResultsInvocationResult>>(expect1);
      }
    }
  }


  virtual ~DescribeInvocationResultsResponseBodyInvocationInvocationResults() = default;
};
class DescribeInvocationResultsResponseBodyInvocation : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeInvocationResultsResponseBodyInvocationInvocationResults> invocationResults{};

  DescribeInvocationResultsResponseBodyInvocation() {}

  explicit DescribeInvocationResultsResponseBodyInvocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (invocationResults) {
      res["InvocationResults"] = invocationResults ? boost::any(invocationResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("InvocationResults") != m.end() && !m["InvocationResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvocationResults"].type()) {
        DescribeInvocationResultsResponseBodyInvocationInvocationResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvocationResults"]));
        invocationResults = make_shared<DescribeInvocationResultsResponseBodyInvocationInvocationResults>(model1);
      }
    }
  }


  virtual ~DescribeInvocationResultsResponseBodyInvocation() = default;
};
class DescribeInvocationResultsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeInvocationResultsResponseBodyInvocation> invocation{};

  DescribeInvocationResultsResponseBody() {}

  explicit DescribeInvocationResultsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (invocation) {
      res["Invocation"] = invocation ? boost::any(invocation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Invocation") != m.end() && !m["Invocation"].empty()) {
      if (typeid(map<string, boost::any>) == m["Invocation"].type()) {
        DescribeInvocationResultsResponseBodyInvocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Invocation"]));
        invocation = make_shared<DescribeInvocationResultsResponseBodyInvocation>(model1);
      }
    }
  }


  virtual ~DescribeInvocationResultsResponseBody() = default;
};
class DescribeInvocationResultsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInvocationResultsResponseBody> body{};

  DescribeInvocationResultsResponse() {}

  explicit DescribeInvocationResultsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInvocationResultsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInvocationResultsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInvocationResultsResponse() = default;
};
class DescribeInvocationsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> invokeId{};
  shared_ptr<string> commandId{};
  shared_ptr<string> commandName{};
  shared_ptr<string> commandType{};
  shared_ptr<bool> timed{};
  shared_ptr<string> invokeStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> contentEncoding{};
  shared_ptr<bool> includeOutput{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> repeatMode{};

  DescribeInvocationsRequest() {}

  explicit DescribeInvocationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (invokeId) {
      res["InvokeId"] = boost::any(*invokeId);
    }
    if (commandId) {
      res["CommandId"] = boost::any(*commandId);
    }
    if (commandName) {
      res["CommandName"] = boost::any(*commandName);
    }
    if (commandType) {
      res["CommandType"] = boost::any(*commandType);
    }
    if (timed) {
      res["Timed"] = boost::any(*timed);
    }
    if (invokeStatus) {
      res["InvokeStatus"] = boost::any(*invokeStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (contentEncoding) {
      res["ContentEncoding"] = boost::any(*contentEncoding);
    }
    if (includeOutput) {
      res["IncludeOutput"] = boost::any(*includeOutput);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (repeatMode) {
      res["RepeatMode"] = boost::any(*repeatMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InvokeId") != m.end() && !m["InvokeId"].empty()) {
      invokeId = make_shared<string>(boost::any_cast<string>(m["InvokeId"]));
    }
    if (m.find("CommandId") != m.end() && !m["CommandId"].empty()) {
      commandId = make_shared<string>(boost::any_cast<string>(m["CommandId"]));
    }
    if (m.find("CommandName") != m.end() && !m["CommandName"].empty()) {
      commandName = make_shared<string>(boost::any_cast<string>(m["CommandName"]));
    }
    if (m.find("CommandType") != m.end() && !m["CommandType"].empty()) {
      commandType = make_shared<string>(boost::any_cast<string>(m["CommandType"]));
    }
    if (m.find("Timed") != m.end() && !m["Timed"].empty()) {
      timed = make_shared<bool>(boost::any_cast<bool>(m["Timed"]));
    }
    if (m.find("InvokeStatus") != m.end() && !m["InvokeStatus"].empty()) {
      invokeStatus = make_shared<string>(boost::any_cast<string>(m["InvokeStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ContentEncoding") != m.end() && !m["ContentEncoding"].empty()) {
      contentEncoding = make_shared<string>(boost::any_cast<string>(m["ContentEncoding"]));
    }
    if (m.find("IncludeOutput") != m.end() && !m["IncludeOutput"].empty()) {
      includeOutput = make_shared<bool>(boost::any_cast<bool>(m["IncludeOutput"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RepeatMode") != m.end() && !m["RepeatMode"].empty()) {
      repeatMode = make_shared<string>(boost::any_cast<string>(m["RepeatMode"]));
    }
  }


  virtual ~DescribeInvocationsRequest() = default;
};
class DescribeInvocationsResponseBodyInvocationsInvocationInvokeInstancesInvokeInstance : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> invocationStatus{};
  shared_ptr<long> repeats{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> output{};
  shared_ptr<long> dropped{};
  shared_ptr<string> stopTime{};
  shared_ptr<long> exitCode{};
  shared_ptr<string> startTime{};
  shared_ptr<string> errorInfo{};
  shared_ptr<bool> timed{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> instanceInvokeStatus{};

  DescribeInvocationsResponseBodyInvocationsInvocationInvokeInstancesInvokeInstance() {}

  explicit DescribeInvocationsResponseBodyInvocationsInvocationInvokeInstancesInvokeInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (invocationStatus) {
      res["InvocationStatus"] = boost::any(*invocationStatus);
    }
    if (repeats) {
      res["Repeats"] = boost::any(*repeats);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (dropped) {
      res["Dropped"] = boost::any(*dropped);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    if (exitCode) {
      res["ExitCode"] = boost::any(*exitCode);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (errorInfo) {
      res["ErrorInfo"] = boost::any(*errorInfo);
    }
    if (timed) {
      res["Timed"] = boost::any(*timed);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (instanceInvokeStatus) {
      res["InstanceInvokeStatus"] = boost::any(*instanceInvokeStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("InvocationStatus") != m.end() && !m["InvocationStatus"].empty()) {
      invocationStatus = make_shared<string>(boost::any_cast<string>(m["InvocationStatus"]));
    }
    if (m.find("Repeats") != m.end() && !m["Repeats"].empty()) {
      repeats = make_shared<long>(boost::any_cast<long>(m["Repeats"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("Dropped") != m.end() && !m["Dropped"].empty()) {
      dropped = make_shared<long>(boost::any_cast<long>(m["Dropped"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<string>(boost::any_cast<string>(m["StopTime"]));
    }
    if (m.find("ExitCode") != m.end() && !m["ExitCode"].empty()) {
      exitCode = make_shared<long>(boost::any_cast<long>(m["ExitCode"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("ErrorInfo") != m.end() && !m["ErrorInfo"].empty()) {
      errorInfo = make_shared<string>(boost::any_cast<string>(m["ErrorInfo"]));
    }
    if (m.find("Timed") != m.end() && !m["Timed"].empty()) {
      timed = make_shared<bool>(boost::any_cast<bool>(m["Timed"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("InstanceInvokeStatus") != m.end() && !m["InstanceInvokeStatus"].empty()) {
      instanceInvokeStatus = make_shared<string>(boost::any_cast<string>(m["InstanceInvokeStatus"]));
    }
  }


  virtual ~DescribeInvocationsResponseBodyInvocationsInvocationInvokeInstancesInvokeInstance() = default;
};
class DescribeInvocationsResponseBodyInvocationsInvocationInvokeInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInvocationsResponseBodyInvocationsInvocationInvokeInstancesInvokeInstance>> invokeInstance{};

  DescribeInvocationsResponseBodyInvocationsInvocationInvokeInstances() {}

  explicit DescribeInvocationsResponseBodyInvocationsInvocationInvokeInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invokeInstance) {
      vector<boost::any> temp1;
      for(auto item1:*invokeInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InvokeInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InvokeInstance") != m.end() && !m["InvokeInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["InvokeInstance"].type()) {
        vector<DescribeInvocationsResponseBodyInvocationsInvocationInvokeInstancesInvokeInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InvokeInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInvocationsResponseBodyInvocationsInvocationInvokeInstancesInvokeInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        invokeInstance = make_shared<vector<DescribeInvocationsResponseBodyInvocationsInvocationInvokeInstancesInvokeInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeInvocationsResponseBodyInvocationsInvocationInvokeInstances() = default;
};
class DescribeInvocationsResponseBodyInvocationsInvocation : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> frequency{};
  shared_ptr<string> invocationStatus{};
  shared_ptr<string> repeatMode{};
  shared_ptr<string> commandId{};
  shared_ptr<string> commandType{};
  shared_ptr<string> invokeStatus{};
  shared_ptr<string> parameters{};
  shared_ptr<bool> timed{};
  shared_ptr<string> commandContent{};
  shared_ptr<string> commandName{};
  shared_ptr<string> invokeId{};
  shared_ptr<string> username{};
  shared_ptr<DescribeInvocationsResponseBodyInvocationsInvocationInvokeInstances> invokeInstances{};

  DescribeInvocationsResponseBodyInvocationsInvocation() {}

  explicit DescribeInvocationsResponseBodyInvocationsInvocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (frequency) {
      res["Frequency"] = boost::any(*frequency);
    }
    if (invocationStatus) {
      res["InvocationStatus"] = boost::any(*invocationStatus);
    }
    if (repeatMode) {
      res["RepeatMode"] = boost::any(*repeatMode);
    }
    if (commandId) {
      res["CommandId"] = boost::any(*commandId);
    }
    if (commandType) {
      res["CommandType"] = boost::any(*commandType);
    }
    if (invokeStatus) {
      res["InvokeStatus"] = boost::any(*invokeStatus);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (timed) {
      res["Timed"] = boost::any(*timed);
    }
    if (commandContent) {
      res["CommandContent"] = boost::any(*commandContent);
    }
    if (commandName) {
      res["CommandName"] = boost::any(*commandName);
    }
    if (invokeId) {
      res["InvokeId"] = boost::any(*invokeId);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    if (invokeInstances) {
      res["InvokeInstances"] = invokeInstances ? boost::any(invokeInstances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Frequency") != m.end() && !m["Frequency"].empty()) {
      frequency = make_shared<string>(boost::any_cast<string>(m["Frequency"]));
    }
    if (m.find("InvocationStatus") != m.end() && !m["InvocationStatus"].empty()) {
      invocationStatus = make_shared<string>(boost::any_cast<string>(m["InvocationStatus"]));
    }
    if (m.find("RepeatMode") != m.end() && !m["RepeatMode"].empty()) {
      repeatMode = make_shared<string>(boost::any_cast<string>(m["RepeatMode"]));
    }
    if (m.find("CommandId") != m.end() && !m["CommandId"].empty()) {
      commandId = make_shared<string>(boost::any_cast<string>(m["CommandId"]));
    }
    if (m.find("CommandType") != m.end() && !m["CommandType"].empty()) {
      commandType = make_shared<string>(boost::any_cast<string>(m["CommandType"]));
    }
    if (m.find("InvokeStatus") != m.end() && !m["InvokeStatus"].empty()) {
      invokeStatus = make_shared<string>(boost::any_cast<string>(m["InvokeStatus"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
    if (m.find("Timed") != m.end() && !m["Timed"].empty()) {
      timed = make_shared<bool>(boost::any_cast<bool>(m["Timed"]));
    }
    if (m.find("CommandContent") != m.end() && !m["CommandContent"].empty()) {
      commandContent = make_shared<string>(boost::any_cast<string>(m["CommandContent"]));
    }
    if (m.find("CommandName") != m.end() && !m["CommandName"].empty()) {
      commandName = make_shared<string>(boost::any_cast<string>(m["CommandName"]));
    }
    if (m.find("InvokeId") != m.end() && !m["InvokeId"].empty()) {
      invokeId = make_shared<string>(boost::any_cast<string>(m["InvokeId"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
    if (m.find("InvokeInstances") != m.end() && !m["InvokeInstances"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvokeInstances"].type()) {
        DescribeInvocationsResponseBodyInvocationsInvocationInvokeInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvokeInstances"]));
        invokeInstances = make_shared<DescribeInvocationsResponseBodyInvocationsInvocationInvokeInstances>(model1);
      }
    }
  }


  virtual ~DescribeInvocationsResponseBodyInvocationsInvocation() = default;
};
class DescribeInvocationsResponseBodyInvocations : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInvocationsResponseBodyInvocationsInvocation>> invocation{};

  DescribeInvocationsResponseBodyInvocations() {}

  explicit DescribeInvocationsResponseBodyInvocations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invocation) {
      vector<boost::any> temp1;
      for(auto item1:*invocation){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Invocation"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Invocation") != m.end() && !m["Invocation"].empty()) {
      if (typeid(vector<boost::any>) == m["Invocation"].type()) {
        vector<DescribeInvocationsResponseBodyInvocationsInvocation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Invocation"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInvocationsResponseBodyInvocationsInvocation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        invocation = make_shared<vector<DescribeInvocationsResponseBodyInvocationsInvocation>>(expect1);
      }
    }
  }


  virtual ~DescribeInvocationsResponseBodyInvocations() = default;
};
class DescribeInvocationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeInvocationsResponseBodyInvocations> invocations{};

  DescribeInvocationsResponseBody() {}

  explicit DescribeInvocationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (invocations) {
      res["Invocations"] = invocations ? boost::any(invocations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Invocations") != m.end() && !m["Invocations"].empty()) {
      if (typeid(map<string, boost::any>) == m["Invocations"].type()) {
        DescribeInvocationsResponseBodyInvocations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Invocations"]));
        invocations = make_shared<DescribeInvocationsResponseBodyInvocations>(model1);
      }
    }
  }


  virtual ~DescribeInvocationsResponseBody() = default;
};
class DescribeInvocationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInvocationsResponseBody> body{};

  DescribeInvocationsResponse() {}

  explicit DescribeInvocationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInvocationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInvocationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInvocationsResponse() = default;
};
class DescribeKeyPairsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeKeyPairsRequestTag() {}

  explicit DescribeKeyPairsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeKeyPairsRequestTag() = default;
};
class DescribeKeyPairsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> keyPairFingerPrint{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<DescribeKeyPairsRequestTag>> tag{};

  DescribeKeyPairsRequest() {}

  explicit DescribeKeyPairsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (keyPairFingerPrint) {
      res["KeyPairFingerPrint"] = boost::any(*keyPairFingerPrint);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("KeyPairFingerPrint") != m.end() && !m["KeyPairFingerPrint"].empty()) {
      keyPairFingerPrint = make_shared<string>(boost::any_cast<string>(m["KeyPairFingerPrint"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeKeyPairsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeKeyPairsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeKeyPairsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeKeyPairsRequest() = default;
};
class DescribeKeyPairsResponseBodyKeyPairsKeyPairTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  DescribeKeyPairsResponseBodyKeyPairsKeyPairTagsTag() {}

  explicit DescribeKeyPairsResponseBodyKeyPairsKeyPairTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~DescribeKeyPairsResponseBodyKeyPairsKeyPairTagsTag() = default;
};
class DescribeKeyPairsResponseBodyKeyPairsKeyPairTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeKeyPairsResponseBodyKeyPairsKeyPairTagsTag>> tag{};

  DescribeKeyPairsResponseBodyKeyPairsKeyPairTags() {}

  explicit DescribeKeyPairsResponseBodyKeyPairsKeyPairTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeKeyPairsResponseBodyKeyPairsKeyPairTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeKeyPairsResponseBodyKeyPairsKeyPairTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeKeyPairsResponseBodyKeyPairsKeyPairTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeKeyPairsResponseBodyKeyPairsKeyPairTags() = default;
};
class DescribeKeyPairsResponseBodyKeyPairsKeyPair : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> keyPairFingerPrint{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<DescribeKeyPairsResponseBodyKeyPairsKeyPairTags> tags{};

  DescribeKeyPairsResponseBodyKeyPairsKeyPair() {}

  explicit DescribeKeyPairsResponseBodyKeyPairsKeyPair(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (keyPairFingerPrint) {
      res["KeyPairFingerPrint"] = boost::any(*keyPairFingerPrint);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("KeyPairFingerPrint") != m.end() && !m["KeyPairFingerPrint"].empty()) {
      keyPairFingerPrint = make_shared<string>(boost::any_cast<string>(m["KeyPairFingerPrint"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeKeyPairsResponseBodyKeyPairsKeyPairTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeKeyPairsResponseBodyKeyPairsKeyPairTags>(model1);
      }
    }
  }


  virtual ~DescribeKeyPairsResponseBodyKeyPairsKeyPair() = default;
};
class DescribeKeyPairsResponseBodyKeyPairs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeKeyPairsResponseBodyKeyPairsKeyPair>> keyPair{};

  DescribeKeyPairsResponseBodyKeyPairs() {}

  explicit DescribeKeyPairsResponseBodyKeyPairs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPair) {
      vector<boost::any> temp1;
      for(auto item1:*keyPair){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["KeyPair"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPair") != m.end() && !m["KeyPair"].empty()) {
      if (typeid(vector<boost::any>) == m["KeyPair"].type()) {
        vector<DescribeKeyPairsResponseBodyKeyPairsKeyPair> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["KeyPair"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeKeyPairsResponseBodyKeyPairsKeyPair model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        keyPair = make_shared<vector<DescribeKeyPairsResponseBodyKeyPairsKeyPair>>(expect1);
      }
    }
  }


  virtual ~DescribeKeyPairsResponseBodyKeyPairs() = default;
};
class DescribeKeyPairsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeKeyPairsResponseBodyKeyPairs> keyPairs{};

  DescribeKeyPairsResponseBody() {}

  explicit DescribeKeyPairsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (keyPairs) {
      res["KeyPairs"] = keyPairs ? boost::any(keyPairs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("KeyPairs") != m.end() && !m["KeyPairs"].empty()) {
      if (typeid(map<string, boost::any>) == m["KeyPairs"].type()) {
        DescribeKeyPairsResponseBodyKeyPairs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["KeyPairs"]));
        keyPairs = make_shared<DescribeKeyPairsResponseBodyKeyPairs>(model1);
      }
    }
  }


  virtual ~DescribeKeyPairsResponseBody() = default;
};
class DescribeKeyPairsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeKeyPairsResponseBody> body{};

  DescribeKeyPairsResponse() {}

  explicit DescribeKeyPairsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeKeyPairsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeKeyPairsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeKeyPairsResponse() = default;
};
class DescribeLaunchTemplatesRequestTemplateTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeLaunchTemplatesRequestTemplateTag() {}

  explicit DescribeLaunchTemplatesRequestTemplateTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeLaunchTemplatesRequestTemplateTag() = default;
};
class DescribeLaunchTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLaunchTemplatesRequestTemplateTag>> templateTag{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> launchTemplateId{};
  shared_ptr<vector<string>> launchTemplateName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> templateResourceGroupId{};

  DescribeLaunchTemplatesRequest() {}

  explicit DescribeLaunchTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateTag) {
      vector<boost::any> temp1;
      for(auto item1:*templateTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TemplateTag"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (launchTemplateId) {
      res["LaunchTemplateId"] = boost::any(*launchTemplateId);
    }
    if (launchTemplateName) {
      res["LaunchTemplateName"] = boost::any(*launchTemplateName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (templateResourceGroupId) {
      res["TemplateResourceGroupId"] = boost::any(*templateResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateTag") != m.end() && !m["TemplateTag"].empty()) {
      if (typeid(vector<boost::any>) == m["TemplateTag"].type()) {
        vector<DescribeLaunchTemplatesRequestTemplateTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TemplateTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLaunchTemplatesRequestTemplateTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templateTag = make_shared<vector<DescribeLaunchTemplatesRequestTemplateTag>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("LaunchTemplateId") != m.end() && !m["LaunchTemplateId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LaunchTemplateId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LaunchTemplateId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      launchTemplateId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LaunchTemplateName") != m.end() && !m["LaunchTemplateName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LaunchTemplateName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LaunchTemplateName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      launchTemplateName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TemplateResourceGroupId") != m.end() && !m["TemplateResourceGroupId"].empty()) {
      templateResourceGroupId = make_shared<string>(boost::any_cast<string>(m["TemplateResourceGroupId"]));
    }
  }


  virtual ~DescribeLaunchTemplatesRequest() = default;
};
class DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSetTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSetTagsTag() {}

  explicit DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSetTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSetTagsTag() = default;
};
class DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSetTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSetTagsTag>> tag{};

  DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSetTags() {}

  explicit DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSetTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSetTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSetTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSetTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSetTags() = default;
};
class DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSet : public Darabonba::Model {
public:
  shared_ptr<string> launchTemplateName{};
  shared_ptr<long> defaultVersionNumber{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> launchTemplateId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> createdBy{};
  shared_ptr<long> latestVersionNumber{};
  shared_ptr<DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSetTags> tags{};

  DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSet() {}

  explicit DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (launchTemplateName) {
      res["LaunchTemplateName"] = boost::any(*launchTemplateName);
    }
    if (defaultVersionNumber) {
      res["DefaultVersionNumber"] = boost::any(*defaultVersionNumber);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (launchTemplateId) {
      res["LaunchTemplateId"] = boost::any(*launchTemplateId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (createdBy) {
      res["CreatedBy"] = boost::any(*createdBy);
    }
    if (latestVersionNumber) {
      res["LatestVersionNumber"] = boost::any(*latestVersionNumber);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LaunchTemplateName") != m.end() && !m["LaunchTemplateName"].empty()) {
      launchTemplateName = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateName"]));
    }
    if (m.find("DefaultVersionNumber") != m.end() && !m["DefaultVersionNumber"].empty()) {
      defaultVersionNumber = make_shared<long>(boost::any_cast<long>(m["DefaultVersionNumber"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("LaunchTemplateId") != m.end() && !m["LaunchTemplateId"].empty()) {
      launchTemplateId = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("CreatedBy") != m.end() && !m["CreatedBy"].empty()) {
      createdBy = make_shared<string>(boost::any_cast<string>(m["CreatedBy"]));
    }
    if (m.find("LatestVersionNumber") != m.end() && !m["LatestVersionNumber"].empty()) {
      latestVersionNumber = make_shared<long>(boost::any_cast<long>(m["LatestVersionNumber"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSetTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSetTags>(model1);
      }
    }
  }


  virtual ~DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSet() = default;
};
class DescribeLaunchTemplatesResponseBodyLaunchTemplateSets : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSet>> launchTemplateSet{};

  DescribeLaunchTemplatesResponseBodyLaunchTemplateSets() {}

  explicit DescribeLaunchTemplatesResponseBodyLaunchTemplateSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (launchTemplateSet) {
      vector<boost::any> temp1;
      for(auto item1:*launchTemplateSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LaunchTemplateSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LaunchTemplateSet") != m.end() && !m["LaunchTemplateSet"].empty()) {
      if (typeid(vector<boost::any>) == m["LaunchTemplateSet"].type()) {
        vector<DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LaunchTemplateSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        launchTemplateSet = make_shared<vector<DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSet>>(expect1);
      }
    }
  }


  virtual ~DescribeLaunchTemplatesResponseBodyLaunchTemplateSets() = default;
};
class DescribeLaunchTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeLaunchTemplatesResponseBodyLaunchTemplateSets> launchTemplateSets{};

  DescribeLaunchTemplatesResponseBody() {}

  explicit DescribeLaunchTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (launchTemplateSets) {
      res["LaunchTemplateSets"] = launchTemplateSets ? boost::any(launchTemplateSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("LaunchTemplateSets") != m.end() && !m["LaunchTemplateSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["LaunchTemplateSets"].type()) {
        DescribeLaunchTemplatesResponseBodyLaunchTemplateSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LaunchTemplateSets"]));
        launchTemplateSets = make_shared<DescribeLaunchTemplatesResponseBodyLaunchTemplateSets>(model1);
      }
    }
  }


  virtual ~DescribeLaunchTemplatesResponseBody() = default;
};
class DescribeLaunchTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeLaunchTemplatesResponseBody> body{};

  DescribeLaunchTemplatesResponse() {}

  explicit DescribeLaunchTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLaunchTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLaunchTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLaunchTemplatesResponse() = default;
};
class DescribeLaunchTemplateVersionsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<int>> launchTemplateVersion{};
  shared_ptr<string> launchTemplateId{};
  shared_ptr<string> launchTemplateName{};
  shared_ptr<long> minVersion{};
  shared_ptr<long> maxVersion{};
  shared_ptr<bool> defaultVersion{};
  shared_ptr<bool> detailFlag{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeLaunchTemplateVersionsRequest() {}

  explicit DescribeLaunchTemplateVersionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (launchTemplateVersion) {
      res["LaunchTemplateVersion"] = boost::any(*launchTemplateVersion);
    }
    if (launchTemplateId) {
      res["LaunchTemplateId"] = boost::any(*launchTemplateId);
    }
    if (launchTemplateName) {
      res["LaunchTemplateName"] = boost::any(*launchTemplateName);
    }
    if (minVersion) {
      res["MinVersion"] = boost::any(*minVersion);
    }
    if (maxVersion) {
      res["MaxVersion"] = boost::any(*maxVersion);
    }
    if (defaultVersion) {
      res["DefaultVersion"] = boost::any(*defaultVersion);
    }
    if (detailFlag) {
      res["DetailFlag"] = boost::any(*detailFlag);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("LaunchTemplateVersion") != m.end() && !m["LaunchTemplateVersion"].empty()) {
      vector<int> toVec1;
      if (typeid(vector<boost::any>) == m["LaunchTemplateVersion"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LaunchTemplateVersion"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<int>(item));
        }
      }
      launchTemplateVersion = make_shared<vector<int>>(toVec1);
    }
    if (m.find("LaunchTemplateId") != m.end() && !m["LaunchTemplateId"].empty()) {
      launchTemplateId = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateId"]));
    }
    if (m.find("LaunchTemplateName") != m.end() && !m["LaunchTemplateName"].empty()) {
      launchTemplateName = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateName"]));
    }
    if (m.find("MinVersion") != m.end() && !m["MinVersion"].empty()) {
      minVersion = make_shared<long>(boost::any_cast<long>(m["MinVersion"]));
    }
    if (m.find("MaxVersion") != m.end() && !m["MaxVersion"].empty()) {
      maxVersion = make_shared<long>(boost::any_cast<long>(m["MaxVersion"]));
    }
    if (m.find("DefaultVersion") != m.end() && !m["DefaultVersion"].empty()) {
      defaultVersion = make_shared<bool>(boost::any_cast<bool>(m["DefaultVersion"]));
    }
    if (m.find("DetailFlag") != m.end() && !m["DetailFlag"].empty()) {
      detailFlag = make_shared<bool>(boost::any_cast<bool>(m["DetailFlag"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeLaunchTemplateVersionsRequest() = default;
};
class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataSystemDisk : public Darabonba::Model {
public:
  shared_ptr<string> performanceLevel{};
  shared_ptr<string> diskName{};
  shared_ptr<long> size{};
  shared_ptr<bool> deleteWithInstance{};
  shared_ptr<string> category{};
  shared_ptr<string> description{};
  shared_ptr<long> iops{};

  DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataSystemDisk() {}

  explicit DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (iops) {
      res["Iops"] = boost::any(*iops);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<bool>(boost::any_cast<bool>(m["DeleteWithInstance"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Iops") != m.end() && !m["Iops"].empty()) {
      iops = make_shared<long>(boost::any_cast<long>(m["Iops"]));
    }
  }


  virtual ~DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataSystemDisk() = default;
};
class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataDataDisksDataDisk : public Darabonba::Model {
public:
  shared_ptr<string> performanceLevel{};
  shared_ptr<string> description{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> device{};
  shared_ptr<long> size{};
  shared_ptr<string> diskName{};
  shared_ptr<string> category{};
  shared_ptr<bool> deleteWithInstance{};
  shared_ptr<string> encrypted{};

  DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataDataDisksDataDisk() {}

  explicit DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataDataDisksDataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<bool>(boost::any_cast<bool>(m["DeleteWithInstance"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<string>(boost::any_cast<string>(m["Encrypted"]));
    }
  }


  virtual ~DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataDataDisksDataDisk() = default;
};
class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataDataDisks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataDataDisksDataDisk>> dataDisk{};

  DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataDataDisks() {}

  explicit DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataDataDisks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDisk) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisk"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisk"].type()) {
        vector<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataDataDisksDataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataDataDisksDataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisk = make_shared<vector<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataDataDisksDataDisk>>(expect1);
      }
    }
  }


  virtual ~DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataDataDisks() = default;
};
class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfacesNetworkInterfaceSecurityGroupIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> securityGroupId{};

  DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfacesNetworkInterfaceSecurityGroupIds() {}

  explicit DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfacesNetworkInterfaceSecurityGroupIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfacesNetworkInterfaceSecurityGroupIds() = default;
};
class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfacesNetworkInterface : public Darabonba::Model {
public:
  shared_ptr<string> networkInterfaceName{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> description{};
  shared_ptr<string> primaryIpAddress{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfacesNetworkInterfaceSecurityGroupIds> securityGroupIds{};

  DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfacesNetworkInterface() {}

  explicit DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfacesNetworkInterface(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaceName) {
      res["NetworkInterfaceName"] = boost::any(*networkInterfaceName);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (primaryIpAddress) {
      res["PrimaryIpAddress"] = boost::any(*primaryIpAddress);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = securityGroupIds ? boost::any(securityGroupIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaceName") != m.end() && !m["NetworkInterfaceName"].empty()) {
      networkInterfaceName = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceName"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("PrimaryIpAddress") != m.end() && !m["PrimaryIpAddress"].empty()) {
      primaryIpAddress = make_shared<string>(boost::any_cast<string>(m["PrimaryIpAddress"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityGroupIds"].type()) {
        DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfacesNetworkInterfaceSecurityGroupIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityGroupIds"]));
        securityGroupIds = make_shared<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfacesNetworkInterfaceSecurityGroupIds>(model1);
      }
    }
  }


  virtual ~DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfacesNetworkInterface() = default;
};
class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfaces : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfacesNetworkInterface>> networkInterface{};

  DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfaces() {}

  explicit DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterface) {
      vector<boost::any> temp1;
      for(auto item1:*networkInterface){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkInterface"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterface") != m.end() && !m["NetworkInterface"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkInterface"].type()) {
        vector<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfacesNetworkInterface> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkInterface"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfacesNetworkInterface model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkInterface = make_shared<vector<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfacesNetworkInterface>>(expect1);
      }
    }
  }


  virtual ~DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfaces() = default;
};
class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataTagsInstanceTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataTagsInstanceTag() {}

  explicit DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataTagsInstanceTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataTagsInstanceTag() = default;
};
class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataTagsInstanceTag>> instanceTag{};

  DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataTags() {}

  explicit DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceTag) {
      vector<boost::any> temp1;
      for(auto item1:*instanceTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceTag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceTag") != m.end() && !m["InstanceTag"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceTag"].type()) {
        vector<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataTagsInstanceTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataTagsInstanceTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceTag = make_shared<vector<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataTagsInstanceTag>>(expect1);
      }
    }
  }


  virtual ~DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataTags() = default;
};
class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataSecurityGroupIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> securityGroupId{};

  DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataSecurityGroupIds() {}

  explicit DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataSecurityGroupIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataSecurityGroupIds() = default;
};
class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateData : public Darabonba::Model {
public:
  shared_ptr<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataSystemDisk> systemDisk{};
  shared_ptr<string> deploymentSetId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> networkType{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<bool> enableVmOsConfig{};
  shared_ptr<string> description{};
  shared_ptr<long> spotDuration{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> securityEnhancementStrategy{};
  shared_ptr<string> userData{};
  shared_ptr<double> spotPriceLimit{};
  shared_ptr<bool> passwordInherit{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> imageId{};
  shared_ptr<string> autoReleaseTime{};
  shared_ptr<string> imageOwnerAlias{};
  shared_ptr<string> hostName{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<long> internetMaxBandwidthIn{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> period{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> ioOptimized{};
  shared_ptr<string> ramRoleName{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> zoneId{};
  shared_ptr<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataDataDisks> dataDisks{};
  shared_ptr<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfaces> networkInterfaces{};
  shared_ptr<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataTags> tags{};
  shared_ptr<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataSecurityGroupIds> securityGroupIds{};

  DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateData() {}

  explicit DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!systemDisk) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("systemDisk is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deploymentSetId) {
      res["DeploymentSetId"] = boost::any(*deploymentSetId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (enableVmOsConfig) {
      res["EnableVmOsConfig"] = boost::any(*enableVmOsConfig);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (spotDuration) {
      res["SpotDuration"] = boost::any(*spotDuration);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (securityEnhancementStrategy) {
      res["SecurityEnhancementStrategy"] = boost::any(*securityEnhancementStrategy);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (spotPriceLimit) {
      res["SpotPriceLimit"] = boost::any(*spotPriceLimit);
    }
    if (passwordInherit) {
      res["PasswordInherit"] = boost::any(*passwordInherit);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (autoReleaseTime) {
      res["AutoReleaseTime"] = boost::any(*autoReleaseTime);
    }
    if (imageOwnerAlias) {
      res["ImageOwnerAlias"] = boost::any(*imageOwnerAlias);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (internetMaxBandwidthIn) {
      res["InternetMaxBandwidthIn"] = boost::any(*internetMaxBandwidthIn);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (dataDisks) {
      res["DataDisks"] = dataDisks ? boost::any(dataDisks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkInterfaces) {
      res["NetworkInterfaces"] = networkInterfaces ? boost::any(networkInterfaces->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = securityGroupIds ? boost::any(securityGroupIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataSystemDisk>(model1);
      }
    }
    if (m.find("DeploymentSetId") != m.end() && !m["DeploymentSetId"].empty()) {
      deploymentSetId = make_shared<string>(boost::any_cast<string>(m["DeploymentSetId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("EnableVmOsConfig") != m.end() && !m["EnableVmOsConfig"].empty()) {
      enableVmOsConfig = make_shared<bool>(boost::any_cast<bool>(m["EnableVmOsConfig"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SpotDuration") != m.end() && !m["SpotDuration"].empty()) {
      spotDuration = make_shared<long>(boost::any_cast<long>(m["SpotDuration"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("SecurityEnhancementStrategy") != m.end() && !m["SecurityEnhancementStrategy"].empty()) {
      securityEnhancementStrategy = make_shared<string>(boost::any_cast<string>(m["SecurityEnhancementStrategy"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("SpotPriceLimit") != m.end() && !m["SpotPriceLimit"].empty()) {
      spotPriceLimit = make_shared<double>(boost::any_cast<double>(m["SpotPriceLimit"]));
    }
    if (m.find("PasswordInherit") != m.end() && !m["PasswordInherit"].empty()) {
      passwordInherit = make_shared<bool>(boost::any_cast<bool>(m["PasswordInherit"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("AutoReleaseTime") != m.end() && !m["AutoReleaseTime"].empty()) {
      autoReleaseTime = make_shared<string>(boost::any_cast<string>(m["AutoReleaseTime"]));
    }
    if (m.find("ImageOwnerAlias") != m.end() && !m["ImageOwnerAlias"].empty()) {
      imageOwnerAlias = make_shared<string>(boost::any_cast<string>(m["ImageOwnerAlias"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("InternetMaxBandwidthIn") != m.end() && !m["InternetMaxBandwidthIn"].empty()) {
      internetMaxBandwidthIn = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthIn"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("DataDisks") != m.end() && !m["DataDisks"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataDisks"].type()) {
        DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataDataDisks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataDisks"]));
        dataDisks = make_shared<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataDataDisks>(model1);
      }
    }
    if (m.find("NetworkInterfaces") != m.end() && !m["NetworkInterfaces"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkInterfaces"].type()) {
        DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfaces model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkInterfaces"]));
        networkInterfaces = make_shared<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfaces>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataTags>(model1);
      }
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityGroupIds"].type()) {
        DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataSecurityGroupIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityGroupIds"]));
        securityGroupIds = make_shared<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataSecurityGroupIds>(model1);
      }
    }
  }


  virtual ~DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateData() = default;
};
class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSet : public Darabonba::Model {
public:
  shared_ptr<string> launchTemplateName{};
  shared_ptr<bool> defaultVersion{};
  shared_ptr<long> versionNumber{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> launchTemplateId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> createdBy{};
  shared_ptr<string> versionDescription{};
  shared_ptr<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateData> launchTemplateData{};

  DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSet() {}

  explicit DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (launchTemplateName) {
      res["LaunchTemplateName"] = boost::any(*launchTemplateName);
    }
    if (defaultVersion) {
      res["DefaultVersion"] = boost::any(*defaultVersion);
    }
    if (versionNumber) {
      res["VersionNumber"] = boost::any(*versionNumber);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (launchTemplateId) {
      res["LaunchTemplateId"] = boost::any(*launchTemplateId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createdBy) {
      res["CreatedBy"] = boost::any(*createdBy);
    }
    if (versionDescription) {
      res["VersionDescription"] = boost::any(*versionDescription);
    }
    if (launchTemplateData) {
      res["LaunchTemplateData"] = launchTemplateData ? boost::any(launchTemplateData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LaunchTemplateName") != m.end() && !m["LaunchTemplateName"].empty()) {
      launchTemplateName = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateName"]));
    }
    if (m.find("DefaultVersion") != m.end() && !m["DefaultVersion"].empty()) {
      defaultVersion = make_shared<bool>(boost::any_cast<bool>(m["DefaultVersion"]));
    }
    if (m.find("VersionNumber") != m.end() && !m["VersionNumber"].empty()) {
      versionNumber = make_shared<long>(boost::any_cast<long>(m["VersionNumber"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("LaunchTemplateId") != m.end() && !m["LaunchTemplateId"].empty()) {
      launchTemplateId = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatedBy") != m.end() && !m["CreatedBy"].empty()) {
      createdBy = make_shared<string>(boost::any_cast<string>(m["CreatedBy"]));
    }
    if (m.find("VersionDescription") != m.end() && !m["VersionDescription"].empty()) {
      versionDescription = make_shared<string>(boost::any_cast<string>(m["VersionDescription"]));
    }
    if (m.find("LaunchTemplateData") != m.end() && !m["LaunchTemplateData"].empty()) {
      if (typeid(map<string, boost::any>) == m["LaunchTemplateData"].type()) {
        DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LaunchTemplateData"]));
        launchTemplateData = make_shared<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateData>(model1);
      }
    }
  }


  virtual ~DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSet() = default;
};
class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSets : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSet>> launchTemplateVersionSet{};

  DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSets() {}

  explicit DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (launchTemplateVersionSet) {
      vector<boost::any> temp1;
      for(auto item1:*launchTemplateVersionSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LaunchTemplateVersionSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LaunchTemplateVersionSet") != m.end() && !m["LaunchTemplateVersionSet"].empty()) {
      if (typeid(vector<boost::any>) == m["LaunchTemplateVersionSet"].type()) {
        vector<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LaunchTemplateVersionSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        launchTemplateVersionSet = make_shared<vector<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSet>>(expect1);
      }
    }
  }


  virtual ~DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSets() = default;
};
class DescribeLaunchTemplateVersionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSets> launchTemplateVersionSets{};

  DescribeLaunchTemplateVersionsResponseBody() {}

  explicit DescribeLaunchTemplateVersionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (launchTemplateVersionSets) {
      res["LaunchTemplateVersionSets"] = launchTemplateVersionSets ? boost::any(launchTemplateVersionSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("LaunchTemplateVersionSets") != m.end() && !m["LaunchTemplateVersionSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["LaunchTemplateVersionSets"].type()) {
        DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LaunchTemplateVersionSets"]));
        launchTemplateVersionSets = make_shared<DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSets>(model1);
      }
    }
  }


  virtual ~DescribeLaunchTemplateVersionsResponseBody() = default;
};
class DescribeLaunchTemplateVersionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeLaunchTemplateVersionsResponseBody> body{};

  DescribeLaunchTemplateVersionsResponse() {}

  explicit DescribeLaunchTemplateVersionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLaunchTemplateVersionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLaunchTemplateVersionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLaunchTemplateVersionsResponse() = default;
};
class DescribeLimitationRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> limitation{};

  DescribeLimitationRequest() {}

  explicit DescribeLimitationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (limitation) {
      res["Limitation"] = boost::any(*limitation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("Limitation") != m.end() && !m["Limitation"].empty()) {
      limitation = make_shared<string>(boost::any_cast<string>(m["Limitation"]));
    }
  }


  virtual ~DescribeLimitationRequest() = default;
};
class DescribeLimitationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> limitation{};
  shared_ptr<string> value{};
  shared_ptr<string> requestId{};

  DescribeLimitationResponseBody() {}

  explicit DescribeLimitationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (limitation) {
      res["Limitation"] = boost::any(*limitation);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Limitation") != m.end() && !m["Limitation"].empty()) {
      limitation = make_shared<string>(boost::any_cast<string>(m["Limitation"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLimitationResponseBody() = default;
};
class DescribeLimitationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeLimitationResponseBody> body{};

  DescribeLimitationResponse() {}

  explicit DescribeLimitationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLimitationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLimitationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLimitationResponse() = default;
};
class DescribeManagedInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<string> osType{};
  shared_ptr<string> instanceIp{};
  shared_ptr<string> activationId{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeManagedInstancesRequest() {}

  explicit DescribeManagedInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (instanceIp) {
      res["InstanceIp"] = boost::any(*instanceIp);
    }
    if (activationId) {
      res["ActivationId"] = boost::any(*activationId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("InstanceIp") != m.end() && !m["InstanceIp"].empty()) {
      instanceIp = make_shared<string>(boost::any_cast<string>(m["InstanceIp"]));
    }
    if (m.find("ActivationId") != m.end() && !m["ActivationId"].empty()) {
      activationId = make_shared<string>(boost::any_cast<string>(m["ActivationId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeManagedInstancesRequest() = default;
};
class DescribeManagedInstancesResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<string> lastInvokedTime{};
  shared_ptr<bool> connected{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> hostname{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> activationId{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> agentVersion{};
  shared_ptr<string> registrationTime{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> osType{};
  shared_ptr<string> osVersion{};
  shared_ptr<long> invocationCount{};
  shared_ptr<string> machineId{};

  DescribeManagedInstancesResponseBodyInstances() {}

  explicit DescribeManagedInstancesResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lastInvokedTime) {
      res["LastInvokedTime"] = boost::any(*lastInvokedTime);
    }
    if (connected) {
      res["Connected"] = boost::any(*connected);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (hostname) {
      res["Hostname"] = boost::any(*hostname);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (activationId) {
      res["ActivationId"] = boost::any(*activationId);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (agentVersion) {
      res["AgentVersion"] = boost::any(*agentVersion);
    }
    if (registrationTime) {
      res["RegistrationTime"] = boost::any(*registrationTime);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (osVersion) {
      res["OsVersion"] = boost::any(*osVersion);
    }
    if (invocationCount) {
      res["InvocationCount"] = boost::any(*invocationCount);
    }
    if (machineId) {
      res["MachineId"] = boost::any(*machineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LastInvokedTime") != m.end() && !m["LastInvokedTime"].empty()) {
      lastInvokedTime = make_shared<string>(boost::any_cast<string>(m["LastInvokedTime"]));
    }
    if (m.find("Connected") != m.end() && !m["Connected"].empty()) {
      connected = make_shared<bool>(boost::any_cast<bool>(m["Connected"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("Hostname") != m.end() && !m["Hostname"].empty()) {
      hostname = make_shared<string>(boost::any_cast<string>(m["Hostname"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ActivationId") != m.end() && !m["ActivationId"].empty()) {
      activationId = make_shared<string>(boost::any_cast<string>(m["ActivationId"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("AgentVersion") != m.end() && !m["AgentVersion"].empty()) {
      agentVersion = make_shared<string>(boost::any_cast<string>(m["AgentVersion"]));
    }
    if (m.find("RegistrationTime") != m.end() && !m["RegistrationTime"].empty()) {
      registrationTime = make_shared<string>(boost::any_cast<string>(m["RegistrationTime"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("OsVersion") != m.end() && !m["OsVersion"].empty()) {
      osVersion = make_shared<string>(boost::any_cast<string>(m["OsVersion"]));
    }
    if (m.find("InvocationCount") != m.end() && !m["InvocationCount"].empty()) {
      invocationCount = make_shared<long>(boost::any_cast<long>(m["InvocationCount"]));
    }
    if (m.find("MachineId") != m.end() && !m["MachineId"].empty()) {
      machineId = make_shared<string>(boost::any_cast<string>(m["MachineId"]));
    }
  }


  virtual ~DescribeManagedInstancesResponseBodyInstances() = default;
};
class DescribeManagedInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DescribeManagedInstancesResponseBodyInstances>> instances{};

  DescribeManagedInstancesResponseBody() {}

  explicit DescribeManagedInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<DescribeManagedInstancesResponseBodyInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeManagedInstancesResponseBodyInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<DescribeManagedInstancesResponseBodyInstances>>(expect1);
      }
    }
  }


  virtual ~DescribeManagedInstancesResponseBody() = default;
};
class DescribeManagedInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeManagedInstancesResponseBody> body{};

  DescribeManagedInstancesResponse() {}

  explicit DescribeManagedInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeManagedInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeManagedInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeManagedInstancesResponse() = default;
};
class DescribeNatGatewaysRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> vpcId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeNatGatewaysRequest() {}

  explicit DescribeNatGatewaysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeNatGatewaysRequest() = default;
};
class DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> forwardTableId{};

  DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds() {}

  explicit DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardTableId) {
      res["ForwardTableId"] = boost::any(*forwardTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardTableId") != m.end() && !m["ForwardTableId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ForwardTableId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ForwardTableId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      forwardTableId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds() = default;
};
class DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayBandwidthPackageIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> bandwidthPackageId{};

  DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayBandwidthPackageIds() {}

  explicit DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayBandwidthPackageIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BandwidthPackageId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BandwidthPackageId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      bandwidthPackageId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayBandwidthPackageIds() = default;
};
class DescribeNatGatewaysResponseBodyNatGatewaysNatGateway : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> spec{};
  shared_ptr<string> description{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> businessStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds> forwardTableIds{};
  shared_ptr<DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayBandwidthPackageIds> bandwidthPackageIds{};

  DescribeNatGatewaysResponseBodyNatGatewaysNatGateway() {}

  explicit DescribeNatGatewaysResponseBodyNatGatewaysNatGateway(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (forwardTableIds) {
      res["ForwardTableIds"] = forwardTableIds ? boost::any(forwardTableIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bandwidthPackageIds) {
      res["BandwidthPackageIds"] = bandwidthPackageIds ? boost::any(bandwidthPackageIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ForwardTableIds") != m.end() && !m["ForwardTableIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["ForwardTableIds"].type()) {
        DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ForwardTableIds"]));
        forwardTableIds = make_shared<DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds>(model1);
      }
    }
    if (m.find("BandwidthPackageIds") != m.end() && !m["BandwidthPackageIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["BandwidthPackageIds"].type()) {
        DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayBandwidthPackageIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BandwidthPackageIds"]));
        bandwidthPackageIds = make_shared<DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayBandwidthPackageIds>(model1);
      }
    }
  }


  virtual ~DescribeNatGatewaysResponseBodyNatGatewaysNatGateway() = default;
};
class DescribeNatGatewaysResponseBodyNatGateways : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNatGatewaysResponseBodyNatGatewaysNatGateway>> natGateway{};

  DescribeNatGatewaysResponseBodyNatGateways() {}

  explicit DescribeNatGatewaysResponseBodyNatGateways(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (natGateway) {
      vector<boost::any> temp1;
      for(auto item1:*natGateway){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NatGateway"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NatGateway") != m.end() && !m["NatGateway"].empty()) {
      if (typeid(vector<boost::any>) == m["NatGateway"].type()) {
        vector<DescribeNatGatewaysResponseBodyNatGatewaysNatGateway> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NatGateway"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNatGatewaysResponseBodyNatGatewaysNatGateway model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        natGateway = make_shared<vector<DescribeNatGatewaysResponseBodyNatGatewaysNatGateway>>(expect1);
      }
    }
  }


  virtual ~DescribeNatGatewaysResponseBodyNatGateways() = default;
};
class DescribeNatGatewaysResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeNatGatewaysResponseBodyNatGateways> natGateways{};

  DescribeNatGatewaysResponseBody() {}

  explicit DescribeNatGatewaysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (natGateways) {
      res["NatGateways"] = natGateways ? boost::any(natGateways->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("NatGateways") != m.end() && !m["NatGateways"].empty()) {
      if (typeid(map<string, boost::any>) == m["NatGateways"].type()) {
        DescribeNatGatewaysResponseBodyNatGateways model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NatGateways"]));
        natGateways = make_shared<DescribeNatGatewaysResponseBodyNatGateways>(model1);
      }
    }
  }


  virtual ~DescribeNatGatewaysResponseBody() = default;
};
class DescribeNatGatewaysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeNatGatewaysResponseBody> body{};

  DescribeNatGatewaysResponse() {}

  explicit DescribeNatGatewaysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNatGatewaysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNatGatewaysResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNatGatewaysResponse() = default;
};
class DescribeNetworkInterfaceAttributeRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeNetworkInterfaceAttributeRequestTag() {}

  explicit DescribeNetworkInterfaceAttributeRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeNetworkInterfaceAttributeRequestTag() = default;
};
class DescribeNetworkInterfaceAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkInterfaceAttributeRequestTag>> tag{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<string> attribute{};

  DescribeNetworkInterfaceAttributeRequest() {}

  explicit DescribeNetworkInterfaceAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (attribute) {
      res["Attribute"] = boost::any(*attribute);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeNetworkInterfaceAttributeRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkInterfaceAttributeRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeNetworkInterfaceAttributeRequestTag>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("Attribute") != m.end() && !m["Attribute"].empty()) {
      attribute = make_shared<string>(boost::any_cast<string>(m["Attribute"]));
    }
  }


  virtual ~DescribeNetworkInterfaceAttributeRequest() = default;
};
class DescribeNetworkInterfaceAttributeResponseBodySecurityGroupIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> securityGroupId{};

  DescribeNetworkInterfaceAttributeResponseBodySecurityGroupIds() {}

  explicit DescribeNetworkInterfaceAttributeResponseBodySecurityGroupIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNetworkInterfaceAttributeResponseBodySecurityGroupIds() = default;
};
class DescribeNetworkInterfaceAttributeResponseBodyAssociatedPublicIp : public Darabonba::Model {
public:
  shared_ptr<string> publicIpAddress{};
  shared_ptr<string> allocationId{};

  DescribeNetworkInterfaceAttributeResponseBodyAssociatedPublicIp() {}

  explicit DescribeNetworkInterfaceAttributeResponseBodyAssociatedPublicIp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (publicIpAddress) {
      res["PublicIpAddress"] = boost::any(*publicIpAddress);
    }
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PublicIpAddress") != m.end() && !m["PublicIpAddress"].empty()) {
      publicIpAddress = make_shared<string>(boost::any_cast<string>(m["PublicIpAddress"]));
    }
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
  }


  virtual ~DescribeNetworkInterfaceAttributeResponseBodyAssociatedPublicIp() = default;
};
class DescribeNetworkInterfaceAttributeResponseBodyAttachmentMemberNetworkInterfaceIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> memberNetworkInterfaceId{};

  DescribeNetworkInterfaceAttributeResponseBodyAttachmentMemberNetworkInterfaceIds() {}

  explicit DescribeNetworkInterfaceAttributeResponseBodyAttachmentMemberNetworkInterfaceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memberNetworkInterfaceId) {
      res["MemberNetworkInterfaceId"] = boost::any(*memberNetworkInterfaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemberNetworkInterfaceId") != m.end() && !m["MemberNetworkInterfaceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MemberNetworkInterfaceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MemberNetworkInterfaceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      memberNetworkInterfaceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNetworkInterfaceAttributeResponseBodyAttachmentMemberNetworkInterfaceIds() = default;
};
class DescribeNetworkInterfaceAttributeResponseBodyAttachment : public Darabonba::Model {
public:
  shared_ptr<long> deviceIndex{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> trunkNetworkInterfaceId{};
  shared_ptr<DescribeNetworkInterfaceAttributeResponseBodyAttachmentMemberNetworkInterfaceIds> memberNetworkInterfaceIds{};

  DescribeNetworkInterfaceAttributeResponseBodyAttachment() {}

  explicit DescribeNetworkInterfaceAttributeResponseBodyAttachment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceIndex) {
      res["DeviceIndex"] = boost::any(*deviceIndex);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (trunkNetworkInterfaceId) {
      res["TrunkNetworkInterfaceId"] = boost::any(*trunkNetworkInterfaceId);
    }
    if (memberNetworkInterfaceIds) {
      res["MemberNetworkInterfaceIds"] = memberNetworkInterfaceIds ? boost::any(memberNetworkInterfaceIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceIndex") != m.end() && !m["DeviceIndex"].empty()) {
      deviceIndex = make_shared<long>(boost::any_cast<long>(m["DeviceIndex"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TrunkNetworkInterfaceId") != m.end() && !m["TrunkNetworkInterfaceId"].empty()) {
      trunkNetworkInterfaceId = make_shared<string>(boost::any_cast<string>(m["TrunkNetworkInterfaceId"]));
    }
    if (m.find("MemberNetworkInterfaceIds") != m.end() && !m["MemberNetworkInterfaceIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["MemberNetworkInterfaceIds"].type()) {
        DescribeNetworkInterfaceAttributeResponseBodyAttachmentMemberNetworkInterfaceIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MemberNetworkInterfaceIds"]));
        memberNetworkInterfaceIds = make_shared<DescribeNetworkInterfaceAttributeResponseBodyAttachmentMemberNetworkInterfaceIds>(model1);
      }
    }
  }


  virtual ~DescribeNetworkInterfaceAttributeResponseBodyAttachment() = default;
};
class DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsPrivateIpSetAssociatedPublicIp : public Darabonba::Model {
public:
  shared_ptr<string> publicIpAddress{};
  shared_ptr<string> allocationId{};

  DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsPrivateIpSetAssociatedPublicIp() {}

  explicit DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsPrivateIpSetAssociatedPublicIp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (publicIpAddress) {
      res["PublicIpAddress"] = boost::any(*publicIpAddress);
    }
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PublicIpAddress") != m.end() && !m["PublicIpAddress"].empty()) {
      publicIpAddress = make_shared<string>(boost::any_cast<string>(m["PublicIpAddress"]));
    }
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
  }


  virtual ~DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsPrivateIpSetAssociatedPublicIp() = default;
};
class DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsPrivateIpSet : public Darabonba::Model {
public:
  shared_ptr<string> privateIpAddress{};
  shared_ptr<bool> primary{};
  shared_ptr<DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsPrivateIpSetAssociatedPublicIp> associatedPublicIp{};

  DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsPrivateIpSet() {}

  explicit DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsPrivateIpSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (primary) {
      res["Primary"] = boost::any(*primary);
    }
    if (associatedPublicIp) {
      res["AssociatedPublicIp"] = associatedPublicIp ? boost::any(associatedPublicIp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("Primary") != m.end() && !m["Primary"].empty()) {
      primary = make_shared<bool>(boost::any_cast<bool>(m["Primary"]));
    }
    if (m.find("AssociatedPublicIp") != m.end() && !m["AssociatedPublicIp"].empty()) {
      if (typeid(map<string, boost::any>) == m["AssociatedPublicIp"].type()) {
        DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsPrivateIpSetAssociatedPublicIp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AssociatedPublicIp"]));
        associatedPublicIp = make_shared<DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsPrivateIpSetAssociatedPublicIp>(model1);
      }
    }
  }


  virtual ~DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsPrivateIpSet() = default;
};
class DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSets : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsPrivateIpSet>> privateIpSet{};

  DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSets() {}

  explicit DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateIpSet) {
      vector<boost::any> temp1;
      for(auto item1:*privateIpSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrivateIpSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateIpSet") != m.end() && !m["PrivateIpSet"].empty()) {
      if (typeid(vector<boost::any>) == m["PrivateIpSet"].type()) {
        vector<DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsPrivateIpSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrivateIpSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsPrivateIpSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        privateIpSet = make_shared<vector<DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsPrivateIpSet>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSets() = default;
};
class DescribeNetworkInterfaceAttributeResponseBodyIpv6SetsIpv6Set : public Darabonba::Model {
public:
  shared_ptr<string> ipv6Address{};

  DescribeNetworkInterfaceAttributeResponseBodyIpv6SetsIpv6Set() {}

  explicit DescribeNetworkInterfaceAttributeResponseBodyIpv6SetsIpv6Set(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6Address) {
      res["Ipv6Address"] = boost::any(*ipv6Address);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6Address") != m.end() && !m["Ipv6Address"].empty()) {
      ipv6Address = make_shared<string>(boost::any_cast<string>(m["Ipv6Address"]));
    }
  }


  virtual ~DescribeNetworkInterfaceAttributeResponseBodyIpv6SetsIpv6Set() = default;
};
class DescribeNetworkInterfaceAttributeResponseBodyIpv6Sets : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkInterfaceAttributeResponseBodyIpv6SetsIpv6Set>> ipv6Set{};

  DescribeNetworkInterfaceAttributeResponseBodyIpv6Sets() {}

  explicit DescribeNetworkInterfaceAttributeResponseBodyIpv6Sets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6Set) {
      vector<boost::any> temp1;
      for(auto item1:*ipv6Set){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv6Set"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6Set") != m.end() && !m["Ipv6Set"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv6Set"].type()) {
        vector<DescribeNetworkInterfaceAttributeResponseBodyIpv6SetsIpv6Set> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv6Set"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkInterfaceAttributeResponseBodyIpv6SetsIpv6Set model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv6Set = make_shared<vector<DescribeNetworkInterfaceAttributeResponseBodyIpv6SetsIpv6Set>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkInterfaceAttributeResponseBodyIpv6Sets() = default;
};
class DescribeNetworkInterfaceAttributeResponseBodyTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  DescribeNetworkInterfaceAttributeResponseBodyTagsTag() {}

  explicit DescribeNetworkInterfaceAttributeResponseBodyTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~DescribeNetworkInterfaceAttributeResponseBodyTagsTag() = default;
};
class DescribeNetworkInterfaceAttributeResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkInterfaceAttributeResponseBodyTagsTag>> tag{};

  DescribeNetworkInterfaceAttributeResponseBodyTags() {}

  explicit DescribeNetworkInterfaceAttributeResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeNetworkInterfaceAttributeResponseBodyTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkInterfaceAttributeResponseBodyTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeNetworkInterfaceAttributeResponseBodyTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkInterfaceAttributeResponseBodyTags() = default;
};
class DescribeNetworkInterfaceAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> type{};
  shared_ptr<string> status{};
  shared_ptr<string> networkInterfaceTrafficMode{};
  shared_ptr<string> networkInterfaceName{};
  shared_ptr<string> macAddress{};
  shared_ptr<long> queuePairNumber{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<long> serviceID{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ownerId{};
  shared_ptr<bool> serviceManaged{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> description{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<long> queueNumber{};
  shared_ptr<DescribeNetworkInterfaceAttributeResponseBodySecurityGroupIds> securityGroupIds{};
  shared_ptr<DescribeNetworkInterfaceAttributeResponseBodyAssociatedPublicIp> associatedPublicIp{};
  shared_ptr<DescribeNetworkInterfaceAttributeResponseBodyAttachment> attachment{};
  shared_ptr<DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSets> privateIpSets{};
  shared_ptr<DescribeNetworkInterfaceAttributeResponseBodyIpv6Sets> ipv6Sets{};
  shared_ptr<DescribeNetworkInterfaceAttributeResponseBodyTags> tags{};

  DescribeNetworkInterfaceAttributeResponseBody() {}

  explicit DescribeNetworkInterfaceAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (networkInterfaceTrafficMode) {
      res["NetworkInterfaceTrafficMode"] = boost::any(*networkInterfaceTrafficMode);
    }
    if (networkInterfaceName) {
      res["NetworkInterfaceName"] = boost::any(*networkInterfaceName);
    }
    if (macAddress) {
      res["MacAddress"] = boost::any(*macAddress);
    }
    if (queuePairNumber) {
      res["QueuePairNumber"] = boost::any(*queuePairNumber);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (serviceID) {
      res["ServiceID"] = boost::any(*serviceID);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (serviceManaged) {
      res["ServiceManaged"] = boost::any(*serviceManaged);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (queueNumber) {
      res["QueueNumber"] = boost::any(*queueNumber);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = securityGroupIds ? boost::any(securityGroupIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (associatedPublicIp) {
      res["AssociatedPublicIp"] = associatedPublicIp ? boost::any(associatedPublicIp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (attachment) {
      res["Attachment"] = attachment ? boost::any(attachment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (privateIpSets) {
      res["PrivateIpSets"] = privateIpSets ? boost::any(privateIpSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipv6Sets) {
      res["Ipv6Sets"] = ipv6Sets ? boost::any(ipv6Sets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("NetworkInterfaceTrafficMode") != m.end() && !m["NetworkInterfaceTrafficMode"].empty()) {
      networkInterfaceTrafficMode = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceTrafficMode"]));
    }
    if (m.find("NetworkInterfaceName") != m.end() && !m["NetworkInterfaceName"].empty()) {
      networkInterfaceName = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceName"]));
    }
    if (m.find("MacAddress") != m.end() && !m["MacAddress"].empty()) {
      macAddress = make_shared<string>(boost::any_cast<string>(m["MacAddress"]));
    }
    if (m.find("QueuePairNumber") != m.end() && !m["QueuePairNumber"].empty()) {
      queuePairNumber = make_shared<long>(boost::any_cast<long>(m["QueuePairNumber"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("ServiceID") != m.end() && !m["ServiceID"].empty()) {
      serviceID = make_shared<long>(boost::any_cast<long>(m["ServiceID"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ServiceManaged") != m.end() && !m["ServiceManaged"].empty()) {
      serviceManaged = make_shared<bool>(boost::any_cast<bool>(m["ServiceManaged"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("QueueNumber") != m.end() && !m["QueueNumber"].empty()) {
      queueNumber = make_shared<long>(boost::any_cast<long>(m["QueueNumber"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityGroupIds"].type()) {
        DescribeNetworkInterfaceAttributeResponseBodySecurityGroupIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityGroupIds"]));
        securityGroupIds = make_shared<DescribeNetworkInterfaceAttributeResponseBodySecurityGroupIds>(model1);
      }
    }
    if (m.find("AssociatedPublicIp") != m.end() && !m["AssociatedPublicIp"].empty()) {
      if (typeid(map<string, boost::any>) == m["AssociatedPublicIp"].type()) {
        DescribeNetworkInterfaceAttributeResponseBodyAssociatedPublicIp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AssociatedPublicIp"]));
        associatedPublicIp = make_shared<DescribeNetworkInterfaceAttributeResponseBodyAssociatedPublicIp>(model1);
      }
    }
    if (m.find("Attachment") != m.end() && !m["Attachment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Attachment"].type()) {
        DescribeNetworkInterfaceAttributeResponseBodyAttachment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Attachment"]));
        attachment = make_shared<DescribeNetworkInterfaceAttributeResponseBodyAttachment>(model1);
      }
    }
    if (m.find("PrivateIpSets") != m.end() && !m["PrivateIpSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivateIpSets"].type()) {
        DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivateIpSets"]));
        privateIpSets = make_shared<DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSets>(model1);
      }
    }
    if (m.find("Ipv6Sets") != m.end() && !m["Ipv6Sets"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ipv6Sets"].type()) {
        DescribeNetworkInterfaceAttributeResponseBodyIpv6Sets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ipv6Sets"]));
        ipv6Sets = make_shared<DescribeNetworkInterfaceAttributeResponseBodyIpv6Sets>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeNetworkInterfaceAttributeResponseBodyTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeNetworkInterfaceAttributeResponseBodyTags>(model1);
      }
    }
  }


  virtual ~DescribeNetworkInterfaceAttributeResponseBody() = default;
};
class DescribeNetworkInterfaceAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeNetworkInterfaceAttributeResponseBody> body{};

  DescribeNetworkInterfaceAttributeResponse() {}

  explicit DescribeNetworkInterfaceAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNetworkInterfaceAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNetworkInterfaceAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNetworkInterfaceAttributeResponse() = default;
};
class DescribeNetworkInterfacePermissionsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> networkInterfacePermissionId{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeNetworkInterfacePermissionsRequest() {}

  explicit DescribeNetworkInterfacePermissionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (networkInterfacePermissionId) {
      res["NetworkInterfacePermissionId"] = boost::any(*networkInterfacePermissionId);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("NetworkInterfacePermissionId") != m.end() && !m["NetworkInterfacePermissionId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NetworkInterfacePermissionId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NetworkInterfacePermissionId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      networkInterfacePermissionId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeNetworkInterfacePermissionsRequest() = default;
};
class DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissionsNetworkInterfacePermission : public Darabonba::Model {
public:
  shared_ptr<string> permission{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<long> accountId{};
  shared_ptr<string> networkInterfacePermissionId{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> permissionState{};

  DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissionsNetworkInterfacePermission() {}

  explicit DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissionsNetworkInterfacePermission(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (permission) {
      res["Permission"] = boost::any(*permission);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (networkInterfacePermissionId) {
      res["NetworkInterfacePermissionId"] = boost::any(*networkInterfacePermissionId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (permissionState) {
      res["PermissionState"] = boost::any(*permissionState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Permission") != m.end() && !m["Permission"].empty()) {
      permission = make_shared<string>(boost::any_cast<string>(m["Permission"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("NetworkInterfacePermissionId") != m.end() && !m["NetworkInterfacePermissionId"].empty()) {
      networkInterfacePermissionId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfacePermissionId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("PermissionState") != m.end() && !m["PermissionState"].empty()) {
      permissionState = make_shared<string>(boost::any_cast<string>(m["PermissionState"]));
    }
  }


  virtual ~DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissionsNetworkInterfacePermission() = default;
};
class DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissionsNetworkInterfacePermission>> networkInterfacePermission{};

  DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissions() {}

  explicit DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfacePermission) {
      vector<boost::any> temp1;
      for(auto item1:*networkInterfacePermission){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkInterfacePermission"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfacePermission") != m.end() && !m["NetworkInterfacePermission"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkInterfacePermission"].type()) {
        vector<DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissionsNetworkInterfacePermission> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkInterfacePermission"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissionsNetworkInterfacePermission model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkInterfacePermission = make_shared<vector<DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissionsNetworkInterfacePermission>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissions() = default;
};
class DescribeNetworkInterfacePermissionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissions> networkInterfacePermissions{};

  DescribeNetworkInterfacePermissionsResponseBody() {}

  explicit DescribeNetworkInterfacePermissionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (networkInterfacePermissions) {
      res["NetworkInterfacePermissions"] = networkInterfacePermissions ? boost::any(networkInterfacePermissions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("NetworkInterfacePermissions") != m.end() && !m["NetworkInterfacePermissions"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkInterfacePermissions"].type()) {
        DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkInterfacePermissions"]));
        networkInterfacePermissions = make_shared<DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissions>(model1);
      }
    }
  }


  virtual ~DescribeNetworkInterfacePermissionsResponseBody() = default;
};
class DescribeNetworkInterfacePermissionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeNetworkInterfacePermissionsResponseBody> body{};

  DescribeNetworkInterfacePermissionsResponse() {}

  explicit DescribeNetworkInterfacePermissionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNetworkInterfacePermissionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNetworkInterfacePermissionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNetworkInterfacePermissionsResponse() = default;
};
class DescribeNetworkInterfacesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeNetworkInterfacesRequestTag() {}

  explicit DescribeNetworkInterfacesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeNetworkInterfacesRequestTag() = default;
};
class DescribeNetworkInterfacesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<DescribeNetworkInterfacesRequestTag>> tag{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> primaryIpAddress{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> networkInterfaceName{};
  shared_ptr<string> type{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> serviceManaged{};
  shared_ptr<string> status{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> maxResults{};
  shared_ptr<vector<string>> privateIpAddress{};
  shared_ptr<vector<string>> networkInterfaceId{};
  shared_ptr<vector<string>> ipv6Address{};

  DescribeNetworkInterfacesRequest() {}

  explicit DescribeNetworkInterfacesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (primaryIpAddress) {
      res["PrimaryIpAddress"] = boost::any(*primaryIpAddress);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (networkInterfaceName) {
      res["NetworkInterfaceName"] = boost::any(*networkInterfaceName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (serviceManaged) {
      res["ServiceManaged"] = boost::any(*serviceManaged);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (ipv6Address) {
      res["Ipv6Address"] = boost::any(*ipv6Address);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeNetworkInterfacesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkInterfacesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeNetworkInterfacesRequestTag>>(expect1);
      }
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("PrimaryIpAddress") != m.end() && !m["PrimaryIpAddress"].empty()) {
      primaryIpAddress = make_shared<string>(boost::any_cast<string>(m["PrimaryIpAddress"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("NetworkInterfaceName") != m.end() && !m["NetworkInterfaceName"].empty()) {
      networkInterfaceName = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ServiceManaged") != m.end() && !m["ServiceManaged"].empty()) {
      serviceManaged = make_shared<bool>(boost::any_cast<bool>(m["ServiceManaged"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrivateIpAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrivateIpAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      privateIpAddress = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NetworkInterfaceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NetworkInterfaceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      networkInterfaceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Ipv6Address") != m.end() && !m["Ipv6Address"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ipv6Address"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ipv6Address"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipv6Address = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNetworkInterfacesRequest() = default;
};
class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSetAssociatedPublicIp : public Darabonba::Model {
public:
  shared_ptr<string> publicIpAddress{};
  shared_ptr<string> allocationId{};

  DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSetAssociatedPublicIp() {}

  explicit DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSetAssociatedPublicIp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (publicIpAddress) {
      res["PublicIpAddress"] = boost::any(*publicIpAddress);
    }
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PublicIpAddress") != m.end() && !m["PublicIpAddress"].empty()) {
      publicIpAddress = make_shared<string>(boost::any_cast<string>(m["PublicIpAddress"]));
    }
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
  }


  virtual ~DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSetAssociatedPublicIp() = default;
};
class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet : public Darabonba::Model {
public:
  shared_ptr<string> privateIpAddress{};
  shared_ptr<bool> primary{};
  shared_ptr<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSetAssociatedPublicIp> associatedPublicIp{};

  DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet() {}

  explicit DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (primary) {
      res["Primary"] = boost::any(*primary);
    }
    if (associatedPublicIp) {
      res["AssociatedPublicIp"] = associatedPublicIp ? boost::any(associatedPublicIp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("Primary") != m.end() && !m["Primary"].empty()) {
      primary = make_shared<bool>(boost::any_cast<bool>(m["Primary"]));
    }
    if (m.find("AssociatedPublicIp") != m.end() && !m["AssociatedPublicIp"].empty()) {
      if (typeid(map<string, boost::any>) == m["AssociatedPublicIp"].type()) {
        DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSetAssociatedPublicIp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AssociatedPublicIp"]));
        associatedPublicIp = make_shared<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSetAssociatedPublicIp>(model1);
      }
    }
  }


  virtual ~DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet() = default;
};
class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet>> privateIpSet{};

  DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets() {}

  explicit DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateIpSet) {
      vector<boost::any> temp1;
      for(auto item1:*privateIpSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrivateIpSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateIpSet") != m.end() && !m["PrivateIpSet"].empty()) {
      if (typeid(vector<boost::any>) == m["PrivateIpSet"].type()) {
        vector<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrivateIpSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        privateIpSet = make_shared<vector<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets() = default;
};
class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set : public Darabonba::Model {
public:
  shared_ptr<string> ipv6Address{};

  DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set() {}

  explicit DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6Address) {
      res["Ipv6Address"] = boost::any(*ipv6Address);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6Address") != m.end() && !m["Ipv6Address"].empty()) {
      ipv6Address = make_shared<string>(boost::any_cast<string>(m["Ipv6Address"]));
    }
  }


  virtual ~DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set() = default;
};
class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set>> ipv6Set{};

  DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets() {}

  explicit DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6Set) {
      vector<boost::any> temp1;
      for(auto item1:*ipv6Set){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv6Set"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6Set") != m.end() && !m["Ipv6Set"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv6Set"].type()) {
        vector<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv6Set"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv6Set = make_shared<vector<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets() = default;
};
class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTagsTag() {}

  explicit DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTagsTag() = default;
};
class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTagsTag>> tag{};

  DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTags() {}

  explicit DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTags() = default;
};
class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> securityGroupId{};

  DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds() {}

  explicit DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds() = default;
};
class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAssociatedPublicIp : public Darabonba::Model {
public:
  shared_ptr<string> publicIpAddress{};
  shared_ptr<string> allocationId{};

  DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAssociatedPublicIp() {}

  explicit DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAssociatedPublicIp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (publicIpAddress) {
      res["PublicIpAddress"] = boost::any(*publicIpAddress);
    }
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PublicIpAddress") != m.end() && !m["PublicIpAddress"].empty()) {
      publicIpAddress = make_shared<string>(boost::any_cast<string>(m["PublicIpAddress"]));
    }
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
  }


  virtual ~DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAssociatedPublicIp() = default;
};
class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAttachment : public Darabonba::Model {
public:
  shared_ptr<long> deviceIndex{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> trunkNetworkInterfaceId{};

  DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAttachment() {}

  explicit DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAttachment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceIndex) {
      res["DeviceIndex"] = boost::any(*deviceIndex);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (trunkNetworkInterfaceId) {
      res["TrunkNetworkInterfaceId"] = boost::any(*trunkNetworkInterfaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceIndex") != m.end() && !m["DeviceIndex"].empty()) {
      deviceIndex = make_shared<long>(boost::any_cast<long>(m["DeviceIndex"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TrunkNetworkInterfaceId") != m.end() && !m["TrunkNetworkInterfaceId"].empty()) {
      trunkNetworkInterfaceId = make_shared<string>(boost::any_cast<string>(m["TrunkNetworkInterfaceId"]));
    }
  }


  virtual ~DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAttachment() = default;
};
class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> type{};
  shared_ptr<string> status{};
  shared_ptr<string> networkInterfaceTrafficMode{};
  shared_ptr<string> networkInterfaceName{};
  shared_ptr<string> macAddress{};
  shared_ptr<long> queuePairNumber{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<long> serviceID{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ownerId{};
  shared_ptr<bool> serviceManaged{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> description{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<long> queueNumber{};
  shared_ptr<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets> privateIpSets{};
  shared_ptr<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets> ipv6Sets{};
  shared_ptr<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTags> tags{};
  shared_ptr<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds> securityGroupIds{};
  shared_ptr<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAssociatedPublicIp> associatedPublicIp{};
  shared_ptr<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAttachment> attachment{};

  DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet() {}

  explicit DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (networkInterfaceTrafficMode) {
      res["NetworkInterfaceTrafficMode"] = boost::any(*networkInterfaceTrafficMode);
    }
    if (networkInterfaceName) {
      res["NetworkInterfaceName"] = boost::any(*networkInterfaceName);
    }
    if (macAddress) {
      res["MacAddress"] = boost::any(*macAddress);
    }
    if (queuePairNumber) {
      res["QueuePairNumber"] = boost::any(*queuePairNumber);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (serviceID) {
      res["ServiceID"] = boost::any(*serviceID);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (serviceManaged) {
      res["ServiceManaged"] = boost::any(*serviceManaged);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (queueNumber) {
      res["QueueNumber"] = boost::any(*queueNumber);
    }
    if (privateIpSets) {
      res["PrivateIpSets"] = privateIpSets ? boost::any(privateIpSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipv6Sets) {
      res["Ipv6Sets"] = ipv6Sets ? boost::any(ipv6Sets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = securityGroupIds ? boost::any(securityGroupIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (associatedPublicIp) {
      res["AssociatedPublicIp"] = associatedPublicIp ? boost::any(associatedPublicIp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (attachment) {
      res["Attachment"] = attachment ? boost::any(attachment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("NetworkInterfaceTrafficMode") != m.end() && !m["NetworkInterfaceTrafficMode"].empty()) {
      networkInterfaceTrafficMode = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceTrafficMode"]));
    }
    if (m.find("NetworkInterfaceName") != m.end() && !m["NetworkInterfaceName"].empty()) {
      networkInterfaceName = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceName"]));
    }
    if (m.find("MacAddress") != m.end() && !m["MacAddress"].empty()) {
      macAddress = make_shared<string>(boost::any_cast<string>(m["MacAddress"]));
    }
    if (m.find("QueuePairNumber") != m.end() && !m["QueuePairNumber"].empty()) {
      queuePairNumber = make_shared<long>(boost::any_cast<long>(m["QueuePairNumber"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("ServiceID") != m.end() && !m["ServiceID"].empty()) {
      serviceID = make_shared<long>(boost::any_cast<long>(m["ServiceID"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ServiceManaged") != m.end() && !m["ServiceManaged"].empty()) {
      serviceManaged = make_shared<bool>(boost::any_cast<bool>(m["ServiceManaged"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("QueueNumber") != m.end() && !m["QueueNumber"].empty()) {
      queueNumber = make_shared<long>(boost::any_cast<long>(m["QueueNumber"]));
    }
    if (m.find("PrivateIpSets") != m.end() && !m["PrivateIpSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivateIpSets"].type()) {
        DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivateIpSets"]));
        privateIpSets = make_shared<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets>(model1);
      }
    }
    if (m.find("Ipv6Sets") != m.end() && !m["Ipv6Sets"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ipv6Sets"].type()) {
        DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ipv6Sets"]));
        ipv6Sets = make_shared<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTags>(model1);
      }
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityGroupIds"].type()) {
        DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityGroupIds"]));
        securityGroupIds = make_shared<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds>(model1);
      }
    }
    if (m.find("AssociatedPublicIp") != m.end() && !m["AssociatedPublicIp"].empty()) {
      if (typeid(map<string, boost::any>) == m["AssociatedPublicIp"].type()) {
        DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAssociatedPublicIp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AssociatedPublicIp"]));
        associatedPublicIp = make_shared<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAssociatedPublicIp>(model1);
      }
    }
    if (m.find("Attachment") != m.end() && !m["Attachment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Attachment"].type()) {
        DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAttachment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Attachment"]));
        attachment = make_shared<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAttachment>(model1);
      }
    }
  }


  virtual ~DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet() = default;
};
class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet>> networkInterfaceSet{};

  DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets() {}

  explicit DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaceSet) {
      vector<boost::any> temp1;
      for(auto item1:*networkInterfaceSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkInterfaceSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaceSet") != m.end() && !m["NetworkInterfaceSet"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkInterfaceSet"].type()) {
        vector<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkInterfaceSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkInterfaceSet = make_shared<vector<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets() = default;
};
class DescribeNetworkInterfacesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets> networkInterfaceSets{};

  DescribeNetworkInterfacesResponseBody() {}

  explicit DescribeNetworkInterfacesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (networkInterfaceSets) {
      res["NetworkInterfaceSets"] = networkInterfaceSets ? boost::any(networkInterfaceSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("NetworkInterfaceSets") != m.end() && !m["NetworkInterfaceSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkInterfaceSets"].type()) {
        DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkInterfaceSets"]));
        networkInterfaceSets = make_shared<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets>(model1);
      }
    }
  }


  virtual ~DescribeNetworkInterfacesResponseBody() = default;
};
class DescribeNetworkInterfacesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeNetworkInterfacesResponseBody> body{};

  DescribeNetworkInterfacesResponse() {}

  explicit DescribeNetworkInterfacesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNetworkInterfacesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNetworkInterfacesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNetworkInterfacesResponse() = default;
};
class DescribeNewProjectEipMonitorDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> allocationId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> period{};
  shared_ptr<string> ownerAccount{};

  DescribeNewProjectEipMonitorDataRequest() {}

  explicit DescribeNewProjectEipMonitorDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeNewProjectEipMonitorDataRequest() = default;
};
class DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData : public Darabonba::Model {
public:
  shared_ptr<long> eipTX{};
  shared_ptr<long> eipPackets{};
  shared_ptr<long> eipBandwidth{};
  shared_ptr<string> timeStamp{};
  shared_ptr<long> eipFlow{};
  shared_ptr<long> eipRX{};

  DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData() {}

  explicit DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipTX) {
      res["EipTX"] = boost::any(*eipTX);
    }
    if (eipPackets) {
      res["EipPackets"] = boost::any(*eipPackets);
    }
    if (eipBandwidth) {
      res["EipBandwidth"] = boost::any(*eipBandwidth);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (eipFlow) {
      res["EipFlow"] = boost::any(*eipFlow);
    }
    if (eipRX) {
      res["EipRX"] = boost::any(*eipRX);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipTX") != m.end() && !m["EipTX"].empty()) {
      eipTX = make_shared<long>(boost::any_cast<long>(m["EipTX"]));
    }
    if (m.find("EipPackets") != m.end() && !m["EipPackets"].empty()) {
      eipPackets = make_shared<long>(boost::any_cast<long>(m["EipPackets"]));
    }
    if (m.find("EipBandwidth") != m.end() && !m["EipBandwidth"].empty()) {
      eipBandwidth = make_shared<long>(boost::any_cast<long>(m["EipBandwidth"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("EipFlow") != m.end() && !m["EipFlow"].empty()) {
      eipFlow = make_shared<long>(boost::any_cast<long>(m["EipFlow"]));
    }
    if (m.find("EipRX") != m.end() && !m["EipRX"].empty()) {
      eipRX = make_shared<long>(boost::any_cast<long>(m["EipRX"]));
    }
  }


  virtual ~DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData() = default;
};
class DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatas : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData>> eipMonitorData{};

  DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatas() {}

  explicit DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipMonitorData) {
      vector<boost::any> temp1;
      for(auto item1:*eipMonitorData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EipMonitorData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipMonitorData") != m.end() && !m["EipMonitorData"].empty()) {
      if (typeid(vector<boost::any>) == m["EipMonitorData"].type()) {
        vector<DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EipMonitorData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eipMonitorData = make_shared<vector<DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData>>(expect1);
      }
    }
  }


  virtual ~DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatas() = default;
};
class DescribeNewProjectEipMonitorDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatas> eipMonitorDatas{};

  DescribeNewProjectEipMonitorDataResponseBody() {}

  explicit DescribeNewProjectEipMonitorDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (eipMonitorDatas) {
      res["EipMonitorDatas"] = eipMonitorDatas ? boost::any(eipMonitorDatas->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("EipMonitorDatas") != m.end() && !m["EipMonitorDatas"].empty()) {
      if (typeid(map<string, boost::any>) == m["EipMonitorDatas"].type()) {
        DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatas model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EipMonitorDatas"]));
        eipMonitorDatas = make_shared<DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatas>(model1);
      }
    }
  }


  virtual ~DescribeNewProjectEipMonitorDataResponseBody() = default;
};
class DescribeNewProjectEipMonitorDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeNewProjectEipMonitorDataResponseBody> body{};

  DescribeNewProjectEipMonitorDataResponse() {}

  explicit DescribeNewProjectEipMonitorDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNewProjectEipMonitorDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNewProjectEipMonitorDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNewProjectEipMonitorDataResponse() = default;
};
class DescribePhysicalConnectionsRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<string>> value{};

  DescribePhysicalConnectionsRequestFilter() {}

  explicit DescribePhysicalConnectionsRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Value"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      value = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribePhysicalConnectionsRequestFilter() = default;
};
class DescribePhysicalConnectionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> userCidr{};
  shared_ptr<vector<DescribePhysicalConnectionsRequestFilter>> filter{};

  DescribePhysicalConnectionsRequest() {}

  explicit DescribePhysicalConnectionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (userCidr) {
      res["UserCidr"] = boost::any(*userCidr);
    }
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("UserCidr") != m.end() && !m["UserCidr"].empty()) {
      userCidr = make_shared<string>(boost::any_cast<string>(m["UserCidr"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<DescribePhysicalConnectionsRequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePhysicalConnectionsRequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<DescribePhysicalConnectionsRequestFilter>>(expect1);
      }
    }
  }


  virtual ~DescribePhysicalConnectionsRequest() = default;
};
class DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType : public Darabonba::Model {
public:
  shared_ptr<string> adLocation{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> portNumber{};
  shared_ptr<string> circuitCode{};
  shared_ptr<string> spec{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> description{};
  shared_ptr<string> portType{};
  shared_ptr<string> enabledTime{};
  shared_ptr<string> businessStatus{};
  shared_ptr<string> lineOperator{};
  shared_ptr<string> name{};
  shared_ptr<string> redundantPhysicalConnectionId{};
  shared_ptr<string> peerLocation{};
  shared_ptr<string> accessPointId{};
  shared_ptr<string> physicalConnectionId{};

  DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType() {}

  explicit DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adLocation) {
      res["AdLocation"] = boost::any(*adLocation);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (portNumber) {
      res["PortNumber"] = boost::any(*portNumber);
    }
    if (circuitCode) {
      res["CircuitCode"] = boost::any(*circuitCode);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (portType) {
      res["PortType"] = boost::any(*portType);
    }
    if (enabledTime) {
      res["EnabledTime"] = boost::any(*enabledTime);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (lineOperator) {
      res["LineOperator"] = boost::any(*lineOperator);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (redundantPhysicalConnectionId) {
      res["RedundantPhysicalConnectionId"] = boost::any(*redundantPhysicalConnectionId);
    }
    if (peerLocation) {
      res["PeerLocation"] = boost::any(*peerLocation);
    }
    if (accessPointId) {
      res["AccessPointId"] = boost::any(*accessPointId);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdLocation") != m.end() && !m["AdLocation"].empty()) {
      adLocation = make_shared<string>(boost::any_cast<string>(m["AdLocation"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("PortNumber") != m.end() && !m["PortNumber"].empty()) {
      portNumber = make_shared<string>(boost::any_cast<string>(m["PortNumber"]));
    }
    if (m.find("CircuitCode") != m.end() && !m["CircuitCode"].empty()) {
      circuitCode = make_shared<string>(boost::any_cast<string>(m["CircuitCode"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("PortType") != m.end() && !m["PortType"].empty()) {
      portType = make_shared<string>(boost::any_cast<string>(m["PortType"]));
    }
    if (m.find("EnabledTime") != m.end() && !m["EnabledTime"].empty()) {
      enabledTime = make_shared<string>(boost::any_cast<string>(m["EnabledTime"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("LineOperator") != m.end() && !m["LineOperator"].empty()) {
      lineOperator = make_shared<string>(boost::any_cast<string>(m["LineOperator"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RedundantPhysicalConnectionId") != m.end() && !m["RedundantPhysicalConnectionId"].empty()) {
      redundantPhysicalConnectionId = make_shared<string>(boost::any_cast<string>(m["RedundantPhysicalConnectionId"]));
    }
    if (m.find("PeerLocation") != m.end() && !m["PeerLocation"].empty()) {
      peerLocation = make_shared<string>(boost::any_cast<string>(m["PeerLocation"]));
    }
    if (m.find("AccessPointId") != m.end() && !m["AccessPointId"].empty()) {
      accessPointId = make_shared<string>(boost::any_cast<string>(m["AccessPointId"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
  }


  virtual ~DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType() = default;
};
class DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType>> physicalConnectionType{};

  DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet() {}

  explicit DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (physicalConnectionType) {
      vector<boost::any> temp1;
      for(auto item1:*physicalConnectionType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PhysicalConnectionType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhysicalConnectionType") != m.end() && !m["PhysicalConnectionType"].empty()) {
      if (typeid(vector<boost::any>) == m["PhysicalConnectionType"].type()) {
        vector<DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PhysicalConnectionType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        physicalConnectionType = make_shared<vector<DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType>>(expect1);
      }
    }
  }


  virtual ~DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet() = default;
};
class DescribePhysicalConnectionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet> physicalConnectionSet{};

  DescribePhysicalConnectionsResponseBody() {}

  explicit DescribePhysicalConnectionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (physicalConnectionSet) {
      res["PhysicalConnectionSet"] = physicalConnectionSet ? boost::any(physicalConnectionSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PhysicalConnectionSet") != m.end() && !m["PhysicalConnectionSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["PhysicalConnectionSet"].type()) {
        DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PhysicalConnectionSet"]));
        physicalConnectionSet = make_shared<DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet>(model1);
      }
    }
  }


  virtual ~DescribePhysicalConnectionsResponseBody() = default;
};
class DescribePhysicalConnectionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePhysicalConnectionsResponseBody> body{};

  DescribePhysicalConnectionsResponse() {}

  explicit DescribePhysicalConnectionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePhysicalConnectionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePhysicalConnectionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePhysicalConnectionsResponse() = default;
};
class DescribePrefixListAssociationsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> prefixListId{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> maxResults{};

  DescribePrefixListAssociationsRequest() {}

  explicit DescribePrefixListAssociationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (prefixListId) {
      res["PrefixListId"] = boost::any(*prefixListId);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PrefixListId") != m.end() && !m["PrefixListId"].empty()) {
      prefixListId = make_shared<string>(boost::any_cast<string>(m["PrefixListId"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
  }


  virtual ~DescribePrefixListAssociationsRequest() = default;
};
class DescribePrefixListAssociationsResponseBodyPrefixListAssociationsPrefixListAssociation : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};

  DescribePrefixListAssociationsResponseBodyPrefixListAssociationsPrefixListAssociation() {}

  explicit DescribePrefixListAssociationsResponseBodyPrefixListAssociationsPrefixListAssociation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~DescribePrefixListAssociationsResponseBodyPrefixListAssociationsPrefixListAssociation() = default;
};
class DescribePrefixListAssociationsResponseBodyPrefixListAssociations : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePrefixListAssociationsResponseBodyPrefixListAssociationsPrefixListAssociation>> prefixListAssociation{};

  DescribePrefixListAssociationsResponseBodyPrefixListAssociations() {}

  explicit DescribePrefixListAssociationsResponseBodyPrefixListAssociations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (prefixListAssociation) {
      vector<boost::any> temp1;
      for(auto item1:*prefixListAssociation){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrefixListAssociation"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrefixListAssociation") != m.end() && !m["PrefixListAssociation"].empty()) {
      if (typeid(vector<boost::any>) == m["PrefixListAssociation"].type()) {
        vector<DescribePrefixListAssociationsResponseBodyPrefixListAssociationsPrefixListAssociation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrefixListAssociation"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePrefixListAssociationsResponseBodyPrefixListAssociationsPrefixListAssociation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        prefixListAssociation = make_shared<vector<DescribePrefixListAssociationsResponseBodyPrefixListAssociationsPrefixListAssociation>>(expect1);
      }
    }
  }


  virtual ~DescribePrefixListAssociationsResponseBodyPrefixListAssociations() = default;
};
class DescribePrefixListAssociationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribePrefixListAssociationsResponseBodyPrefixListAssociations> prefixListAssociations{};

  DescribePrefixListAssociationsResponseBody() {}

  explicit DescribePrefixListAssociationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (prefixListAssociations) {
      res["PrefixListAssociations"] = prefixListAssociations ? boost::any(prefixListAssociations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PrefixListAssociations") != m.end() && !m["PrefixListAssociations"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrefixListAssociations"].type()) {
        DescribePrefixListAssociationsResponseBodyPrefixListAssociations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrefixListAssociations"]));
        prefixListAssociations = make_shared<DescribePrefixListAssociationsResponseBodyPrefixListAssociations>(model1);
      }
    }
  }


  virtual ~DescribePrefixListAssociationsResponseBody() = default;
};
class DescribePrefixListAssociationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePrefixListAssociationsResponseBody> body{};

  DescribePrefixListAssociationsResponse() {}

  explicit DescribePrefixListAssociationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePrefixListAssociationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePrefixListAssociationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePrefixListAssociationsResponse() = default;
};
class DescribePrefixListAttributesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> prefixListId{};

  DescribePrefixListAttributesRequest() {}

  explicit DescribePrefixListAttributesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (prefixListId) {
      res["PrefixListId"] = boost::any(*prefixListId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PrefixListId") != m.end() && !m["PrefixListId"].empty()) {
      prefixListId = make_shared<string>(boost::any_cast<string>(m["PrefixListId"]));
    }
  }


  virtual ~DescribePrefixListAttributesRequest() = default;
};
class DescribePrefixListAttributesResponseBodyEntriesEntry : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> cidr{};

  DescribePrefixListAttributesResponseBodyEntriesEntry() {}

  explicit DescribePrefixListAttributesResponseBodyEntriesEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (cidr) {
      res["Cidr"] = boost::any(*cidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Cidr") != m.end() && !m["Cidr"].empty()) {
      cidr = make_shared<string>(boost::any_cast<string>(m["Cidr"]));
    }
  }


  virtual ~DescribePrefixListAttributesResponseBodyEntriesEntry() = default;
};
class DescribePrefixListAttributesResponseBodyEntries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePrefixListAttributesResponseBodyEntriesEntry>> entry{};

  DescribePrefixListAttributesResponseBodyEntries() {}

  explicit DescribePrefixListAttributesResponseBodyEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entry) {
      vector<boost::any> temp1;
      for(auto item1:*entry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Entry"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Entry") != m.end() && !m["Entry"].empty()) {
      if (typeid(vector<boost::any>) == m["Entry"].type()) {
        vector<DescribePrefixListAttributesResponseBodyEntriesEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Entry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePrefixListAttributesResponseBodyEntriesEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entry = make_shared<vector<DescribePrefixListAttributesResponseBodyEntriesEntry>>(expect1);
      }
    }
  }


  virtual ~DescribePrefixListAttributesResponseBodyEntries() = default;
};
class DescribePrefixListAttributesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<long> maxEntries{};
  shared_ptr<string> requestId{};
  shared_ptr<string> description{};
  shared_ptr<string> addressFamily{};
  shared_ptr<string> prefixListName{};
  shared_ptr<string> prefixListId{};
  shared_ptr<DescribePrefixListAttributesResponseBodyEntries> entries{};

  DescribePrefixListAttributesResponseBody() {}

  explicit DescribePrefixListAttributesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (maxEntries) {
      res["MaxEntries"] = boost::any(*maxEntries);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (addressFamily) {
      res["AddressFamily"] = boost::any(*addressFamily);
    }
    if (prefixListName) {
      res["PrefixListName"] = boost::any(*prefixListName);
    }
    if (prefixListId) {
      res["PrefixListId"] = boost::any(*prefixListId);
    }
    if (entries) {
      res["Entries"] = entries ? boost::any(entries->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MaxEntries") != m.end() && !m["MaxEntries"].empty()) {
      maxEntries = make_shared<long>(boost::any_cast<long>(m["MaxEntries"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("AddressFamily") != m.end() && !m["AddressFamily"].empty()) {
      addressFamily = make_shared<string>(boost::any_cast<string>(m["AddressFamily"]));
    }
    if (m.find("PrefixListName") != m.end() && !m["PrefixListName"].empty()) {
      prefixListName = make_shared<string>(boost::any_cast<string>(m["PrefixListName"]));
    }
    if (m.find("PrefixListId") != m.end() && !m["PrefixListId"].empty()) {
      prefixListId = make_shared<string>(boost::any_cast<string>(m["PrefixListId"]));
    }
    if (m.find("Entries") != m.end() && !m["Entries"].empty()) {
      if (typeid(map<string, boost::any>) == m["Entries"].type()) {
        DescribePrefixListAttributesResponseBodyEntries model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Entries"]));
        entries = make_shared<DescribePrefixListAttributesResponseBodyEntries>(model1);
      }
    }
  }


  virtual ~DescribePrefixListAttributesResponseBody() = default;
};
class DescribePrefixListAttributesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePrefixListAttributesResponseBody> body{};

  DescribePrefixListAttributesResponse() {}

  explicit DescribePrefixListAttributesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePrefixListAttributesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePrefixListAttributesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePrefixListAttributesResponse() = default;
};
class DescribePrefixListsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> prefixListId{};
  shared_ptr<string> prefixListName{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> addressFamily{};

  DescribePrefixListsRequest() {}

  explicit DescribePrefixListsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (prefixListId) {
      res["PrefixListId"] = boost::any(*prefixListId);
    }
    if (prefixListName) {
      res["PrefixListName"] = boost::any(*prefixListName);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (addressFamily) {
      res["AddressFamily"] = boost::any(*addressFamily);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PrefixListId") != m.end() && !m["PrefixListId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrefixListId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrefixListId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      prefixListId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PrefixListName") != m.end() && !m["PrefixListName"].empty()) {
      prefixListName = make_shared<string>(boost::any_cast<string>(m["PrefixListName"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("AddressFamily") != m.end() && !m["AddressFamily"].empty()) {
      addressFamily = make_shared<string>(boost::any_cast<string>(m["AddressFamily"]));
    }
  }


  virtual ~DescribePrefixListsRequest() = default;
};
class DescribePrefixListsResponseBodyPrefixListsPrefixList : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<long> associationCount{};
  shared_ptr<long> maxEntries{};
  shared_ptr<string> description{};
  shared_ptr<string> addressFamily{};
  shared_ptr<string> prefixListName{};
  shared_ptr<string> prefixListId{};

  DescribePrefixListsResponseBodyPrefixListsPrefixList() {}

  explicit DescribePrefixListsResponseBodyPrefixListsPrefixList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (associationCount) {
      res["AssociationCount"] = boost::any(*associationCount);
    }
    if (maxEntries) {
      res["MaxEntries"] = boost::any(*maxEntries);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (addressFamily) {
      res["AddressFamily"] = boost::any(*addressFamily);
    }
    if (prefixListName) {
      res["PrefixListName"] = boost::any(*prefixListName);
    }
    if (prefixListId) {
      res["PrefixListId"] = boost::any(*prefixListId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("AssociationCount") != m.end() && !m["AssociationCount"].empty()) {
      associationCount = make_shared<long>(boost::any_cast<long>(m["AssociationCount"]));
    }
    if (m.find("MaxEntries") != m.end() && !m["MaxEntries"].empty()) {
      maxEntries = make_shared<long>(boost::any_cast<long>(m["MaxEntries"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("AddressFamily") != m.end() && !m["AddressFamily"].empty()) {
      addressFamily = make_shared<string>(boost::any_cast<string>(m["AddressFamily"]));
    }
    if (m.find("PrefixListName") != m.end() && !m["PrefixListName"].empty()) {
      prefixListName = make_shared<string>(boost::any_cast<string>(m["PrefixListName"]));
    }
    if (m.find("PrefixListId") != m.end() && !m["PrefixListId"].empty()) {
      prefixListId = make_shared<string>(boost::any_cast<string>(m["PrefixListId"]));
    }
  }


  virtual ~DescribePrefixListsResponseBodyPrefixListsPrefixList() = default;
};
class DescribePrefixListsResponseBodyPrefixLists : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePrefixListsResponseBodyPrefixListsPrefixList>> prefixList{};

  DescribePrefixListsResponseBodyPrefixLists() {}

  explicit DescribePrefixListsResponseBodyPrefixLists(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (prefixList) {
      vector<boost::any> temp1;
      for(auto item1:*prefixList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrefixList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrefixList") != m.end() && !m["PrefixList"].empty()) {
      if (typeid(vector<boost::any>) == m["PrefixList"].type()) {
        vector<DescribePrefixListsResponseBodyPrefixListsPrefixList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrefixList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePrefixListsResponseBodyPrefixListsPrefixList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        prefixList = make_shared<vector<DescribePrefixListsResponseBodyPrefixListsPrefixList>>(expect1);
      }
    }
  }


  virtual ~DescribePrefixListsResponseBodyPrefixLists() = default;
};
class DescribePrefixListsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribePrefixListsResponseBodyPrefixLists> prefixLists{};

  DescribePrefixListsResponseBody() {}

  explicit DescribePrefixListsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (prefixLists) {
      res["PrefixLists"] = prefixLists ? boost::any(prefixLists->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PrefixLists") != m.end() && !m["PrefixLists"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrefixLists"].type()) {
        DescribePrefixListsResponseBodyPrefixLists model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrefixLists"]));
        prefixLists = make_shared<DescribePrefixListsResponseBodyPrefixLists>(model1);
      }
    }
  }


  virtual ~DescribePrefixListsResponseBody() = default;
};
class DescribePrefixListsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePrefixListsResponseBody> body{};

  DescribePrefixListsResponse() {}

  explicit DescribePrefixListsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePrefixListsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePrefixListsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePrefixListsResponse() = default;
};
class DescribePriceRequestSystemDisk : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<long> size{};
  shared_ptr<string> performanceLevel{};

  DescribePriceRequestSystemDisk() {}

  explicit DescribePriceRequestSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
  }


  virtual ~DescribePriceRequestSystemDisk() = default;
};
class DescribePriceRequestDataDisk : public Darabonba::Model {
public:
  shared_ptr<long> size{};
  shared_ptr<string> category{};
  shared_ptr<string> performanceLevel{};

  DescribePriceRequestDataDisk() {}

  explicit DescribePriceRequestDataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
  }


  virtual ~DescribePriceRequestDataDisk() = default;
};
class DescribePriceRequest : public Darabonba::Model {
public:
  shared_ptr<DescribePriceRequestSystemDisk> systemDisk{};
  shared_ptr<vector<DescribePriceRequestDataDisk>> dataDisk{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> imageId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> dedicatedHostType{};
  shared_ptr<string> ioOptimized{};
  shared_ptr<string> instanceNetworkType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<long> period{};
  shared_ptr<string> priceUnit{};
  shared_ptr<long> amount{};
  shared_ptr<string> offeringType{};
  shared_ptr<long> instanceAmount{};
  shared_ptr<string> scope{};
  shared_ptr<string> platform{};
  shared_ptr<long> capacity{};
  shared_ptr<string> assuranceTimes{};
  shared_ptr<long> instanceCpuCoreCount{};
  shared_ptr<string> isp{};
  shared_ptr<vector<string>> instanceTypeList{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<long> spotDuration{};
  shared_ptr<string> zoneId{};

  DescribePriceRequest() {}

  explicit DescribePriceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataDisk) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisk"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (dedicatedHostType) {
      res["DedicatedHostType"] = boost::any(*dedicatedHostType);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (instanceNetworkType) {
      res["InstanceNetworkType"] = boost::any(*instanceNetworkType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (priceUnit) {
      res["PriceUnit"] = boost::any(*priceUnit);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (offeringType) {
      res["OfferingType"] = boost::any(*offeringType);
    }
    if (instanceAmount) {
      res["InstanceAmount"] = boost::any(*instanceAmount);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (capacity) {
      res["Capacity"] = boost::any(*capacity);
    }
    if (assuranceTimes) {
      res["AssuranceTimes"] = boost::any(*assuranceTimes);
    }
    if (instanceCpuCoreCount) {
      res["InstanceCpuCoreCount"] = boost::any(*instanceCpuCoreCount);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (instanceTypeList) {
      res["InstanceTypeList"] = boost::any(*instanceTypeList);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (spotDuration) {
      res["SpotDuration"] = boost::any(*spotDuration);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        DescribePriceRequestSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<DescribePriceRequestSystemDisk>(model1);
      }
    }
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisk"].type()) {
        vector<DescribePriceRequestDataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePriceRequestDataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisk = make_shared<vector<DescribePriceRequestDataDisk>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("DedicatedHostType") != m.end() && !m["DedicatedHostType"].empty()) {
      dedicatedHostType = make_shared<string>(boost::any_cast<string>(m["DedicatedHostType"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("InstanceNetworkType") != m.end() && !m["InstanceNetworkType"].empty()) {
      instanceNetworkType = make_shared<string>(boost::any_cast<string>(m["InstanceNetworkType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PriceUnit") != m.end() && !m["PriceUnit"].empty()) {
      priceUnit = make_shared<string>(boost::any_cast<string>(m["PriceUnit"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("OfferingType") != m.end() && !m["OfferingType"].empty()) {
      offeringType = make_shared<string>(boost::any_cast<string>(m["OfferingType"]));
    }
    if (m.find("InstanceAmount") != m.end() && !m["InstanceAmount"].empty()) {
      instanceAmount = make_shared<long>(boost::any_cast<long>(m["InstanceAmount"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("Capacity") != m.end() && !m["Capacity"].empty()) {
      capacity = make_shared<long>(boost::any_cast<long>(m["Capacity"]));
    }
    if (m.find("AssuranceTimes") != m.end() && !m["AssuranceTimes"].empty()) {
      assuranceTimes = make_shared<string>(boost::any_cast<string>(m["AssuranceTimes"]));
    }
    if (m.find("InstanceCpuCoreCount") != m.end() && !m["InstanceCpuCoreCount"].empty()) {
      instanceCpuCoreCount = make_shared<long>(boost::any_cast<long>(m["InstanceCpuCoreCount"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("InstanceTypeList") != m.end() && !m["InstanceTypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypeList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("SpotDuration") != m.end() && !m["SpotDuration"].empty()) {
      spotDuration = make_shared<long>(boost::any_cast<long>(m["SpotDuration"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribePriceRequest() = default;
};
class DescribePriceResponseBodyPriceInfoRulesRule : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> ruleId{};

  DescribePriceResponseBodyPriceInfoRulesRule() {}

  explicit DescribePriceResponseBodyPriceInfoRulesRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoRulesRule() = default;
};
class DescribePriceResponseBodyPriceInfoRules : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePriceResponseBodyPriceInfoRulesRule>> rule{};

  DescribePriceResponseBodyPriceInfoRules() {}

  explicit DescribePriceResponseBodyPriceInfoRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rule) {
      vector<boost::any> temp1;
      for(auto item1:*rule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(vector<boost::any>) == m["Rule"].type()) {
        vector<DescribePriceResponseBodyPriceInfoRulesRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePriceResponseBodyPriceInfoRulesRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rule = make_shared<vector<DescribePriceResponseBodyPriceInfoRulesRule>>(expect1);
      }
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoRules() = default;
};
class DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRulesRule : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> ruleId{};

  DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRulesRule() {}

  explicit DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRulesRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRulesRule() = default;
};
class DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRules : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRulesRule>> rule{};

  DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRules() {}

  explicit DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rule) {
      vector<boost::any> temp1;
      for(auto item1:*rule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(vector<boost::any>) == m["Rule"].type()) {
        vector<DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRulesRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRulesRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rule = make_shared<vector<DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRulesRule>>(expect1);
      }
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRules() = default;
};
class DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModel : public Darabonba::Model {
public:
  shared_ptr<string> resource{};
  shared_ptr<double> originalPrice{};
  shared_ptr<double> discountPrice{};
  shared_ptr<double> tradePrice{};
  shared_ptr<DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRules> subRules{};

  DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModel() {}

  explicit DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    if (subRules) {
      res["SubRules"] = subRules ? boost::any(subRules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<double>(boost::any_cast<double>(m["DiscountPrice"]));
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
    if (m.find("SubRules") != m.end() && !m["SubRules"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubRules"].type()) {
        DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubRules"]));
        subRules = make_shared<DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRules>(model1);
      }
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModel() = default;
};
class DescribePriceResponseBodyPriceInfoPriceDetailInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModel>> resourcePriceModel{};

  DescribePriceResponseBodyPriceInfoPriceDetailInfos() {}

  explicit DescribePriceResponseBodyPriceInfoPriceDetailInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourcePriceModel) {
      vector<boost::any> temp1;
      for(auto item1:*resourcePriceModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourcePriceModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourcePriceModel") != m.end() && !m["ResourcePriceModel"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourcePriceModel"].type()) {
        vector<DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourcePriceModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourcePriceModel = make_shared<vector<DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModel>>(expect1);
      }
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoPriceDetailInfos() = default;
};
class DescribePriceResponseBodyPriceInfoPrice : public Darabonba::Model {
public:
  shared_ptr<double> originalPrice{};
  shared_ptr<double> reservedInstanceHourPrice{};
  shared_ptr<double> discountPrice{};
  shared_ptr<string> currency{};
  shared_ptr<double> tradePrice{};
  shared_ptr<DescribePriceResponseBodyPriceInfoPriceDetailInfos> detailInfos{};

  DescribePriceResponseBodyPriceInfoPrice() {}

  explicit DescribePriceResponseBodyPriceInfoPrice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (reservedInstanceHourPrice) {
      res["ReservedInstanceHourPrice"] = boost::any(*reservedInstanceHourPrice);
    }
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    if (detailInfos) {
      res["DetailInfos"] = detailInfos ? boost::any(detailInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("ReservedInstanceHourPrice") != m.end() && !m["ReservedInstanceHourPrice"].empty()) {
      reservedInstanceHourPrice = make_shared<double>(boost::any_cast<double>(m["ReservedInstanceHourPrice"]));
    }
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<double>(boost::any_cast<double>(m["DiscountPrice"]));
    }
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
    if (m.find("DetailInfos") != m.end() && !m["DetailInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["DetailInfos"].type()) {
        DescribePriceResponseBodyPriceInfoPriceDetailInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DetailInfos"]));
        detailInfos = make_shared<DescribePriceResponseBodyPriceInfoPriceDetailInfos>(model1);
      }
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoPrice() = default;
};
class DescribePriceResponseBodyPriceInfo : public Darabonba::Model {
public:
  shared_ptr<DescribePriceResponseBodyPriceInfoRules> rules{};
  shared_ptr<DescribePriceResponseBodyPriceInfoPrice> price{};

  DescribePriceResponseBodyPriceInfo() {}

  explicit DescribePriceResponseBodyPriceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rules) {
      res["Rules"] = rules ? boost::any(rules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (price) {
      res["Price"] = price ? boost::any(price->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rules"].type()) {
        DescribePriceResponseBodyPriceInfoRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rules"]));
        rules = make_shared<DescribePriceResponseBodyPriceInfoRules>(model1);
      }
    }
    if (m.find("Price") != m.end() && !m["Price"].empty()) {
      if (typeid(map<string, boost::any>) == m["Price"].type()) {
        DescribePriceResponseBodyPriceInfoPrice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Price"]));
        price = make_shared<DescribePriceResponseBodyPriceInfoPrice>(model1);
      }
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfo() = default;
};
class DescribePriceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribePriceResponseBodyPriceInfo> priceInfo{};

  DescribePriceResponseBody() {}

  explicit DescribePriceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (priceInfo) {
      res["PriceInfo"] = priceInfo ? boost::any(priceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PriceInfo") != m.end() && !m["PriceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PriceInfo"].type()) {
        DescribePriceResponseBodyPriceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PriceInfo"]));
        priceInfo = make_shared<DescribePriceResponseBodyPriceInfo>(model1);
      }
    }
  }


  virtual ~DescribePriceResponseBody() = default;
};
class DescribePriceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePriceResponseBody> body{};

  DescribePriceResponse() {}

  explicit DescribePriceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePriceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePriceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePriceResponse() = default;
};
class DescribeRecommendInstanceTypeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> cores{};
  shared_ptr<double> memory{};
  shared_ptr<string> instanceFamilyLevel{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> networkType{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<string> ioOptimized{};
  shared_ptr<string> priorityStrategy{};
  shared_ptr<double> maxPrice{};
  shared_ptr<string> regionId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> systemDiskCategory{};
  shared_ptr<string> zoneMatchMode{};
  shared_ptr<string> scene{};
  shared_ptr<vector<string>> instanceTypeFamily{};

  DescribeRecommendInstanceTypeRequest() {}

  explicit DescribeRecommendInstanceTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (instanceFamilyLevel) {
      res["InstanceFamilyLevel"] = boost::any(*instanceFamilyLevel);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (priorityStrategy) {
      res["PriorityStrategy"] = boost::any(*priorityStrategy);
    }
    if (maxPrice) {
      res["MaxPrice"] = boost::any(*maxPrice);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (systemDiskCategory) {
      res["SystemDiskCategory"] = boost::any(*systemDiskCategory);
    }
    if (zoneMatchMode) {
      res["ZoneMatchMode"] = boost::any(*zoneMatchMode);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("InstanceFamilyLevel") != m.end() && !m["InstanceFamilyLevel"].empty()) {
      instanceFamilyLevel = make_shared<string>(boost::any_cast<string>(m["InstanceFamilyLevel"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("PriorityStrategy") != m.end() && !m["PriorityStrategy"].empty()) {
      priorityStrategy = make_shared<string>(boost::any_cast<string>(m["PriorityStrategy"]));
    }
    if (m.find("MaxPrice") != m.end() && !m["MaxPrice"].empty()) {
      maxPrice = make_shared<double>(boost::any_cast<double>(m["MaxPrice"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("SystemDiskCategory") != m.end() && !m["SystemDiskCategory"].empty()) {
      systemDiskCategory = make_shared<string>(boost::any_cast<string>(m["SystemDiskCategory"]));
    }
    if (m.find("ZoneMatchMode") != m.end() && !m["ZoneMatchMode"].empty()) {
      zoneMatchMode = make_shared<string>(boost::any_cast<string>(m["ZoneMatchMode"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypeFamily"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypeFamily"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypeFamily = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeRecommendInstanceTypeRequest() = default;
};
class DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZonesZoneNetworkTypes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> networkType{};

  DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZonesZoneNetworkTypes() {}

  explicit DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZonesZoneNetworkTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NetworkType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NetworkType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      networkType = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZonesZoneNetworkTypes() = default;
};
class DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZonesZone : public Darabonba::Model {
public:
  shared_ptr<string> zoneNo{};
  shared_ptr<DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZonesZoneNetworkTypes> networkTypes{};

  DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZonesZone() {}

  explicit DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZonesZone(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (zoneNo) {
      res["ZoneNo"] = boost::any(*zoneNo);
    }
    if (networkTypes) {
      res["NetworkTypes"] = networkTypes ? boost::any(networkTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ZoneNo") != m.end() && !m["ZoneNo"].empty()) {
      zoneNo = make_shared<string>(boost::any_cast<string>(m["ZoneNo"]));
    }
    if (m.find("NetworkTypes") != m.end() && !m["NetworkTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkTypes"].type()) {
        DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZonesZoneNetworkTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkTypes"]));
        networkTypes = make_shared<DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZonesZoneNetworkTypes>(model1);
      }
    }
  }


  virtual ~DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZonesZone() = default;
};
class DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZones : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZonesZone>> zone{};

  DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZones() {}

  explicit DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (zone) {
      vector<boost::any> temp1;
      for(auto item1:*zone){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["zone"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("zone") != m.end() && !m["zone"].empty()) {
      if (typeid(vector<boost::any>) == m["zone"].type()) {
        vector<DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZonesZone> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["zone"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZonesZone model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        zone = make_shared<vector<DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZonesZone>>(expect1);
      }
    }
  }


  virtual ~DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZones() = default;
};
class DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeInstanceType : public Darabonba::Model {
public:
  shared_ptr<string> supportIoOptimized{};
  shared_ptr<long> cores{};
  shared_ptr<long> memory{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> instanceTypeFamily{};
  shared_ptr<string> generation{};

  DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeInstanceType() {}

  explicit DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeInstanceType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportIoOptimized) {
      res["SupportIoOptimized"] = boost::any(*supportIoOptimized);
    }
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    if (generation) {
      res["Generation"] = boost::any(*generation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportIoOptimized") != m.end() && !m["SupportIoOptimized"].empty()) {
      supportIoOptimized = make_shared<string>(boost::any_cast<string>(m["SupportIoOptimized"]));
    }
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      instanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamily"]));
    }
    if (m.find("Generation") != m.end() && !m["Generation"].empty()) {
      generation = make_shared<string>(boost::any_cast<string>(m["Generation"]));
    }
  }


  virtual ~DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeInstanceType() = default;
};
class DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceType : public Darabonba::Model {
public:
  shared_ptr<string> commodityCode{};
  shared_ptr<string> zoneId{};
  shared_ptr<long> priority{};
  shared_ptr<string> networkType{};
  shared_ptr<string> scene{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZones> zones{};
  shared_ptr<DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeInstanceType> instanceType{};

  DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceType() {}

  explicit DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (zones) {
      res["Zones"] = zones ? boost::any(zones->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceType) {
      res["InstanceType"] = instanceType ? boost::any(instanceType->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("Zones") != m.end() && !m["Zones"].empty()) {
      if (typeid(map<string, boost::any>) == m["Zones"].type()) {
        DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZones model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Zones"]));
        zones = make_shared<DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZones>(model1);
      }
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceType"].type()) {
        DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeInstanceType model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceType"]));
        instanceType = make_shared<DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeInstanceType>(model1);
      }
    }
  }


  virtual ~DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceType() = default;
};
class DescribeRecommendInstanceTypeResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceType>> recommendInstanceType{};

  DescribeRecommendInstanceTypeResponseBodyData() {}

  explicit DescribeRecommendInstanceTypeResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommendInstanceType) {
      vector<boost::any> temp1;
      for(auto item1:*recommendInstanceType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecommendInstanceType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecommendInstanceType") != m.end() && !m["RecommendInstanceType"].empty()) {
      if (typeid(vector<boost::any>) == m["RecommendInstanceType"].type()) {
        vector<DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecommendInstanceType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recommendInstanceType = make_shared<vector<DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceType>>(expect1);
      }
    }
  }


  virtual ~DescribeRecommendInstanceTypeResponseBodyData() = default;
};
class DescribeRecommendInstanceTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRecommendInstanceTypeResponseBodyData> data{};

  DescribeRecommendInstanceTypeResponseBody() {}

  explicit DescribeRecommendInstanceTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeRecommendInstanceTypeResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeRecommendInstanceTypeResponseBodyData>(model1);
      }
    }
  }


  virtual ~DescribeRecommendInstanceTypeResponseBody() = default;
};
class DescribeRecommendInstanceTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRecommendInstanceTypeResponseBody> body{};

  DescribeRecommendInstanceTypeResponse() {}

  explicit DescribeRecommendInstanceTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRecommendInstanceTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRecommendInstanceTypeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRecommendInstanceTypeResponse() = default;
};
class DescribeRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> acceptLanguage{};

  DescribeRegionsRequest() {}

  explicit DescribeRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
  }


  virtual ~DescribeRegionsRequest() = default;
};
class DescribeRegionsResponseBodyRegionsRegion : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> regionEndpoint{};
  shared_ptr<string> localName{};
  shared_ptr<string> regionId{};

  DescribeRegionsResponseBodyRegionsRegion() {}

  explicit DescribeRegionsResponseBodyRegionsRegion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (regionEndpoint) {
      res["RegionEndpoint"] = boost::any(*regionEndpoint);
    }
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("RegionEndpoint") != m.end() && !m["RegionEndpoint"].empty()) {
      regionEndpoint = make_shared<string>(boost::any_cast<string>(m["RegionEndpoint"]));
    }
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeRegionsResponseBodyRegionsRegion() = default;
};
class DescribeRegionsResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRegionsResponseBodyRegionsRegion>> region{};

  DescribeRegionsResponseBodyRegions() {}

  explicit DescribeRegionsResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      vector<boost::any> temp1;
      for(auto item1:*region){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Region"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      if (typeid(vector<boost::any>) == m["Region"].type()) {
        vector<DescribeRegionsResponseBodyRegionsRegion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Region"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRegionsResponseBodyRegionsRegion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        region = make_shared<vector<DescribeRegionsResponseBodyRegionsRegion>>(expect1);
      }
    }
  }


  virtual ~DescribeRegionsResponseBodyRegions() = default;
};
class DescribeRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRegionsResponseBodyRegions> regions{};

  DescribeRegionsResponseBody() {}

  explicit DescribeRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (regions) {
      res["Regions"] = regions ? boost::any(regions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(map<string, boost::any>) == m["Regions"].type()) {
        DescribeRegionsResponseBodyRegions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Regions"]));
        regions = make_shared<DescribeRegionsResponseBodyRegions>(model1);
      }
    }
  }


  virtual ~DescribeRegionsResponseBody() = default;
};
class DescribeRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRegionsResponseBody> body{};

  DescribeRegionsResponse() {}

  explicit DescribeRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRegionsResponse() = default;
};
class DescribeRenewalPriceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceId{};
  shared_ptr<long> period{};
  shared_ptr<string> priceUnit{};
  shared_ptr<long> expectedRenewDay{};

  DescribeRenewalPriceRequest() {}

  explicit DescribeRenewalPriceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (priceUnit) {
      res["PriceUnit"] = boost::any(*priceUnit);
    }
    if (expectedRenewDay) {
      res["ExpectedRenewDay"] = boost::any(*expectedRenewDay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PriceUnit") != m.end() && !m["PriceUnit"].empty()) {
      priceUnit = make_shared<string>(boost::any_cast<string>(m["PriceUnit"]));
    }
    if (m.find("ExpectedRenewDay") != m.end() && !m["ExpectedRenewDay"].empty()) {
      expectedRenewDay = make_shared<long>(boost::any_cast<long>(m["ExpectedRenewDay"]));
    }
  }


  virtual ~DescribeRenewalPriceRequest() = default;
};
class DescribeRenewalPriceResponseBodyPriceInfoRulesRule : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> ruleId{};

  DescribeRenewalPriceResponseBodyPriceInfoRulesRule() {}

  explicit DescribeRenewalPriceResponseBodyPriceInfoRulesRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~DescribeRenewalPriceResponseBodyPriceInfoRulesRule() = default;
};
class DescribeRenewalPriceResponseBodyPriceInfoRules : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRenewalPriceResponseBodyPriceInfoRulesRule>> rule{};

  DescribeRenewalPriceResponseBodyPriceInfoRules() {}

  explicit DescribeRenewalPriceResponseBodyPriceInfoRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rule) {
      vector<boost::any> temp1;
      for(auto item1:*rule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(vector<boost::any>) == m["Rule"].type()) {
        vector<DescribeRenewalPriceResponseBodyPriceInfoRulesRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRenewalPriceResponseBodyPriceInfoRulesRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rule = make_shared<vector<DescribeRenewalPriceResponseBodyPriceInfoRulesRule>>(expect1);
      }
    }
  }


  virtual ~DescribeRenewalPriceResponseBodyPriceInfoRules() = default;
};
class DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRulesRule : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> ruleId{};

  DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRulesRule() {}

  explicit DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRulesRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRulesRule() = default;
};
class DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRules : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRulesRule>> rule{};

  DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRules() {}

  explicit DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rule) {
      vector<boost::any> temp1;
      for(auto item1:*rule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(vector<boost::any>) == m["Rule"].type()) {
        vector<DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRulesRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRulesRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rule = make_shared<vector<DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRulesRule>>(expect1);
      }
    }
  }


  virtual ~DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRules() = default;
};
class DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModel : public Darabonba::Model {
public:
  shared_ptr<string> resource{};
  shared_ptr<double> originalPrice{};
  shared_ptr<double> discountPrice{};
  shared_ptr<double> tradePrice{};
  shared_ptr<DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRules> subRules{};

  DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModel() {}

  explicit DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    if (subRules) {
      res["SubRules"] = subRules ? boost::any(subRules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<double>(boost::any_cast<double>(m["DiscountPrice"]));
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
    if (m.find("SubRules") != m.end() && !m["SubRules"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubRules"].type()) {
        DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubRules"]));
        subRules = make_shared<DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRules>(model1);
      }
    }
  }


  virtual ~DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModel() = default;
};
class DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModel>> resourcePriceModel{};

  DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfos() {}

  explicit DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourcePriceModel) {
      vector<boost::any> temp1;
      for(auto item1:*resourcePriceModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourcePriceModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourcePriceModel") != m.end() && !m["ResourcePriceModel"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourcePriceModel"].type()) {
        vector<DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourcePriceModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourcePriceModel = make_shared<vector<DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModel>>(expect1);
      }
    }
  }


  virtual ~DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfos() = default;
};
class DescribeRenewalPriceResponseBodyPriceInfoPrice : public Darabonba::Model {
public:
  shared_ptr<double> originalPrice{};
  shared_ptr<double> discountPrice{};
  shared_ptr<string> currency{};
  shared_ptr<double> tradePrice{};
  shared_ptr<DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfos> detailInfos{};

  DescribeRenewalPriceResponseBodyPriceInfoPrice() {}

  explicit DescribeRenewalPriceResponseBodyPriceInfoPrice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    if (detailInfos) {
      res["DetailInfos"] = detailInfos ? boost::any(detailInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<double>(boost::any_cast<double>(m["DiscountPrice"]));
    }
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
    if (m.find("DetailInfos") != m.end() && !m["DetailInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["DetailInfos"].type()) {
        DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DetailInfos"]));
        detailInfos = make_shared<DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfos>(model1);
      }
    }
  }


  virtual ~DescribeRenewalPriceResponseBodyPriceInfoPrice() = default;
};
class DescribeRenewalPriceResponseBodyPriceInfo : public Darabonba::Model {
public:
  shared_ptr<DescribeRenewalPriceResponseBodyPriceInfoRules> rules{};
  shared_ptr<DescribeRenewalPriceResponseBodyPriceInfoPrice> price{};

  DescribeRenewalPriceResponseBodyPriceInfo() {}

  explicit DescribeRenewalPriceResponseBodyPriceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rules) {
      res["Rules"] = rules ? boost::any(rules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (price) {
      res["Price"] = price ? boost::any(price->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rules"].type()) {
        DescribeRenewalPriceResponseBodyPriceInfoRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rules"]));
        rules = make_shared<DescribeRenewalPriceResponseBodyPriceInfoRules>(model1);
      }
    }
    if (m.find("Price") != m.end() && !m["Price"].empty()) {
      if (typeid(map<string, boost::any>) == m["Price"].type()) {
        DescribeRenewalPriceResponseBodyPriceInfoPrice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Price"]));
        price = make_shared<DescribeRenewalPriceResponseBodyPriceInfoPrice>(model1);
      }
    }
  }


  virtual ~DescribeRenewalPriceResponseBodyPriceInfo() = default;
};
class DescribeRenewalPriceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRenewalPriceResponseBodyPriceInfo> priceInfo{};

  DescribeRenewalPriceResponseBody() {}

  explicit DescribeRenewalPriceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (priceInfo) {
      res["PriceInfo"] = priceInfo ? boost::any(priceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PriceInfo") != m.end() && !m["PriceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PriceInfo"].type()) {
        DescribeRenewalPriceResponseBodyPriceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PriceInfo"]));
        priceInfo = make_shared<DescribeRenewalPriceResponseBodyPriceInfo>(model1);
      }
    }
  }


  virtual ~DescribeRenewalPriceResponseBody() = default;
};
class DescribeRenewalPriceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRenewalPriceResponseBody> body{};

  DescribeRenewalPriceResponse() {}

  explicit DescribeRenewalPriceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRenewalPriceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRenewalPriceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRenewalPriceResponse() = default;
};
class DescribeReservedInstancesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeReservedInstancesRequestTag() {}

  explicit DescribeReservedInstancesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeReservedInstancesRequestTag() = default;
};
class DescribeReservedInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeReservedInstancesRequestTag>> tag{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> reservedInstanceId{};
  shared_ptr<vector<string>> status{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> reservedInstanceName{};
  shared_ptr<string> lockReason{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> instanceTypeFamily{};
  shared_ptr<string> scope{};
  shared_ptr<string> offeringType{};
  shared_ptr<string> allocationType{};

  DescribeReservedInstancesRequest() {}

  explicit DescribeReservedInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (reservedInstanceId) {
      res["ReservedInstanceId"] = boost::any(*reservedInstanceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (reservedInstanceName) {
      res["ReservedInstanceName"] = boost::any(*reservedInstanceName);
    }
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (offeringType) {
      res["OfferingType"] = boost::any(*offeringType);
    }
    if (allocationType) {
      res["AllocationType"] = boost::any(*allocationType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeReservedInstancesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeReservedInstancesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeReservedInstancesRequestTag>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ReservedInstanceId") != m.end() && !m["ReservedInstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReservedInstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReservedInstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      reservedInstanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Status"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Status"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      status = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("ReservedInstanceName") != m.end() && !m["ReservedInstanceName"].empty()) {
      reservedInstanceName = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceName"]));
    }
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      instanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamily"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("OfferingType") != m.end() && !m["OfferingType"].empty()) {
      offeringType = make_shared<string>(boost::any_cast<string>(m["OfferingType"]));
    }
    if (m.find("AllocationType") != m.end() && !m["AllocationType"].empty()) {
      allocationType = make_shared<string>(boost::any_cast<string>(m["AllocationType"]));
    }
  }


  virtual ~DescribeReservedInstancesRequest() = default;
};
class DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocksOperationLock : public Darabonba::Model {
public:
  shared_ptr<string> lockReason{};

  DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocksOperationLock() {}

  explicit DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocksOperationLock(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
  }


  virtual ~DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocksOperationLock() = default;
};
class DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocksOperationLock>> operationLock{};

  DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocks() {}

  explicit DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationLock) {
      vector<boost::any> temp1;
      for(auto item1:*operationLock){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperationLock"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationLock") != m.end() && !m["OperationLock"].empty()) {
      if (typeid(vector<boost::any>) == m["OperationLock"].type()) {
        vector<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocksOperationLock> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperationLock"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocksOperationLock model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operationLock = make_shared<vector<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocksOperationLock>>(expect1);
      }
    }
  }


  virtual ~DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocks() = default;
};
class DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTagsTag() {}

  explicit DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTagsTag() = default;
};
class DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTagsTag>> tag{};

  DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTags() {}

  explicit DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTags() = default;
};
class DescribeReservedInstancesResponseBodyReservedInstancesReservedInstance : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> reservedInstanceName{};
  shared_ptr<string> reservedInstanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> instanceAmount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> offeringType{};
  shared_ptr<string> startTime{};
  shared_ptr<string> description{};
  shared_ptr<string> allocationStatus{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> platform{};
  shared_ptr<string> scope{};
  shared_ptr<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocks> operationLocks{};
  shared_ptr<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTags> tags{};

  DescribeReservedInstancesResponseBodyReservedInstancesReservedInstance() {}

  explicit DescribeReservedInstancesResponseBodyReservedInstancesReservedInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (reservedInstanceName) {
      res["ReservedInstanceName"] = boost::any(*reservedInstanceName);
    }
    if (reservedInstanceId) {
      res["ReservedInstanceId"] = boost::any(*reservedInstanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (instanceAmount) {
      res["InstanceAmount"] = boost::any(*instanceAmount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (offeringType) {
      res["OfferingType"] = boost::any(*offeringType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (allocationStatus) {
      res["AllocationStatus"] = boost::any(*allocationStatus);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (operationLocks) {
      res["OperationLocks"] = operationLocks ? boost::any(operationLocks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("ReservedInstanceName") != m.end() && !m["ReservedInstanceName"].empty()) {
      reservedInstanceName = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceName"]));
    }
    if (m.find("ReservedInstanceId") != m.end() && !m["ReservedInstanceId"].empty()) {
      reservedInstanceId = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InstanceAmount") != m.end() && !m["InstanceAmount"].empty()) {
      instanceAmount = make_shared<long>(boost::any_cast<long>(m["InstanceAmount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("OfferingType") != m.end() && !m["OfferingType"].empty()) {
      offeringType = make_shared<string>(boost::any_cast<string>(m["OfferingType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("AllocationStatus") != m.end() && !m["AllocationStatus"].empty()) {
      allocationStatus = make_shared<string>(boost::any_cast<string>(m["AllocationStatus"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("OperationLocks") != m.end() && !m["OperationLocks"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperationLocks"].type()) {
        DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperationLocks"]));
        operationLocks = make_shared<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocks>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTags>(model1);
      }
    }
  }


  virtual ~DescribeReservedInstancesResponseBodyReservedInstancesReservedInstance() = default;
};
class DescribeReservedInstancesResponseBodyReservedInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstance>> reservedInstance{};

  DescribeReservedInstancesResponseBodyReservedInstances() {}

  explicit DescribeReservedInstancesResponseBodyReservedInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reservedInstance) {
      vector<boost::any> temp1;
      for(auto item1:*reservedInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReservedInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReservedInstance") != m.end() && !m["ReservedInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["ReservedInstance"].type()) {
        vector<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReservedInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeReservedInstancesResponseBodyReservedInstancesReservedInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reservedInstance = make_shared<vector<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeReservedInstancesResponseBodyReservedInstances() = default;
};
class DescribeReservedInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeReservedInstancesResponseBodyReservedInstances> reservedInstances{};

  DescribeReservedInstancesResponseBody() {}

  explicit DescribeReservedInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (reservedInstances) {
      res["ReservedInstances"] = reservedInstances ? boost::any(reservedInstances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("ReservedInstances") != m.end() && !m["ReservedInstances"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReservedInstances"].type()) {
        DescribeReservedInstancesResponseBodyReservedInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReservedInstances"]));
        reservedInstances = make_shared<DescribeReservedInstancesResponseBodyReservedInstances>(model1);
      }
    }
  }


  virtual ~DescribeReservedInstancesResponseBody() = default;
};
class DescribeReservedInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeReservedInstancesResponseBody> body{};

  DescribeReservedInstancesResponse() {}

  explicit DescribeReservedInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeReservedInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeReservedInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeReservedInstancesResponse() = default;
};
class DescribeResourceByTagsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeResourceByTagsRequestTag() {}

  explicit DescribeResourceByTagsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeResourceByTagsRequestTag() = default;
};
class DescribeResourceByTagsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<DescribeResourceByTagsRequestTag>> tag{};

  DescribeResourceByTagsRequest() {}

  explicit DescribeResourceByTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeResourceByTagsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceByTagsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeResourceByTagsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceByTagsRequest() = default;
};
class DescribeResourceByTagsResponseBodyResourcesResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> regionId{};

  DescribeResourceByTagsResponseBodyResourcesResource() {}

  explicit DescribeResourceByTagsResponseBodyResourcesResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeResourceByTagsResponseBodyResourcesResource() = default;
};
class DescribeResourceByTagsResponseBodyResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeResourceByTagsResponseBodyResourcesResource>> resource{};

  DescribeResourceByTagsResponseBodyResources() {}

  explicit DescribeResourceByTagsResponseBodyResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resource) {
      vector<boost::any> temp1;
      for(auto item1:*resource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(vector<boost::any>) == m["Resource"].type()) {
        vector<DescribeResourceByTagsResponseBodyResourcesResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceByTagsResponseBodyResourcesResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resource = make_shared<vector<DescribeResourceByTagsResponseBodyResourcesResource>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceByTagsResponseBodyResources() = default;
};
class DescribeResourceByTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeResourceByTagsResponseBodyResources> resources{};

  DescribeResourceByTagsResponseBody() {}

  explicit DescribeResourceByTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (resources) {
      res["Resources"] = resources ? boost::any(resources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resources"].type()) {
        DescribeResourceByTagsResponseBodyResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resources"]));
        resources = make_shared<DescribeResourceByTagsResponseBodyResources>(model1);
      }
    }
  }


  virtual ~DescribeResourceByTagsResponseBody() = default;
};
class DescribeResourceByTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeResourceByTagsResponseBody> body{};

  DescribeResourceByTagsResponse() {}

  explicit DescribeResourceByTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeResourceByTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeResourceByTagsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeResourceByTagsResponse() = default;
};
class DescribeResourcesModificationRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<bool> migrateAcrossZone{};
  shared_ptr<string> destinationResource{};
  shared_ptr<string> operationType{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> cores{};
  shared_ptr<double> memory{};

  DescribeResourcesModificationRequest() {}

  explicit DescribeResourcesModificationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (migrateAcrossZone) {
      res["MigrateAcrossZone"] = boost::any(*migrateAcrossZone);
    }
    if (destinationResource) {
      res["DestinationResource"] = boost::any(*destinationResource);
    }
    if (operationType) {
      res["OperationType"] = boost::any(*operationType);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("MigrateAcrossZone") != m.end() && !m["MigrateAcrossZone"].empty()) {
      migrateAcrossZone = make_shared<bool>(boost::any_cast<bool>(m["MigrateAcrossZone"]));
    }
    if (m.find("DestinationResource") != m.end() && !m["DestinationResource"].empty()) {
      destinationResource = make_shared<string>(boost::any_cast<string>(m["DestinationResource"]));
    }
    if (m.find("OperationType") != m.end() && !m["OperationType"].empty()) {
      operationType = make_shared<string>(boost::any_cast<string>(m["OperationType"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
  }


  virtual ~DescribeResourcesModificationRequest() = default;
};
class DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResourcesSupportedResource : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> value{};
  shared_ptr<long> max{};
  shared_ptr<string> unit{};
  shared_ptr<string> statusCategory{};
  shared_ptr<long> min{};

  DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResourcesSupportedResource() {}

  explicit DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResourcesSupportedResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (statusCategory) {
      res["StatusCategory"] = boost::any(*statusCategory);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<long>(boost::any_cast<long>(m["Max"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("StatusCategory") != m.end() && !m["StatusCategory"].empty()) {
      statusCategory = make_shared<string>(boost::any_cast<string>(m["StatusCategory"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<long>(boost::any_cast<long>(m["Min"]));
    }
  }


  virtual ~DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResourcesSupportedResource() = default;
};
class DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResourcesSupportedResource>> supportedResource{};

  DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResources() {}

  explicit DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportedResource) {
      vector<boost::any> temp1;
      for(auto item1:*supportedResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SupportedResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportedResource") != m.end() && !m["SupportedResource"].empty()) {
      if (typeid(vector<boost::any>) == m["SupportedResource"].type()) {
        vector<DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResourcesSupportedResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SupportedResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResourcesSupportedResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supportedResource = make_shared<vector<DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResourcesSupportedResource>>(expect1);
      }
    }
  }


  virtual ~DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResources() = default;
};
class DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResource : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResources> supportedResources{};

  DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResource() {}

  explicit DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (supportedResources) {
      res["SupportedResources"] = supportedResources ? boost::any(supportedResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("SupportedResources") != m.end() && !m["SupportedResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportedResources"].type()) {
        DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportedResources"]));
        supportedResources = make_shared<DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResources>(model1);
      }
    }
  }


  virtual ~DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResource() = default;
};
class DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResource>> availableResource{};

  DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResources() {}

  explicit DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableResource) {
      vector<boost::any> temp1;
      for(auto item1:*availableResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvailableResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableResource") != m.end() && !m["AvailableResource"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableResource"].type()) {
        vector<DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        availableResource = make_shared<vector<DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResource>>(expect1);
      }
    }
  }


  virtual ~DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResources() = default;
};
class DescribeResourcesModificationResponseBodyAvailableZonesAvailableZone : public Darabonba::Model {
public:
  shared_ptr<string> zoneId{};
  shared_ptr<string> status{};
  shared_ptr<string> statusCategory{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResources> availableResources{};

  DescribeResourcesModificationResponseBodyAvailableZonesAvailableZone() {}

  explicit DescribeResourcesModificationResponseBodyAvailableZonesAvailableZone(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusCategory) {
      res["StatusCategory"] = boost::any(*statusCategory);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (availableResources) {
      res["AvailableResources"] = availableResources ? boost::any(availableResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StatusCategory") != m.end() && !m["StatusCategory"].empty()) {
      statusCategory = make_shared<string>(boost::any_cast<string>(m["StatusCategory"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AvailableResources") != m.end() && !m["AvailableResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvailableResources"].type()) {
        DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvailableResources"]));
        availableResources = make_shared<DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResources>(model1);
      }
    }
  }


  virtual ~DescribeResourcesModificationResponseBodyAvailableZonesAvailableZone() = default;
};
class DescribeResourcesModificationResponseBodyAvailableZones : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeResourcesModificationResponseBodyAvailableZonesAvailableZone>> availableZone{};

  DescribeResourcesModificationResponseBodyAvailableZones() {}

  explicit DescribeResourcesModificationResponseBodyAvailableZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableZone) {
      vector<boost::any> temp1;
      for(auto item1:*availableZone){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvailableZone"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableZone") != m.end() && !m["AvailableZone"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableZone"].type()) {
        vector<DescribeResourcesModificationResponseBodyAvailableZonesAvailableZone> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableZone"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourcesModificationResponseBodyAvailableZonesAvailableZone model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        availableZone = make_shared<vector<DescribeResourcesModificationResponseBodyAvailableZonesAvailableZone>>(expect1);
      }
    }
  }


  virtual ~DescribeResourcesModificationResponseBodyAvailableZones() = default;
};
class DescribeResourcesModificationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeResourcesModificationResponseBodyAvailableZones> availableZones{};

  DescribeResourcesModificationResponseBody() {}

  explicit DescribeResourcesModificationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (availableZones) {
      res["AvailableZones"] = availableZones ? boost::any(availableZones->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("AvailableZones") != m.end() && !m["AvailableZones"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvailableZones"].type()) {
        DescribeResourcesModificationResponseBodyAvailableZones model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvailableZones"]));
        availableZones = make_shared<DescribeResourcesModificationResponseBodyAvailableZones>(model1);
      }
    }
  }


  virtual ~DescribeResourcesModificationResponseBody() = default;
};
class DescribeResourcesModificationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeResourcesModificationResponseBody> body{};

  DescribeResourcesModificationResponse() {}

  explicit DescribeResourcesModificationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeResourcesModificationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeResourcesModificationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeResourcesModificationResponse() = default;
};
class DescribeRouterInterfacesRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<string>> value{};

  DescribeRouterInterfacesRequestFilter() {}

  explicit DescribeRouterInterfacesRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Value"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      value = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeRouterInterfacesRequestFilter() = default;
};
class DescribeRouterInterfacesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeRouterInterfacesRequestFilter>> filter{};

  DescribeRouterInterfacesRequest() {}

  explicit DescribeRouterInterfacesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<DescribeRouterInterfacesRequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRouterInterfacesRequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<DescribeRouterInterfacesRequestFilter>>(expect1);
      }
    }
  }


  virtual ~DescribeRouterInterfacesRequest() = default;
};
class DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType : public Darabonba::Model {
public:
  shared_ptr<string> healthCheckTargetIp{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> status{};
  shared_ptr<string> spec{};
  shared_ptr<string> oppositeInterfaceId{};
  shared_ptr<string> routerInterfaceId{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> oppositeRouterType{};
  shared_ptr<string> oppositeInterfaceOwnerId{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> oppositeRouterId{};
  shared_ptr<string> oppositeInterfaceSpec{};
  shared_ptr<string> routerId{};
  shared_ptr<string> oppositeInterfaceBusinessStatus{};
  shared_ptr<string> connectedTime{};
  shared_ptr<string> oppositeInterfaceStatus{};
  shared_ptr<string> healthCheckSourceIp{};
  shared_ptr<string> endTime{};
  shared_ptr<string> oppositeRegionId{};
  shared_ptr<string> oppositeAccessPointId{};
  shared_ptr<string> businessStatus{};
  shared_ptr<string> role{};
  shared_ptr<string> routerType{};
  shared_ptr<string> accessPointId{};

  DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType() {}

  explicit DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthCheckTargetIp) {
      res["HealthCheckTargetIp"] = boost::any(*healthCheckTargetIp);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (oppositeInterfaceId) {
      res["OppositeInterfaceId"] = boost::any(*oppositeInterfaceId);
    }
    if (routerInterfaceId) {
      res["RouterInterfaceId"] = boost::any(*routerInterfaceId);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (oppositeRouterType) {
      res["OppositeRouterType"] = boost::any(*oppositeRouterType);
    }
    if (oppositeInterfaceOwnerId) {
      res["OppositeInterfaceOwnerId"] = boost::any(*oppositeInterfaceOwnerId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (oppositeRouterId) {
      res["OppositeRouterId"] = boost::any(*oppositeRouterId);
    }
    if (oppositeInterfaceSpec) {
      res["OppositeInterfaceSpec"] = boost::any(*oppositeInterfaceSpec);
    }
    if (routerId) {
      res["RouterId"] = boost::any(*routerId);
    }
    if (oppositeInterfaceBusinessStatus) {
      res["OppositeInterfaceBusinessStatus"] = boost::any(*oppositeInterfaceBusinessStatus);
    }
    if (connectedTime) {
      res["ConnectedTime"] = boost::any(*connectedTime);
    }
    if (oppositeInterfaceStatus) {
      res["OppositeInterfaceStatus"] = boost::any(*oppositeInterfaceStatus);
    }
    if (healthCheckSourceIp) {
      res["HealthCheckSourceIp"] = boost::any(*healthCheckSourceIp);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (oppositeRegionId) {
      res["OppositeRegionId"] = boost::any(*oppositeRegionId);
    }
    if (oppositeAccessPointId) {
      res["OppositeAccessPointId"] = boost::any(*oppositeAccessPointId);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (routerType) {
      res["RouterType"] = boost::any(*routerType);
    }
    if (accessPointId) {
      res["AccessPointId"] = boost::any(*accessPointId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthCheckTargetIp") != m.end() && !m["HealthCheckTargetIp"].empty()) {
      healthCheckTargetIp = make_shared<string>(boost::any_cast<string>(m["HealthCheckTargetIp"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("OppositeInterfaceId") != m.end() && !m["OppositeInterfaceId"].empty()) {
      oppositeInterfaceId = make_shared<string>(boost::any_cast<string>(m["OppositeInterfaceId"]));
    }
    if (m.find("RouterInterfaceId") != m.end() && !m["RouterInterfaceId"].empty()) {
      routerInterfaceId = make_shared<string>(boost::any_cast<string>(m["RouterInterfaceId"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("OppositeRouterType") != m.end() && !m["OppositeRouterType"].empty()) {
      oppositeRouterType = make_shared<string>(boost::any_cast<string>(m["OppositeRouterType"]));
    }
    if (m.find("OppositeInterfaceOwnerId") != m.end() && !m["OppositeInterfaceOwnerId"].empty()) {
      oppositeInterfaceOwnerId = make_shared<string>(boost::any_cast<string>(m["OppositeInterfaceOwnerId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OppositeRouterId") != m.end() && !m["OppositeRouterId"].empty()) {
      oppositeRouterId = make_shared<string>(boost::any_cast<string>(m["OppositeRouterId"]));
    }
    if (m.find("OppositeInterfaceSpec") != m.end() && !m["OppositeInterfaceSpec"].empty()) {
      oppositeInterfaceSpec = make_shared<string>(boost::any_cast<string>(m["OppositeInterfaceSpec"]));
    }
    if (m.find("RouterId") != m.end() && !m["RouterId"].empty()) {
      routerId = make_shared<string>(boost::any_cast<string>(m["RouterId"]));
    }
    if (m.find("OppositeInterfaceBusinessStatus") != m.end() && !m["OppositeInterfaceBusinessStatus"].empty()) {
      oppositeInterfaceBusinessStatus = make_shared<string>(boost::any_cast<string>(m["OppositeInterfaceBusinessStatus"]));
    }
    if (m.find("ConnectedTime") != m.end() && !m["ConnectedTime"].empty()) {
      connectedTime = make_shared<string>(boost::any_cast<string>(m["ConnectedTime"]));
    }
    if (m.find("OppositeInterfaceStatus") != m.end() && !m["OppositeInterfaceStatus"].empty()) {
      oppositeInterfaceStatus = make_shared<string>(boost::any_cast<string>(m["OppositeInterfaceStatus"]));
    }
    if (m.find("HealthCheckSourceIp") != m.end() && !m["HealthCheckSourceIp"].empty()) {
      healthCheckSourceIp = make_shared<string>(boost::any_cast<string>(m["HealthCheckSourceIp"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OppositeRegionId") != m.end() && !m["OppositeRegionId"].empty()) {
      oppositeRegionId = make_shared<string>(boost::any_cast<string>(m["OppositeRegionId"]));
    }
    if (m.find("OppositeAccessPointId") != m.end() && !m["OppositeAccessPointId"].empty()) {
      oppositeAccessPointId = make_shared<string>(boost::any_cast<string>(m["OppositeAccessPointId"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("RouterType") != m.end() && !m["RouterType"].empty()) {
      routerType = make_shared<string>(boost::any_cast<string>(m["RouterType"]));
    }
    if (m.find("AccessPointId") != m.end() && !m["AccessPointId"].empty()) {
      accessPointId = make_shared<string>(boost::any_cast<string>(m["AccessPointId"]));
    }
  }


  virtual ~DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType() = default;
};
class DescribeRouterInterfacesResponseBodyRouterInterfaceSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType>> routerInterfaceType{};

  DescribeRouterInterfacesResponseBodyRouterInterfaceSet() {}

  explicit DescribeRouterInterfacesResponseBodyRouterInterfaceSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routerInterfaceType) {
      vector<boost::any> temp1;
      for(auto item1:*routerInterfaceType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RouterInterfaceType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouterInterfaceType") != m.end() && !m["RouterInterfaceType"].empty()) {
      if (typeid(vector<boost::any>) == m["RouterInterfaceType"].type()) {
        vector<DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RouterInterfaceType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routerInterfaceType = make_shared<vector<DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType>>(expect1);
      }
    }
  }


  virtual ~DescribeRouterInterfacesResponseBodyRouterInterfaceSet() = default;
};
class DescribeRouterInterfacesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeRouterInterfacesResponseBodyRouterInterfaceSet> routerInterfaceSet{};

  DescribeRouterInterfacesResponseBody() {}

  explicit DescribeRouterInterfacesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (routerInterfaceSet) {
      res["RouterInterfaceSet"] = routerInterfaceSet ? boost::any(routerInterfaceSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("RouterInterfaceSet") != m.end() && !m["RouterInterfaceSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["RouterInterfaceSet"].type()) {
        DescribeRouterInterfacesResponseBodyRouterInterfaceSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RouterInterfaceSet"]));
        routerInterfaceSet = make_shared<DescribeRouterInterfacesResponseBodyRouterInterfaceSet>(model1);
      }
    }
  }


  virtual ~DescribeRouterInterfacesResponseBody() = default;
};
class DescribeRouterInterfacesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRouterInterfacesResponseBody> body{};

  DescribeRouterInterfacesResponse() {}

  explicit DescribeRouterInterfacesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRouterInterfacesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRouterInterfacesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRouterInterfacesResponse() = default;
};
class DescribeRouteTablesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> VRouterId{};
  shared_ptr<string> routeTableId{};
  shared_ptr<string> routerType{};
  shared_ptr<string> routerId{};
  shared_ptr<string> routeTableName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ownerAccount{};

  DescribeRouteTablesRequest() {}

  explicit DescribeRouteTablesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (VRouterId) {
      res["VRouterId"] = boost::any(*VRouterId);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (routerType) {
      res["RouterType"] = boost::any(*routerType);
    }
    if (routerId) {
      res["RouterId"] = boost::any(*routerId);
    }
    if (routeTableName) {
      res["RouteTableName"] = boost::any(*routeTableName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VRouterId") != m.end() && !m["VRouterId"].empty()) {
      VRouterId = make_shared<string>(boost::any_cast<string>(m["VRouterId"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("RouterType") != m.end() && !m["RouterType"].empty()) {
      routerType = make_shared<string>(boost::any_cast<string>(m["RouterType"]));
    }
    if (m.find("RouterId") != m.end() && !m["RouterId"].empty()) {
      routerId = make_shared<string>(boost::any_cast<string>(m["RouterId"]));
    }
    if (m.find("RouteTableName") != m.end() && !m["RouteTableName"].empty()) {
      routeTableName = make_shared<string>(boost::any_cast<string>(m["RouteTableName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeRouteTablesRequest() = default;
};
class DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop : public Darabonba::Model {
public:
  shared_ptr<long> weight{};
  shared_ptr<string> nextHopId{};
  shared_ptr<string> nextHopType{};
  shared_ptr<long> enabled{};

  DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop() {}

  explicit DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    if (nextHopId) {
      res["NextHopId"] = boost::any(*nextHopId);
    }
    if (nextHopType) {
      res["NextHopType"] = boost::any(*nextHopType);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
    if (m.find("NextHopId") != m.end() && !m["NextHopId"].empty()) {
      nextHopId = make_shared<string>(boost::any_cast<string>(m["NextHopId"]));
    }
    if (m.find("NextHopType") != m.end() && !m["NextHopType"].empty()) {
      nextHopType = make_shared<string>(boost::any_cast<string>(m["NextHopType"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<long>(boost::any_cast<long>(m["Enabled"]));
    }
  }


  virtual ~DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop() = default;
};
class DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop>> nextHop{};

  DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops() {}

  explicit DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextHop) {
      vector<boost::any> temp1;
      for(auto item1:*nextHop){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NextHop"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      if (typeid(vector<boost::any>) == m["NextHop"].type()) {
        vector<DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NextHop"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nextHop = make_shared<vector<DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop>>(expect1);
      }
    }
  }


  virtual ~DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops() = default;
};
class DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> status{};
  shared_ptr<string> nextHopType{};
  shared_ptr<string> destinationCidrBlock{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> routeTableId{};
  shared_ptr<DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops> nextHops{};

  DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry() {}

  explicit DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (nextHopType) {
      res["NextHopType"] = boost::any(*nextHopType);
    }
    if (destinationCidrBlock) {
      res["DestinationCidrBlock"] = boost::any(*destinationCidrBlock);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (nextHops) {
      res["NextHops"] = nextHops ? boost::any(nextHops->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("NextHopType") != m.end() && !m["NextHopType"].empty()) {
      nextHopType = make_shared<string>(boost::any_cast<string>(m["NextHopType"]));
    }
    if (m.find("DestinationCidrBlock") != m.end() && !m["DestinationCidrBlock"].empty()) {
      destinationCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestinationCidrBlock"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("NextHops") != m.end() && !m["NextHops"].empty()) {
      if (typeid(map<string, boost::any>) == m["NextHops"].type()) {
        DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NextHops"]));
        nextHops = make_shared<DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops>(model1);
      }
    }
  }


  virtual ~DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry() = default;
};
class DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry>> routeEntry{};

  DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys() {}

  explicit DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routeEntry) {
      vector<boost::any> temp1;
      for(auto item1:*routeEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RouteEntry"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouteEntry") != m.end() && !m["RouteEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["RouteEntry"].type()) {
        vector<DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RouteEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routeEntry = make_shared<vector<DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry>>(expect1);
      }
    }
  }


  virtual ~DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys() = default;
};
class DescribeRouteTablesResponseBodyRouteTablesRouteTable : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> VRouterId{};
  shared_ptr<string> routeTableId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> routeTableType{};
  shared_ptr<DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys> routeEntrys{};

  DescribeRouteTablesResponseBodyRouteTablesRouteTable() {}

  explicit DescribeRouteTablesResponseBodyRouteTablesRouteTable(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (VRouterId) {
      res["VRouterId"] = boost::any(*VRouterId);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (routeTableType) {
      res["RouteTableType"] = boost::any(*routeTableType);
    }
    if (routeEntrys) {
      res["RouteEntrys"] = routeEntrys ? boost::any(routeEntrys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("VRouterId") != m.end() && !m["VRouterId"].empty()) {
      VRouterId = make_shared<string>(boost::any_cast<string>(m["VRouterId"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RouteTableType") != m.end() && !m["RouteTableType"].empty()) {
      routeTableType = make_shared<string>(boost::any_cast<string>(m["RouteTableType"]));
    }
    if (m.find("RouteEntrys") != m.end() && !m["RouteEntrys"].empty()) {
      if (typeid(map<string, boost::any>) == m["RouteEntrys"].type()) {
        DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RouteEntrys"]));
        routeEntrys = make_shared<DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys>(model1);
      }
    }
  }


  virtual ~DescribeRouteTablesResponseBodyRouteTablesRouteTable() = default;
};
class DescribeRouteTablesResponseBodyRouteTables : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRouteTablesResponseBodyRouteTablesRouteTable>> routeTable{};

  DescribeRouteTablesResponseBodyRouteTables() {}

  explicit DescribeRouteTablesResponseBodyRouteTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routeTable) {
      vector<boost::any> temp1;
      for(auto item1:*routeTable){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RouteTable"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouteTable") != m.end() && !m["RouteTable"].empty()) {
      if (typeid(vector<boost::any>) == m["RouteTable"].type()) {
        vector<DescribeRouteTablesResponseBodyRouteTablesRouteTable> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RouteTable"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRouteTablesResponseBodyRouteTablesRouteTable model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routeTable = make_shared<vector<DescribeRouteTablesResponseBodyRouteTablesRouteTable>>(expect1);
      }
    }
  }


  virtual ~DescribeRouteTablesResponseBodyRouteTables() = default;
};
class DescribeRouteTablesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeRouteTablesResponseBodyRouteTables> routeTables{};

  DescribeRouteTablesResponseBody() {}

  explicit DescribeRouteTablesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (routeTables) {
      res["RouteTables"] = routeTables ? boost::any(routeTables->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("RouteTables") != m.end() && !m["RouteTables"].empty()) {
      if (typeid(map<string, boost::any>) == m["RouteTables"].type()) {
        DescribeRouteTablesResponseBodyRouteTables model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RouteTables"]));
        routeTables = make_shared<DescribeRouteTablesResponseBodyRouteTables>(model1);
      }
    }
  }


  virtual ~DescribeRouteTablesResponseBody() = default;
};
class DescribeRouteTablesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRouteTablesResponseBody> body{};

  DescribeRouteTablesResponse() {}

  explicit DescribeRouteTablesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRouteTablesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRouteTablesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRouteTablesResponse() = default;
};
class DescribeSecurityGroupAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> nicType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> direction{};

  DescribeSecurityGroupAttributeRequest() {}

  explicit DescribeSecurityGroupAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (nicType) {
      res["NicType"] = boost::any(*nicType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("NicType") != m.end() && !m["NicType"].empty()) {
      nicType = make_shared<string>(boost::any_cast<string>(m["NicType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
  }


  virtual ~DescribeSecurityGroupAttributeRequest() = default;
};
class DescribeSecurityGroupAttributeResponseBodyPermissionsPermission : public Darabonba::Model {
public:
  shared_ptr<string> direction{};
  shared_ptr<string> sourceGroupId{};
  shared_ptr<string> destGroupOwnerAccount{};
  shared_ptr<string> destPrefixListId{};
  shared_ptr<string> destPrefixListName{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> ipv6DestCidrIp{};
  shared_ptr<string> createTime{};
  shared_ptr<string> ipv6SourceCidrIp{};
  shared_ptr<string> destGroupId{};
  shared_ptr<string> destCidrIp{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> priority{};
  shared_ptr<string> destGroupName{};
  shared_ptr<string> nicType{};
  shared_ptr<string> policy{};
  shared_ptr<string> description{};
  shared_ptr<string> portRange{};
  shared_ptr<string> sourcePrefixListName{};
  shared_ptr<string> sourcePrefixListId{};
  shared_ptr<string> sourceGroupOwnerAccount{};
  shared_ptr<string> sourceGroupName{};
  shared_ptr<string> sourcePortRange{};

  DescribeSecurityGroupAttributeResponseBodyPermissionsPermission() {}

  explicit DescribeSecurityGroupAttributeResponseBodyPermissionsPermission(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (sourceGroupId) {
      res["SourceGroupId"] = boost::any(*sourceGroupId);
    }
    if (destGroupOwnerAccount) {
      res["DestGroupOwnerAccount"] = boost::any(*destGroupOwnerAccount);
    }
    if (destPrefixListId) {
      res["DestPrefixListId"] = boost::any(*destPrefixListId);
    }
    if (destPrefixListName) {
      res["DestPrefixListName"] = boost::any(*destPrefixListName);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (ipv6DestCidrIp) {
      res["Ipv6DestCidrIp"] = boost::any(*ipv6DestCidrIp);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (ipv6SourceCidrIp) {
      res["Ipv6SourceCidrIp"] = boost::any(*ipv6SourceCidrIp);
    }
    if (destGroupId) {
      res["DestGroupId"] = boost::any(*destGroupId);
    }
    if (destCidrIp) {
      res["DestCidrIp"] = boost::any(*destCidrIp);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (destGroupName) {
      res["DestGroupName"] = boost::any(*destGroupName);
    }
    if (nicType) {
      res["NicType"] = boost::any(*nicType);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (sourcePrefixListName) {
      res["SourcePrefixListName"] = boost::any(*sourcePrefixListName);
    }
    if (sourcePrefixListId) {
      res["SourcePrefixListId"] = boost::any(*sourcePrefixListId);
    }
    if (sourceGroupOwnerAccount) {
      res["SourceGroupOwnerAccount"] = boost::any(*sourceGroupOwnerAccount);
    }
    if (sourceGroupName) {
      res["SourceGroupName"] = boost::any(*sourceGroupName);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("SourceGroupId") != m.end() && !m["SourceGroupId"].empty()) {
      sourceGroupId = make_shared<string>(boost::any_cast<string>(m["SourceGroupId"]));
    }
    if (m.find("DestGroupOwnerAccount") != m.end() && !m["DestGroupOwnerAccount"].empty()) {
      destGroupOwnerAccount = make_shared<string>(boost::any_cast<string>(m["DestGroupOwnerAccount"]));
    }
    if (m.find("DestPrefixListId") != m.end() && !m["DestPrefixListId"].empty()) {
      destPrefixListId = make_shared<string>(boost::any_cast<string>(m["DestPrefixListId"]));
    }
    if (m.find("DestPrefixListName") != m.end() && !m["DestPrefixListName"].empty()) {
      destPrefixListName = make_shared<string>(boost::any_cast<string>(m["DestPrefixListName"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("Ipv6DestCidrIp") != m.end() && !m["Ipv6DestCidrIp"].empty()) {
      ipv6DestCidrIp = make_shared<string>(boost::any_cast<string>(m["Ipv6DestCidrIp"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Ipv6SourceCidrIp") != m.end() && !m["Ipv6SourceCidrIp"].empty()) {
      ipv6SourceCidrIp = make_shared<string>(boost::any_cast<string>(m["Ipv6SourceCidrIp"]));
    }
    if (m.find("DestGroupId") != m.end() && !m["DestGroupId"].empty()) {
      destGroupId = make_shared<string>(boost::any_cast<string>(m["DestGroupId"]));
    }
    if (m.find("DestCidrIp") != m.end() && !m["DestCidrIp"].empty()) {
      destCidrIp = make_shared<string>(boost::any_cast<string>(m["DestCidrIp"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("DestGroupName") != m.end() && !m["DestGroupName"].empty()) {
      destGroupName = make_shared<string>(boost::any_cast<string>(m["DestGroupName"]));
    }
    if (m.find("NicType") != m.end() && !m["NicType"].empty()) {
      nicType = make_shared<string>(boost::any_cast<string>(m["NicType"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("SourcePrefixListName") != m.end() && !m["SourcePrefixListName"].empty()) {
      sourcePrefixListName = make_shared<string>(boost::any_cast<string>(m["SourcePrefixListName"]));
    }
    if (m.find("SourcePrefixListId") != m.end() && !m["SourcePrefixListId"].empty()) {
      sourcePrefixListId = make_shared<string>(boost::any_cast<string>(m["SourcePrefixListId"]));
    }
    if (m.find("SourceGroupOwnerAccount") != m.end() && !m["SourceGroupOwnerAccount"].empty()) {
      sourceGroupOwnerAccount = make_shared<string>(boost::any_cast<string>(m["SourceGroupOwnerAccount"]));
    }
    if (m.find("SourceGroupName") != m.end() && !m["SourceGroupName"].empty()) {
      sourceGroupName = make_shared<string>(boost::any_cast<string>(m["SourceGroupName"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
  }


  virtual ~DescribeSecurityGroupAttributeResponseBodyPermissionsPermission() = default;
};
class DescribeSecurityGroupAttributeResponseBodyPermissions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSecurityGroupAttributeResponseBodyPermissionsPermission>> permission{};

  DescribeSecurityGroupAttributeResponseBodyPermissions() {}

  explicit DescribeSecurityGroupAttributeResponseBodyPermissions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (permission) {
      vector<boost::any> temp1;
      for(auto item1:*permission){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Permission"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Permission") != m.end() && !m["Permission"].empty()) {
      if (typeid(vector<boost::any>) == m["Permission"].type()) {
        vector<DescribeSecurityGroupAttributeResponseBodyPermissionsPermission> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Permission"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityGroupAttributeResponseBodyPermissionsPermission model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        permission = make_shared<vector<DescribeSecurityGroupAttributeResponseBodyPermissionsPermission>>(expect1);
      }
    }
  }


  virtual ~DescribeSecurityGroupAttributeResponseBodyPermissions() = default;
};
class DescribeSecurityGroupAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> innerAccessPolicy{};
  shared_ptr<string> description{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> securityGroupName{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeSecurityGroupAttributeResponseBodyPermissions> permissions{};

  DescribeSecurityGroupAttributeResponseBody() {}

  explicit DescribeSecurityGroupAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (innerAccessPolicy) {
      res["InnerAccessPolicy"] = boost::any(*innerAccessPolicy);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (permissions) {
      res["Permissions"] = permissions ? boost::any(permissions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InnerAccessPolicy") != m.end() && !m["InnerAccessPolicy"].empty()) {
      innerAccessPolicy = make_shared<string>(boost::any_cast<string>(m["InnerAccessPolicy"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Permissions") != m.end() && !m["Permissions"].empty()) {
      if (typeid(map<string, boost::any>) == m["Permissions"].type()) {
        DescribeSecurityGroupAttributeResponseBodyPermissions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Permissions"]));
        permissions = make_shared<DescribeSecurityGroupAttributeResponseBodyPermissions>(model1);
      }
    }
  }


  virtual ~DescribeSecurityGroupAttributeResponseBody() = default;
};
class DescribeSecurityGroupAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSecurityGroupAttributeResponseBody> body{};

  DescribeSecurityGroupAttributeResponse() {}

  explicit DescribeSecurityGroupAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecurityGroupAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecurityGroupAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecurityGroupAttributeResponse() = default;
};
class DescribeSecurityGroupReferencesRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<vector<string>> securityGroupId{};

  DescribeSecurityGroupReferencesRequest() {}

  explicit DescribeSecurityGroupReferencesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSecurityGroupReferencesRequest() = default;
};
class DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReferenceReferencingSecurityGroupsReferencingSecurityGroup : public Darabonba::Model {
public:
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> aliUid{};

  DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReferenceReferencingSecurityGroupsReferencingSecurityGroup() {}

  explicit DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReferenceReferencingSecurityGroupsReferencingSecurityGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<string>(boost::any_cast<string>(m["AliUid"]));
    }
  }


  virtual ~DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReferenceReferencingSecurityGroupsReferencingSecurityGroup() = default;
};
class DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReferenceReferencingSecurityGroups : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReferenceReferencingSecurityGroupsReferencingSecurityGroup>> referencingSecurityGroup{};

  DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReferenceReferencingSecurityGroups() {}

  explicit DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReferenceReferencingSecurityGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencingSecurityGroup) {
      vector<boost::any> temp1;
      for(auto item1:*referencingSecurityGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReferencingSecurityGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencingSecurityGroup") != m.end() && !m["ReferencingSecurityGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["ReferencingSecurityGroup"].type()) {
        vector<DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReferenceReferencingSecurityGroupsReferencingSecurityGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReferencingSecurityGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReferenceReferencingSecurityGroupsReferencingSecurityGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        referencingSecurityGroup = make_shared<vector<DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReferenceReferencingSecurityGroupsReferencingSecurityGroup>>(expect1);
      }
    }
  }


  virtual ~DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReferenceReferencingSecurityGroups() = default;
};
class DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReference : public Darabonba::Model {
public:
  shared_ptr<string> securityGroupId{};
  shared_ptr<DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReferenceReferencingSecurityGroups> referencingSecurityGroups{};

  DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReference() {}

  explicit DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReference(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (referencingSecurityGroups) {
      res["ReferencingSecurityGroups"] = referencingSecurityGroups ? boost::any(referencingSecurityGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("ReferencingSecurityGroups") != m.end() && !m["ReferencingSecurityGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReferencingSecurityGroups"].type()) {
        DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReferenceReferencingSecurityGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReferencingSecurityGroups"]));
        referencingSecurityGroups = make_shared<DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReferenceReferencingSecurityGroups>(model1);
      }
    }
  }


  virtual ~DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReference() = default;
};
class DescribeSecurityGroupReferencesResponseBodySecurityGroupReferences : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReference>> securityGroupReference{};

  DescribeSecurityGroupReferencesResponseBodySecurityGroupReferences() {}

  explicit DescribeSecurityGroupReferencesResponseBodySecurityGroupReferences(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupReference) {
      vector<boost::any> temp1;
      for(auto item1:*securityGroupReference){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityGroupReference"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupReference") != m.end() && !m["SecurityGroupReference"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityGroupReference"].type()) {
        vector<DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReference> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityGroupReference"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReference model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityGroupReference = make_shared<vector<DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReference>>(expect1);
      }
    }
  }


  virtual ~DescribeSecurityGroupReferencesResponseBodySecurityGroupReferences() = default;
};
class DescribeSecurityGroupReferencesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSecurityGroupReferencesResponseBodySecurityGroupReferences> securityGroupReferences{};

  DescribeSecurityGroupReferencesResponseBody() {}

  explicit DescribeSecurityGroupReferencesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityGroupReferences) {
      res["SecurityGroupReferences"] = securityGroupReferences ? boost::any(securityGroupReferences->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityGroupReferences") != m.end() && !m["SecurityGroupReferences"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityGroupReferences"].type()) {
        DescribeSecurityGroupReferencesResponseBodySecurityGroupReferences model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityGroupReferences"]));
        securityGroupReferences = make_shared<DescribeSecurityGroupReferencesResponseBodySecurityGroupReferences>(model1);
      }
    }
  }


  virtual ~DescribeSecurityGroupReferencesResponseBody() = default;
};
class DescribeSecurityGroupReferencesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSecurityGroupReferencesResponseBody> body{};

  DescribeSecurityGroupReferencesResponse() {}

  explicit DescribeSecurityGroupReferencesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecurityGroupReferencesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecurityGroupReferencesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecurityGroupReferencesResponse() = default;
};
class DescribeSecurityGroupsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeSecurityGroupsRequestTag() {}

  explicit DescribeSecurityGroupsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeSecurityGroupsRequestTag() = default;
};
class DescribeSecurityGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> vpcId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> securityGroupIds{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> networkType{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> securityGroupName{};
  shared_ptr<bool> isQueryEcsCount{};
  shared_ptr<bool> fuzzyQuery{};
  shared_ptr<string> securityGroupType{};
  shared_ptr<bool> dryRun{};
  shared_ptr<vector<DescribeSecurityGroupsRequestTag>> tag{};

  DescribeSecurityGroupsRequest() {}

  explicit DescribeSecurityGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    if (isQueryEcsCount) {
      res["IsQueryEcsCount"] = boost::any(*isQueryEcsCount);
    }
    if (fuzzyQuery) {
      res["FuzzyQuery"] = boost::any(*fuzzyQuery);
    }
    if (securityGroupType) {
      res["SecurityGroupType"] = boost::any(*securityGroupType);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      securityGroupIds = make_shared<string>(boost::any_cast<string>(m["SecurityGroupIds"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
    if (m.find("IsQueryEcsCount") != m.end() && !m["IsQueryEcsCount"].empty()) {
      isQueryEcsCount = make_shared<bool>(boost::any_cast<bool>(m["IsQueryEcsCount"]));
    }
    if (m.find("FuzzyQuery") != m.end() && !m["FuzzyQuery"].empty()) {
      fuzzyQuery = make_shared<bool>(boost::any_cast<bool>(m["FuzzyQuery"]));
    }
    if (m.find("SecurityGroupType") != m.end() && !m["SecurityGroupType"].empty()) {
      securityGroupType = make_shared<string>(boost::any_cast<string>(m["SecurityGroupType"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeSecurityGroupsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityGroupsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeSecurityGroupsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeSecurityGroupsRequest() = default;
};
class DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupTagsTag() {}

  explicit DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupTagsTag() = default;
};
class DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupTagsTag>> tag{};

  DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupTags() {}

  explicit DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupTags() = default;
};
class DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> vpcId{};
  shared_ptr<bool> serviceManaged{};
  shared_ptr<string> description{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityGroupName{};
  shared_ptr<long> ecsCount{};
  shared_ptr<long> serviceID{};
  shared_ptr<string> securityGroupType{};
  shared_ptr<long> availableInstanceAmount{};
  shared_ptr<DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupTags> tags{};

  DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup() {}

  explicit DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (serviceManaged) {
      res["ServiceManaged"] = boost::any(*serviceManaged);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    if (ecsCount) {
      res["EcsCount"] = boost::any(*ecsCount);
    }
    if (serviceID) {
      res["ServiceID"] = boost::any(*serviceID);
    }
    if (securityGroupType) {
      res["SecurityGroupType"] = boost::any(*securityGroupType);
    }
    if (availableInstanceAmount) {
      res["AvailableInstanceAmount"] = boost::any(*availableInstanceAmount);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ServiceManaged") != m.end() && !m["ServiceManaged"].empty()) {
      serviceManaged = make_shared<bool>(boost::any_cast<bool>(m["ServiceManaged"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
    if (m.find("EcsCount") != m.end() && !m["EcsCount"].empty()) {
      ecsCount = make_shared<long>(boost::any_cast<long>(m["EcsCount"]));
    }
    if (m.find("ServiceID") != m.end() && !m["ServiceID"].empty()) {
      serviceID = make_shared<long>(boost::any_cast<long>(m["ServiceID"]));
    }
    if (m.find("SecurityGroupType") != m.end() && !m["SecurityGroupType"].empty()) {
      securityGroupType = make_shared<string>(boost::any_cast<string>(m["SecurityGroupType"]));
    }
    if (m.find("AvailableInstanceAmount") != m.end() && !m["AvailableInstanceAmount"].empty()) {
      availableInstanceAmount = make_shared<long>(boost::any_cast<long>(m["AvailableInstanceAmount"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupTags>(model1);
      }
    }
  }


  virtual ~DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup() = default;
};
class DescribeSecurityGroupsResponseBodySecurityGroups : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup>> securityGroup{};

  DescribeSecurityGroupsResponseBodySecurityGroups() {}

  explicit DescribeSecurityGroupsResponseBodySecurityGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroup) {
      vector<boost::any> temp1;
      for(auto item1:*securityGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroup") != m.end() && !m["SecurityGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityGroup"].type()) {
        vector<DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityGroup = make_shared<vector<DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup>>(expect1);
      }
    }
  }


  virtual ~DescribeSecurityGroupsResponseBodySecurityGroups() = default;
};
class DescribeSecurityGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeSecurityGroupsResponseBodySecurityGroups> securityGroups{};

  DescribeSecurityGroupsResponseBody() {}

  explicit DescribeSecurityGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (securityGroups) {
      res["SecurityGroups"] = securityGroups ? boost::any(securityGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SecurityGroups") != m.end() && !m["SecurityGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityGroups"].type()) {
        DescribeSecurityGroupsResponseBodySecurityGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityGroups"]));
        securityGroups = make_shared<DescribeSecurityGroupsResponseBodySecurityGroups>(model1);
      }
    }
  }


  virtual ~DescribeSecurityGroupsResponseBody() = default;
};
class DescribeSecurityGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSecurityGroupsResponseBody> body{};

  DescribeSecurityGroupsResponse() {}

  explicit DescribeSecurityGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecurityGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecurityGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecurityGroupsResponse() = default;
};
class DescribeSendFileResultsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> invokeId{};
  shared_ptr<string> name{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeSendFileResultsRequest() {}

  explicit DescribeSendFileResultsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (invokeId) {
      res["InvokeId"] = boost::any(*invokeId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InvokeId") != m.end() && !m["InvokeId"].empty()) {
      invokeId = make_shared<string>(boost::any_cast<string>(m["InvokeId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeSendFileResultsRequest() = default;
};
class DescribeSendFileResultsResponseBodyInvocationsInvocationInvokeInstancesInvokeInstance : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> invocationStatus{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> errorInfo{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> instanceId{};

  DescribeSendFileResultsResponseBodyInvocationsInvocationInvokeInstancesInvokeInstance() {}

  explicit DescribeSendFileResultsResponseBodyInvocationsInvocationInvokeInstancesInvokeInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (invocationStatus) {
      res["InvocationStatus"] = boost::any(*invocationStatus);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (errorInfo) {
      res["ErrorInfo"] = boost::any(*errorInfo);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("InvocationStatus") != m.end() && !m["InvocationStatus"].empty()) {
      invocationStatus = make_shared<string>(boost::any_cast<string>(m["InvocationStatus"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("ErrorInfo") != m.end() && !m["ErrorInfo"].empty()) {
      errorInfo = make_shared<string>(boost::any_cast<string>(m["ErrorInfo"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeSendFileResultsResponseBodyInvocationsInvocationInvokeInstancesInvokeInstance() = default;
};
class DescribeSendFileResultsResponseBodyInvocationsInvocationInvokeInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSendFileResultsResponseBodyInvocationsInvocationInvokeInstancesInvokeInstance>> invokeInstance{};

  DescribeSendFileResultsResponseBodyInvocationsInvocationInvokeInstances() {}

  explicit DescribeSendFileResultsResponseBodyInvocationsInvocationInvokeInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invokeInstance) {
      vector<boost::any> temp1;
      for(auto item1:*invokeInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InvokeInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InvokeInstance") != m.end() && !m["InvokeInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["InvokeInstance"].type()) {
        vector<DescribeSendFileResultsResponseBodyInvocationsInvocationInvokeInstancesInvokeInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InvokeInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSendFileResultsResponseBodyInvocationsInvocationInvokeInstancesInvokeInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        invokeInstance = make_shared<vector<DescribeSendFileResultsResponseBodyInvocationsInvocationInvokeInstancesInvokeInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeSendFileResultsResponseBodyInvocationsInvocationInvokeInstances() = default;
};
class DescribeSendFileResultsResponseBodyInvocationsInvocation : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> invocationStatus{};
  shared_ptr<string> contentType{};
  shared_ptr<string> targetDir{};
  shared_ptr<string> fileOwner{};
  shared_ptr<string> description{};
  shared_ptr<long> vmCount{};
  shared_ptr<string> fileMode{};
  shared_ptr<string> fileGroup{};
  shared_ptr<string> invokeId{};
  shared_ptr<string> name{};
  shared_ptr<string> content{};
  shared_ptr<string> overwrite{};
  shared_ptr<DescribeSendFileResultsResponseBodyInvocationsInvocationInvokeInstances> invokeInstances{};

  DescribeSendFileResultsResponseBodyInvocationsInvocation() {}

  explicit DescribeSendFileResultsResponseBodyInvocationsInvocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (invocationStatus) {
      res["InvocationStatus"] = boost::any(*invocationStatus);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (targetDir) {
      res["TargetDir"] = boost::any(*targetDir);
    }
    if (fileOwner) {
      res["FileOwner"] = boost::any(*fileOwner);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (vmCount) {
      res["VmCount"] = boost::any(*vmCount);
    }
    if (fileMode) {
      res["FileMode"] = boost::any(*fileMode);
    }
    if (fileGroup) {
      res["FileGroup"] = boost::any(*fileGroup);
    }
    if (invokeId) {
      res["InvokeId"] = boost::any(*invokeId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (overwrite) {
      res["Overwrite"] = boost::any(*overwrite);
    }
    if (invokeInstances) {
      res["InvokeInstances"] = invokeInstances ? boost::any(invokeInstances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("InvocationStatus") != m.end() && !m["InvocationStatus"].empty()) {
      invocationStatus = make_shared<string>(boost::any_cast<string>(m["InvocationStatus"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("TargetDir") != m.end() && !m["TargetDir"].empty()) {
      targetDir = make_shared<string>(boost::any_cast<string>(m["TargetDir"]));
    }
    if (m.find("FileOwner") != m.end() && !m["FileOwner"].empty()) {
      fileOwner = make_shared<string>(boost::any_cast<string>(m["FileOwner"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("VmCount") != m.end() && !m["VmCount"].empty()) {
      vmCount = make_shared<long>(boost::any_cast<long>(m["VmCount"]));
    }
    if (m.find("FileMode") != m.end() && !m["FileMode"].empty()) {
      fileMode = make_shared<string>(boost::any_cast<string>(m["FileMode"]));
    }
    if (m.find("FileGroup") != m.end() && !m["FileGroup"].empty()) {
      fileGroup = make_shared<string>(boost::any_cast<string>(m["FileGroup"]));
    }
    if (m.find("InvokeId") != m.end() && !m["InvokeId"].empty()) {
      invokeId = make_shared<string>(boost::any_cast<string>(m["InvokeId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Overwrite") != m.end() && !m["Overwrite"].empty()) {
      overwrite = make_shared<string>(boost::any_cast<string>(m["Overwrite"]));
    }
    if (m.find("InvokeInstances") != m.end() && !m["InvokeInstances"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvokeInstances"].type()) {
        DescribeSendFileResultsResponseBodyInvocationsInvocationInvokeInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvokeInstances"]));
        invokeInstances = make_shared<DescribeSendFileResultsResponseBodyInvocationsInvocationInvokeInstances>(model1);
      }
    }
  }


  virtual ~DescribeSendFileResultsResponseBodyInvocationsInvocation() = default;
};
class DescribeSendFileResultsResponseBodyInvocations : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSendFileResultsResponseBodyInvocationsInvocation>> invocation{};

  DescribeSendFileResultsResponseBodyInvocations() {}

  explicit DescribeSendFileResultsResponseBodyInvocations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invocation) {
      vector<boost::any> temp1;
      for(auto item1:*invocation){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Invocation"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Invocation") != m.end() && !m["Invocation"].empty()) {
      if (typeid(vector<boost::any>) == m["Invocation"].type()) {
        vector<DescribeSendFileResultsResponseBodyInvocationsInvocation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Invocation"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSendFileResultsResponseBodyInvocationsInvocation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        invocation = make_shared<vector<DescribeSendFileResultsResponseBodyInvocationsInvocation>>(expect1);
      }
    }
  }


  virtual ~DescribeSendFileResultsResponseBodyInvocations() = default;
};
class DescribeSendFileResultsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeSendFileResultsResponseBodyInvocations> invocations{};

  DescribeSendFileResultsResponseBody() {}

  explicit DescribeSendFileResultsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (invocations) {
      res["Invocations"] = invocations ? boost::any(invocations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Invocations") != m.end() && !m["Invocations"].empty()) {
      if (typeid(map<string, boost::any>) == m["Invocations"].type()) {
        DescribeSendFileResultsResponseBodyInvocations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Invocations"]));
        invocations = make_shared<DescribeSendFileResultsResponseBodyInvocations>(model1);
      }
    }
  }


  virtual ~DescribeSendFileResultsResponseBody() = default;
};
class DescribeSendFileResultsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSendFileResultsResponseBody> body{};

  DescribeSendFileResultsResponse() {}

  explicit DescribeSendFileResultsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSendFileResultsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSendFileResultsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSendFileResultsResponse() = default;
};
class DescribeSnapshotGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> snapshotGroupId{};
  shared_ptr<vector<string>> status{};
  shared_ptr<vector<string>> additionalAttributes{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> maxResults{};

  DescribeSnapshotGroupsRequest() {}

  explicit DescribeSnapshotGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (snapshotGroupId) {
      res["SnapshotGroupId"] = boost::any(*snapshotGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (additionalAttributes) {
      res["AdditionalAttributes"] = boost::any(*additionalAttributes);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SnapshotGroupId") != m.end() && !m["SnapshotGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SnapshotGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SnapshotGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      snapshotGroupId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Status"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Status"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      status = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AdditionalAttributes") != m.end() && !m["AdditionalAttributes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AdditionalAttributes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AdditionalAttributes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      additionalAttributes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
  }


  virtual ~DescribeSnapshotGroupsRequest() = default;
};
class DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshotsSnapshot : public Darabonba::Model {
public:
  shared_ptr<string> sourceDiskId{};
  shared_ptr<string> progress{};
  shared_ptr<long> instantAccessRetentionDays{};
  shared_ptr<string> snapshotId{};
  shared_ptr<bool> instantAccess{};
  shared_ptr<string> sourceDiskType{};

  DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshotsSnapshot() {}

  explicit DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshotsSnapshot(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceDiskId) {
      res["SourceDiskId"] = boost::any(*sourceDiskId);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (instantAccessRetentionDays) {
      res["InstantAccessRetentionDays"] = boost::any(*instantAccessRetentionDays);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (instantAccess) {
      res["InstantAccess"] = boost::any(*instantAccess);
    }
    if (sourceDiskType) {
      res["SourceDiskType"] = boost::any(*sourceDiskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceDiskId") != m.end() && !m["SourceDiskId"].empty()) {
      sourceDiskId = make_shared<string>(boost::any_cast<string>(m["SourceDiskId"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("InstantAccessRetentionDays") != m.end() && !m["InstantAccessRetentionDays"].empty()) {
      instantAccessRetentionDays = make_shared<long>(boost::any_cast<long>(m["InstantAccessRetentionDays"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("InstantAccess") != m.end() && !m["InstantAccess"].empty()) {
      instantAccess = make_shared<bool>(boost::any_cast<bool>(m["InstantAccess"]));
    }
    if (m.find("SourceDiskType") != m.end() && !m["SourceDiskType"].empty()) {
      sourceDiskType = make_shared<string>(boost::any_cast<string>(m["SourceDiskType"]));
    }
  }


  virtual ~DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshotsSnapshot() = default;
};
class DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshots : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshotsSnapshot>> snapshot{};

  DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshots() {}

  explicit DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshots(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshot) {
      vector<boost::any> temp1;
      for(auto item1:*snapshot){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Snapshot"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Snapshot") != m.end() && !m["Snapshot"].empty()) {
      if (typeid(vector<boost::any>) == m["Snapshot"].type()) {
        vector<DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshotsSnapshot> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Snapshot"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshotsSnapshot model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snapshot = make_shared<vector<DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshotsSnapshot>>(expect1);
      }
    }
  }


  virtual ~DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshots() = default;
};
class DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroup : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> progressStatus{};
  shared_ptr<string> snapshotGroupId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshots> snapshots{};

  DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroup() {}

  explicit DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (progressStatus) {
      res["ProgressStatus"] = boost::any(*progressStatus);
    }
    if (snapshotGroupId) {
      res["SnapshotGroupId"] = boost::any(*snapshotGroupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (snapshots) {
      res["Snapshots"] = snapshots ? boost::any(snapshots->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ProgressStatus") != m.end() && !m["ProgressStatus"].empty()) {
      progressStatus = make_shared<string>(boost::any_cast<string>(m["ProgressStatus"]));
    }
    if (m.find("SnapshotGroupId") != m.end() && !m["SnapshotGroupId"].empty()) {
      snapshotGroupId = make_shared<string>(boost::any_cast<string>(m["SnapshotGroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      if (typeid(map<string, boost::any>) == m["Snapshots"].type()) {
        DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshots model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Snapshots"]));
        snapshots = make_shared<DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshots>(model1);
      }
    }
  }


  virtual ~DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroup() = default;
};
class DescribeSnapshotGroupsResponseBodySnapshotGroups : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroup>> snapshotGroup{};

  DescribeSnapshotGroupsResponseBodySnapshotGroups() {}

  explicit DescribeSnapshotGroupsResponseBodySnapshotGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshotGroup) {
      vector<boost::any> temp1;
      for(auto item1:*snapshotGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SnapshotGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnapshotGroup") != m.end() && !m["SnapshotGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["SnapshotGroup"].type()) {
        vector<DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SnapshotGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snapshotGroup = make_shared<vector<DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroup>>(expect1);
      }
    }
  }


  virtual ~DescribeSnapshotGroupsResponseBodySnapshotGroups() = default;
};
class DescribeSnapshotGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSnapshotGroupsResponseBodySnapshotGroups> snapshotGroups{};

  DescribeSnapshotGroupsResponseBody() {}

  explicit DescribeSnapshotGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snapshotGroups) {
      res["SnapshotGroups"] = snapshotGroups ? boost::any(snapshotGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnapshotGroups") != m.end() && !m["SnapshotGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotGroups"].type()) {
        DescribeSnapshotGroupsResponseBodySnapshotGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotGroups"]));
        snapshotGroups = make_shared<DescribeSnapshotGroupsResponseBodySnapshotGroups>(model1);
      }
    }
  }


  virtual ~DescribeSnapshotGroupsResponseBody() = default;
};
class DescribeSnapshotGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSnapshotGroupsResponseBody> body{};

  DescribeSnapshotGroupsResponse() {}

  explicit DescribeSnapshotGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSnapshotGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSnapshotGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSnapshotGroupsResponse() = default;
};
class DescribeSnapshotLinksRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> diskIds{};
  shared_ptr<string> snapshotLinkIds{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeSnapshotLinksRequest() {}

  explicit DescribeSnapshotLinksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (diskIds) {
      res["DiskIds"] = boost::any(*diskIds);
    }
    if (snapshotLinkIds) {
      res["SnapshotLinkIds"] = boost::any(*snapshotLinkIds);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DiskIds") != m.end() && !m["DiskIds"].empty()) {
      diskIds = make_shared<string>(boost::any_cast<string>(m["DiskIds"]));
    }
    if (m.find("SnapshotLinkIds") != m.end() && !m["SnapshotLinkIds"].empty()) {
      snapshotLinkIds = make_shared<string>(boost::any_cast<string>(m["SnapshotLinkIds"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeSnapshotLinksRequest() = default;
};
class DescribeSnapshotLinksResponseBodySnapshotLinksSnapshotLink : public Darabonba::Model {
public:
  shared_ptr<bool> instantAccess{};
  shared_ptr<long> totalSize{};
  shared_ptr<string> sourceDiskName{};
  shared_ptr<long> sourceDiskSize{};
  shared_ptr<string> sourceDiskType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> snapshotLinkId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sourceDiskId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> category{};

  DescribeSnapshotLinksResponseBodySnapshotLinksSnapshotLink() {}

  explicit DescribeSnapshotLinksResponseBodySnapshotLinksSnapshotLink(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instantAccess) {
      res["InstantAccess"] = boost::any(*instantAccess);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    if (sourceDiskName) {
      res["SourceDiskName"] = boost::any(*sourceDiskName);
    }
    if (sourceDiskSize) {
      res["SourceDiskSize"] = boost::any(*sourceDiskSize);
    }
    if (sourceDiskType) {
      res["SourceDiskType"] = boost::any(*sourceDiskType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (snapshotLinkId) {
      res["SnapshotLinkId"] = boost::any(*snapshotLinkId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sourceDiskId) {
      res["SourceDiskId"] = boost::any(*sourceDiskId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstantAccess") != m.end() && !m["InstantAccess"].empty()) {
      instantAccess = make_shared<bool>(boost::any_cast<bool>(m["InstantAccess"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
    if (m.find("SourceDiskName") != m.end() && !m["SourceDiskName"].empty()) {
      sourceDiskName = make_shared<string>(boost::any_cast<string>(m["SourceDiskName"]));
    }
    if (m.find("SourceDiskSize") != m.end() && !m["SourceDiskSize"].empty()) {
      sourceDiskSize = make_shared<long>(boost::any_cast<long>(m["SourceDiskSize"]));
    }
    if (m.find("SourceDiskType") != m.end() && !m["SourceDiskType"].empty()) {
      sourceDiskType = make_shared<string>(boost::any_cast<string>(m["SourceDiskType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SnapshotLinkId") != m.end() && !m["SnapshotLinkId"].empty()) {
      snapshotLinkId = make_shared<string>(boost::any_cast<string>(m["SnapshotLinkId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SourceDiskId") != m.end() && !m["SourceDiskId"].empty()) {
      sourceDiskId = make_shared<string>(boost::any_cast<string>(m["SourceDiskId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
  }


  virtual ~DescribeSnapshotLinksResponseBodySnapshotLinksSnapshotLink() = default;
};
class DescribeSnapshotLinksResponseBodySnapshotLinks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSnapshotLinksResponseBodySnapshotLinksSnapshotLink>> snapshotLink{};

  DescribeSnapshotLinksResponseBodySnapshotLinks() {}

  explicit DescribeSnapshotLinksResponseBodySnapshotLinks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshotLink) {
      vector<boost::any> temp1;
      for(auto item1:*snapshotLink){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SnapshotLink"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnapshotLink") != m.end() && !m["SnapshotLink"].empty()) {
      if (typeid(vector<boost::any>) == m["SnapshotLink"].type()) {
        vector<DescribeSnapshotLinksResponseBodySnapshotLinksSnapshotLink> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SnapshotLink"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSnapshotLinksResponseBodySnapshotLinksSnapshotLink model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snapshotLink = make_shared<vector<DescribeSnapshotLinksResponseBodySnapshotLinksSnapshotLink>>(expect1);
      }
    }
  }


  virtual ~DescribeSnapshotLinksResponseBodySnapshotLinks() = default;
};
class DescribeSnapshotLinksResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeSnapshotLinksResponseBodySnapshotLinks> snapshotLinks{};

  DescribeSnapshotLinksResponseBody() {}

  explicit DescribeSnapshotLinksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (snapshotLinks) {
      res["SnapshotLinks"] = snapshotLinks ? boost::any(snapshotLinks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("SnapshotLinks") != m.end() && !m["SnapshotLinks"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotLinks"].type()) {
        DescribeSnapshotLinksResponseBodySnapshotLinks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotLinks"]));
        snapshotLinks = make_shared<DescribeSnapshotLinksResponseBodySnapshotLinks>(model1);
      }
    }
  }


  virtual ~DescribeSnapshotLinksResponseBody() = default;
};
class DescribeSnapshotLinksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSnapshotLinksResponseBody> body{};

  DescribeSnapshotLinksResponse() {}

  explicit DescribeSnapshotLinksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSnapshotLinksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSnapshotLinksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSnapshotLinksResponse() = default;
};
class DescribeSnapshotMonitorDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> period{};
  shared_ptr<string> category{};
  shared_ptr<string> ownerAccount{};

  DescribeSnapshotMonitorDataRequest() {}

  explicit DescribeSnapshotMonitorDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeSnapshotMonitorDataRequest() = default;
};
class DescribeSnapshotMonitorDataResponseBodyMonitorDataDataPoint : public Darabonba::Model {
public:
  shared_ptr<long> size{};
  shared_ptr<string> timeStamp{};

  DescribeSnapshotMonitorDataResponseBodyMonitorDataDataPoint() {}

  explicit DescribeSnapshotMonitorDataResponseBodyMonitorDataDataPoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeSnapshotMonitorDataResponseBodyMonitorDataDataPoint() = default;
};
class DescribeSnapshotMonitorDataResponseBodyMonitorData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSnapshotMonitorDataResponseBodyMonitorDataDataPoint>> dataPoint{};

  DescribeSnapshotMonitorDataResponseBodyMonitorData() {}

  explicit DescribeSnapshotMonitorDataResponseBodyMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataPoint) {
      vector<boost::any> temp1;
      for(auto item1:*dataPoint){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataPoint"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataPoint") != m.end() && !m["DataPoint"].empty()) {
      if (typeid(vector<boost::any>) == m["DataPoint"].type()) {
        vector<DescribeSnapshotMonitorDataResponseBodyMonitorDataDataPoint> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataPoint"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSnapshotMonitorDataResponseBodyMonitorDataDataPoint model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataPoint = make_shared<vector<DescribeSnapshotMonitorDataResponseBodyMonitorDataDataPoint>>(expect1);
      }
    }
  }


  virtual ~DescribeSnapshotMonitorDataResponseBodyMonitorData() = default;
};
class DescribeSnapshotMonitorDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSnapshotMonitorDataResponseBodyMonitorData> monitorData{};

  DescribeSnapshotMonitorDataResponseBody() {}

  explicit DescribeSnapshotMonitorDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (monitorData) {
      res["MonitorData"] = monitorData ? boost::any(monitorData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("MonitorData") != m.end() && !m["MonitorData"].empty()) {
      if (typeid(map<string, boost::any>) == m["MonitorData"].type()) {
        DescribeSnapshotMonitorDataResponseBodyMonitorData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MonitorData"]));
        monitorData = make_shared<DescribeSnapshotMonitorDataResponseBodyMonitorData>(model1);
      }
    }
  }


  virtual ~DescribeSnapshotMonitorDataResponseBody() = default;
};
class DescribeSnapshotMonitorDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSnapshotMonitorDataResponseBody> body{};

  DescribeSnapshotMonitorDataResponse() {}

  explicit DescribeSnapshotMonitorDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSnapshotMonitorDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSnapshotMonitorDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSnapshotMonitorDataResponse() = default;
};
class DescribeSnapshotPackageRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ownerAccount{};

  DescribeSnapshotPackageRequest() {}

  explicit DescribeSnapshotPackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeSnapshotPackageRequest() = default;
};
class DescribeSnapshotPackageResponseBodySnapshotPackagesSnapshotPackage : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<long> initCapacity{};

  DescribeSnapshotPackageResponseBodySnapshotPackagesSnapshotPackage() {}

  explicit DescribeSnapshotPackageResponseBodySnapshotPackagesSnapshotPackage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (initCapacity) {
      res["InitCapacity"] = boost::any(*initCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("InitCapacity") != m.end() && !m["InitCapacity"].empty()) {
      initCapacity = make_shared<long>(boost::any_cast<long>(m["InitCapacity"]));
    }
  }


  virtual ~DescribeSnapshotPackageResponseBodySnapshotPackagesSnapshotPackage() = default;
};
class DescribeSnapshotPackageResponseBodySnapshotPackages : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSnapshotPackageResponseBodySnapshotPackagesSnapshotPackage>> snapshotPackage{};

  DescribeSnapshotPackageResponseBodySnapshotPackages() {}

  explicit DescribeSnapshotPackageResponseBodySnapshotPackages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshotPackage) {
      vector<boost::any> temp1;
      for(auto item1:*snapshotPackage){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SnapshotPackage"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnapshotPackage") != m.end() && !m["SnapshotPackage"].empty()) {
      if (typeid(vector<boost::any>) == m["SnapshotPackage"].type()) {
        vector<DescribeSnapshotPackageResponseBodySnapshotPackagesSnapshotPackage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SnapshotPackage"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSnapshotPackageResponseBodySnapshotPackagesSnapshotPackage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snapshotPackage = make_shared<vector<DescribeSnapshotPackageResponseBodySnapshotPackagesSnapshotPackage>>(expect1);
      }
    }
  }


  virtual ~DescribeSnapshotPackageResponseBodySnapshotPackages() = default;
};
class DescribeSnapshotPackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeSnapshotPackageResponseBodySnapshotPackages> snapshotPackages{};

  DescribeSnapshotPackageResponseBody() {}

  explicit DescribeSnapshotPackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (snapshotPackages) {
      res["SnapshotPackages"] = snapshotPackages ? boost::any(snapshotPackages->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("SnapshotPackages") != m.end() && !m["SnapshotPackages"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotPackages"].type()) {
        DescribeSnapshotPackageResponseBodySnapshotPackages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotPackages"]));
        snapshotPackages = make_shared<DescribeSnapshotPackageResponseBodySnapshotPackages>(model1);
      }
    }
  }


  virtual ~DescribeSnapshotPackageResponseBody() = default;
};
class DescribeSnapshotPackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSnapshotPackageResponseBody> body{};

  DescribeSnapshotPackageResponse() {}

  explicit DescribeSnapshotPackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSnapshotPackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSnapshotPackageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSnapshotPackageResponse() = default;
};
class DescribeSnapshotsRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeSnapshotsRequestFilter() {}

  explicit DescribeSnapshotsRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeSnapshotsRequestFilter() = default;
};
class DescribeSnapshotsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeSnapshotsRequestTag() {}

  explicit DescribeSnapshotsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeSnapshotsRequestTag() = default;
};
class DescribeSnapshotsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSnapshotsRequestFilter>> filter{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> diskId{};
  shared_ptr<string> snapshotLinkId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> snapshotIds{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> snapshotName{};
  shared_ptr<string> status{};
  shared_ptr<string> snapshotType{};
  shared_ptr<string> usage{};
  shared_ptr<string> sourceDiskType{};
  shared_ptr<bool> encrypted{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> KMSKeyId{};
  shared_ptr<string> category{};
  shared_ptr<vector<DescribeSnapshotsRequestTag>> tag{};

  DescribeSnapshotsRequest() {}

  explicit DescribeSnapshotsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (snapshotLinkId) {
      res["SnapshotLinkId"] = boost::any(*snapshotLinkId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (snapshotIds) {
      res["SnapshotIds"] = boost::any(*snapshotIds);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (snapshotName) {
      res["SnapshotName"] = boost::any(*snapshotName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (snapshotType) {
      res["SnapshotType"] = boost::any(*snapshotType);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (sourceDiskType) {
      res["SourceDiskType"] = boost::any(*sourceDiskType);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<DescribeSnapshotsRequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSnapshotsRequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<DescribeSnapshotsRequestFilter>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("SnapshotLinkId") != m.end() && !m["SnapshotLinkId"].empty()) {
      snapshotLinkId = make_shared<string>(boost::any_cast<string>(m["SnapshotLinkId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SnapshotIds") != m.end() && !m["SnapshotIds"].empty()) {
      snapshotIds = make_shared<string>(boost::any_cast<string>(m["SnapshotIds"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("SnapshotName") != m.end() && !m["SnapshotName"].empty()) {
      snapshotName = make_shared<string>(boost::any_cast<string>(m["SnapshotName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SnapshotType") != m.end() && !m["SnapshotType"].empty()) {
      snapshotType = make_shared<string>(boost::any_cast<string>(m["SnapshotType"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("SourceDiskType") != m.end() && !m["SourceDiskType"].empty()) {
      sourceDiskType = make_shared<string>(boost::any_cast<string>(m["SourceDiskType"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<bool>(boost::any_cast<bool>(m["Encrypted"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeSnapshotsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSnapshotsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeSnapshotsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeSnapshotsRequest() = default;
};
class DescribeSnapshotsResponseBodySnapshotsSnapshotTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  DescribeSnapshotsResponseBodySnapshotsSnapshotTagsTag() {}

  explicit DescribeSnapshotsResponseBodySnapshotsSnapshotTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~DescribeSnapshotsResponseBodySnapshotsSnapshotTagsTag() = default;
};
class DescribeSnapshotsResponseBodySnapshotsSnapshotTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSnapshotsResponseBodySnapshotsSnapshotTagsTag>> tag{};

  DescribeSnapshotsResponseBodySnapshotsSnapshotTags() {}

  explicit DescribeSnapshotsResponseBodySnapshotsSnapshotTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeSnapshotsResponseBodySnapshotsSnapshotTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSnapshotsResponseBodySnapshotsSnapshotTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeSnapshotsResponseBodySnapshotsSnapshotTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeSnapshotsResponseBodySnapshotsSnapshotTags() = default;
};
class DescribeSnapshotsResponseBodySnapshotsSnapshot : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> progress{};
  shared_ptr<bool> instantAccess{};
  shared_ptr<long> remainTime{};
  shared_ptr<string> sourceDiskSize{};
  shared_ptr<long> retentionDays{};
  shared_ptr<string> sourceDiskType{};
  shared_ptr<string> sourceStorageType{};
  shared_ptr<string> usage{};
  shared_ptr<string> lastModifiedTime{};
  shared_ptr<bool> encrypted{};
  shared_ptr<string> snapshotType{};
  shared_ptr<string> sourceDiskId{};
  shared_ptr<string> snapshotName{};
  shared_ptr<long> instantAccessRetentionDays{};
  shared_ptr<string> description{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> category{};
  shared_ptr<string> KMSKeyId{};
  shared_ptr<string> snapshotSN{};
  shared_ptr<string> productCode{};
  shared_ptr<string> sourceSnapshotId{};
  shared_ptr<string> sourceRegionId{};
  shared_ptr<DescribeSnapshotsResponseBodySnapshotsSnapshotTags> tags{};

  DescribeSnapshotsResponseBodySnapshotsSnapshot() {}

  explicit DescribeSnapshotsResponseBodySnapshotsSnapshot(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (instantAccess) {
      res["InstantAccess"] = boost::any(*instantAccess);
    }
    if (remainTime) {
      res["RemainTime"] = boost::any(*remainTime);
    }
    if (sourceDiskSize) {
      res["SourceDiskSize"] = boost::any(*sourceDiskSize);
    }
    if (retentionDays) {
      res["RetentionDays"] = boost::any(*retentionDays);
    }
    if (sourceDiskType) {
      res["SourceDiskType"] = boost::any(*sourceDiskType);
    }
    if (sourceStorageType) {
      res["SourceStorageType"] = boost::any(*sourceStorageType);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (lastModifiedTime) {
      res["LastModifiedTime"] = boost::any(*lastModifiedTime);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (snapshotType) {
      res["SnapshotType"] = boost::any(*snapshotType);
    }
    if (sourceDiskId) {
      res["SourceDiskId"] = boost::any(*sourceDiskId);
    }
    if (snapshotName) {
      res["SnapshotName"] = boost::any(*snapshotName);
    }
    if (instantAccessRetentionDays) {
      res["InstantAccessRetentionDays"] = boost::any(*instantAccessRetentionDays);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (snapshotSN) {
      res["SnapshotSN"] = boost::any(*snapshotSN);
    }
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (sourceSnapshotId) {
      res["SourceSnapshotId"] = boost::any(*sourceSnapshotId);
    }
    if (sourceRegionId) {
      res["SourceRegionId"] = boost::any(*sourceRegionId);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("InstantAccess") != m.end() && !m["InstantAccess"].empty()) {
      instantAccess = make_shared<bool>(boost::any_cast<bool>(m["InstantAccess"]));
    }
    if (m.find("RemainTime") != m.end() && !m["RemainTime"].empty()) {
      remainTime = make_shared<long>(boost::any_cast<long>(m["RemainTime"]));
    }
    if (m.find("SourceDiskSize") != m.end() && !m["SourceDiskSize"].empty()) {
      sourceDiskSize = make_shared<string>(boost::any_cast<string>(m["SourceDiskSize"]));
    }
    if (m.find("RetentionDays") != m.end() && !m["RetentionDays"].empty()) {
      retentionDays = make_shared<long>(boost::any_cast<long>(m["RetentionDays"]));
    }
    if (m.find("SourceDiskType") != m.end() && !m["SourceDiskType"].empty()) {
      sourceDiskType = make_shared<string>(boost::any_cast<string>(m["SourceDiskType"]));
    }
    if (m.find("SourceStorageType") != m.end() && !m["SourceStorageType"].empty()) {
      sourceStorageType = make_shared<string>(boost::any_cast<string>(m["SourceStorageType"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("LastModifiedTime") != m.end() && !m["LastModifiedTime"].empty()) {
      lastModifiedTime = make_shared<string>(boost::any_cast<string>(m["LastModifiedTime"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<bool>(boost::any_cast<bool>(m["Encrypted"]));
    }
    if (m.find("SnapshotType") != m.end() && !m["SnapshotType"].empty()) {
      snapshotType = make_shared<string>(boost::any_cast<string>(m["SnapshotType"]));
    }
    if (m.find("SourceDiskId") != m.end() && !m["SourceDiskId"].empty()) {
      sourceDiskId = make_shared<string>(boost::any_cast<string>(m["SourceDiskId"]));
    }
    if (m.find("SnapshotName") != m.end() && !m["SnapshotName"].empty()) {
      snapshotName = make_shared<string>(boost::any_cast<string>(m["SnapshotName"]));
    }
    if (m.find("InstantAccessRetentionDays") != m.end() && !m["InstantAccessRetentionDays"].empty()) {
      instantAccessRetentionDays = make_shared<long>(boost::any_cast<long>(m["InstantAccessRetentionDays"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("SnapshotSN") != m.end() && !m["SnapshotSN"].empty()) {
      snapshotSN = make_shared<string>(boost::any_cast<string>(m["SnapshotSN"]));
    }
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("SourceSnapshotId") != m.end() && !m["SourceSnapshotId"].empty()) {
      sourceSnapshotId = make_shared<string>(boost::any_cast<string>(m["SourceSnapshotId"]));
    }
    if (m.find("SourceRegionId") != m.end() && !m["SourceRegionId"].empty()) {
      sourceRegionId = make_shared<string>(boost::any_cast<string>(m["SourceRegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeSnapshotsResponseBodySnapshotsSnapshotTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeSnapshotsResponseBodySnapshotsSnapshotTags>(model1);
      }
    }
  }


  virtual ~DescribeSnapshotsResponseBodySnapshotsSnapshot() = default;
};
class DescribeSnapshotsResponseBodySnapshots : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSnapshotsResponseBodySnapshotsSnapshot>> snapshot{};

  DescribeSnapshotsResponseBodySnapshots() {}

  explicit DescribeSnapshotsResponseBodySnapshots(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshot) {
      vector<boost::any> temp1;
      for(auto item1:*snapshot){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Snapshot"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Snapshot") != m.end() && !m["Snapshot"].empty()) {
      if (typeid(vector<boost::any>) == m["Snapshot"].type()) {
        vector<DescribeSnapshotsResponseBodySnapshotsSnapshot> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Snapshot"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSnapshotsResponseBodySnapshotsSnapshot model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snapshot = make_shared<vector<DescribeSnapshotsResponseBodySnapshotsSnapshot>>(expect1);
      }
    }
  }


  virtual ~DescribeSnapshotsResponseBodySnapshots() = default;
};
class DescribeSnapshotsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeSnapshotsResponseBodySnapshots> snapshots{};

  DescribeSnapshotsResponseBody() {}

  explicit DescribeSnapshotsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (snapshots) {
      res["Snapshots"] = snapshots ? boost::any(snapshots->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      if (typeid(map<string, boost::any>) == m["Snapshots"].type()) {
        DescribeSnapshotsResponseBodySnapshots model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Snapshots"]));
        snapshots = make_shared<DescribeSnapshotsResponseBodySnapshots>(model1);
      }
    }
  }


  virtual ~DescribeSnapshotsResponseBody() = default;
};
class DescribeSnapshotsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSnapshotsResponseBody> body{};

  DescribeSnapshotsResponse() {}

  explicit DescribeSnapshotsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSnapshotsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSnapshotsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSnapshotsResponse() = default;
};
class DescribeSnapshotsUsageRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};

  DescribeSnapshotsUsageRequest() {}

  explicit DescribeSnapshotsUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeSnapshotsUsageRequest() = default;
};
class DescribeSnapshotsUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> snapshotSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> snapshotCount{};

  DescribeSnapshotsUsageResponseBody() {}

  explicit DescribeSnapshotsUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshotSize) {
      res["SnapshotSize"] = boost::any(*snapshotSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snapshotCount) {
      res["SnapshotCount"] = boost::any(*snapshotCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnapshotSize") != m.end() && !m["SnapshotSize"].empty()) {
      snapshotSize = make_shared<long>(boost::any_cast<long>(m["SnapshotSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnapshotCount") != m.end() && !m["SnapshotCount"].empty()) {
      snapshotCount = make_shared<long>(boost::any_cast<long>(m["SnapshotCount"]));
    }
  }


  virtual ~DescribeSnapshotsUsageResponseBody() = default;
};
class DescribeSnapshotsUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSnapshotsUsageResponseBody> body{};

  DescribeSnapshotsUsageResponse() {}

  explicit DescribeSnapshotsUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSnapshotsUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSnapshotsUsageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSnapshotsUsageResponse() = default;
};
class DescribeSpotAdviceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<string> regionId{};
  shared_ptr<long> cores{};
  shared_ptr<double> memory{};
  shared_ptr<long> minCores{};
  shared_ptr<double> minMemory{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> instanceTypeFamily{};
  shared_ptr<string> instanceFamilyLevel{};
  shared_ptr<string> gpuSpec{};
  shared_ptr<long> gpuAmount{};

  DescribeSpotAdviceRequest() {}

  explicit DescribeSpotAdviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = boost::any(*instanceTypes);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (minCores) {
      res["MinCores"] = boost::any(*minCores);
    }
    if (minMemory) {
      res["MinMemory"] = boost::any(*minMemory);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    if (instanceFamilyLevel) {
      res["InstanceFamilyLevel"] = boost::any(*instanceFamilyLevel);
    }
    if (gpuSpec) {
      res["GpuSpec"] = boost::any(*gpuSpec);
    }
    if (gpuAmount) {
      res["GpuAmount"] = boost::any(*gpuAmount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("MinCores") != m.end() && !m["MinCores"].empty()) {
      minCores = make_shared<long>(boost::any_cast<long>(m["MinCores"]));
    }
    if (m.find("MinMemory") != m.end() && !m["MinMemory"].empty()) {
      minMemory = make_shared<double>(boost::any_cast<double>(m["MinMemory"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      instanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamily"]));
    }
    if (m.find("InstanceFamilyLevel") != m.end() && !m["InstanceFamilyLevel"].empty()) {
      instanceFamilyLevel = make_shared<string>(boost::any_cast<string>(m["InstanceFamilyLevel"]));
    }
    if (m.find("GpuSpec") != m.end() && !m["GpuSpec"].empty()) {
      gpuSpec = make_shared<string>(boost::any_cast<string>(m["GpuSpec"]));
    }
    if (m.find("GpuAmount") != m.end() && !m["GpuAmount"].empty()) {
      gpuAmount = make_shared<long>(boost::any_cast<long>(m["GpuAmount"]));
    }
  }


  virtual ~DescribeSpotAdviceRequest() = default;
};
class DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZoneAvailableSpotResourcesAvailableSpotResource : public Darabonba::Model {
public:
  shared_ptr<string> interruptRateDesc{};
  shared_ptr<long> averageSpotDiscount{};
  shared_ptr<string> instanceType{};
  shared_ptr<double> interruptionRate{};

  DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZoneAvailableSpotResourcesAvailableSpotResource() {}

  explicit DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZoneAvailableSpotResourcesAvailableSpotResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interruptRateDesc) {
      res["InterruptRateDesc"] = boost::any(*interruptRateDesc);
    }
    if (averageSpotDiscount) {
      res["AverageSpotDiscount"] = boost::any(*averageSpotDiscount);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (interruptionRate) {
      res["InterruptionRate"] = boost::any(*interruptionRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InterruptRateDesc") != m.end() && !m["InterruptRateDesc"].empty()) {
      interruptRateDesc = make_shared<string>(boost::any_cast<string>(m["InterruptRateDesc"]));
    }
    if (m.find("AverageSpotDiscount") != m.end() && !m["AverageSpotDiscount"].empty()) {
      averageSpotDiscount = make_shared<long>(boost::any_cast<long>(m["AverageSpotDiscount"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InterruptionRate") != m.end() && !m["InterruptionRate"].empty()) {
      interruptionRate = make_shared<double>(boost::any_cast<double>(m["InterruptionRate"]));
    }
  }


  virtual ~DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZoneAvailableSpotResourcesAvailableSpotResource() = default;
};
class DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZoneAvailableSpotResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZoneAvailableSpotResourcesAvailableSpotResource>> availableSpotResource{};

  DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZoneAvailableSpotResources() {}

  explicit DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZoneAvailableSpotResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableSpotResource) {
      vector<boost::any> temp1;
      for(auto item1:*availableSpotResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvailableSpotResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableSpotResource") != m.end() && !m["AvailableSpotResource"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableSpotResource"].type()) {
        vector<DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZoneAvailableSpotResourcesAvailableSpotResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableSpotResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZoneAvailableSpotResourcesAvailableSpotResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        availableSpotResource = make_shared<vector<DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZoneAvailableSpotResourcesAvailableSpotResource>>(expect1);
      }
    }
  }


  virtual ~DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZoneAvailableSpotResources() = default;
};
class DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZone : public Darabonba::Model {
public:
  shared_ptr<string> zoneId{};
  shared_ptr<DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZoneAvailableSpotResources> availableSpotResources{};

  DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZone() {}

  explicit DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZone(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (availableSpotResources) {
      res["AvailableSpotResources"] = availableSpotResources ? boost::any(availableSpotResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("AvailableSpotResources") != m.end() && !m["AvailableSpotResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvailableSpotResources"].type()) {
        DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZoneAvailableSpotResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvailableSpotResources"]));
        availableSpotResources = make_shared<DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZoneAvailableSpotResources>(model1);
      }
    }
  }


  virtual ~DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZone() = default;
};
class DescribeSpotAdviceResponseBodyAvailableSpotZones : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZone>> availableSpotZone{};

  DescribeSpotAdviceResponseBodyAvailableSpotZones() {}

  explicit DescribeSpotAdviceResponseBodyAvailableSpotZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableSpotZone) {
      vector<boost::any> temp1;
      for(auto item1:*availableSpotZone){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvailableSpotZone"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableSpotZone") != m.end() && !m["AvailableSpotZone"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableSpotZone"].type()) {
        vector<DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZone> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableSpotZone"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZone model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        availableSpotZone = make_shared<vector<DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZone>>(expect1);
      }
    }
  }


  virtual ~DescribeSpotAdviceResponseBodyAvailableSpotZones() = default;
};
class DescribeSpotAdviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSpotAdviceResponseBodyAvailableSpotZones> availableSpotZones{};

  DescribeSpotAdviceResponseBody() {}

  explicit DescribeSpotAdviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (availableSpotZones) {
      res["AvailableSpotZones"] = availableSpotZones ? boost::any(availableSpotZones->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("AvailableSpotZones") != m.end() && !m["AvailableSpotZones"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvailableSpotZones"].type()) {
        DescribeSpotAdviceResponseBodyAvailableSpotZones model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvailableSpotZones"]));
        availableSpotZones = make_shared<DescribeSpotAdviceResponseBodyAvailableSpotZones>(model1);
      }
    }
  }


  virtual ~DescribeSpotAdviceResponseBody() = default;
};
class DescribeSpotAdviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSpotAdviceResponseBody> body{};

  DescribeSpotAdviceResponse() {}

  explicit DescribeSpotAdviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSpotAdviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSpotAdviceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSpotAdviceResponse() = default;
};
class DescribeSpotPriceHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> networkType{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> spotDuration{};
  shared_ptr<string> ioOptimized{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> OSType{};
  shared_ptr<long> offset{};

  DescribeSpotPriceHistoryRequest() {}

  explicit DescribeSpotPriceHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (spotDuration) {
      res["SpotDuration"] = boost::any(*spotDuration);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (OSType) {
      res["OSType"] = boost::any(*OSType);
    }
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("SpotDuration") != m.end() && !m["SpotDuration"].empty()) {
      spotDuration = make_shared<long>(boost::any_cast<long>(m["SpotDuration"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OSType") != m.end() && !m["OSType"].empty()) {
      OSType = make_shared<string>(boost::any_cast<string>(m["OSType"]));
    }
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
  }


  virtual ~DescribeSpotPriceHistoryRequest() = default;
};
class DescribeSpotPriceHistoryResponseBodySpotPricesSpotPriceType : public Darabonba::Model {
public:
  shared_ptr<string> ioOptimized{};
  shared_ptr<string> zoneId{};
  shared_ptr<double> spotPrice{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> networkType{};
  shared_ptr<string> instanceType{};
  shared_ptr<double> originPrice{};

  DescribeSpotPriceHistoryResponseBodySpotPricesSpotPriceType() {}

  explicit DescribeSpotPriceHistoryResponseBodySpotPricesSpotPriceType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (spotPrice) {
      res["SpotPrice"] = boost::any(*spotPrice);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (originPrice) {
      res["OriginPrice"] = boost::any(*originPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("SpotPrice") != m.end() && !m["SpotPrice"].empty()) {
      spotPrice = make_shared<double>(boost::any_cast<double>(m["SpotPrice"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OriginPrice") != m.end() && !m["OriginPrice"].empty()) {
      originPrice = make_shared<double>(boost::any_cast<double>(m["OriginPrice"]));
    }
  }


  virtual ~DescribeSpotPriceHistoryResponseBodySpotPricesSpotPriceType() = default;
};
class DescribeSpotPriceHistoryResponseBodySpotPrices : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSpotPriceHistoryResponseBodySpotPricesSpotPriceType>> spotPriceType{};

  DescribeSpotPriceHistoryResponseBodySpotPrices() {}

  explicit DescribeSpotPriceHistoryResponseBodySpotPrices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (spotPriceType) {
      vector<boost::any> temp1;
      for(auto item1:*spotPriceType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpotPriceType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpotPriceType") != m.end() && !m["SpotPriceType"].empty()) {
      if (typeid(vector<boost::any>) == m["SpotPriceType"].type()) {
        vector<DescribeSpotPriceHistoryResponseBodySpotPricesSpotPriceType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpotPriceType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSpotPriceHistoryResponseBodySpotPricesSpotPriceType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spotPriceType = make_shared<vector<DescribeSpotPriceHistoryResponseBodySpotPricesSpotPriceType>>(expect1);
      }
    }
  }


  virtual ~DescribeSpotPriceHistoryResponseBodySpotPrices() = default;
};
class DescribeSpotPriceHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> currency{};
  shared_ptr<long> nextOffset{};
  shared_ptr<DescribeSpotPriceHistoryResponseBodySpotPrices> spotPrices{};

  DescribeSpotPriceHistoryResponseBody() {}

  explicit DescribeSpotPriceHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (nextOffset) {
      res["NextOffset"] = boost::any(*nextOffset);
    }
    if (spotPrices) {
      res["SpotPrices"] = spotPrices ? boost::any(spotPrices->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("NextOffset") != m.end() && !m["NextOffset"].empty()) {
      nextOffset = make_shared<long>(boost::any_cast<long>(m["NextOffset"]));
    }
    if (m.find("SpotPrices") != m.end() && !m["SpotPrices"].empty()) {
      if (typeid(map<string, boost::any>) == m["SpotPrices"].type()) {
        DescribeSpotPriceHistoryResponseBodySpotPrices model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SpotPrices"]));
        spotPrices = make_shared<DescribeSpotPriceHistoryResponseBodySpotPrices>(model1);
      }
    }
  }


  virtual ~DescribeSpotPriceHistoryResponseBody() = default;
};
class DescribeSpotPriceHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSpotPriceHistoryResponseBody> body{};

  DescribeSpotPriceHistoryResponse() {}

  explicit DescribeSpotPriceHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSpotPriceHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSpotPriceHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSpotPriceHistoryResponse() = default;
};
class DescribeStorageCapacityUnitsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeStorageCapacityUnitsRequestTag() {}

  explicit DescribeStorageCapacityUnitsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeStorageCapacityUnitsRequestTag() = default;
};
class DescribeStorageCapacityUnitsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> name{};
  shared_ptr<long> capacity{};
  shared_ptr<string> allocationType{};
  shared_ptr<vector<string>> storageCapacityUnitId{};
  shared_ptr<vector<string>> status{};
  shared_ptr<vector<DescribeStorageCapacityUnitsRequestTag>> tag{};

  DescribeStorageCapacityUnitsRequest() {}

  explicit DescribeStorageCapacityUnitsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (capacity) {
      res["Capacity"] = boost::any(*capacity);
    }
    if (allocationType) {
      res["AllocationType"] = boost::any(*allocationType);
    }
    if (storageCapacityUnitId) {
      res["StorageCapacityUnitId"] = boost::any(*storageCapacityUnitId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Capacity") != m.end() && !m["Capacity"].empty()) {
      capacity = make_shared<long>(boost::any_cast<long>(m["Capacity"]));
    }
    if (m.find("AllocationType") != m.end() && !m["AllocationType"].empty()) {
      allocationType = make_shared<string>(boost::any_cast<string>(m["AllocationType"]));
    }
    if (m.find("StorageCapacityUnitId") != m.end() && !m["StorageCapacityUnitId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StorageCapacityUnitId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StorageCapacityUnitId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      storageCapacityUnitId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Status"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Status"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      status = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeStorageCapacityUnitsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStorageCapacityUnitsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeStorageCapacityUnitsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeStorageCapacityUnitsRequest() = default;
};
class DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnitTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnitTagsTag() {}

  explicit DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnitTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnitTagsTag() = default;
};
class DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnitTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnitTagsTag>> tag{};

  DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnitTags() {}

  explicit DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnitTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnitTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnitTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnitTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnitTags() = default;
};
class DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnit : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> status{};
  shared_ptr<string> startTime{};
  shared_ptr<long> capacity{};
  shared_ptr<string> description{};
  shared_ptr<string> allocationStatus{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> storageCapacityUnitId{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnitTags> tags{};

  DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnit() {}

  explicit DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (capacity) {
      res["Capacity"] = boost::any(*capacity);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (allocationStatus) {
      res["AllocationStatus"] = boost::any(*allocationStatus);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (storageCapacityUnitId) {
      res["StorageCapacityUnitId"] = boost::any(*storageCapacityUnitId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Capacity") != m.end() && !m["Capacity"].empty()) {
      capacity = make_shared<long>(boost::any_cast<long>(m["Capacity"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("AllocationStatus") != m.end() && !m["AllocationStatus"].empty()) {
      allocationStatus = make_shared<string>(boost::any_cast<string>(m["AllocationStatus"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("StorageCapacityUnitId") != m.end() && !m["StorageCapacityUnitId"].empty()) {
      storageCapacityUnitId = make_shared<string>(boost::any_cast<string>(m["StorageCapacityUnitId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnitTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnitTags>(model1);
      }
    }
  }


  virtual ~DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnit() = default;
};
class DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnits : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnit>> storageCapacityUnit{};

  DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnits() {}

  explicit DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnits(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (storageCapacityUnit) {
      vector<boost::any> temp1;
      for(auto item1:*storageCapacityUnit){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StorageCapacityUnit"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StorageCapacityUnit") != m.end() && !m["StorageCapacityUnit"].empty()) {
      if (typeid(vector<boost::any>) == m["StorageCapacityUnit"].type()) {
        vector<DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnit> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StorageCapacityUnit"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnit model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        storageCapacityUnit = make_shared<vector<DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnit>>(expect1);
      }
    }
  }


  virtual ~DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnits() = default;
};
class DescribeStorageCapacityUnitsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnits> storageCapacityUnits{};

  DescribeStorageCapacityUnitsResponseBody() {}

  explicit DescribeStorageCapacityUnitsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (storageCapacityUnits) {
      res["StorageCapacityUnits"] = storageCapacityUnits ? boost::any(storageCapacityUnits->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("StorageCapacityUnits") != m.end() && !m["StorageCapacityUnits"].empty()) {
      if (typeid(map<string, boost::any>) == m["StorageCapacityUnits"].type()) {
        DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnits model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StorageCapacityUnits"]));
        storageCapacityUnits = make_shared<DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnits>(model1);
      }
    }
  }


  virtual ~DescribeStorageCapacityUnitsResponseBody() = default;
};
class DescribeStorageCapacityUnitsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeStorageCapacityUnitsResponseBody> body{};

  DescribeStorageCapacityUnitsResponse() {}

  explicit DescribeStorageCapacityUnitsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStorageCapacityUnitsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStorageCapacityUnitsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStorageCapacityUnitsResponse() = default;
};
class DescribeStorageSetDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> storageSetId{};
  shared_ptr<long> storageSetPartitionNumber{};
  shared_ptr<string> diskIds{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeStorageSetDetailsRequest() {}

  explicit DescribeStorageSetDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    if (storageSetPartitionNumber) {
      res["StorageSetPartitionNumber"] = boost::any(*storageSetPartitionNumber);
    }
    if (diskIds) {
      res["DiskIds"] = boost::any(*diskIds);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
    if (m.find("StorageSetPartitionNumber") != m.end() && !m["StorageSetPartitionNumber"].empty()) {
      storageSetPartitionNumber = make_shared<long>(boost::any_cast<long>(m["StorageSetPartitionNumber"]));
    }
    if (m.find("DiskIds") != m.end() && !m["DiskIds"].empty()) {
      diskIds = make_shared<string>(boost::any_cast<string>(m["DiskIds"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeStorageSetDetailsRequest() = default;
};
class DescribeStorageSetDetailsResponseBodyDisksDisk : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> diskName{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> storageSetId{};
  shared_ptr<string> diskId{};
  shared_ptr<string> category{};
  shared_ptr<long> storageSetPartitionNumber{};
  shared_ptr<string> regionId{};

  DescribeStorageSetDetailsResponseBodyDisksDisk() {}

  explicit DescribeStorageSetDetailsResponseBodyDisksDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (storageSetPartitionNumber) {
      res["StorageSetPartitionNumber"] = boost::any(*storageSetPartitionNumber);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("StorageSetPartitionNumber") != m.end() && !m["StorageSetPartitionNumber"].empty()) {
      storageSetPartitionNumber = make_shared<long>(boost::any_cast<long>(m["StorageSetPartitionNumber"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeStorageSetDetailsResponseBodyDisksDisk() = default;
};
class DescribeStorageSetDetailsResponseBodyDisks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeStorageSetDetailsResponseBodyDisksDisk>> disk{};

  DescribeStorageSetDetailsResponseBodyDisks() {}

  explicit DescribeStorageSetDetailsResponseBodyDisks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disk) {
      vector<boost::any> temp1;
      for(auto item1:*disk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Disk"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Disk") != m.end() && !m["Disk"].empty()) {
      if (typeid(vector<boost::any>) == m["Disk"].type()) {
        vector<DescribeStorageSetDetailsResponseBodyDisksDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Disk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStorageSetDetailsResponseBodyDisksDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        disk = make_shared<vector<DescribeStorageSetDetailsResponseBodyDisksDisk>>(expect1);
      }
    }
  }


  virtual ~DescribeStorageSetDetailsResponseBodyDisks() = default;
};
class DescribeStorageSetDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeStorageSetDetailsResponseBodyDisks> disks{};

  DescribeStorageSetDetailsResponseBody() {}

  explicit DescribeStorageSetDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (disks) {
      res["Disks"] = disks ? boost::any(disks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Disks") != m.end() && !m["Disks"].empty()) {
      if (typeid(map<string, boost::any>) == m["Disks"].type()) {
        DescribeStorageSetDetailsResponseBodyDisks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Disks"]));
        disks = make_shared<DescribeStorageSetDetailsResponseBodyDisks>(model1);
      }
    }
  }


  virtual ~DescribeStorageSetDetailsResponseBody() = default;
};
class DescribeStorageSetDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeStorageSetDetailsResponseBody> body{};

  DescribeStorageSetDetailsResponse() {}

  explicit DescribeStorageSetDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStorageSetDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStorageSetDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStorageSetDetailsResponse() = default;
};
class DescribeStorageSetsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> storageSetIds{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> storageSetName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeStorageSetsRequest() {}

  explicit DescribeStorageSetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (storageSetIds) {
      res["StorageSetIds"] = boost::any(*storageSetIds);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (storageSetName) {
      res["StorageSetName"] = boost::any(*storageSetName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StorageSetIds") != m.end() && !m["StorageSetIds"].empty()) {
      storageSetIds = make_shared<string>(boost::any_cast<string>(m["StorageSetIds"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("StorageSetName") != m.end() && !m["StorageSetName"].empty()) {
      storageSetName = make_shared<string>(boost::any_cast<string>(m["StorageSetName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeStorageSetsRequest() = default;
};
class DescribeStorageSetsResponseBodyStorageSetsStorageSet : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> storageSetId{};
  shared_ptr<long> storageSetPartitionNumber{};
  shared_ptr<string> storageSetName{};
  shared_ptr<string> regionId{};

  DescribeStorageSetsResponseBodyStorageSetsStorageSet() {}

  explicit DescribeStorageSetsResponseBodyStorageSetsStorageSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    if (storageSetPartitionNumber) {
      res["StorageSetPartitionNumber"] = boost::any(*storageSetPartitionNumber);
    }
    if (storageSetName) {
      res["StorageSetName"] = boost::any(*storageSetName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
    if (m.find("StorageSetPartitionNumber") != m.end() && !m["StorageSetPartitionNumber"].empty()) {
      storageSetPartitionNumber = make_shared<long>(boost::any_cast<long>(m["StorageSetPartitionNumber"]));
    }
    if (m.find("StorageSetName") != m.end() && !m["StorageSetName"].empty()) {
      storageSetName = make_shared<string>(boost::any_cast<string>(m["StorageSetName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeStorageSetsResponseBodyStorageSetsStorageSet() = default;
};
class DescribeStorageSetsResponseBodyStorageSets : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeStorageSetsResponseBodyStorageSetsStorageSet>> storageSet{};

  DescribeStorageSetsResponseBodyStorageSets() {}

  explicit DescribeStorageSetsResponseBodyStorageSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (storageSet) {
      vector<boost::any> temp1;
      for(auto item1:*storageSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StorageSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StorageSet") != m.end() && !m["StorageSet"].empty()) {
      if (typeid(vector<boost::any>) == m["StorageSet"].type()) {
        vector<DescribeStorageSetsResponseBodyStorageSetsStorageSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StorageSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStorageSetsResponseBodyStorageSetsStorageSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        storageSet = make_shared<vector<DescribeStorageSetsResponseBodyStorageSetsStorageSet>>(expect1);
      }
    }
  }


  virtual ~DescribeStorageSetsResponseBodyStorageSets() = default;
};
class DescribeStorageSetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeStorageSetsResponseBodyStorageSets> storageSets{};

  DescribeStorageSetsResponseBody() {}

  explicit DescribeStorageSetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (storageSets) {
      res["StorageSets"] = storageSets ? boost::any(storageSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("StorageSets") != m.end() && !m["StorageSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["StorageSets"].type()) {
        DescribeStorageSetsResponseBodyStorageSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StorageSets"]));
        storageSets = make_shared<DescribeStorageSetsResponseBodyStorageSets>(model1);
      }
    }
  }


  virtual ~DescribeStorageSetsResponseBody() = default;
};
class DescribeStorageSetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeStorageSetsResponseBody> body{};

  DescribeStorageSetsResponse() {}

  explicit DescribeStorageSetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStorageSetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStorageSetsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStorageSetsResponse() = default;
};
class DescribeTagsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeTagsRequestTag() {}

  explicit DescribeTagsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeTagsRequestTag() = default;
};
class DescribeTagsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> category{};
  shared_ptr<vector<DescribeTagsRequestTag>> tag{};

  DescribeTagsRequest() {}

  explicit DescribeTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeTagsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTagsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeTagsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeTagsRequest() = default;
};
class DescribeTagsResponseBodyTagsTagResourceTypeCount : public Darabonba::Model {
public:
  shared_ptr<long> instance{};
  shared_ptr<long> image{};
  shared_ptr<long> ddh{};
  shared_ptr<long> snapshotPolicy{};
  shared_ptr<long> securitygroup{};
  shared_ptr<long> snapshot{};
  shared_ptr<long> reservedInstance{};
  shared_ptr<long> launchTemplate{};
  shared_ptr<long> eni{};
  shared_ptr<long> disk{};
  shared_ptr<long> keyPair{};
  shared_ptr<long> volume{};

  DescribeTagsResponseBodyTagsTagResourceTypeCount() {}

  explicit DescribeTagsResponseBodyTagsTagResourceTypeCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      res["Instance"] = boost::any(*instance);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (ddh) {
      res["Ddh"] = boost::any(*ddh);
    }
    if (snapshotPolicy) {
      res["SnapshotPolicy"] = boost::any(*snapshotPolicy);
    }
    if (securitygroup) {
      res["Securitygroup"] = boost::any(*securitygroup);
    }
    if (snapshot) {
      res["Snapshot"] = boost::any(*snapshot);
    }
    if (reservedInstance) {
      res["ReservedInstance"] = boost::any(*reservedInstance);
    }
    if (launchTemplate) {
      res["LaunchTemplate"] = boost::any(*launchTemplate);
    }
    if (eni) {
      res["Eni"] = boost::any(*eni);
    }
    if (disk) {
      res["Disk"] = boost::any(*disk);
    }
    if (keyPair) {
      res["KeyPair"] = boost::any(*keyPair);
    }
    if (volume) {
      res["Volume"] = boost::any(*volume);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      instance = make_shared<long>(boost::any_cast<long>(m["Instance"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<long>(boost::any_cast<long>(m["Image"]));
    }
    if (m.find("Ddh") != m.end() && !m["Ddh"].empty()) {
      ddh = make_shared<long>(boost::any_cast<long>(m["Ddh"]));
    }
    if (m.find("SnapshotPolicy") != m.end() && !m["SnapshotPolicy"].empty()) {
      snapshotPolicy = make_shared<long>(boost::any_cast<long>(m["SnapshotPolicy"]));
    }
    if (m.find("Securitygroup") != m.end() && !m["Securitygroup"].empty()) {
      securitygroup = make_shared<long>(boost::any_cast<long>(m["Securitygroup"]));
    }
    if (m.find("Snapshot") != m.end() && !m["Snapshot"].empty()) {
      snapshot = make_shared<long>(boost::any_cast<long>(m["Snapshot"]));
    }
    if (m.find("ReservedInstance") != m.end() && !m["ReservedInstance"].empty()) {
      reservedInstance = make_shared<long>(boost::any_cast<long>(m["ReservedInstance"]));
    }
    if (m.find("LaunchTemplate") != m.end() && !m["LaunchTemplate"].empty()) {
      launchTemplate = make_shared<long>(boost::any_cast<long>(m["LaunchTemplate"]));
    }
    if (m.find("Eni") != m.end() && !m["Eni"].empty()) {
      eni = make_shared<long>(boost::any_cast<long>(m["Eni"]));
    }
    if (m.find("Disk") != m.end() && !m["Disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["Disk"]));
    }
    if (m.find("KeyPair") != m.end() && !m["KeyPair"].empty()) {
      keyPair = make_shared<long>(boost::any_cast<long>(m["KeyPair"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      volume = make_shared<long>(boost::any_cast<long>(m["Volume"]));
    }
  }


  virtual ~DescribeTagsResponseBodyTagsTagResourceTypeCount() = default;
};
class DescribeTagsResponseBodyTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};
  shared_ptr<DescribeTagsResponseBodyTagsTagResourceTypeCount> resourceTypeCount{};

  DescribeTagsResponseBodyTagsTag() {}

  explicit DescribeTagsResponseBodyTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (resourceTypeCount) {
      res["ResourceTypeCount"] = resourceTypeCount ? boost::any(resourceTypeCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("ResourceTypeCount") != m.end() && !m["ResourceTypeCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceTypeCount"].type()) {
        DescribeTagsResponseBodyTagsTagResourceTypeCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceTypeCount"]));
        resourceTypeCount = make_shared<DescribeTagsResponseBodyTagsTagResourceTypeCount>(model1);
      }
    }
  }


  virtual ~DescribeTagsResponseBodyTagsTag() = default;
};
class DescribeTagsResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTagsResponseBodyTagsTag>> tag{};

  DescribeTagsResponseBodyTags() {}

  explicit DescribeTagsResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeTagsResponseBodyTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTagsResponseBodyTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeTagsResponseBodyTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeTagsResponseBodyTags() = default;
};
class DescribeTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeTagsResponseBodyTags> tags{};

  DescribeTagsResponseBody() {}

  explicit DescribeTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeTagsResponseBodyTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeTagsResponseBodyTags>(model1);
      }
    }
  }


  virtual ~DescribeTagsResponseBody() = default;
};
class DescribeTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeTagsResponseBody> body{};

  DescribeTagsResponse() {}

  explicit DescribeTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTagsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTagsResponse() = default;
};
class DescribeTaskAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};

  DescribeTaskAttributeRequest() {}

  explicit DescribeTaskAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeTaskAttributeRequest() = default;
};
class DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem() {}

  explicit DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem() = default;
};
class DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgressRelatedItemSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem>> relatedItem{};

  DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgressRelatedItemSet() {}

  explicit DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgressRelatedItemSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (relatedItem) {
      vector<boost::any> temp1;
      for(auto item1:*relatedItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RelatedItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RelatedItem") != m.end() && !m["RelatedItem"].empty()) {
      if (typeid(vector<boost::any>) == m["RelatedItem"].type()) {
        vector<DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RelatedItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relatedItem = make_shared<vector<DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem>>(expect1);
      }
    }
  }


  virtual ~DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgressRelatedItemSet() = default;
};
class DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgress : public Darabonba::Model {
public:
  shared_ptr<string> errorMsg{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> operationStatus{};
  shared_ptr<DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgressRelatedItemSet> relatedItemSet{};

  DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgress() {}

  explicit DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (operationStatus) {
      res["OperationStatus"] = boost::any(*operationStatus);
    }
    if (relatedItemSet) {
      res["RelatedItemSet"] = relatedItemSet ? boost::any(relatedItemSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("OperationStatus") != m.end() && !m["OperationStatus"].empty()) {
      operationStatus = make_shared<string>(boost::any_cast<string>(m["OperationStatus"]));
    }
    if (m.find("RelatedItemSet") != m.end() && !m["RelatedItemSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["RelatedItemSet"].type()) {
        DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgressRelatedItemSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RelatedItemSet"]));
        relatedItemSet = make_shared<DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgressRelatedItemSet>(model1);
      }
    }
  }


  virtual ~DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgress() = default;
};
class DescribeTaskAttributeResponseBodyOperationProgressSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgress>> operationProgress{};

  DescribeTaskAttributeResponseBodyOperationProgressSet() {}

  explicit DescribeTaskAttributeResponseBodyOperationProgressSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationProgress) {
      vector<boost::any> temp1;
      for(auto item1:*operationProgress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperationProgress"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationProgress") != m.end() && !m["OperationProgress"].empty()) {
      if (typeid(vector<boost::any>) == m["OperationProgress"].type()) {
        vector<DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperationProgress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operationProgress = make_shared<vector<DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgress>>(expect1);
      }
    }
  }


  virtual ~DescribeTaskAttributeResponseBodyOperationProgressSet() = default;
};
class DescribeTaskAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> supportCancel{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> successCount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskAction{};
  shared_ptr<long> failedCount{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> taskProcess{};
  shared_ptr<string> finishedTime{};
  shared_ptr<string> taskId{};
  shared_ptr<DescribeTaskAttributeResponseBodyOperationProgressSet> operationProgressSet{};

  DescribeTaskAttributeResponseBody() {}

  explicit DescribeTaskAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (supportCancel) {
      res["SupportCancel"] = boost::any(*supportCancel);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskAction) {
      res["TaskAction"] = boost::any(*taskAction);
    }
    if (failedCount) {
      res["FailedCount"] = boost::any(*failedCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (taskProcess) {
      res["TaskProcess"] = boost::any(*taskProcess);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (operationProgressSet) {
      res["OperationProgressSet"] = operationProgressSet ? boost::any(operationProgressSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("SupportCancel") != m.end() && !m["SupportCancel"].empty()) {
      supportCancel = make_shared<string>(boost::any_cast<string>(m["SupportCancel"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskAction") != m.end() && !m["TaskAction"].empty()) {
      taskAction = make_shared<string>(boost::any_cast<string>(m["TaskAction"]));
    }
    if (m.find("FailedCount") != m.end() && !m["FailedCount"].empty()) {
      failedCount = make_shared<long>(boost::any_cast<long>(m["FailedCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("TaskProcess") != m.end() && !m["TaskProcess"].empty()) {
      taskProcess = make_shared<string>(boost::any_cast<string>(m["TaskProcess"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<string>(boost::any_cast<string>(m["FinishedTime"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("OperationProgressSet") != m.end() && !m["OperationProgressSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperationProgressSet"].type()) {
        DescribeTaskAttributeResponseBodyOperationProgressSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperationProgressSet"]));
        operationProgressSet = make_shared<DescribeTaskAttributeResponseBodyOperationProgressSet>(model1);
      }
    }
  }


  virtual ~DescribeTaskAttributeResponseBody() = default;
};
class DescribeTaskAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeTaskAttributeResponseBody> body{};

  DescribeTaskAttributeResponse() {}

  explicit DescribeTaskAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTaskAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTaskAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTaskAttributeResponse() = default;
};
class DescribeTasksRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskIds{};
  shared_ptr<string> taskAction{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  DescribeTasksRequest() {}

  explicit DescribeTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    if (taskAction) {
      res["TaskAction"] = boost::any(*taskAction);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      taskIds = make_shared<string>(boost::any_cast<string>(m["TaskIds"]));
    }
    if (m.find("TaskAction") != m.end() && !m["TaskAction"].empty()) {
      taskAction = make_shared<string>(boost::any_cast<string>(m["TaskAction"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~DescribeTasksRequest() = default;
};
class DescribeTasksResponseBodyTaskSetTask : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> finishedTime{};
  shared_ptr<string> supportCancel{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskAction{};

  DescribeTasksResponseBodyTaskSetTask() {}

  explicit DescribeTasksResponseBodyTaskSetTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (supportCancel) {
      res["SupportCancel"] = boost::any(*supportCancel);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskAction) {
      res["TaskAction"] = boost::any(*taskAction);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<string>(boost::any_cast<string>(m["FinishedTime"]));
    }
    if (m.find("SupportCancel") != m.end() && !m["SupportCancel"].empty()) {
      supportCancel = make_shared<string>(boost::any_cast<string>(m["SupportCancel"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskAction") != m.end() && !m["TaskAction"].empty()) {
      taskAction = make_shared<string>(boost::any_cast<string>(m["TaskAction"]));
    }
  }


  virtual ~DescribeTasksResponseBodyTaskSetTask() = default;
};
class DescribeTasksResponseBodyTaskSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTasksResponseBodyTaskSetTask>> task{};

  DescribeTasksResponseBodyTaskSet() {}

  explicit DescribeTasksResponseBodyTaskSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (task) {
      vector<boost::any> temp1;
      for(auto item1:*task){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Task"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      if (typeid(vector<boost::any>) == m["Task"].type()) {
        vector<DescribeTasksResponseBodyTaskSetTask> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Task"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTasksResponseBodyTaskSetTask model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        task = make_shared<vector<DescribeTasksResponseBodyTaskSetTask>>(expect1);
      }
    }
  }


  virtual ~DescribeTasksResponseBodyTaskSet() = default;
};
class DescribeTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeTasksResponseBodyTaskSet> taskSet{};

  DescribeTasksResponseBody() {}

  explicit DescribeTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskSet) {
      res["TaskSet"] = taskSet ? boost::any(taskSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskSet") != m.end() && !m["TaskSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskSet"].type()) {
        DescribeTasksResponseBodyTaskSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskSet"]));
        taskSet = make_shared<DescribeTasksResponseBodyTaskSet>(model1);
      }
    }
  }


  virtual ~DescribeTasksResponseBody() = default;
};
class DescribeTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeTasksResponseBody> body{};

  DescribeTasksResponse() {}

  explicit DescribeTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTasksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTasksResponse() = default;
};
class DescribeUserBusinessBehaviorRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> statusKey{};

  DescribeUserBusinessBehaviorRequest() {}

  explicit DescribeUserBusinessBehaviorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (statusKey) {
      res["statusKey"] = boost::any(*statusKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("statusKey") != m.end() && !m["statusKey"].empty()) {
      statusKey = make_shared<string>(boost::any_cast<string>(m["statusKey"]));
    }
  }


  virtual ~DescribeUserBusinessBehaviorRequest() = default;
};
class DescribeUserBusinessBehaviorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> statusValue{};
  shared_ptr<string> requestId{};

  DescribeUserBusinessBehaviorResponseBody() {}

  explicit DescribeUserBusinessBehaviorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (statusValue) {
      res["StatusValue"] = boost::any(*statusValue);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StatusValue") != m.end() && !m["StatusValue"].empty()) {
      statusValue = make_shared<string>(boost::any_cast<string>(m["StatusValue"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUserBusinessBehaviorResponseBody() = default;
};
class DescribeUserBusinessBehaviorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeUserBusinessBehaviorResponseBody> body{};

  DescribeUserBusinessBehaviorResponse() {}

  explicit DescribeUserBusinessBehaviorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserBusinessBehaviorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserBusinessBehaviorResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserBusinessBehaviorResponse() = default;
};
class DescribeUserDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceId{};

  DescribeUserDataRequest() {}

  explicit DescribeUserDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeUserDataRequest() = default;
};
class DescribeUserDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> userData{};
  shared_ptr<string> regionId{};

  DescribeUserDataResponseBody() {}

  explicit DescribeUserDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeUserDataResponseBody() = default;
};
class DescribeUserDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeUserDataResponseBody> body{};

  DescribeUserDataResponse() {}

  explicit DescribeUserDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserDataResponse() = default;
};
class DescribeVirtualBorderRoutersRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<string>> value{};

  DescribeVirtualBorderRoutersRequestFilter() {}

  explicit DescribeVirtualBorderRoutersRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Value"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      value = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVirtualBorderRoutersRequestFilter() = default;
};
class DescribeVirtualBorderRoutersRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeVirtualBorderRoutersRequestFilter>> filter{};

  DescribeVirtualBorderRoutersRequest() {}

  explicit DescribeVirtualBorderRoutersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<DescribeVirtualBorderRoutersRequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVirtualBorderRoutersRequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<DescribeVirtualBorderRoutersRequestFilter>>(expect1);
      }
    }
  }


  virtual ~DescribeVirtualBorderRoutersRequest() = default;
};
class DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType : public Darabonba::Model {
public:
  shared_ptr<string> vlanInterfaceId{};
  shared_ptr<string> status{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> circuitCode{};
  shared_ptr<string> physicalConnectionOwnerUid{};
  shared_ptr<string> localGatewayIp{};
  shared_ptr<string> activationTime{};
  shared_ptr<string> physicalConnectionBusinessStatus{};
  shared_ptr<string> peeringSubnetMask{};
  shared_ptr<string> routeTableId{};
  shared_ptr<string> description{};
  shared_ptr<string> physicalConnectionStatus{};
  shared_ptr<string> recoveryTime{};
  shared_ptr<string> terminationTime{};
  shared_ptr<string> peerGatewayIp{};
  shared_ptr<string> name{};
  shared_ptr<string> accessPointId{};
  shared_ptr<string> vbrId{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<long> vlanId{};

  DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType() {}

  explicit DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vlanInterfaceId) {
      res["VlanInterfaceId"] = boost::any(*vlanInterfaceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (circuitCode) {
      res["CircuitCode"] = boost::any(*circuitCode);
    }
    if (physicalConnectionOwnerUid) {
      res["PhysicalConnectionOwnerUid"] = boost::any(*physicalConnectionOwnerUid);
    }
    if (localGatewayIp) {
      res["LocalGatewayIp"] = boost::any(*localGatewayIp);
    }
    if (activationTime) {
      res["ActivationTime"] = boost::any(*activationTime);
    }
    if (physicalConnectionBusinessStatus) {
      res["PhysicalConnectionBusinessStatus"] = boost::any(*physicalConnectionBusinessStatus);
    }
    if (peeringSubnetMask) {
      res["PeeringSubnetMask"] = boost::any(*peeringSubnetMask);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (physicalConnectionStatus) {
      res["PhysicalConnectionStatus"] = boost::any(*physicalConnectionStatus);
    }
    if (recoveryTime) {
      res["RecoveryTime"] = boost::any(*recoveryTime);
    }
    if (terminationTime) {
      res["TerminationTime"] = boost::any(*terminationTime);
    }
    if (peerGatewayIp) {
      res["PeerGatewayIp"] = boost::any(*peerGatewayIp);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (accessPointId) {
      res["AccessPointId"] = boost::any(*accessPointId);
    }
    if (vbrId) {
      res["VbrId"] = boost::any(*vbrId);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (vlanId) {
      res["VlanId"] = boost::any(*vlanId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VlanInterfaceId") != m.end() && !m["VlanInterfaceId"].empty()) {
      vlanInterfaceId = make_shared<string>(boost::any_cast<string>(m["VlanInterfaceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("CircuitCode") != m.end() && !m["CircuitCode"].empty()) {
      circuitCode = make_shared<string>(boost::any_cast<string>(m["CircuitCode"]));
    }
    if (m.find("PhysicalConnectionOwnerUid") != m.end() && !m["PhysicalConnectionOwnerUid"].empty()) {
      physicalConnectionOwnerUid = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionOwnerUid"]));
    }
    if (m.find("LocalGatewayIp") != m.end() && !m["LocalGatewayIp"].empty()) {
      localGatewayIp = make_shared<string>(boost::any_cast<string>(m["LocalGatewayIp"]));
    }
    if (m.find("ActivationTime") != m.end() && !m["ActivationTime"].empty()) {
      activationTime = make_shared<string>(boost::any_cast<string>(m["ActivationTime"]));
    }
    if (m.find("PhysicalConnectionBusinessStatus") != m.end() && !m["PhysicalConnectionBusinessStatus"].empty()) {
      physicalConnectionBusinessStatus = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionBusinessStatus"]));
    }
    if (m.find("PeeringSubnetMask") != m.end() && !m["PeeringSubnetMask"].empty()) {
      peeringSubnetMask = make_shared<string>(boost::any_cast<string>(m["PeeringSubnetMask"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("PhysicalConnectionStatus") != m.end() && !m["PhysicalConnectionStatus"].empty()) {
      physicalConnectionStatus = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionStatus"]));
    }
    if (m.find("RecoveryTime") != m.end() && !m["RecoveryTime"].empty()) {
      recoveryTime = make_shared<string>(boost::any_cast<string>(m["RecoveryTime"]));
    }
    if (m.find("TerminationTime") != m.end() && !m["TerminationTime"].empty()) {
      terminationTime = make_shared<string>(boost::any_cast<string>(m["TerminationTime"]));
    }
    if (m.find("PeerGatewayIp") != m.end() && !m["PeerGatewayIp"].empty()) {
      peerGatewayIp = make_shared<string>(boost::any_cast<string>(m["PeerGatewayIp"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("AccessPointId") != m.end() && !m["AccessPointId"].empty()) {
      accessPointId = make_shared<string>(boost::any_cast<string>(m["AccessPointId"]));
    }
    if (m.find("VbrId") != m.end() && !m["VbrId"].empty()) {
      vbrId = make_shared<string>(boost::any_cast<string>(m["VbrId"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("VlanId") != m.end() && !m["VlanId"].empty()) {
      vlanId = make_shared<long>(boost::any_cast<long>(m["VlanId"]));
    }
  }


  virtual ~DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType() = default;
};
class DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType>> virtualBorderRouterType{};

  DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet() {}

  explicit DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (virtualBorderRouterType) {
      vector<boost::any> temp1;
      for(auto item1:*virtualBorderRouterType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VirtualBorderRouterType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VirtualBorderRouterType") != m.end() && !m["VirtualBorderRouterType"].empty()) {
      if (typeid(vector<boost::any>) == m["VirtualBorderRouterType"].type()) {
        vector<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VirtualBorderRouterType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        virtualBorderRouterType = make_shared<vector<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType>>(expect1);
      }
    }
  }


  virtual ~DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet() = default;
};
class DescribeVirtualBorderRoutersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet> virtualBorderRouterSet{};

  DescribeVirtualBorderRoutersResponseBody() {}

  explicit DescribeVirtualBorderRoutersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (virtualBorderRouterSet) {
      res["VirtualBorderRouterSet"] = virtualBorderRouterSet ? boost::any(virtualBorderRouterSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VirtualBorderRouterSet") != m.end() && !m["VirtualBorderRouterSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["VirtualBorderRouterSet"].type()) {
        DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VirtualBorderRouterSet"]));
        virtualBorderRouterSet = make_shared<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet>(model1);
      }
    }
  }


  virtual ~DescribeVirtualBorderRoutersResponseBody() = default;
};
class DescribeVirtualBorderRoutersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeVirtualBorderRoutersResponseBody> body{};

  DescribeVirtualBorderRoutersResponse() {}

  explicit DescribeVirtualBorderRoutersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVirtualBorderRoutersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVirtualBorderRoutersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVirtualBorderRoutersResponse() = default;
};
class DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<string>> value{};

  DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter() {}

  explicit DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Value"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      value = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter() = default;
};
class DescribeVirtualBorderRoutersForPhysicalConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter>> filter{};

  DescribeVirtualBorderRoutersForPhysicalConnectionRequest() {}

  explicit DescribeVirtualBorderRoutersForPhysicalConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter>>(expect1);
      }
    }
  }


  virtual ~DescribeVirtualBorderRoutersForPhysicalConnectionRequest() = default;
};
class DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> circuitCode{};
  shared_ptr<string> recoveryTime{};
  shared_ptr<string> terminationTime{};
  shared_ptr<string> activationTime{};
  shared_ptr<long> vbrOwnerUid{};
  shared_ptr<string> vbrId{};
  shared_ptr<long> vlanId{};

  DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType() {}

  explicit DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (circuitCode) {
      res["CircuitCode"] = boost::any(*circuitCode);
    }
    if (recoveryTime) {
      res["RecoveryTime"] = boost::any(*recoveryTime);
    }
    if (terminationTime) {
      res["TerminationTime"] = boost::any(*terminationTime);
    }
    if (activationTime) {
      res["ActivationTime"] = boost::any(*activationTime);
    }
    if (vbrOwnerUid) {
      res["VbrOwnerUid"] = boost::any(*vbrOwnerUid);
    }
    if (vbrId) {
      res["VbrId"] = boost::any(*vbrId);
    }
    if (vlanId) {
      res["VlanId"] = boost::any(*vlanId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("CircuitCode") != m.end() && !m["CircuitCode"].empty()) {
      circuitCode = make_shared<string>(boost::any_cast<string>(m["CircuitCode"]));
    }
    if (m.find("RecoveryTime") != m.end() && !m["RecoveryTime"].empty()) {
      recoveryTime = make_shared<string>(boost::any_cast<string>(m["RecoveryTime"]));
    }
    if (m.find("TerminationTime") != m.end() && !m["TerminationTime"].empty()) {
      terminationTime = make_shared<string>(boost::any_cast<string>(m["TerminationTime"]));
    }
    if (m.find("ActivationTime") != m.end() && !m["ActivationTime"].empty()) {
      activationTime = make_shared<string>(boost::any_cast<string>(m["ActivationTime"]));
    }
    if (m.find("VbrOwnerUid") != m.end() && !m["VbrOwnerUid"].empty()) {
      vbrOwnerUid = make_shared<long>(boost::any_cast<long>(m["VbrOwnerUid"]));
    }
    if (m.find("VbrId") != m.end() && !m["VbrId"].empty()) {
      vbrId = make_shared<string>(boost::any_cast<string>(m["VbrId"]));
    }
    if (m.find("VlanId") != m.end() && !m["VlanId"].empty()) {
      vlanId = make_shared<long>(boost::any_cast<long>(m["VlanId"]));
    }
  }


  virtual ~DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType() = default;
};
class DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType>> virtualBorderRouterForPhysicalConnectionType{};

  DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet() {}

  explicit DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (virtualBorderRouterForPhysicalConnectionType) {
      vector<boost::any> temp1;
      for(auto item1:*virtualBorderRouterForPhysicalConnectionType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VirtualBorderRouterForPhysicalConnectionType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VirtualBorderRouterForPhysicalConnectionType") != m.end() && !m["VirtualBorderRouterForPhysicalConnectionType"].empty()) {
      if (typeid(vector<boost::any>) == m["VirtualBorderRouterForPhysicalConnectionType"].type()) {
        vector<DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VirtualBorderRouterForPhysicalConnectionType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        virtualBorderRouterForPhysicalConnectionType = make_shared<vector<DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType>>(expect1);
      }
    }
  }


  virtual ~DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet() = default;
};
class DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet> virtualBorderRouterForPhysicalConnectionSet{};

  DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody() {}

  explicit DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (virtualBorderRouterForPhysicalConnectionSet) {
      res["VirtualBorderRouterForPhysicalConnectionSet"] = virtualBorderRouterForPhysicalConnectionSet ? boost::any(virtualBorderRouterForPhysicalConnectionSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VirtualBorderRouterForPhysicalConnectionSet") != m.end() && !m["VirtualBorderRouterForPhysicalConnectionSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["VirtualBorderRouterForPhysicalConnectionSet"].type()) {
        DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VirtualBorderRouterForPhysicalConnectionSet"]));
        virtualBorderRouterForPhysicalConnectionSet = make_shared<DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet>(model1);
      }
    }
  }


  virtual ~DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody() = default;
};
class DescribeVirtualBorderRoutersForPhysicalConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody> body{};

  DescribeVirtualBorderRoutersForPhysicalConnectionResponse() {}

  explicit DescribeVirtualBorderRoutersForPhysicalConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVirtualBorderRoutersForPhysicalConnectionResponse() = default;
};
class DescribeVpcsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> isDefault{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ownerAccount{};

  DescribeVpcsRequest() {}

  explicit DescribeVpcsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeVpcsRequest() = default;
};
class DescribeVpcsResponseBodyVpcsVpcVSwitchIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> vSwitchId{};

  DescribeVpcsResponseBodyVpcsVpcVSwitchIds() {}

  explicit DescribeVpcsResponseBodyVpcsVpcVSwitchIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVpcsResponseBodyVpcsVpcVSwitchIds() = default;
};
class DescribeVpcsResponseBodyVpcsVpcUserCidrs : public Darabonba::Model {
public:
  shared_ptr<vector<string>> userCidr{};

  DescribeVpcsResponseBodyVpcsVpcUserCidrs() {}

  explicit DescribeVpcsResponseBodyVpcsVpcUserCidrs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userCidr) {
      res["UserCidr"] = boost::any(*userCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserCidr") != m.end() && !m["UserCidr"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserCidr"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserCidr"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userCidr = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVpcsResponseBodyVpcsVpcUserCidrs() = default;
};
class DescribeVpcsResponseBodyVpcsVpc : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> vpcName{};
  shared_ptr<string> status{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> VRouterId{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> description{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeVpcsResponseBodyVpcsVpcVSwitchIds> vSwitchIds{};
  shared_ptr<DescribeVpcsResponseBodyVpcsVpcUserCidrs> userCidrs{};

  DescribeVpcsResponseBodyVpcsVpc() {}

  explicit DescribeVpcsResponseBodyVpcsVpc(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (VRouterId) {
      res["VRouterId"] = boost::any(*VRouterId);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = vSwitchIds ? boost::any(vSwitchIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userCidrs) {
      res["UserCidrs"] = userCidrs ? boost::any(userCidrs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VRouterId") != m.end() && !m["VRouterId"].empty()) {
      VRouterId = make_shared<string>(boost::any_cast<string>(m["VRouterId"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["VSwitchIds"].type()) {
        DescribeVpcsResponseBodyVpcsVpcVSwitchIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VSwitchIds"]));
        vSwitchIds = make_shared<DescribeVpcsResponseBodyVpcsVpcVSwitchIds>(model1);
      }
    }
    if (m.find("UserCidrs") != m.end() && !m["UserCidrs"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserCidrs"].type()) {
        DescribeVpcsResponseBodyVpcsVpcUserCidrs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserCidrs"]));
        userCidrs = make_shared<DescribeVpcsResponseBodyVpcsVpcUserCidrs>(model1);
      }
    }
  }


  virtual ~DescribeVpcsResponseBodyVpcsVpc() = default;
};
class DescribeVpcsResponseBodyVpcs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpcsResponseBodyVpcsVpc>> vpc{};

  DescribeVpcsResponseBodyVpcs() {}

  explicit DescribeVpcsResponseBodyVpcs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpc) {
      vector<boost::any> temp1;
      for(auto item1:*vpc){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Vpc"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Vpc") != m.end() && !m["Vpc"].empty()) {
      if (typeid(vector<boost::any>) == m["Vpc"].type()) {
        vector<DescribeVpcsResponseBodyVpcsVpc> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Vpc"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpcsResponseBodyVpcsVpc model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vpc = make_shared<vector<DescribeVpcsResponseBodyVpcsVpc>>(expect1);
      }
    }
  }


  virtual ~DescribeVpcsResponseBodyVpcs() = default;
};
class DescribeVpcsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeVpcsResponseBodyVpcs> vpcs{};

  DescribeVpcsResponseBody() {}

  explicit DescribeVpcsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vpcs) {
      res["Vpcs"] = vpcs ? boost::any(vpcs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Vpcs") != m.end() && !m["Vpcs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Vpcs"].type()) {
        DescribeVpcsResponseBodyVpcs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Vpcs"]));
        vpcs = make_shared<DescribeVpcsResponseBodyVpcs>(model1);
      }
    }
  }


  virtual ~DescribeVpcsResponseBody() = default;
};
class DescribeVpcsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeVpcsResponseBody> body{};

  DescribeVpcsResponse() {}

  explicit DescribeVpcsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVpcsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVpcsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVpcsResponse() = default;
};
class DescribeVRoutersRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> VRouterId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ownerAccount{};

  DescribeVRoutersRequest() {}

  explicit DescribeVRoutersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (VRouterId) {
      res["VRouterId"] = boost::any(*VRouterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VRouterId") != m.end() && !m["VRouterId"].empty()) {
      VRouterId = make_shared<string>(boost::any_cast<string>(m["VRouterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeVRoutersRequest() = default;
};
class DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> routeTableId{};

  DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds() {}

  explicit DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RouteTableId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RouteTableId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      routeTableId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds() = default;
};
class DescribeVRoutersResponseBodyVRoutersVRouter : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> VRouterId{};
  shared_ptr<string> description{};
  shared_ptr<string> VRouterName{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds> routeTableIds{};

  DescribeVRoutersResponseBodyVRoutersVRouter() {}

  explicit DescribeVRoutersResponseBodyVRoutersVRouter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (VRouterId) {
      res["VRouterId"] = boost::any(*VRouterId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (VRouterName) {
      res["VRouterName"] = boost::any(*VRouterName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (routeTableIds) {
      res["RouteTableIds"] = routeTableIds ? boost::any(routeTableIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("VRouterId") != m.end() && !m["VRouterId"].empty()) {
      VRouterId = make_shared<string>(boost::any_cast<string>(m["VRouterId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("VRouterName") != m.end() && !m["VRouterName"].empty()) {
      VRouterName = make_shared<string>(boost::any_cast<string>(m["VRouterName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RouteTableIds") != m.end() && !m["RouteTableIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["RouteTableIds"].type()) {
        DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RouteTableIds"]));
        routeTableIds = make_shared<DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds>(model1);
      }
    }
  }


  virtual ~DescribeVRoutersResponseBodyVRoutersVRouter() = default;
};
class DescribeVRoutersResponseBodyVRouters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVRoutersResponseBodyVRoutersVRouter>> VRouter{};

  DescribeVRoutersResponseBodyVRouters() {}

  explicit DescribeVRoutersResponseBodyVRouters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (VRouter) {
      vector<boost::any> temp1;
      for(auto item1:*VRouter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VRouter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VRouter") != m.end() && !m["VRouter"].empty()) {
      if (typeid(vector<boost::any>) == m["VRouter"].type()) {
        vector<DescribeVRoutersResponseBodyVRoutersVRouter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VRouter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVRoutersResponseBodyVRoutersVRouter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        VRouter = make_shared<vector<DescribeVRoutersResponseBodyVRoutersVRouter>>(expect1);
      }
    }
  }


  virtual ~DescribeVRoutersResponseBodyVRouters() = default;
};
class DescribeVRoutersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeVRoutersResponseBodyVRouters> VRouters{};

  DescribeVRoutersResponseBody() {}

  explicit DescribeVRoutersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (VRouters) {
      res["VRouters"] = VRouters ? boost::any(VRouters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VRouters") != m.end() && !m["VRouters"].empty()) {
      if (typeid(map<string, boost::any>) == m["VRouters"].type()) {
        DescribeVRoutersResponseBodyVRouters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VRouters"]));
        VRouters = make_shared<DescribeVRoutersResponseBodyVRouters>(model1);
      }
    }
  }


  virtual ~DescribeVRoutersResponseBody() = default;
};
class DescribeVRoutersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeVRoutersResponseBody> body{};

  DescribeVRoutersResponse() {}

  explicit DescribeVRoutersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVRoutersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVRoutersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVRoutersResponse() = default;
};
class DescribeVSwitchesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> isDefault{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ownerAccount{};

  DescribeVSwitchesRequest() {}

  explicit DescribeVSwitchesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeVSwitchesRequest() = default;
};
class DescribeVSwitchesResponseBodyVSwitchesVSwitch : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> status{};
  shared_ptr<string> vpcId{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> description{};
  shared_ptr<long> availableIpAddressCount{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> vSwitchName{};

  DescribeVSwitchesResponseBodyVSwitchesVSwitch() {}

  explicit DescribeVSwitchesResponseBodyVSwitchesVSwitch(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (availableIpAddressCount) {
      res["AvailableIpAddressCount"] = boost::any(*availableIpAddressCount);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (vSwitchName) {
      res["VSwitchName"] = boost::any(*vSwitchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("AvailableIpAddressCount") != m.end() && !m["AvailableIpAddressCount"].empty()) {
      availableIpAddressCount = make_shared<long>(boost::any_cast<long>(m["AvailableIpAddressCount"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("VSwitchName") != m.end() && !m["VSwitchName"].empty()) {
      vSwitchName = make_shared<string>(boost::any_cast<string>(m["VSwitchName"]));
    }
  }


  virtual ~DescribeVSwitchesResponseBodyVSwitchesVSwitch() = default;
};
class DescribeVSwitchesResponseBodyVSwitches : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVSwitchesResponseBodyVSwitchesVSwitch>> vSwitch{};

  DescribeVSwitchesResponseBodyVSwitches() {}

  explicit DescribeVSwitchesResponseBodyVSwitches(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vSwitch) {
      vector<boost::any> temp1;
      for(auto item1:*vSwitch){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VSwitch"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VSwitch") != m.end() && !m["VSwitch"].empty()) {
      if (typeid(vector<boost::any>) == m["VSwitch"].type()) {
        vector<DescribeVSwitchesResponseBodyVSwitchesVSwitch> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VSwitch"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVSwitchesResponseBodyVSwitchesVSwitch model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vSwitch = make_shared<vector<DescribeVSwitchesResponseBodyVSwitchesVSwitch>>(expect1);
      }
    }
  }


  virtual ~DescribeVSwitchesResponseBodyVSwitches() = default;
};
class DescribeVSwitchesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeVSwitchesResponseBodyVSwitches> vSwitches{};

  DescribeVSwitchesResponseBody() {}

  explicit DescribeVSwitchesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vSwitches) {
      res["VSwitches"] = vSwitches ? boost::any(vSwitches->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VSwitches") != m.end() && !m["VSwitches"].empty()) {
      if (typeid(map<string, boost::any>) == m["VSwitches"].type()) {
        DescribeVSwitchesResponseBodyVSwitches model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VSwitches"]));
        vSwitches = make_shared<DescribeVSwitchesResponseBodyVSwitches>(model1);
      }
    }
  }


  virtual ~DescribeVSwitchesResponseBody() = default;
};
class DescribeVSwitchesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeVSwitchesResponseBody> body{};

  DescribeVSwitchesResponse() {}

  explicit DescribeVSwitchesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVSwitchesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVSwitchesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVSwitchesResponse() = default;
};
class DescribeZonesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<bool> verbose{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<string> acceptLanguage{};

  DescribeZonesRequest() {}

  explicit DescribeZonesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (verbose) {
      res["Verbose"] = boost::any(*verbose);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("Verbose") != m.end() && !m["Verbose"].empty()) {
      verbose = make_shared<bool>(boost::any_cast<bool>(m["Verbose"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
  }


  virtual ~DescribeZonesRequest() = default;
};
class DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoSystemDiskCategories : public Darabonba::Model {
public:
  shared_ptr<vector<string>> supportedSystemDiskCategory{};

  DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoSystemDiskCategories() {}

  explicit DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoSystemDiskCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportedSystemDiskCategory) {
      res["supportedSystemDiskCategory"] = boost::any(*supportedSystemDiskCategory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("supportedSystemDiskCategory") != m.end() && !m["supportedSystemDiskCategory"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["supportedSystemDiskCategory"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["supportedSystemDiskCategory"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportedSystemDiskCategory = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoSystemDiskCategories() = default;
};
class DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceGenerations : public Darabonba::Model {
public:
  shared_ptr<vector<string>> supportedInstanceGeneration{};

  DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceGenerations() {}

  explicit DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceGenerations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportedInstanceGeneration) {
      res["supportedInstanceGeneration"] = boost::any(*supportedInstanceGeneration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("supportedInstanceGeneration") != m.end() && !m["supportedInstanceGeneration"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["supportedInstanceGeneration"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["supportedInstanceGeneration"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportedInstanceGeneration = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceGenerations() = default;
};
class DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoDataDiskCategories : public Darabonba::Model {
public:
  shared_ptr<vector<string>> supportedDataDiskCategory{};

  DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoDataDiskCategories() {}

  explicit DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoDataDiskCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportedDataDiskCategory) {
      res["supportedDataDiskCategory"] = boost::any(*supportedDataDiskCategory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("supportedDataDiskCategory") != m.end() && !m["supportedDataDiskCategory"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["supportedDataDiskCategory"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["supportedDataDiskCategory"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportedDataDiskCategory = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoDataDiskCategories() = default;
};
class DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceTypes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> supportedInstanceType{};

  DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceTypes() {}

  explicit DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportedInstanceType) {
      res["supportedInstanceType"] = boost::any(*supportedInstanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("supportedInstanceType") != m.end() && !m["supportedInstanceType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["supportedInstanceType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["supportedInstanceType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportedInstanceType = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceTypes() = default;
};
class DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceTypeFamilies : public Darabonba::Model {
public:
  shared_ptr<vector<string>> supportedInstanceTypeFamily{};

  DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceTypeFamilies() {}

  explicit DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceTypeFamilies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportedInstanceTypeFamily) {
      res["supportedInstanceTypeFamily"] = boost::any(*supportedInstanceTypeFamily);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("supportedInstanceTypeFamily") != m.end() && !m["supportedInstanceTypeFamily"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["supportedInstanceTypeFamily"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["supportedInstanceTypeFamily"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportedInstanceTypeFamily = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceTypeFamilies() = default;
};
class DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoNetworkTypes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> supportedNetworkCategory{};

  DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoNetworkTypes() {}

  explicit DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoNetworkTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportedNetworkCategory) {
      res["supportedNetworkCategory"] = boost::any(*supportedNetworkCategory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("supportedNetworkCategory") != m.end() && !m["supportedNetworkCategory"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["supportedNetworkCategory"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["supportedNetworkCategory"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportedNetworkCategory = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoNetworkTypes() = default;
};
class DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfo : public Darabonba::Model {
public:
  shared_ptr<bool> ioOptimized{};
  shared_ptr<DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoSystemDiskCategories> systemDiskCategories{};
  shared_ptr<DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceGenerations> instanceGenerations{};
  shared_ptr<DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoDataDiskCategories> dataDiskCategories{};
  shared_ptr<DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceTypes> instanceTypes{};
  shared_ptr<DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceTypeFamilies> instanceTypeFamilies{};
  shared_ptr<DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoNetworkTypes> networkTypes{};

  DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfo() {}

  explicit DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (systemDiskCategories) {
      res["SystemDiskCategories"] = systemDiskCategories ? boost::any(systemDiskCategories->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceGenerations) {
      res["InstanceGenerations"] = instanceGenerations ? boost::any(instanceGenerations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataDiskCategories) {
      res["DataDiskCategories"] = dataDiskCategories ? boost::any(dataDiskCategories->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceTypes) {
      res["InstanceTypes"] = instanceTypes ? boost::any(instanceTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceTypeFamilies) {
      res["InstanceTypeFamilies"] = instanceTypeFamilies ? boost::any(instanceTypeFamilies->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkTypes) {
      res["NetworkTypes"] = networkTypes ? boost::any(networkTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<bool>(boost::any_cast<bool>(m["IoOptimized"]));
    }
    if (m.find("SystemDiskCategories") != m.end() && !m["SystemDiskCategories"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDiskCategories"].type()) {
        DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoSystemDiskCategories model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDiskCategories"]));
        systemDiskCategories = make_shared<DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoSystemDiskCategories>(model1);
      }
    }
    if (m.find("InstanceGenerations") != m.end() && !m["InstanceGenerations"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceGenerations"].type()) {
        DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceGenerations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceGenerations"]));
        instanceGenerations = make_shared<DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceGenerations>(model1);
      }
    }
    if (m.find("DataDiskCategories") != m.end() && !m["DataDiskCategories"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataDiskCategories"].type()) {
        DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoDataDiskCategories model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataDiskCategories"]));
        dataDiskCategories = make_shared<DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoDataDiskCategories>(model1);
      }
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTypes"].type()) {
        DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTypes"]));
        instanceTypes = make_shared<DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceTypes>(model1);
      }
    }
    if (m.find("InstanceTypeFamilies") != m.end() && !m["InstanceTypeFamilies"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTypeFamilies"].type()) {
        DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceTypeFamilies model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTypeFamilies"]));
        instanceTypeFamilies = make_shared<DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceTypeFamilies>(model1);
      }
    }
    if (m.find("NetworkTypes") != m.end() && !m["NetworkTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkTypes"].type()) {
        DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoNetworkTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkTypes"]));
        networkTypes = make_shared<DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoNetworkTypes>(model1);
      }
    }
  }


  virtual ~DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfo() = default;
};
class DescribeZonesResponseBodyZonesZoneAvailableResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfo>> resourcesInfo{};

  DescribeZonesResponseBodyZonesZoneAvailableResources() {}

  explicit DescribeZonesResponseBodyZonesZoneAvailableResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourcesInfo) {
      vector<boost::any> temp1;
      for(auto item1:*resourcesInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourcesInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourcesInfo") != m.end() && !m["ResourcesInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourcesInfo"].type()) {
        vector<DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourcesInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourcesInfo = make_shared<vector<DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeZonesResponseBodyZonesZoneAvailableResources() = default;
};
class DescribeZonesResponseBodyZonesZoneAvailableResourceCreation : public Darabonba::Model {
public:
  shared_ptr<vector<string>> resourceTypes{};

  DescribeZonesResponseBodyZonesZoneAvailableResourceCreation() {}

  explicit DescribeZonesResponseBodyZonesZoneAvailableResourceCreation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceTypes) {
      res["ResourceTypes"] = boost::any(*resourceTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceTypes") != m.end() && !m["ResourceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeZonesResponseBodyZonesZoneAvailableResourceCreation() = default;
};
class DescribeZonesResponseBodyZonesZoneDedicatedHostGenerations : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dedicatedHostGeneration{};

  DescribeZonesResponseBodyZonesZoneDedicatedHostGenerations() {}

  explicit DescribeZonesResponseBodyZonesZoneDedicatedHostGenerations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostGeneration) {
      res["DedicatedHostGeneration"] = boost::any(*dedicatedHostGeneration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostGeneration") != m.end() && !m["DedicatedHostGeneration"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DedicatedHostGeneration"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DedicatedHostGeneration"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dedicatedHostGeneration = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeZonesResponseBodyZonesZoneDedicatedHostGenerations() = default;
};
class DescribeZonesResponseBodyZonesZoneAvailableInstanceTypes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceTypes{};

  DescribeZonesResponseBodyZonesZoneAvailableInstanceTypes() {}

  explicit DescribeZonesResponseBodyZonesZoneAvailableInstanceTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceTypes) {
      res["InstanceTypes"] = boost::any(*instanceTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeZonesResponseBodyZonesZoneAvailableInstanceTypes() = default;
};
class DescribeZonesResponseBodyZonesZoneAvailableDiskCategories : public Darabonba::Model {
public:
  shared_ptr<vector<string>> diskCategories{};

  DescribeZonesResponseBodyZonesZoneAvailableDiskCategories() {}

  explicit DescribeZonesResponseBodyZonesZoneAvailableDiskCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskCategories) {
      res["DiskCategories"] = boost::any(*diskCategories);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskCategories") != m.end() && !m["DiskCategories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DiskCategories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DiskCategories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      diskCategories = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeZonesResponseBodyZonesZoneAvailableDiskCategories() = default;
};
class DescribeZonesResponseBodyZonesZoneAvailableDedicatedHostTypes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dedicatedHostType{};

  DescribeZonesResponseBodyZonesZoneAvailableDedicatedHostTypes() {}

  explicit DescribeZonesResponseBodyZonesZoneAvailableDedicatedHostTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostType) {
      res["DedicatedHostType"] = boost::any(*dedicatedHostType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostType") != m.end() && !m["DedicatedHostType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DedicatedHostType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DedicatedHostType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dedicatedHostType = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeZonesResponseBodyZonesZoneAvailableDedicatedHostTypes() = default;
};
class DescribeZonesResponseBodyZonesZoneAvailableVolumeCategories : public Darabonba::Model {
public:
  shared_ptr<vector<string>> volumeCategories{};

  DescribeZonesResponseBodyZonesZoneAvailableVolumeCategories() {}

  explicit DescribeZonesResponseBodyZonesZoneAvailableVolumeCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (volumeCategories) {
      res["VolumeCategories"] = boost::any(*volumeCategories);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VolumeCategories") != m.end() && !m["VolumeCategories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VolumeCategories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VolumeCategories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      volumeCategories = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeZonesResponseBodyZonesZoneAvailableVolumeCategories() = default;
};
class DescribeZonesResponseBodyZonesZone : public Darabonba::Model {
public:
  shared_ptr<string> zoneId{};
  shared_ptr<string> localName{};
  shared_ptr<DescribeZonesResponseBodyZonesZoneAvailableResources> availableResources{};
  shared_ptr<DescribeZonesResponseBodyZonesZoneAvailableResourceCreation> availableResourceCreation{};
  shared_ptr<DescribeZonesResponseBodyZonesZoneDedicatedHostGenerations> dedicatedHostGenerations{};
  shared_ptr<DescribeZonesResponseBodyZonesZoneAvailableInstanceTypes> availableInstanceTypes{};
  shared_ptr<DescribeZonesResponseBodyZonesZoneAvailableDiskCategories> availableDiskCategories{};
  shared_ptr<DescribeZonesResponseBodyZonesZoneAvailableDedicatedHostTypes> availableDedicatedHostTypes{};
  shared_ptr<DescribeZonesResponseBodyZonesZoneAvailableVolumeCategories> availableVolumeCategories{};

  DescribeZonesResponseBodyZonesZone() {}

  explicit DescribeZonesResponseBodyZonesZone(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (availableResources) {
      res["AvailableResources"] = availableResources ? boost::any(availableResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (availableResourceCreation) {
      res["AvailableResourceCreation"] = availableResourceCreation ? boost::any(availableResourceCreation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dedicatedHostGenerations) {
      res["DedicatedHostGenerations"] = dedicatedHostGenerations ? boost::any(dedicatedHostGenerations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (availableInstanceTypes) {
      res["AvailableInstanceTypes"] = availableInstanceTypes ? boost::any(availableInstanceTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (availableDiskCategories) {
      res["AvailableDiskCategories"] = availableDiskCategories ? boost::any(availableDiskCategories->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (availableDedicatedHostTypes) {
      res["AvailableDedicatedHostTypes"] = availableDedicatedHostTypes ? boost::any(availableDedicatedHostTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (availableVolumeCategories) {
      res["AvailableVolumeCategories"] = availableVolumeCategories ? boost::any(availableVolumeCategories->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("AvailableResources") != m.end() && !m["AvailableResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvailableResources"].type()) {
        DescribeZonesResponseBodyZonesZoneAvailableResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvailableResources"]));
        availableResources = make_shared<DescribeZonesResponseBodyZonesZoneAvailableResources>(model1);
      }
    }
    if (m.find("AvailableResourceCreation") != m.end() && !m["AvailableResourceCreation"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvailableResourceCreation"].type()) {
        DescribeZonesResponseBodyZonesZoneAvailableResourceCreation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvailableResourceCreation"]));
        availableResourceCreation = make_shared<DescribeZonesResponseBodyZonesZoneAvailableResourceCreation>(model1);
      }
    }
    if (m.find("DedicatedHostGenerations") != m.end() && !m["DedicatedHostGenerations"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedHostGenerations"].type()) {
        DescribeZonesResponseBodyZonesZoneDedicatedHostGenerations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedHostGenerations"]));
        dedicatedHostGenerations = make_shared<DescribeZonesResponseBodyZonesZoneDedicatedHostGenerations>(model1);
      }
    }
    if (m.find("AvailableInstanceTypes") != m.end() && !m["AvailableInstanceTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvailableInstanceTypes"].type()) {
        DescribeZonesResponseBodyZonesZoneAvailableInstanceTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvailableInstanceTypes"]));
        availableInstanceTypes = make_shared<DescribeZonesResponseBodyZonesZoneAvailableInstanceTypes>(model1);
      }
    }
    if (m.find("AvailableDiskCategories") != m.end() && !m["AvailableDiskCategories"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvailableDiskCategories"].type()) {
        DescribeZonesResponseBodyZonesZoneAvailableDiskCategories model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvailableDiskCategories"]));
        availableDiskCategories = make_shared<DescribeZonesResponseBodyZonesZoneAvailableDiskCategories>(model1);
      }
    }
    if (m.find("AvailableDedicatedHostTypes") != m.end() && !m["AvailableDedicatedHostTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvailableDedicatedHostTypes"].type()) {
        DescribeZonesResponseBodyZonesZoneAvailableDedicatedHostTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvailableDedicatedHostTypes"]));
        availableDedicatedHostTypes = make_shared<DescribeZonesResponseBodyZonesZoneAvailableDedicatedHostTypes>(model1);
      }
    }
    if (m.find("AvailableVolumeCategories") != m.end() && !m["AvailableVolumeCategories"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvailableVolumeCategories"].type()) {
        DescribeZonesResponseBodyZonesZoneAvailableVolumeCategories model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvailableVolumeCategories"]));
        availableVolumeCategories = make_shared<DescribeZonesResponseBodyZonesZoneAvailableVolumeCategories>(model1);
      }
    }
  }


  virtual ~DescribeZonesResponseBodyZonesZone() = default;
};
class DescribeZonesResponseBodyZones : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeZonesResponseBodyZonesZone>> zone{};

  DescribeZonesResponseBodyZones() {}

  explicit DescribeZonesResponseBodyZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (zone) {
      vector<boost::any> temp1;
      for(auto item1:*zone){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Zone"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Zone") != m.end() && !m["Zone"].empty()) {
      if (typeid(vector<boost::any>) == m["Zone"].type()) {
        vector<DescribeZonesResponseBodyZonesZone> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Zone"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeZonesResponseBodyZonesZone model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        zone = make_shared<vector<DescribeZonesResponseBodyZonesZone>>(expect1);
      }
    }
  }


  virtual ~DescribeZonesResponseBodyZones() = default;
};
class DescribeZonesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeZonesResponseBodyZones> zones{};

  DescribeZonesResponseBody() {}

  explicit DescribeZonesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (zones) {
      res["Zones"] = zones ? boost::any(zones->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Zones") != m.end() && !m["Zones"].empty()) {
      if (typeid(map<string, boost::any>) == m["Zones"].type()) {
        DescribeZonesResponseBodyZones model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Zones"]));
        zones = make_shared<DescribeZonesResponseBodyZones>(model1);
      }
    }
  }


  virtual ~DescribeZonesResponseBody() = default;
};
class DescribeZonesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeZonesResponseBody> body{};

  DescribeZonesResponse() {}

  explicit DescribeZonesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeZonesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeZonesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeZonesResponse() = default;
};
class DetachClassicLinkVpcRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> vpcId{};

  DetachClassicLinkVpcRequest() {}

  explicit DetachClassicLinkVpcRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DetachClassicLinkVpcRequest() = default;
};
class DetachClassicLinkVpcResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DetachClassicLinkVpcResponseBody() {}

  explicit DetachClassicLinkVpcResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetachClassicLinkVpcResponseBody() = default;
};
class DetachClassicLinkVpcResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DetachClassicLinkVpcResponseBody> body{};

  DetachClassicLinkVpcResponse() {}

  explicit DetachClassicLinkVpcResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachClassicLinkVpcResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachClassicLinkVpcResponseBody>(model1);
      }
    }
  }


  virtual ~DetachClassicLinkVpcResponse() = default;
};
class DetachDiskRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> diskId{};
  shared_ptr<bool> deleteWithInstance{};
  shared_ptr<string> ownerAccount{};

  DetachDiskRequest() {}

  explicit DetachDiskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<bool>(boost::any_cast<bool>(m["DeleteWithInstance"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DetachDiskRequest() = default;
};
class DetachDiskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DetachDiskResponseBody() {}

  explicit DetachDiskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetachDiskResponseBody() = default;
};
class DetachDiskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DetachDiskResponseBody> body{};

  DetachDiskResponse() {}

  explicit DetachDiskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachDiskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachDiskResponseBody>(model1);
      }
    }
  }


  virtual ~DetachDiskResponse() = default;
};
class DetachInstanceRamRoleRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ramRoleName{};
  shared_ptr<string> instanceIds{};

  DetachInstanceRamRoleRequest() {}

  explicit DetachInstanceRamRoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
  }


  virtual ~DetachInstanceRamRoleRequest() = default;
};
class DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResultInstanceRamRoleSetsInstanceRamRoleSet : public Darabonba::Model {
public:
  shared_ptr<string> ramRoleName{};
  shared_ptr<string> instanceId{};

  DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResultInstanceRamRoleSetsInstanceRamRoleSet() {}

  explicit DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResultInstanceRamRoleSetsInstanceRamRoleSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResultInstanceRamRoleSetsInstanceRamRoleSet() = default;
};
class DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResultInstanceRamRoleSets : public Darabonba::Model {
public:
  shared_ptr<vector<DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResultInstanceRamRoleSetsInstanceRamRoleSet>> instanceRamRoleSet{};

  DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResultInstanceRamRoleSets() {}

  explicit DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResultInstanceRamRoleSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceRamRoleSet) {
      vector<boost::any> temp1;
      for(auto item1:*instanceRamRoleSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceRamRoleSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceRamRoleSet") != m.end() && !m["InstanceRamRoleSet"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceRamRoleSet"].type()) {
        vector<DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResultInstanceRamRoleSetsInstanceRamRoleSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceRamRoleSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResultInstanceRamRoleSetsInstanceRamRoleSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceRamRoleSet = make_shared<vector<DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResultInstanceRamRoleSetsInstanceRamRoleSet>>(expect1);
      }
    }
  }


  virtual ~DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResultInstanceRamRoleSets() = default;
};
class DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResult : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> success{};
  shared_ptr<DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResultInstanceRamRoleSets> instanceRamRoleSets{};

  DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResult() {}

  explicit DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (instanceRamRoleSets) {
      res["InstanceRamRoleSets"] = instanceRamRoleSets ? boost::any(instanceRamRoleSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("InstanceRamRoleSets") != m.end() && !m["InstanceRamRoleSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceRamRoleSets"].type()) {
        DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResultInstanceRamRoleSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceRamRoleSets"]));
        instanceRamRoleSets = make_shared<DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResultInstanceRamRoleSets>(model1);
      }
    }
  }


  virtual ~DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResult() = default;
};
class DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResults : public Darabonba::Model {
public:
  shared_ptr<vector<DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResult>> detachInstanceRamRoleResult{};

  DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResults() {}

  explicit DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detachInstanceRamRoleResult) {
      vector<boost::any> temp1;
      for(auto item1:*detachInstanceRamRoleResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DetachInstanceRamRoleResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DetachInstanceRamRoleResult") != m.end() && !m["DetachInstanceRamRoleResult"].empty()) {
      if (typeid(vector<boost::any>) == m["DetachInstanceRamRoleResult"].type()) {
        vector<DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DetachInstanceRamRoleResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        detachInstanceRamRoleResult = make_shared<vector<DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResult>>(expect1);
      }
    }
  }


  virtual ~DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResults() = default;
};
class DetachInstanceRamRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> ramRoleName{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> failCount{};
  shared_ptr<DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResults> detachInstanceRamRoleResults{};

  DetachInstanceRamRoleResponseBody() {}

  explicit DetachInstanceRamRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (failCount) {
      res["FailCount"] = boost::any(*failCount);
    }
    if (detachInstanceRamRoleResults) {
      res["DetachInstanceRamRoleResults"] = detachInstanceRamRoleResults ? boost::any(detachInstanceRamRoleResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("FailCount") != m.end() && !m["FailCount"].empty()) {
      failCount = make_shared<long>(boost::any_cast<long>(m["FailCount"]));
    }
    if (m.find("DetachInstanceRamRoleResults") != m.end() && !m["DetachInstanceRamRoleResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["DetachInstanceRamRoleResults"].type()) {
        DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DetachInstanceRamRoleResults"]));
        detachInstanceRamRoleResults = make_shared<DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResults>(model1);
      }
    }
  }


  virtual ~DetachInstanceRamRoleResponseBody() = default;
};
class DetachInstanceRamRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DetachInstanceRamRoleResponseBody> body{};

  DetachInstanceRamRoleResponse() {}

  explicit DetachInstanceRamRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachInstanceRamRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachInstanceRamRoleResponseBody>(model1);
      }
    }
  }


  virtual ~DetachInstanceRamRoleResponse() = default;
};
class DetachKeyPairRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> instanceIds{};

  DetachKeyPairRequest() {}

  explicit DetachKeyPairRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
  }


  virtual ~DetachKeyPairRequest() = default;
};
class DetachKeyPairResponseBodyResultsResult : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> success{};

  DetachKeyPairResponseBodyResultsResult() {}

  explicit DetachKeyPairResponseBodyResultsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DetachKeyPairResponseBodyResultsResult() = default;
};
class DetachKeyPairResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<vector<DetachKeyPairResponseBodyResultsResult>> result{};

  DetachKeyPairResponseBodyResults() {}

  explicit DetachKeyPairResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DetachKeyPairResponseBodyResultsResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachKeyPairResponseBodyResultsResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DetachKeyPairResponseBodyResultsResult>>(expect1);
      }
    }
  }


  virtual ~DetachKeyPairResponseBodyResults() = default;
};
class DetachKeyPairResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> keyPairName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> totalCount{};
  shared_ptr<string> failCount{};
  shared_ptr<DetachKeyPairResponseBodyResults> results{};

  DetachKeyPairResponseBody() {}

  explicit DetachKeyPairResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (failCount) {
      res["FailCount"] = boost::any(*failCount);
    }
    if (results) {
      res["Results"] = results ? boost::any(results->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
    if (m.find("FailCount") != m.end() && !m["FailCount"].empty()) {
      failCount = make_shared<string>(boost::any_cast<string>(m["FailCount"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(map<string, boost::any>) == m["Results"].type()) {
        DetachKeyPairResponseBodyResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Results"]));
        results = make_shared<DetachKeyPairResponseBodyResults>(model1);
      }
    }
  }


  virtual ~DetachKeyPairResponseBody() = default;
};
class DetachKeyPairResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DetachKeyPairResponseBody> body{};

  DetachKeyPairResponse() {}

  explicit DetachKeyPairResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachKeyPairResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachKeyPairResponseBody>(model1);
      }
    }
  }


  virtual ~DetachKeyPairResponse() = default;
};
class DetachNetworkInterfaceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> trunkNetworkInstanceId{};

  DetachNetworkInterfaceRequest() {}

  explicit DetachNetworkInterfaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (trunkNetworkInstanceId) {
      res["TrunkNetworkInstanceId"] = boost::any(*trunkNetworkInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TrunkNetworkInstanceId") != m.end() && !m["TrunkNetworkInstanceId"].empty()) {
      trunkNetworkInstanceId = make_shared<string>(boost::any_cast<string>(m["TrunkNetworkInstanceId"]));
    }
  }


  virtual ~DetachNetworkInterfaceRequest() = default;
};
class DetachNetworkInterfaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DetachNetworkInterfaceResponseBody() {}

  explicit DetachNetworkInterfaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetachNetworkInterfaceResponseBody() = default;
};
class DetachNetworkInterfaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DetachNetworkInterfaceResponseBody> body{};

  DetachNetworkInterfaceResponse() {}

  explicit DetachNetworkInterfaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachNetworkInterfaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachNetworkInterfaceResponseBody>(model1);
      }
    }
  }


  virtual ~DetachNetworkInterfaceResponse() = default;
};
class DisableActivationRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> activationId{};

  DisableActivationRequest() {}

  explicit DisableActivationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (activationId) {
      res["ActivationId"] = boost::any(*activationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ActivationId") != m.end() && !m["ActivationId"].empty()) {
      activationId = make_shared<string>(boost::any_cast<string>(m["ActivationId"]));
    }
  }


  virtual ~DisableActivationRequest() = default;
};
class DisableActivationResponseBodyActivation : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<long> deregisteredCount{};
  shared_ptr<long> instanceCount{};
  shared_ptr<string> description{};
  shared_ptr<long> registeredCount{};
  shared_ptr<string> instanceName{};
  shared_ptr<bool> disabled{};
  shared_ptr<string> ipAddressRange{};
  shared_ptr<long> timeToLiveInHours{};
  shared_ptr<string> activationId{};

  DisableActivationResponseBodyActivation() {}

  explicit DisableActivationResponseBodyActivation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (deregisteredCount) {
      res["DeregisteredCount"] = boost::any(*deregisteredCount);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (registeredCount) {
      res["RegisteredCount"] = boost::any(*registeredCount);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (disabled) {
      res["Disabled"] = boost::any(*disabled);
    }
    if (ipAddressRange) {
      res["IpAddressRange"] = boost::any(*ipAddressRange);
    }
    if (timeToLiveInHours) {
      res["TimeToLiveInHours"] = boost::any(*timeToLiveInHours);
    }
    if (activationId) {
      res["ActivationId"] = boost::any(*activationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DeregisteredCount") != m.end() && !m["DeregisteredCount"].empty()) {
      deregisteredCount = make_shared<long>(boost::any_cast<long>(m["DeregisteredCount"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RegisteredCount") != m.end() && !m["RegisteredCount"].empty()) {
      registeredCount = make_shared<long>(boost::any_cast<long>(m["RegisteredCount"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Disabled") != m.end() && !m["Disabled"].empty()) {
      disabled = make_shared<bool>(boost::any_cast<bool>(m["Disabled"]));
    }
    if (m.find("IpAddressRange") != m.end() && !m["IpAddressRange"].empty()) {
      ipAddressRange = make_shared<string>(boost::any_cast<string>(m["IpAddressRange"]));
    }
    if (m.find("TimeToLiveInHours") != m.end() && !m["TimeToLiveInHours"].empty()) {
      timeToLiveInHours = make_shared<long>(boost::any_cast<long>(m["TimeToLiveInHours"]));
    }
    if (m.find("ActivationId") != m.end() && !m["ActivationId"].empty()) {
      activationId = make_shared<string>(boost::any_cast<string>(m["ActivationId"]));
    }
  }


  virtual ~DisableActivationResponseBodyActivation() = default;
};
class DisableActivationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DisableActivationResponseBodyActivation> activation{};

  DisableActivationResponseBody() {}

  explicit DisableActivationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (activation) {
      res["Activation"] = activation ? boost::any(activation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Activation") != m.end() && !m["Activation"].empty()) {
      if (typeid(map<string, boost::any>) == m["Activation"].type()) {
        DisableActivationResponseBodyActivation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Activation"]));
        activation = make_shared<DisableActivationResponseBodyActivation>(model1);
      }
    }
  }


  virtual ~DisableActivationResponseBody() = default;
};
class DisableActivationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DisableActivationResponseBody> body{};

  DisableActivationResponse() {}

  explicit DisableActivationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableActivationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableActivationResponseBody>(model1);
      }
    }
  }


  virtual ~DisableActivationResponse() = default;
};
class EipFillParamsRequest : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> userCidr{};

  EipFillParamsRequest() {}

  explicit EipFillParamsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (userCidr) {
      res["UserCidr"] = boost::any(*userCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("UserCidr") != m.end() && !m["UserCidr"].empty()) {
      userCidr = make_shared<string>(boost::any_cast<string>(m["UserCidr"]));
    }
  }


  virtual ~EipFillParamsRequest() = default;
};
class EipFillParamsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> success{};
  shared_ptr<string> message{};
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  EipFillParamsResponseBody() {}

  explicit EipFillParamsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~EipFillParamsResponseBody() = default;
};
class EipFillParamsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<EipFillParamsResponseBody> body{};

  EipFillParamsResponse() {}

  explicit EipFillParamsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EipFillParamsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EipFillParamsResponseBody>(model1);
      }
    }
  }


  virtual ~EipFillParamsResponse() = default;
};
class EipFillProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> userCidr{};

  EipFillProductRequest() {}

  explicit EipFillProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (userCidr) {
      res["UserCidr"] = boost::any(*userCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("UserCidr") != m.end() && !m["UserCidr"].empty()) {
      userCidr = make_shared<string>(boost::any_cast<string>(m["UserCidr"]));
    }
  }


  virtual ~EipFillProductRequest() = default;
};
class EipFillProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> success{};
  shared_ptr<string> message{};
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  EipFillProductResponseBody() {}

  explicit EipFillProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~EipFillProductResponseBody() = default;
};
class EipFillProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<EipFillProductResponseBody> body{};

  EipFillProductResponse() {}

  explicit EipFillProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EipFillProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EipFillProductResponseBody>(model1);
      }
    }
  }


  virtual ~EipFillProductResponse() = default;
};
class EipNotifyPaidRequest : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> userCidr{};

  EipNotifyPaidRequest() {}

  explicit EipNotifyPaidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (userCidr) {
      res["UserCidr"] = boost::any(*userCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("UserCidr") != m.end() && !m["UserCidr"].empty()) {
      userCidr = make_shared<string>(boost::any_cast<string>(m["UserCidr"]));
    }
  }


  virtual ~EipNotifyPaidRequest() = default;
};
class EipNotifyPaidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> success{};
  shared_ptr<string> message{};
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  EipNotifyPaidResponseBody() {}

  explicit EipNotifyPaidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~EipNotifyPaidResponseBody() = default;
};
class EipNotifyPaidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<EipNotifyPaidResponseBody> body{};

  EipNotifyPaidResponse() {}

  explicit EipNotifyPaidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EipNotifyPaidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EipNotifyPaidResponseBody>(model1);
      }
    }
  }


  virtual ~EipNotifyPaidResponse() = default;
};
class EnablePhysicalConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> userCidr{};

  EnablePhysicalConnectionRequest() {}

  explicit EnablePhysicalConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (userCidr) {
      res["UserCidr"] = boost::any(*userCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("UserCidr") != m.end() && !m["UserCidr"].empty()) {
      userCidr = make_shared<string>(boost::any_cast<string>(m["UserCidr"]));
    }
  }


  virtual ~EnablePhysicalConnectionRequest() = default;
};
class EnablePhysicalConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnablePhysicalConnectionResponseBody() {}

  explicit EnablePhysicalConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnablePhysicalConnectionResponseBody() = default;
};
class EnablePhysicalConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<EnablePhysicalConnectionResponseBody> body{};

  EnablePhysicalConnectionResponse() {}

  explicit EnablePhysicalConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnablePhysicalConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnablePhysicalConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~EnablePhysicalConnectionResponse() = default;
};
class ExportImageRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> OSSBucket{};
  shared_ptr<string> OSSPrefix{};
  shared_ptr<string> imageFormat{};
  shared_ptr<string> roleName{};

  ExportImageRequest() {}

  explicit ExportImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (OSSBucket) {
      res["OSSBucket"] = boost::any(*OSSBucket);
    }
    if (OSSPrefix) {
      res["OSSPrefix"] = boost::any(*OSSPrefix);
    }
    if (imageFormat) {
      res["ImageFormat"] = boost::any(*imageFormat);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("OSSBucket") != m.end() && !m["OSSBucket"].empty()) {
      OSSBucket = make_shared<string>(boost::any_cast<string>(m["OSSBucket"]));
    }
    if (m.find("OSSPrefix") != m.end() && !m["OSSPrefix"].empty()) {
      OSSPrefix = make_shared<string>(boost::any_cast<string>(m["OSSPrefix"]));
    }
    if (m.find("ImageFormat") != m.end() && !m["ImageFormat"].empty()) {
      imageFormat = make_shared<string>(boost::any_cast<string>(m["ImageFormat"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
  }


  virtual ~ExportImageRequest() = default;
};
class ExportImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> regionId{};

  ExportImageResponseBody() {}

  explicit ExportImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ExportImageResponseBody() = default;
};
class ExportImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ExportImageResponseBody> body{};

  ExportImageResponse() {}

  explicit ExportImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportImageResponseBody>(model1);
      }
    }
  }


  virtual ~ExportImageResponse() = default;
};
class ExportSnapshotRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> roleName{};

  ExportSnapshotRequest() {}

  explicit ExportSnapshotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
  }


  virtual ~ExportSnapshotRequest() = default;
};
class ExportSnapshotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> requestId{};

  ExportSnapshotResponseBody() {}

  explicit ExportSnapshotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ExportSnapshotResponseBody() = default;
};
class ExportSnapshotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ExportSnapshotResponseBody> body{};

  ExportSnapshotResponse() {}

  explicit ExportSnapshotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportSnapshotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportSnapshotResponseBody>(model1);
      }
    }
  }


  virtual ~ExportSnapshotResponse() = default;
};
class GetInstanceConsoleOutputRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> removeSymbols{};

  GetInstanceConsoleOutputRequest() {}

  explicit GetInstanceConsoleOutputRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (removeSymbols) {
      res["RemoveSymbols"] = boost::any(*removeSymbols);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RemoveSymbols") != m.end() && !m["RemoveSymbols"].empty()) {
      removeSymbols = make_shared<bool>(boost::any_cast<bool>(m["RemoveSymbols"]));
    }
  }


  virtual ~GetInstanceConsoleOutputRequest() = default;
};
class GetInstanceConsoleOutputResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> lastUpdateTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> consoleOutput{};

  GetInstanceConsoleOutputResponseBody() {}

  explicit GetInstanceConsoleOutputResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lastUpdateTime) {
      res["LastUpdateTime"] = boost::any(*lastUpdateTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (consoleOutput) {
      res["ConsoleOutput"] = boost::any(*consoleOutput);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LastUpdateTime") != m.end() && !m["LastUpdateTime"].empty()) {
      lastUpdateTime = make_shared<string>(boost::any_cast<string>(m["LastUpdateTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ConsoleOutput") != m.end() && !m["ConsoleOutput"].empty()) {
      consoleOutput = make_shared<string>(boost::any_cast<string>(m["ConsoleOutput"]));
    }
  }


  virtual ~GetInstanceConsoleOutputResponseBody() = default;
};
class GetInstanceConsoleOutputResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetInstanceConsoleOutputResponseBody> body{};

  GetInstanceConsoleOutputResponse() {}

  explicit GetInstanceConsoleOutputResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceConsoleOutputResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceConsoleOutputResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceConsoleOutputResponse() = default;
};
class GetInstanceScreenshotRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> wakeUp{};

  GetInstanceScreenshotRequest() {}

  explicit GetInstanceScreenshotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (wakeUp) {
      res["WakeUp"] = boost::any(*wakeUp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("WakeUp") != m.end() && !m["WakeUp"].empty()) {
      wakeUp = make_shared<bool>(boost::any_cast<bool>(m["WakeUp"]));
    }
  }


  virtual ~GetInstanceScreenshotRequest() = default;
};
class GetInstanceScreenshotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> screenshot{};

  GetInstanceScreenshotResponseBody() {}

  explicit GetInstanceScreenshotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (screenshot) {
      res["Screenshot"] = boost::any(*screenshot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Screenshot") != m.end() && !m["Screenshot"].empty()) {
      screenshot = make_shared<string>(boost::any_cast<string>(m["Screenshot"]));
    }
  }


  virtual ~GetInstanceScreenshotResponseBody() = default;
};
class GetInstanceScreenshotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetInstanceScreenshotResponseBody> body{};

  GetInstanceScreenshotResponse() {}

  explicit GetInstanceScreenshotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceScreenshotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceScreenshotResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceScreenshotResponse() = default;
};
class ImportImageRequestDiskDeviceMapping : public Darabonba::Model {
public:
  shared_ptr<long> diskImSize{};
  shared_ptr<string> device{};
  shared_ptr<string> OSSBucket{};
  shared_ptr<string> format{};
  shared_ptr<string> OSSObject{};
  shared_ptr<long> diskImageSize{};

  ImportImageRequestDiskDeviceMapping() {}

  explicit ImportImageRequestDiskDeviceMapping(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskImSize) {
      res["DiskImSize"] = boost::any(*diskImSize);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (OSSBucket) {
      res["OSSBucket"] = boost::any(*OSSBucket);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (OSSObject) {
      res["OSSObject"] = boost::any(*OSSObject);
    }
    if (diskImageSize) {
      res["DiskImageSize"] = boost::any(*diskImageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskImSize") != m.end() && !m["DiskImSize"].empty()) {
      diskImSize = make_shared<long>(boost::any_cast<long>(m["DiskImSize"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("OSSBucket") != m.end() && !m["OSSBucket"].empty()) {
      OSSBucket = make_shared<string>(boost::any_cast<string>(m["OSSBucket"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("OSSObject") != m.end() && !m["OSSObject"].empty()) {
      OSSObject = make_shared<string>(boost::any_cast<string>(m["OSSObject"]));
    }
    if (m.find("DiskImageSize") != m.end() && !m["DiskImageSize"].empty()) {
      diskImageSize = make_shared<long>(boost::any_cast<long>(m["DiskImageSize"]));
    }
  }


  virtual ~ImportImageRequestDiskDeviceMapping() = default;
};
class ImportImageRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ImportImageRequestTag() {}

  explicit ImportImageRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ImportImageRequestTag() = default;
};
class ImportImageRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> imageName{};
  shared_ptr<string> description{};
  shared_ptr<string> architecture{};
  shared_ptr<string> OSType{};
  shared_ptr<string> platform{};
  shared_ptr<string> bootMode{};
  shared_ptr<string> roleName{};
  shared_ptr<string> licenseType{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<ImportImageRequestDiskDeviceMapping>> diskDeviceMapping{};
  shared_ptr<vector<ImportImageRequestTag>> tag{};

  ImportImageRequest() {}

  explicit ImportImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (architecture) {
      res["Architecture"] = boost::any(*architecture);
    }
    if (OSType) {
      res["OSType"] = boost::any(*OSType);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (bootMode) {
      res["BootMode"] = boost::any(*bootMode);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (licenseType) {
      res["LicenseType"] = boost::any(*licenseType);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (diskDeviceMapping) {
      vector<boost::any> temp1;
      for(auto item1:*diskDeviceMapping){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiskDeviceMapping"] = boost::any(temp1);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Architecture") != m.end() && !m["Architecture"].empty()) {
      architecture = make_shared<string>(boost::any_cast<string>(m["Architecture"]));
    }
    if (m.find("OSType") != m.end() && !m["OSType"].empty()) {
      OSType = make_shared<string>(boost::any_cast<string>(m["OSType"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("BootMode") != m.end() && !m["BootMode"].empty()) {
      bootMode = make_shared<string>(boost::any_cast<string>(m["BootMode"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("LicenseType") != m.end() && !m["LicenseType"].empty()) {
      licenseType = make_shared<string>(boost::any_cast<string>(m["LicenseType"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("DiskDeviceMapping") != m.end() && !m["DiskDeviceMapping"].empty()) {
      if (typeid(vector<boost::any>) == m["DiskDeviceMapping"].type()) {
        vector<ImportImageRequestDiskDeviceMapping> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiskDeviceMapping"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportImageRequestDiskDeviceMapping model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diskDeviceMapping = make_shared<vector<ImportImageRequestDiskDeviceMapping>>(expect1);
      }
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ImportImageRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportImageRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ImportImageRequestTag>>(expect1);
      }
    }
  }


  virtual ~ImportImageRequest() = default;
};
class ImportImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> regionId{};

  ImportImageResponseBody() {}

  explicit ImportImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ImportImageResponseBody() = default;
};
class ImportImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ImportImageResponseBody> body{};

  ImportImageResponse() {}

  explicit ImportImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportImageResponseBody>(model1);
      }
    }
  }


  virtual ~ImportImageResponse() = default;
};
class ImportKeyPairRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ImportKeyPairRequestTag() {}

  explicit ImportKeyPairRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ImportKeyPairRequestTag() = default;
};
class ImportKeyPairRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> publicKeyBody{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<ImportKeyPairRequestTag>> tag{};

  ImportKeyPairRequest() {}

  explicit ImportKeyPairRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (publicKeyBody) {
      res["PublicKeyBody"] = boost::any(*publicKeyBody);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("PublicKeyBody") != m.end() && !m["PublicKeyBody"].empty()) {
      publicKeyBody = make_shared<string>(boost::any_cast<string>(m["PublicKeyBody"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ImportKeyPairRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportKeyPairRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ImportKeyPairRequestTag>>(expect1);
      }
    }
  }


  virtual ~ImportKeyPairRequest() = default;
};
class ImportKeyPairResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> keyPairFingerPrint{};

  ImportKeyPairResponseBody() {}

  explicit ImportKeyPairResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (keyPairFingerPrint) {
      res["KeyPairFingerPrint"] = boost::any(*keyPairFingerPrint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("KeyPairFingerPrint") != m.end() && !m["KeyPairFingerPrint"].empty()) {
      keyPairFingerPrint = make_shared<string>(boost::any_cast<string>(m["KeyPairFingerPrint"]));
    }
  }


  virtual ~ImportKeyPairResponseBody() = default;
};
class ImportKeyPairResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ImportKeyPairResponseBody> body{};

  ImportKeyPairResponse() {}

  explicit ImportKeyPairResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportKeyPairResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportKeyPairResponseBody>(model1);
      }
    }
  }


  virtual ~ImportKeyPairResponse() = default;
};
class ImportSnapshotRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> snapshotName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossObject{};
  shared_ptr<string> roleName{};

  ImportSnapshotRequest() {}

  explicit ImportSnapshotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (snapshotName) {
      res["SnapshotName"] = boost::any(*snapshotName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SnapshotName") != m.end() && !m["SnapshotName"].empty()) {
      snapshotName = make_shared<string>(boost::any_cast<string>(m["SnapshotName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
  }


  virtual ~ImportSnapshotRequest() = default;
};
class ImportSnapshotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> snapshotId{};

  ImportSnapshotResponseBody() {}

  explicit ImportSnapshotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
  }


  virtual ~ImportSnapshotResponseBody() = default;
};
class ImportSnapshotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ImportSnapshotResponseBody> body{};

  ImportSnapshotResponse() {}

  explicit ImportSnapshotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportSnapshotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportSnapshotResponseBody>(model1);
      }
    }
  }


  virtual ~ImportSnapshotResponse() = default;
};
class InstallCloudAssistantRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> instanceId{};

  InstallCloudAssistantRequest() {}

  explicit InstallCloudAssistantRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~InstallCloudAssistantRequest() = default;
};
class InstallCloudAssistantResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  InstallCloudAssistantResponseBody() {}

  explicit InstallCloudAssistantResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InstallCloudAssistantResponseBody() = default;
};
class InstallCloudAssistantResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<InstallCloudAssistantResponseBody> body{};

  InstallCloudAssistantResponse() {}

  explicit InstallCloudAssistantResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallCloudAssistantResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallCloudAssistantResponseBody>(model1);
      }
    }
  }


  virtual ~InstallCloudAssistantResponse() = default;
};
class InvokeCommandRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<string> commandId{};
  shared_ptr<string> repeatMode{};
  shared_ptr<bool> timed{};
  shared_ptr<string> frequency{};
  shared_ptr<map<string, boost::any>> parameters{};
  shared_ptr<string> username{};
  shared_ptr<string> windowsPasswordName{};

  InvokeCommandRequest() {}

  explicit InvokeCommandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (commandId) {
      res["CommandId"] = boost::any(*commandId);
    }
    if (repeatMode) {
      res["RepeatMode"] = boost::any(*repeatMode);
    }
    if (timed) {
      res["Timed"] = boost::any(*timed);
    }
    if (frequency) {
      res["Frequency"] = boost::any(*frequency);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    if (windowsPasswordName) {
      res["WindowsPasswordName"] = boost::any(*windowsPasswordName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CommandId") != m.end() && !m["CommandId"].empty()) {
      commandId = make_shared<string>(boost::any_cast<string>(m["CommandId"]));
    }
    if (m.find("RepeatMode") != m.end() && !m["RepeatMode"].empty()) {
      repeatMode = make_shared<string>(boost::any_cast<string>(m["RepeatMode"]));
    }
    if (m.find("Timed") != m.end() && !m["Timed"].empty()) {
      timed = make_shared<bool>(boost::any_cast<bool>(m["Timed"]));
    }
    if (m.find("Frequency") != m.end() && !m["Frequency"].empty()) {
      frequency = make_shared<string>(boost::any_cast<string>(m["Frequency"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Parameters"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      parameters = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
    if (m.find("WindowsPasswordName") != m.end() && !m["WindowsPasswordName"].empty()) {
      windowsPasswordName = make_shared<string>(boost::any_cast<string>(m["WindowsPasswordName"]));
    }
  }


  virtual ~InvokeCommandRequest() = default;
};
class InvokeCommandShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<string> commandId{};
  shared_ptr<string> repeatMode{};
  shared_ptr<bool> timed{};
  shared_ptr<string> frequency{};
  shared_ptr<string> parametersShrink{};
  shared_ptr<string> username{};
  shared_ptr<string> windowsPasswordName{};

  InvokeCommandShrinkRequest() {}

  explicit InvokeCommandShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (commandId) {
      res["CommandId"] = boost::any(*commandId);
    }
    if (repeatMode) {
      res["RepeatMode"] = boost::any(*repeatMode);
    }
    if (timed) {
      res["Timed"] = boost::any(*timed);
    }
    if (frequency) {
      res["Frequency"] = boost::any(*frequency);
    }
    if (parametersShrink) {
      res["Parameters"] = boost::any(*parametersShrink);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    if (windowsPasswordName) {
      res["WindowsPasswordName"] = boost::any(*windowsPasswordName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CommandId") != m.end() && !m["CommandId"].empty()) {
      commandId = make_shared<string>(boost::any_cast<string>(m["CommandId"]));
    }
    if (m.find("RepeatMode") != m.end() && !m["RepeatMode"].empty()) {
      repeatMode = make_shared<string>(boost::any_cast<string>(m["RepeatMode"]));
    }
    if (m.find("Timed") != m.end() && !m["Timed"].empty()) {
      timed = make_shared<bool>(boost::any_cast<bool>(m["Timed"]));
    }
    if (m.find("Frequency") != m.end() && !m["Frequency"].empty()) {
      frequency = make_shared<string>(boost::any_cast<string>(m["Frequency"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parametersShrink = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
    if (m.find("WindowsPasswordName") != m.end() && !m["WindowsPasswordName"].empty()) {
      windowsPasswordName = make_shared<string>(boost::any_cast<string>(m["WindowsPasswordName"]));
    }
  }


  virtual ~InvokeCommandShrinkRequest() = default;
};
class InvokeCommandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> invokeId{};
  shared_ptr<string> requestId{};

  InvokeCommandResponseBody() {}

  explicit InvokeCommandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invokeId) {
      res["InvokeId"] = boost::any(*invokeId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InvokeId") != m.end() && !m["InvokeId"].empty()) {
      invokeId = make_shared<string>(boost::any_cast<string>(m["InvokeId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InvokeCommandResponseBody() = default;
};
class InvokeCommandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<InvokeCommandResponseBody> body{};

  InvokeCommandResponse() {}

  explicit InvokeCommandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InvokeCommandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InvokeCommandResponseBody>(model1);
      }
    }
  }


  virtual ~InvokeCommandResponse() = default;
};
class JoinResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};

  JoinResourceGroupRequest() {}

  explicit JoinResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~JoinResourceGroupRequest() = default;
};
class JoinResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  JoinResourceGroupResponseBody() {}

  explicit JoinResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~JoinResourceGroupResponseBody() = default;
};
class JoinResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<JoinResourceGroupResponseBody> body{};

  JoinResourceGroupResponse() {}

  explicit JoinResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        JoinResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<JoinResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~JoinResourceGroupResponse() = default;
};
class JoinSecurityGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ownerAccount{};

  JoinSecurityGroupRequest() {}

  explicit JoinSecurityGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~JoinSecurityGroupRequest() = default;
};
class JoinSecurityGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  JoinSecurityGroupResponseBody() {}

  explicit JoinSecurityGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~JoinSecurityGroupResponseBody() = default;
};
class JoinSecurityGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<JoinSecurityGroupResponseBody> body{};

  JoinSecurityGroupResponse() {}

  explicit JoinSecurityGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        JoinSecurityGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<JoinSecurityGroupResponseBody>(model1);
      }
    }
  }


  virtual ~JoinSecurityGroupResponse() = default;
};
class LeaveSecurityGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ownerAccount{};

  LeaveSecurityGroupRequest() {}

  explicit LeaveSecurityGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~LeaveSecurityGroupRequest() = default;
};
class LeaveSecurityGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  LeaveSecurityGroupResponseBody() {}

  explicit LeaveSecurityGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~LeaveSecurityGroupResponseBody() = default;
};
class LeaveSecurityGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<LeaveSecurityGroupResponseBody> body{};

  LeaveSecurityGroupResponse() {}

  explicit LeaveSecurityGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        LeaveSecurityGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<LeaveSecurityGroupResponseBody>(model1);
      }
    }
  }


  virtual ~LeaveSecurityGroupResponse() = default;
};
class ListTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTagResourcesRequestTag() {}

  explicit ListTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTagResourcesRequestTag() = default;
};
class ListTagResourcesRequestTagFilter : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tagValues{};
  shared_ptr<string> tagKey{};

  ListTagResourcesRequestTagFilter() {}

  explicit ListTagResourcesRequestTagFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValues) {
      res["TagValues"] = boost::any(*tagValues);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValues") != m.end() && !m["TagValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagValues = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~ListTagResourcesRequestTagFilter() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<vector<ListTagResourcesRequestTag>> tag{};
  shared_ptr<vector<ListTagResourcesRequestTagFilter>> tagFilter{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (tagFilter) {
      vector<boost::any> temp1;
      for(auto item1:*tagFilter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagFilter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListTagResourcesRequestTag>>(expect1);
      }
    }
    if (m.find("TagFilter") != m.end() && !m["TagFilter"].empty()) {
      if (typeid(vector<boost::any>) == m["TagFilter"].type()) {
        vector<ListTagResourcesRequestTagFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagFilter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesRequestTagFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagFilter = make_shared<vector<ListTagResourcesRequestTagFilter>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyTagResourcesTagResource : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> tagKey{};

  ListTagResourcesResponseBodyTagResourcesTagResource() {}

  explicit ListTagResourcesResponseBodyTagResourcesTagResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResourcesTagResource() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<vector<ListTagResourcesResponseBodyTagResourcesTagResource>> tagResource{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagResource) {
      vector<boost::any> temp1;
      for(auto item1:*tagResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagResource") != m.end() && !m["TagResource"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResource"].type()) {
        vector<ListTagResourcesResponseBodyTagResourcesTagResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResourcesTagResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResource = make_shared<vector<ListTagResourcesResponseBodyTagResourcesTagResource>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<ListTagResourcesResponseBodyTagResources> tagResources{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      res["TagResources"] = tagResources ? boost::any(tagResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagResources"].type()) {
        ListTagResourcesResponseBodyTagResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagResources"]));
        tagResources = make_shared<ListTagResourcesResponseBodyTagResources>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ModifyAutoProvisioningGroupRequestLaunchTemplateConfig : public Darabonba::Model {
public:
  shared_ptr<string> vSwitchId{};
  shared_ptr<double> maxPrice{};
  shared_ptr<long> priority{};
  shared_ptr<string> instanceType{};
  shared_ptr<double> weightedCapacity{};

  ModifyAutoProvisioningGroupRequestLaunchTemplateConfig() {}

  explicit ModifyAutoProvisioningGroupRequestLaunchTemplateConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (maxPrice) {
      res["MaxPrice"] = boost::any(*maxPrice);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (weightedCapacity) {
      res["WeightedCapacity"] = boost::any(*weightedCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("MaxPrice") != m.end() && !m["MaxPrice"].empty()) {
      maxPrice = make_shared<double>(boost::any_cast<double>(m["MaxPrice"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("WeightedCapacity") != m.end() && !m["WeightedCapacity"].empty()) {
      weightedCapacity = make_shared<double>(boost::any_cast<double>(m["WeightedCapacity"]));
    }
  }


  virtual ~ModifyAutoProvisioningGroupRequestLaunchTemplateConfig() = default;
};
class ModifyAutoProvisioningGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<ModifyAutoProvisioningGroupRequestLaunchTemplateConfig>> launchTemplateConfig{};
  shared_ptr<string> autoProvisioningGroupId{};
  shared_ptr<string> excessCapacityTerminationPolicy{};
  shared_ptr<string> defaultTargetCapacityType{};
  shared_ptr<bool> terminateInstancesWithExpiration{};
  shared_ptr<double> maxSpotPrice{};
  shared_ptr<string> totalTargetCapacity{};
  shared_ptr<string> payAsYouGoTargetCapacity{};
  shared_ptr<string> spotTargetCapacity{};
  shared_ptr<string> autoProvisioningGroupName{};

  ModifyAutoProvisioningGroupRequest() {}

  explicit ModifyAutoProvisioningGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (launchTemplateConfig) {
      vector<boost::any> temp1;
      for(auto item1:*launchTemplateConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LaunchTemplateConfig"] = boost::any(temp1);
    }
    if (autoProvisioningGroupId) {
      res["AutoProvisioningGroupId"] = boost::any(*autoProvisioningGroupId);
    }
    if (excessCapacityTerminationPolicy) {
      res["ExcessCapacityTerminationPolicy"] = boost::any(*excessCapacityTerminationPolicy);
    }
    if (defaultTargetCapacityType) {
      res["DefaultTargetCapacityType"] = boost::any(*defaultTargetCapacityType);
    }
    if (terminateInstancesWithExpiration) {
      res["TerminateInstancesWithExpiration"] = boost::any(*terminateInstancesWithExpiration);
    }
    if (maxSpotPrice) {
      res["MaxSpotPrice"] = boost::any(*maxSpotPrice);
    }
    if (totalTargetCapacity) {
      res["TotalTargetCapacity"] = boost::any(*totalTargetCapacity);
    }
    if (payAsYouGoTargetCapacity) {
      res["PayAsYouGoTargetCapacity"] = boost::any(*payAsYouGoTargetCapacity);
    }
    if (spotTargetCapacity) {
      res["SpotTargetCapacity"] = boost::any(*spotTargetCapacity);
    }
    if (autoProvisioningGroupName) {
      res["AutoProvisioningGroupName"] = boost::any(*autoProvisioningGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("LaunchTemplateConfig") != m.end() && !m["LaunchTemplateConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["LaunchTemplateConfig"].type()) {
        vector<ModifyAutoProvisioningGroupRequestLaunchTemplateConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LaunchTemplateConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyAutoProvisioningGroupRequestLaunchTemplateConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        launchTemplateConfig = make_shared<vector<ModifyAutoProvisioningGroupRequestLaunchTemplateConfig>>(expect1);
      }
    }
    if (m.find("AutoProvisioningGroupId") != m.end() && !m["AutoProvisioningGroupId"].empty()) {
      autoProvisioningGroupId = make_shared<string>(boost::any_cast<string>(m["AutoProvisioningGroupId"]));
    }
    if (m.find("ExcessCapacityTerminationPolicy") != m.end() && !m["ExcessCapacityTerminationPolicy"].empty()) {
      excessCapacityTerminationPolicy = make_shared<string>(boost::any_cast<string>(m["ExcessCapacityTerminationPolicy"]));
    }
    if (m.find("DefaultTargetCapacityType") != m.end() && !m["DefaultTargetCapacityType"].empty()) {
      defaultTargetCapacityType = make_shared<string>(boost::any_cast<string>(m["DefaultTargetCapacityType"]));
    }
    if (m.find("TerminateInstancesWithExpiration") != m.end() && !m["TerminateInstancesWithExpiration"].empty()) {
      terminateInstancesWithExpiration = make_shared<bool>(boost::any_cast<bool>(m["TerminateInstancesWithExpiration"]));
    }
    if (m.find("MaxSpotPrice") != m.end() && !m["MaxSpotPrice"].empty()) {
      maxSpotPrice = make_shared<double>(boost::any_cast<double>(m["MaxSpotPrice"]));
    }
    if (m.find("TotalTargetCapacity") != m.end() && !m["TotalTargetCapacity"].empty()) {
      totalTargetCapacity = make_shared<string>(boost::any_cast<string>(m["TotalTargetCapacity"]));
    }
    if (m.find("PayAsYouGoTargetCapacity") != m.end() && !m["PayAsYouGoTargetCapacity"].empty()) {
      payAsYouGoTargetCapacity = make_shared<string>(boost::any_cast<string>(m["PayAsYouGoTargetCapacity"]));
    }
    if (m.find("SpotTargetCapacity") != m.end() && !m["SpotTargetCapacity"].empty()) {
      spotTargetCapacity = make_shared<string>(boost::any_cast<string>(m["SpotTargetCapacity"]));
    }
    if (m.find("AutoProvisioningGroupName") != m.end() && !m["AutoProvisioningGroupName"].empty()) {
      autoProvisioningGroupName = make_shared<string>(boost::any_cast<string>(m["AutoProvisioningGroupName"]));
    }
  }


  virtual ~ModifyAutoProvisioningGroupRequest() = default;
};
class ModifyAutoProvisioningGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyAutoProvisioningGroupResponseBody() {}

  explicit ModifyAutoProvisioningGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyAutoProvisioningGroupResponseBody() = default;
};
class ModifyAutoProvisioningGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyAutoProvisioningGroupResponseBody> body{};

  ModifyAutoProvisioningGroupResponse() {}

  explicit ModifyAutoProvisioningGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAutoProvisioningGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAutoProvisioningGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAutoProvisioningGroupResponse() = default;
};
class ModifyAutoSnapshotPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<bool> systemDiskPolicyEnabled{};
  shared_ptr<long> systemDiskPolicyTimePeriod{};
  shared_ptr<long> systemDiskPolicyRetentionDays{};
  shared_ptr<bool> systemDiskPolicyRetentionLastWeek{};
  shared_ptr<bool> dataDiskPolicyEnabled{};
  shared_ptr<long> dataDiskPolicyTimePeriod{};
  shared_ptr<long> dataDiskPolicyRetentionDays{};
  shared_ptr<bool> dataDiskPolicyRetentionLastWeek{};
  shared_ptr<string> ownerAccount{};

  ModifyAutoSnapshotPolicyRequest() {}

  explicit ModifyAutoSnapshotPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (systemDiskPolicyEnabled) {
      res["SystemDiskPolicyEnabled"] = boost::any(*systemDiskPolicyEnabled);
    }
    if (systemDiskPolicyTimePeriod) {
      res["SystemDiskPolicyTimePeriod"] = boost::any(*systemDiskPolicyTimePeriod);
    }
    if (systemDiskPolicyRetentionDays) {
      res["SystemDiskPolicyRetentionDays"] = boost::any(*systemDiskPolicyRetentionDays);
    }
    if (systemDiskPolicyRetentionLastWeek) {
      res["SystemDiskPolicyRetentionLastWeek"] = boost::any(*systemDiskPolicyRetentionLastWeek);
    }
    if (dataDiskPolicyEnabled) {
      res["DataDiskPolicyEnabled"] = boost::any(*dataDiskPolicyEnabled);
    }
    if (dataDiskPolicyTimePeriod) {
      res["DataDiskPolicyTimePeriod"] = boost::any(*dataDiskPolicyTimePeriod);
    }
    if (dataDiskPolicyRetentionDays) {
      res["DataDiskPolicyRetentionDays"] = boost::any(*dataDiskPolicyRetentionDays);
    }
    if (dataDiskPolicyRetentionLastWeek) {
      res["DataDiskPolicyRetentionLastWeek"] = boost::any(*dataDiskPolicyRetentionLastWeek);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SystemDiskPolicyEnabled") != m.end() && !m["SystemDiskPolicyEnabled"].empty()) {
      systemDiskPolicyEnabled = make_shared<bool>(boost::any_cast<bool>(m["SystemDiskPolicyEnabled"]));
    }
    if (m.find("SystemDiskPolicyTimePeriod") != m.end() && !m["SystemDiskPolicyTimePeriod"].empty()) {
      systemDiskPolicyTimePeriod = make_shared<long>(boost::any_cast<long>(m["SystemDiskPolicyTimePeriod"]));
    }
    if (m.find("SystemDiskPolicyRetentionDays") != m.end() && !m["SystemDiskPolicyRetentionDays"].empty()) {
      systemDiskPolicyRetentionDays = make_shared<long>(boost::any_cast<long>(m["SystemDiskPolicyRetentionDays"]));
    }
    if (m.find("SystemDiskPolicyRetentionLastWeek") != m.end() && !m["SystemDiskPolicyRetentionLastWeek"].empty()) {
      systemDiskPolicyRetentionLastWeek = make_shared<bool>(boost::any_cast<bool>(m["SystemDiskPolicyRetentionLastWeek"]));
    }
    if (m.find("DataDiskPolicyEnabled") != m.end() && !m["DataDiskPolicyEnabled"].empty()) {
      dataDiskPolicyEnabled = make_shared<bool>(boost::any_cast<bool>(m["DataDiskPolicyEnabled"]));
    }
    if (m.find("DataDiskPolicyTimePeriod") != m.end() && !m["DataDiskPolicyTimePeriod"].empty()) {
      dataDiskPolicyTimePeriod = make_shared<long>(boost::any_cast<long>(m["DataDiskPolicyTimePeriod"]));
    }
    if (m.find("DataDiskPolicyRetentionDays") != m.end() && !m["DataDiskPolicyRetentionDays"].empty()) {
      dataDiskPolicyRetentionDays = make_shared<long>(boost::any_cast<long>(m["DataDiskPolicyRetentionDays"]));
    }
    if (m.find("DataDiskPolicyRetentionLastWeek") != m.end() && !m["DataDiskPolicyRetentionLastWeek"].empty()) {
      dataDiskPolicyRetentionLastWeek = make_shared<bool>(boost::any_cast<bool>(m["DataDiskPolicyRetentionLastWeek"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ModifyAutoSnapshotPolicyRequest() = default;
};
class ModifyAutoSnapshotPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyAutoSnapshotPolicyResponseBody() {}

  explicit ModifyAutoSnapshotPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyAutoSnapshotPolicyResponseBody() = default;
};
class ModifyAutoSnapshotPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyAutoSnapshotPolicyResponseBody> body{};

  ModifyAutoSnapshotPolicyResponse() {}

  explicit ModifyAutoSnapshotPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAutoSnapshotPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAutoSnapshotPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAutoSnapshotPolicyResponse() = default;
};
class ModifyAutoSnapshotPolicyExRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<string> autoSnapshotPolicyName{};
  shared_ptr<string> timePoints{};
  shared_ptr<string> repeatWeekdays{};
  shared_ptr<long> retentionDays{};
  shared_ptr<bool> enableCrossRegionCopy{};
  shared_ptr<string> targetCopyRegions{};
  shared_ptr<long> copiedSnapshotsRetentionDays{};

  ModifyAutoSnapshotPolicyExRequest() {}

  explicit ModifyAutoSnapshotPolicyExRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["regionId"] = boost::any(*regionId);
    }
    if (autoSnapshotPolicyId) {
      res["autoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    if (autoSnapshotPolicyName) {
      res["autoSnapshotPolicyName"] = boost::any(*autoSnapshotPolicyName);
    }
    if (timePoints) {
      res["timePoints"] = boost::any(*timePoints);
    }
    if (repeatWeekdays) {
      res["repeatWeekdays"] = boost::any(*repeatWeekdays);
    }
    if (retentionDays) {
      res["retentionDays"] = boost::any(*retentionDays);
    }
    if (enableCrossRegionCopy) {
      res["EnableCrossRegionCopy"] = boost::any(*enableCrossRegionCopy);
    }
    if (targetCopyRegions) {
      res["TargetCopyRegions"] = boost::any(*targetCopyRegions);
    }
    if (copiedSnapshotsRetentionDays) {
      res["CopiedSnapshotsRetentionDays"] = boost::any(*copiedSnapshotsRetentionDays);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("regionId") != m.end() && !m["regionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["regionId"]));
    }
    if (m.find("autoSnapshotPolicyId") != m.end() && !m["autoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["autoSnapshotPolicyId"]));
    }
    if (m.find("autoSnapshotPolicyName") != m.end() && !m["autoSnapshotPolicyName"].empty()) {
      autoSnapshotPolicyName = make_shared<string>(boost::any_cast<string>(m["autoSnapshotPolicyName"]));
    }
    if (m.find("timePoints") != m.end() && !m["timePoints"].empty()) {
      timePoints = make_shared<string>(boost::any_cast<string>(m["timePoints"]));
    }
    if (m.find("repeatWeekdays") != m.end() && !m["repeatWeekdays"].empty()) {
      repeatWeekdays = make_shared<string>(boost::any_cast<string>(m["repeatWeekdays"]));
    }
    if (m.find("retentionDays") != m.end() && !m["retentionDays"].empty()) {
      retentionDays = make_shared<long>(boost::any_cast<long>(m["retentionDays"]));
    }
    if (m.find("EnableCrossRegionCopy") != m.end() && !m["EnableCrossRegionCopy"].empty()) {
      enableCrossRegionCopy = make_shared<bool>(boost::any_cast<bool>(m["EnableCrossRegionCopy"]));
    }
    if (m.find("TargetCopyRegions") != m.end() && !m["TargetCopyRegions"].empty()) {
      targetCopyRegions = make_shared<string>(boost::any_cast<string>(m["TargetCopyRegions"]));
    }
    if (m.find("CopiedSnapshotsRetentionDays") != m.end() && !m["CopiedSnapshotsRetentionDays"].empty()) {
      copiedSnapshotsRetentionDays = make_shared<long>(boost::any_cast<long>(m["CopiedSnapshotsRetentionDays"]));
    }
  }


  virtual ~ModifyAutoSnapshotPolicyExRequest() = default;
};
class ModifyAutoSnapshotPolicyExResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyAutoSnapshotPolicyExResponseBody() {}

  explicit ModifyAutoSnapshotPolicyExResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyAutoSnapshotPolicyExResponseBody() = default;
};
class ModifyAutoSnapshotPolicyExResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyAutoSnapshotPolicyExResponseBody> body{};

  ModifyAutoSnapshotPolicyExResponse() {}

  explicit ModifyAutoSnapshotPolicyExResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAutoSnapshotPolicyExResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAutoSnapshotPolicyExResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAutoSnapshotPolicyExResponse() = default;
};
class ModifyBandwidthPackageSpecRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> bandwidth{};

  ModifyBandwidthPackageSpecRequest() {}

  explicit ModifyBandwidthPackageSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<string>(boost::any_cast<string>(m["Bandwidth"]));
    }
  }


  virtual ~ModifyBandwidthPackageSpecRequest() = default;
};
class ModifyBandwidthPackageSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyBandwidthPackageSpecResponseBody() {}

  explicit ModifyBandwidthPackageSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyBandwidthPackageSpecResponseBody() = default;
};
class ModifyBandwidthPackageSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyBandwidthPackageSpecResponseBody> body{};

  ModifyBandwidthPackageSpecResponse() {}

  explicit ModifyBandwidthPackageSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyBandwidthPackageSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyBandwidthPackageSpecResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyBandwidthPackageSpecResponse() = default;
};
class ModifyCapacityReservationRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  ModifyCapacityReservationRequestPrivatePoolOptions() {}

  explicit ModifyCapacityReservationRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ModifyCapacityReservationRequestPrivatePoolOptions() = default;
};
class ModifyCapacityReservationRequest : public Darabonba::Model {
public:
  shared_ptr<ModifyCapacityReservationRequestPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> description{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> endTimeType{};
  shared_ptr<string> platform{};
  shared_ptr<long> instanceAmount{};

  ModifyCapacityReservationRequest() {}

  explicit ModifyCapacityReservationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privatePoolOptions) {
      res["PrivatePoolOptions"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (endTimeType) {
      res["EndTimeType"] = boost::any(*endTimeType);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (instanceAmount) {
      res["InstanceAmount"] = boost::any(*instanceAmount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolOptions"].type()) {
        ModifyCapacityReservationRequestPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolOptions"]));
        privatePoolOptions = make_shared<ModifyCapacityReservationRequestPrivatePoolOptions>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EndTimeType") != m.end() && !m["EndTimeType"].empty()) {
      endTimeType = make_shared<string>(boost::any_cast<string>(m["EndTimeType"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("InstanceAmount") != m.end() && !m["InstanceAmount"].empty()) {
      instanceAmount = make_shared<long>(boost::any_cast<long>(m["InstanceAmount"]));
    }
  }


  virtual ~ModifyCapacityReservationRequest() = default;
};
class ModifyCapacityReservationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyCapacityReservationResponseBody() {}

  explicit ModifyCapacityReservationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCapacityReservationResponseBody() = default;
};
class ModifyCapacityReservationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyCapacityReservationResponseBody> body{};

  ModifyCapacityReservationResponse() {}

  explicit ModifyCapacityReservationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCapacityReservationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCapacityReservationResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCapacityReservationResponse() = default;
};
class ModifyCommandRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> commandId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> commandContent{};
  shared_ptr<string> workingDir{};
  shared_ptr<long> timeout{};

  ModifyCommandRequest() {}

  explicit ModifyCommandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (commandId) {
      res["CommandId"] = boost::any(*commandId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (commandContent) {
      res["CommandContent"] = boost::any(*commandContent);
    }
    if (workingDir) {
      res["WorkingDir"] = boost::any(*workingDir);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("CommandId") != m.end() && !m["CommandId"].empty()) {
      commandId = make_shared<string>(boost::any_cast<string>(m["CommandId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("CommandContent") != m.end() && !m["CommandContent"].empty()) {
      commandContent = make_shared<string>(boost::any_cast<string>(m["CommandContent"]));
    }
    if (m.find("WorkingDir") != m.end() && !m["WorkingDir"].empty()) {
      workingDir = make_shared<string>(boost::any_cast<string>(m["WorkingDir"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~ModifyCommandRequest() = default;
};
class ModifyCommandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyCommandResponseBody() {}

  explicit ModifyCommandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCommandResponseBody() = default;
};
class ModifyCommandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyCommandResponseBody> body{};

  ModifyCommandResponse() {}

  explicit ModifyCommandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCommandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCommandResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCommandResponse() = default;
};
class ModifyDedicatedHostAttributeRequestNetworkAttributes : public Darabonba::Model {
public:
  shared_ptr<long> slbUdpTimeout{};
  shared_ptr<long> udpTimeout{};

  ModifyDedicatedHostAttributeRequestNetworkAttributes() {}

  explicit ModifyDedicatedHostAttributeRequestNetworkAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (slbUdpTimeout) {
      res["SlbUdpTimeout"] = boost::any(*slbUdpTimeout);
    }
    if (udpTimeout) {
      res["UdpTimeout"] = boost::any(*udpTimeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SlbUdpTimeout") != m.end() && !m["SlbUdpTimeout"].empty()) {
      slbUdpTimeout = make_shared<long>(boost::any_cast<long>(m["SlbUdpTimeout"]));
    }
    if (m.find("UdpTimeout") != m.end() && !m["UdpTimeout"].empty()) {
      udpTimeout = make_shared<long>(boost::any_cast<long>(m["UdpTimeout"]));
    }
  }


  virtual ~ModifyDedicatedHostAttributeRequestNetworkAttributes() = default;
};
class ModifyDedicatedHostAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<ModifyDedicatedHostAttributeRequestNetworkAttributes> networkAttributes{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> dedicatedHostName{};
  shared_ptr<string> description{};
  shared_ptr<string> actionOnMaintenance{};
  shared_ptr<string> autoPlacement{};
  shared_ptr<string> dedicatedHostClusterId{};
  shared_ptr<double> cpuOverCommitRatio{};

  ModifyDedicatedHostAttributeRequest() {}

  explicit ModifyDedicatedHostAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkAttributes) {
      res["NetworkAttributes"] = networkAttributes ? boost::any(networkAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (dedicatedHostName) {
      res["DedicatedHostName"] = boost::any(*dedicatedHostName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (actionOnMaintenance) {
      res["ActionOnMaintenance"] = boost::any(*actionOnMaintenance);
    }
    if (autoPlacement) {
      res["AutoPlacement"] = boost::any(*autoPlacement);
    }
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    if (cpuOverCommitRatio) {
      res["CpuOverCommitRatio"] = boost::any(*cpuOverCommitRatio);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkAttributes") != m.end() && !m["NetworkAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkAttributes"].type()) {
        ModifyDedicatedHostAttributeRequestNetworkAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkAttributes"]));
        networkAttributes = make_shared<ModifyDedicatedHostAttributeRequestNetworkAttributes>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("DedicatedHostName") != m.end() && !m["DedicatedHostName"].empty()) {
      dedicatedHostName = make_shared<string>(boost::any_cast<string>(m["DedicatedHostName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ActionOnMaintenance") != m.end() && !m["ActionOnMaintenance"].empty()) {
      actionOnMaintenance = make_shared<string>(boost::any_cast<string>(m["ActionOnMaintenance"]));
    }
    if (m.find("AutoPlacement") != m.end() && !m["AutoPlacement"].empty()) {
      autoPlacement = make_shared<string>(boost::any_cast<string>(m["AutoPlacement"]));
    }
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
    if (m.find("CpuOverCommitRatio") != m.end() && !m["CpuOverCommitRatio"].empty()) {
      cpuOverCommitRatio = make_shared<double>(boost::any_cast<double>(m["CpuOverCommitRatio"]));
    }
  }


  virtual ~ModifyDedicatedHostAttributeRequest() = default;
};
class ModifyDedicatedHostAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDedicatedHostAttributeResponseBody() {}

  explicit ModifyDedicatedHostAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDedicatedHostAttributeResponseBody() = default;
};
class ModifyDedicatedHostAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDedicatedHostAttributeResponseBody> body{};

  ModifyDedicatedHostAttributeResponse() {}

  explicit ModifyDedicatedHostAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDedicatedHostAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDedicatedHostAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDedicatedHostAttributeResponse() = default;
};
class ModifyDedicatedHostAutoReleaseTimeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> autoReleaseTime{};
  shared_ptr<string> ownerAccount{};

  ModifyDedicatedHostAutoReleaseTimeRequest() {}

  explicit ModifyDedicatedHostAutoReleaseTimeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (autoReleaseTime) {
      res["AutoReleaseTime"] = boost::any(*autoReleaseTime);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("AutoReleaseTime") != m.end() && !m["AutoReleaseTime"].empty()) {
      autoReleaseTime = make_shared<string>(boost::any_cast<string>(m["AutoReleaseTime"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ModifyDedicatedHostAutoReleaseTimeRequest() = default;
};
class ModifyDedicatedHostAutoReleaseTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDedicatedHostAutoReleaseTimeResponseBody() {}

  explicit ModifyDedicatedHostAutoReleaseTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDedicatedHostAutoReleaseTimeResponseBody() = default;
};
class ModifyDedicatedHostAutoReleaseTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDedicatedHostAutoReleaseTimeResponseBody> body{};

  ModifyDedicatedHostAutoReleaseTimeResponse() {}

  explicit ModifyDedicatedHostAutoReleaseTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDedicatedHostAutoReleaseTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDedicatedHostAutoReleaseTimeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDedicatedHostAutoReleaseTimeResponse() = default;
};
class ModifyDedicatedHostAutoRenewAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> dedicatedHostIds{};
  shared_ptr<string> regionId{};
  shared_ptr<long> duration{};
  shared_ptr<string> periodUnit{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<string> renewalStatus{};

  ModifyDedicatedHostAutoRenewAttributeRequest() {}

  explicit ModifyDedicatedHostAutoRenewAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (dedicatedHostIds) {
      res["DedicatedHostIds"] = boost::any(*dedicatedHostIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (renewalStatus) {
      res["RenewalStatus"] = boost::any(*renewalStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DedicatedHostIds") != m.end() && !m["DedicatedHostIds"].empty()) {
      dedicatedHostIds = make_shared<string>(boost::any_cast<string>(m["DedicatedHostIds"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("RenewalStatus") != m.end() && !m["RenewalStatus"].empty()) {
      renewalStatus = make_shared<string>(boost::any_cast<string>(m["RenewalStatus"]));
    }
  }


  virtual ~ModifyDedicatedHostAutoRenewAttributeRequest() = default;
};
class ModifyDedicatedHostAutoRenewAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDedicatedHostAutoRenewAttributeResponseBody() {}

  explicit ModifyDedicatedHostAutoRenewAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDedicatedHostAutoRenewAttributeResponseBody() = default;
};
class ModifyDedicatedHostAutoRenewAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDedicatedHostAutoRenewAttributeResponseBody> body{};

  ModifyDedicatedHostAutoRenewAttributeResponse() {}

  explicit ModifyDedicatedHostAutoRenewAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDedicatedHostAutoRenewAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDedicatedHostAutoRenewAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDedicatedHostAutoRenewAttributeResponse() = default;
};
class ModifyDedicatedHostClusterAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> dedicatedHostClusterId{};
  shared_ptr<string> dedicatedHostClusterName{};
  shared_ptr<string> description{};

  ModifyDedicatedHostClusterAttributeRequest() {}

  explicit ModifyDedicatedHostClusterAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    if (dedicatedHostClusterName) {
      res["DedicatedHostClusterName"] = boost::any(*dedicatedHostClusterName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
    if (m.find("DedicatedHostClusterName") != m.end() && !m["DedicatedHostClusterName"].empty()) {
      dedicatedHostClusterName = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~ModifyDedicatedHostClusterAttributeRequest() = default;
};
class ModifyDedicatedHostClusterAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDedicatedHostClusterAttributeResponseBody() {}

  explicit ModifyDedicatedHostClusterAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDedicatedHostClusterAttributeResponseBody() = default;
};
class ModifyDedicatedHostClusterAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDedicatedHostClusterAttributeResponseBody> body{};

  ModifyDedicatedHostClusterAttributeResponse() {}

  explicit ModifyDedicatedHostClusterAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDedicatedHostClusterAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDedicatedHostClusterAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDedicatedHostClusterAttributeResponse() = default;
};
class ModifyDedicatedHostsChargeTypeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> dedicatedHostIds{};
  shared_ptr<string> regionId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<bool> dryRun{};
  shared_ptr<bool> autoPay{};
  shared_ptr<string> dedicatedHostChargeType{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<bool> detailFee{};

  ModifyDedicatedHostsChargeTypeRequest() {}

  explicit ModifyDedicatedHostsChargeTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (dedicatedHostIds) {
      res["DedicatedHostIds"] = boost::any(*dedicatedHostIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (dedicatedHostChargeType) {
      res["DedicatedHostChargeType"] = boost::any(*dedicatedHostChargeType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (detailFee) {
      res["DetailFee"] = boost::any(*detailFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DedicatedHostIds") != m.end() && !m["DedicatedHostIds"].empty()) {
      dedicatedHostIds = make_shared<string>(boost::any_cast<string>(m["DedicatedHostIds"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("DedicatedHostChargeType") != m.end() && !m["DedicatedHostChargeType"].empty()) {
      dedicatedHostChargeType = make_shared<string>(boost::any_cast<string>(m["DedicatedHostChargeType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DetailFee") != m.end() && !m["DetailFee"].empty()) {
      detailFee = make_shared<bool>(boost::any_cast<bool>(m["DetailFee"]));
    }
  }


  virtual ~ModifyDedicatedHostsChargeTypeRequest() = default;
};
class ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstancesFeeOfInstance : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> currency{};
  shared_ptr<string> fee{};

  ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstancesFeeOfInstance() {}

  explicit ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstancesFeeOfInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (fee) {
      res["Fee"] = boost::any(*fee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("Fee") != m.end() && !m["Fee"].empty()) {
      fee = make_shared<string>(boost::any_cast<string>(m["Fee"]));
    }
  }


  virtual ~ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstancesFeeOfInstance() = default;
};
class ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstances : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstancesFeeOfInstance>> feeOfInstance{};

  ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstances() {}

  explicit ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeOfInstance) {
      vector<boost::any> temp1;
      for(auto item1:*feeOfInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FeeOfInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FeeOfInstance") != m.end() && !m["FeeOfInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["FeeOfInstance"].type()) {
        vector<ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstancesFeeOfInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FeeOfInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstancesFeeOfInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        feeOfInstance = make_shared<vector<ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstancesFeeOfInstance>>(expect1);
      }
    }
  }


  virtual ~ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstances() = default;
};
class ModifyDedicatedHostsChargeTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};
  shared_ptr<ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstances> feeOfInstances{};

  ModifyDedicatedHostsChargeTypeResponseBody() {}

  explicit ModifyDedicatedHostsChargeTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (feeOfInstances) {
      res["FeeOfInstances"] = feeOfInstances ? boost::any(feeOfInstances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("FeeOfInstances") != m.end() && !m["FeeOfInstances"].empty()) {
      if (typeid(map<string, boost::any>) == m["FeeOfInstances"].type()) {
        ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FeeOfInstances"]));
        feeOfInstances = make_shared<ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstances>(model1);
      }
    }
  }


  virtual ~ModifyDedicatedHostsChargeTypeResponseBody() = default;
};
class ModifyDedicatedHostsChargeTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDedicatedHostsChargeTypeResponseBody> body{};

  ModifyDedicatedHostsChargeTypeResponse() {}

  explicit ModifyDedicatedHostsChargeTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDedicatedHostsChargeTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDedicatedHostsChargeTypeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDedicatedHostsChargeTypeResponse() = default;
};
class ModifyDemandRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> demandId{};
  shared_ptr<string> demandName{};
  shared_ptr<string> demandDescription{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> amount{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  ModifyDemandRequest() {}

  explicit ModifyDemandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (demandId) {
      res["DemandId"] = boost::any(*demandId);
    }
    if (demandName) {
      res["DemandName"] = boost::any(*demandName);
    }
    if (demandDescription) {
      res["DemandDescription"] = boost::any(*demandDescription);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("DemandId") != m.end() && !m["DemandId"].empty()) {
      demandId = make_shared<string>(boost::any_cast<string>(m["DemandId"]));
    }
    if (m.find("DemandName") != m.end() && !m["DemandName"].empty()) {
      demandName = make_shared<string>(boost::any_cast<string>(m["DemandName"]));
    }
    if (m.find("DemandDescription") != m.end() && !m["DemandDescription"].empty()) {
      demandDescription = make_shared<string>(boost::any_cast<string>(m["DemandDescription"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~ModifyDemandRequest() = default;
};
class ModifyDemandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDemandResponseBody() {}

  explicit ModifyDemandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDemandResponseBody() = default;
};
class ModifyDemandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDemandResponseBody> body{};

  ModifyDemandResponse() {}

  explicit ModifyDemandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDemandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDemandResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDemandResponse() = default;
};
class ModifyDeploymentSetAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> deploymentSetId{};
  shared_ptr<string> description{};
  shared_ptr<string> deploymentSetName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ownerAccount{};

  ModifyDeploymentSetAttributeRequest() {}

  explicit ModifyDeploymentSetAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (deploymentSetId) {
      res["DeploymentSetId"] = boost::any(*deploymentSetId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (deploymentSetName) {
      res["DeploymentSetName"] = boost::any(*deploymentSetName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DeploymentSetId") != m.end() && !m["DeploymentSetId"].empty()) {
      deploymentSetId = make_shared<string>(boost::any_cast<string>(m["DeploymentSetId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeploymentSetName") != m.end() && !m["DeploymentSetName"].empty()) {
      deploymentSetName = make_shared<string>(boost::any_cast<string>(m["DeploymentSetName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ModifyDeploymentSetAttributeRequest() = default;
};
class ModifyDeploymentSetAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDeploymentSetAttributeResponseBody() {}

  explicit ModifyDeploymentSetAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDeploymentSetAttributeResponseBody() = default;
};
class ModifyDeploymentSetAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDeploymentSetAttributeResponseBody> body{};

  ModifyDeploymentSetAttributeResponse() {}

  explicit ModifyDeploymentSetAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDeploymentSetAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDeploymentSetAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDeploymentSetAttributeResponse() = default;
};
class ModifyDiskAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> diskId{};
  shared_ptr<string> diskName{};
  shared_ptr<string> description{};
  shared_ptr<bool> deleteWithInstance{};
  shared_ptr<bool> deleteAutoSnapshot{};
  shared_ptr<bool> enableAutoSnapshot{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> diskIds{};

  ModifyDiskAttributeRequest() {}

  explicit ModifyDiskAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    if (deleteAutoSnapshot) {
      res["DeleteAutoSnapshot"] = boost::any(*deleteAutoSnapshot);
    }
    if (enableAutoSnapshot) {
      res["EnableAutoSnapshot"] = boost::any(*enableAutoSnapshot);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (diskIds) {
      res["DiskIds"] = boost::any(*diskIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<bool>(boost::any_cast<bool>(m["DeleteWithInstance"]));
    }
    if (m.find("DeleteAutoSnapshot") != m.end() && !m["DeleteAutoSnapshot"].empty()) {
      deleteAutoSnapshot = make_shared<bool>(boost::any_cast<bool>(m["DeleteAutoSnapshot"]));
    }
    if (m.find("EnableAutoSnapshot") != m.end() && !m["EnableAutoSnapshot"].empty()) {
      enableAutoSnapshot = make_shared<bool>(boost::any_cast<bool>(m["EnableAutoSnapshot"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DiskIds") != m.end() && !m["DiskIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DiskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DiskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      diskIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyDiskAttributeRequest() = default;
};
class ModifyDiskAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDiskAttributeResponseBody() {}

  explicit ModifyDiskAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDiskAttributeResponseBody() = default;
};
class ModifyDiskAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDiskAttributeResponseBody> body{};

  ModifyDiskAttributeResponse() {}

  explicit ModifyDiskAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDiskAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDiskAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDiskAttributeResponse() = default;
};
class ModifyDiskChargeTypeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> diskIds{};
  shared_ptr<bool> autoPay{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> diskChargeType{};

  ModifyDiskChargeTypeRequest() {}

  explicit ModifyDiskChargeTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (diskIds) {
      res["DiskIds"] = boost::any(*diskIds);
    }
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (diskChargeType) {
      res["DiskChargeType"] = boost::any(*diskChargeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DiskIds") != m.end() && !m["DiskIds"].empty()) {
      diskIds = make_shared<string>(boost::any_cast<string>(m["DiskIds"]));
    }
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DiskChargeType") != m.end() && !m["DiskChargeType"].empty()) {
      diskChargeType = make_shared<string>(boost::any_cast<string>(m["DiskChargeType"]));
    }
  }


  virtual ~ModifyDiskChargeTypeRequest() = default;
};
class ModifyDiskChargeTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  ModifyDiskChargeTypeResponseBody() {}

  explicit ModifyDiskChargeTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDiskChargeTypeResponseBody() = default;
};
class ModifyDiskChargeTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDiskChargeTypeResponseBody> body{};

  ModifyDiskChargeTypeResponse() {}

  explicit ModifyDiskChargeTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDiskChargeTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDiskChargeTypeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDiskChargeTypeResponse() = default;
};
class ModifyDiskSpecRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> diskId{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<string> diskCategory{};
  shared_ptr<bool> dryRun{};

  ModifyDiskSpecRequest() {}

  explicit ModifyDiskSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (diskCategory) {
      res["DiskCategory"] = boost::any(*diskCategory);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("DiskCategory") != m.end() && !m["DiskCategory"].empty()) {
      diskCategory = make_shared<string>(boost::any_cast<string>(m["DiskCategory"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
  }


  virtual ~ModifyDiskSpecRequest() = default;
};
class ModifyDiskSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> orderId{};

  ModifyDiskSpecResponseBody() {}

  explicit ModifyDiskSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~ModifyDiskSpecResponseBody() = default;
};
class ModifyDiskSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDiskSpecResponseBody> body{};

  ModifyDiskSpecResponse() {}

  explicit ModifyDiskSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDiskSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDiskSpecResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDiskSpecResponse() = default;
};
class ModifyEipAddressAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> allocationId{};
  shared_ptr<string> bandwidth{};
  shared_ptr<string> ownerAccount{};

  ModifyEipAddressAttributeRequest() {}

  explicit ModifyEipAddressAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<string>(boost::any_cast<string>(m["Bandwidth"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ModifyEipAddressAttributeRequest() = default;
};
class ModifyEipAddressAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyEipAddressAttributeResponseBody() {}

  explicit ModifyEipAddressAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyEipAddressAttributeResponseBody() = default;
};
class ModifyEipAddressAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyEipAddressAttributeResponseBody> body{};

  ModifyEipAddressAttributeResponse() {}

  explicit ModifyEipAddressAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyEipAddressAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyEipAddressAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyEipAddressAttributeResponse() = default;
};
class ModifyElasticityAssuranceRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  ModifyElasticityAssuranceRequestPrivatePoolOptions() {}

  explicit ModifyElasticityAssuranceRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ModifyElasticityAssuranceRequestPrivatePoolOptions() = default;
};
class ModifyElasticityAssuranceRequest : public Darabonba::Model {
public:
  shared_ptr<ModifyElasticityAssuranceRequestPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> description{};

  ModifyElasticityAssuranceRequest() {}

  explicit ModifyElasticityAssuranceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privatePoolOptions) {
      res["PrivatePoolOptions"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolOptions"].type()) {
        ModifyElasticityAssuranceRequestPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolOptions"]));
        privatePoolOptions = make_shared<ModifyElasticityAssuranceRequestPrivatePoolOptions>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~ModifyElasticityAssuranceRequest() = default;
};
class ModifyElasticityAssuranceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyElasticityAssuranceResponseBody() {}

  explicit ModifyElasticityAssuranceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyElasticityAssuranceResponseBody() = default;
};
class ModifyElasticityAssuranceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyElasticityAssuranceResponseBody> body{};

  ModifyElasticityAssuranceResponse() {}

  explicit ModifyElasticityAssuranceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyElasticityAssuranceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyElasticityAssuranceResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyElasticityAssuranceResponse() = default;
};
class ModifyForwardEntryRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> forwardTableId{};
  shared_ptr<string> forwardEntryId{};
  shared_ptr<string> externalIp{};
  shared_ptr<string> externalPort{};
  shared_ptr<string> internalIp{};
  shared_ptr<string> internalPort{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> regionId{};

  ModifyForwardEntryRequest() {}

  explicit ModifyForwardEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (forwardTableId) {
      res["ForwardTableId"] = boost::any(*forwardTableId);
    }
    if (forwardEntryId) {
      res["ForwardEntryId"] = boost::any(*forwardEntryId);
    }
    if (externalIp) {
      res["ExternalIp"] = boost::any(*externalIp);
    }
    if (externalPort) {
      res["ExternalPort"] = boost::any(*externalPort);
    }
    if (internalIp) {
      res["InternalIp"] = boost::any(*internalIp);
    }
    if (internalPort) {
      res["InternalPort"] = boost::any(*internalPort);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ForwardTableId") != m.end() && !m["ForwardTableId"].empty()) {
      forwardTableId = make_shared<string>(boost::any_cast<string>(m["ForwardTableId"]));
    }
    if (m.find("ForwardEntryId") != m.end() && !m["ForwardEntryId"].empty()) {
      forwardEntryId = make_shared<string>(boost::any_cast<string>(m["ForwardEntryId"]));
    }
    if (m.find("ExternalIp") != m.end() && !m["ExternalIp"].empty()) {
      externalIp = make_shared<string>(boost::any_cast<string>(m["ExternalIp"]));
    }
    if (m.find("ExternalPort") != m.end() && !m["ExternalPort"].empty()) {
      externalPort = make_shared<string>(boost::any_cast<string>(m["ExternalPort"]));
    }
    if (m.find("InternalIp") != m.end() && !m["InternalIp"].empty()) {
      internalIp = make_shared<string>(boost::any_cast<string>(m["InternalIp"]));
    }
    if (m.find("InternalPort") != m.end() && !m["InternalPort"].empty()) {
      internalPort = make_shared<string>(boost::any_cast<string>(m["InternalPort"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyForwardEntryRequest() = default;
};
class ModifyForwardEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyForwardEntryResponseBody() {}

  explicit ModifyForwardEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyForwardEntryResponseBody() = default;
};
class ModifyForwardEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyForwardEntryResponseBody> body{};

  ModifyForwardEntryResponse() {}

  explicit ModifyForwardEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyForwardEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyForwardEntryResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyForwardEntryResponse() = default;
};
class ModifyHaVipAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> haVipId{};
  shared_ptr<string> description{};

  ModifyHaVipAttributeRequest() {}

  explicit ModifyHaVipAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (haVipId) {
      res["HaVipId"] = boost::any(*haVipId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("HaVipId") != m.end() && !m["HaVipId"].empty()) {
      haVipId = make_shared<string>(boost::any_cast<string>(m["HaVipId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~ModifyHaVipAttributeRequest() = default;
};
class ModifyHaVipAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyHaVipAttributeResponseBody() {}

  explicit ModifyHaVipAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyHaVipAttributeResponseBody() = default;
};
class ModifyHaVipAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyHaVipAttributeResponseBody> body{};

  ModifyHaVipAttributeResponse() {}

  explicit ModifyHaVipAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHaVipAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHaVipAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHaVipAttributeResponse() = default;
};
class ModifyHpcClusterAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> hpcClusterId{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};

  ModifyHpcClusterAttributeRequest() {}

  explicit ModifyHpcClusterAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (hpcClusterId) {
      res["HpcClusterId"] = boost::any(*hpcClusterId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("HpcClusterId") != m.end() && !m["HpcClusterId"].empty()) {
      hpcClusterId = make_shared<string>(boost::any_cast<string>(m["HpcClusterId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ModifyHpcClusterAttributeRequest() = default;
};
class ModifyHpcClusterAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyHpcClusterAttributeResponseBody() {}

  explicit ModifyHpcClusterAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyHpcClusterAttributeResponseBody() = default;
};
class ModifyHpcClusterAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyHpcClusterAttributeResponseBody> body{};

  ModifyHpcClusterAttributeResponse() {}

  explicit ModifyHpcClusterAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHpcClusterAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHpcClusterAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHpcClusterAttributeResponse() = default;
};
class ModifyImageAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<string> status{};
  shared_ptr<string> imageFamily{};
  shared_ptr<string> bootMode{};
  shared_ptr<string> licenseType{};
  shared_ptr<string> description{};
  shared_ptr<string> ownerAccount{};

  ModifyImageAttributeRequest() {}

  explicit ModifyImageAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (imageFamily) {
      res["ImageFamily"] = boost::any(*imageFamily);
    }
    if (bootMode) {
      res["BootMode"] = boost::any(*bootMode);
    }
    if (licenseType) {
      res["LicenseType"] = boost::any(*licenseType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ImageFamily") != m.end() && !m["ImageFamily"].empty()) {
      imageFamily = make_shared<string>(boost::any_cast<string>(m["ImageFamily"]));
    }
    if (m.find("BootMode") != m.end() && !m["BootMode"].empty()) {
      bootMode = make_shared<string>(boost::any_cast<string>(m["BootMode"]));
    }
    if (m.find("LicenseType") != m.end() && !m["LicenseType"].empty()) {
      licenseType = make_shared<string>(boost::any_cast<string>(m["LicenseType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ModifyImageAttributeRequest() = default;
};
class ModifyImageAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyImageAttributeResponseBody() {}

  explicit ModifyImageAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyImageAttributeResponseBody() = default;
};
class ModifyImageAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyImageAttributeResponseBody> body{};

  ModifyImageAttributeResponse() {}

  explicit ModifyImageAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyImageAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyImageAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyImageAttributeResponse() = default;
};
class ModifyImageShareGroupPermissionRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> addGroup{};
  shared_ptr<vector<string>> removeGroup{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> ownerAccount{};

  ModifyImageShareGroupPermissionRequest() {}

  explicit ModifyImageShareGroupPermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addGroup) {
      res["AddGroup"] = boost::any(*addGroup);
    }
    if (removeGroup) {
      res["RemoveGroup"] = boost::any(*removeGroup);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddGroup") != m.end() && !m["AddGroup"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AddGroup"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AddGroup"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      addGroup = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RemoveGroup") != m.end() && !m["RemoveGroup"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RemoveGroup"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RemoveGroup"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      removeGroup = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ModifyImageShareGroupPermissionRequest() = default;
};
class ModifyImageShareGroupPermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyImageShareGroupPermissionResponseBody() {}

  explicit ModifyImageShareGroupPermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyImageShareGroupPermissionResponseBody() = default;
};
class ModifyImageShareGroupPermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyImageShareGroupPermissionResponseBody> body{};

  ModifyImageShareGroupPermissionResponse() {}

  explicit ModifyImageShareGroupPermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyImageShareGroupPermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyImageShareGroupPermissionResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyImageShareGroupPermissionResponse() = default;
};
class ModifyImageSharePermissionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> launchPermission{};
  shared_ptr<vector<string>> addAccount{};
  shared_ptr<vector<string>> removeAccount{};
  shared_ptr<bool> isPublic{};

  ModifyImageSharePermissionRequest() {}

  explicit ModifyImageSharePermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (launchPermission) {
      res["LaunchPermission"] = boost::any(*launchPermission);
    }
    if (addAccount) {
      res["AddAccount"] = boost::any(*addAccount);
    }
    if (removeAccount) {
      res["RemoveAccount"] = boost::any(*removeAccount);
    }
    if (isPublic) {
      res["IsPublic"] = boost::any(*isPublic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("LaunchPermission") != m.end() && !m["LaunchPermission"].empty()) {
      launchPermission = make_shared<string>(boost::any_cast<string>(m["LaunchPermission"]));
    }
    if (m.find("AddAccount") != m.end() && !m["AddAccount"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AddAccount"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AddAccount"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      addAccount = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RemoveAccount") != m.end() && !m["RemoveAccount"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RemoveAccount"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RemoveAccount"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      removeAccount = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IsPublic") != m.end() && !m["IsPublic"].empty()) {
      isPublic = make_shared<bool>(boost::any_cast<bool>(m["IsPublic"]));
    }
  }


  virtual ~ModifyImageSharePermissionRequest() = default;
};
class ModifyImageSharePermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyImageSharePermissionResponseBody() {}

  explicit ModifyImageSharePermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyImageSharePermissionResponseBody() = default;
};
class ModifyImageSharePermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyImageSharePermissionResponseBody> body{};

  ModifyImageSharePermissionResponse() {}

  explicit ModifyImageSharePermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyImageSharePermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyImageSharePermissionResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyImageSharePermissionResponse() = default;
};
class ModifyInstanceAttachmentAttributesRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> matchCriteria{};
  shared_ptr<string> id{};

  ModifyInstanceAttachmentAttributesRequestPrivatePoolOptions() {}

  explicit ModifyInstanceAttachmentAttributesRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchCriteria) {
      res["MatchCriteria"] = boost::any(*matchCriteria);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MatchCriteria") != m.end() && !m["MatchCriteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["MatchCriteria"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ModifyInstanceAttachmentAttributesRequestPrivatePoolOptions() = default;
};
class ModifyInstanceAttachmentAttributesRequest : public Darabonba::Model {
public:
  shared_ptr<ModifyInstanceAttachmentAttributesRequestPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceId{};

  ModifyInstanceAttachmentAttributesRequest() {}

  explicit ModifyInstanceAttachmentAttributesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privatePoolOptions) {
      res["PrivatePoolOptions"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolOptions"].type()) {
        ModifyInstanceAttachmentAttributesRequestPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolOptions"]));
        privatePoolOptions = make_shared<ModifyInstanceAttachmentAttributesRequestPrivatePoolOptions>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ModifyInstanceAttachmentAttributesRequest() = default;
};
class ModifyInstanceAttachmentAttributesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceAttachmentAttributesResponseBody() {}

  explicit ModifyInstanceAttachmentAttributesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceAttachmentAttributesResponseBody() = default;
};
class ModifyInstanceAttachmentAttributesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyInstanceAttachmentAttributesResponseBody> body{};

  ModifyInstanceAttachmentAttributesResponse() {}

  explicit ModifyInstanceAttachmentAttributesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceAttachmentAttributesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceAttachmentAttributesResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceAttachmentAttributesResponse() = default;
};
class ModifyInstanceAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> password{};
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> description{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> userData{};
  shared_ptr<bool> recyclable{};
  shared_ptr<string> creditSpecification{};
  shared_ptr<bool> deletionProtection{};
  shared_ptr<long> networkInterfaceQueueNumber{};
  shared_ptr<vector<string>> securityGroupIds{};

  ModifyInstanceAttributeRequest() {}

  explicit ModifyInstanceAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (recyclable) {
      res["Recyclable"] = boost::any(*recyclable);
    }
    if (creditSpecification) {
      res["CreditSpecification"] = boost::any(*creditSpecification);
    }
    if (deletionProtection) {
      res["DeletionProtection"] = boost::any(*deletionProtection);
    }
    if (networkInterfaceQueueNumber) {
      res["NetworkInterfaceQueueNumber"] = boost::any(*networkInterfaceQueueNumber);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Recyclable") != m.end() && !m["Recyclable"].empty()) {
      recyclable = make_shared<bool>(boost::any_cast<bool>(m["Recyclable"]));
    }
    if (m.find("CreditSpecification") != m.end() && !m["CreditSpecification"].empty()) {
      creditSpecification = make_shared<string>(boost::any_cast<string>(m["CreditSpecification"]));
    }
    if (m.find("DeletionProtection") != m.end() && !m["DeletionProtection"].empty()) {
      deletionProtection = make_shared<bool>(boost::any_cast<bool>(m["DeletionProtection"]));
    }
    if (m.find("NetworkInterfaceQueueNumber") != m.end() && !m["NetworkInterfaceQueueNumber"].empty()) {
      networkInterfaceQueueNumber = make_shared<long>(boost::any_cast<long>(m["NetworkInterfaceQueueNumber"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyInstanceAttributeRequest() = default;
};
class ModifyInstanceAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceAttributeResponseBody() {}

  explicit ModifyInstanceAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceAttributeResponseBody() = default;
};
class ModifyInstanceAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyInstanceAttributeResponseBody> body{};

  ModifyInstanceAttributeResponse() {}

  explicit ModifyInstanceAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceAttributeResponse() = default;
};
class ModifyInstanceAutoReleaseTimeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> autoReleaseTime{};
  shared_ptr<string> ownerAccount{};

  ModifyInstanceAutoReleaseTimeRequest() {}

  explicit ModifyInstanceAutoReleaseTimeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (autoReleaseTime) {
      res["AutoReleaseTime"] = boost::any(*autoReleaseTime);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("AutoReleaseTime") != m.end() && !m["AutoReleaseTime"].empty()) {
      autoReleaseTime = make_shared<string>(boost::any_cast<string>(m["AutoReleaseTime"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ModifyInstanceAutoReleaseTimeRequest() = default;
};
class ModifyInstanceAutoReleaseTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceAutoReleaseTimeResponseBody() {}

  explicit ModifyInstanceAutoReleaseTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceAutoReleaseTimeResponseBody() = default;
};
class ModifyInstanceAutoReleaseTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyInstanceAutoReleaseTimeResponseBody> body{};

  ModifyInstanceAutoReleaseTimeResponse() {}

  explicit ModifyInstanceAutoReleaseTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceAutoReleaseTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceAutoReleaseTimeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceAutoReleaseTimeResponse() = default;
};
class ModifyInstanceAutoRenewAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> duration{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<string> renewalStatus{};
  shared_ptr<string> periodUnit{};

  ModifyInstanceAutoRenewAttributeRequest() {}

  explicit ModifyInstanceAutoRenewAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (renewalStatus) {
      res["RenewalStatus"] = boost::any(*renewalStatus);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("RenewalStatus") != m.end() && !m["RenewalStatus"].empty()) {
      renewalStatus = make_shared<string>(boost::any_cast<string>(m["RenewalStatus"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
  }


  virtual ~ModifyInstanceAutoRenewAttributeRequest() = default;
};
class ModifyInstanceAutoRenewAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceAutoRenewAttributeResponseBody() {}

  explicit ModifyInstanceAutoRenewAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceAutoRenewAttributeResponseBody() = default;
};
class ModifyInstanceAutoRenewAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyInstanceAutoRenewAttributeResponseBody> body{};

  ModifyInstanceAutoRenewAttributeResponse() {}

  explicit ModifyInstanceAutoRenewAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceAutoRenewAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceAutoRenewAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceAutoRenewAttributeResponse() = default;
};
class ModifyInstanceChargeTypeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> regionId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<bool> includeDataDisks{};
  shared_ptr<bool> dryRun{};
  shared_ptr<bool> autoPay{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<bool> isDetailFee{};

  ModifyInstanceChargeTypeRequest() {}

  explicit ModifyInstanceChargeTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (includeDataDisks) {
      res["IncludeDataDisks"] = boost::any(*includeDataDisks);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (isDetailFee) {
      res["IsDetailFee"] = boost::any(*isDetailFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("IncludeDataDisks") != m.end() && !m["IncludeDataDisks"].empty()) {
      includeDataDisks = make_shared<bool>(boost::any_cast<bool>(m["IncludeDataDisks"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("IsDetailFee") != m.end() && !m["IsDetailFee"].empty()) {
      isDetailFee = make_shared<bool>(boost::any_cast<bool>(m["IsDetailFee"]));
    }
  }


  virtual ~ModifyInstanceChargeTypeRequest() = default;
};
class ModifyInstanceChargeTypeResponseBodyFeeOfInstancesFeeOfInstance : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> currency{};
  shared_ptr<string> fee{};

  ModifyInstanceChargeTypeResponseBodyFeeOfInstancesFeeOfInstance() {}

  explicit ModifyInstanceChargeTypeResponseBodyFeeOfInstancesFeeOfInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (fee) {
      res["Fee"] = boost::any(*fee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("Fee") != m.end() && !m["Fee"].empty()) {
      fee = make_shared<string>(boost::any_cast<string>(m["Fee"]));
    }
  }


  virtual ~ModifyInstanceChargeTypeResponseBodyFeeOfInstancesFeeOfInstance() = default;
};
class ModifyInstanceChargeTypeResponseBodyFeeOfInstances : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyInstanceChargeTypeResponseBodyFeeOfInstancesFeeOfInstance>> feeOfInstance{};

  ModifyInstanceChargeTypeResponseBodyFeeOfInstances() {}

  explicit ModifyInstanceChargeTypeResponseBodyFeeOfInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeOfInstance) {
      vector<boost::any> temp1;
      for(auto item1:*feeOfInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FeeOfInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FeeOfInstance") != m.end() && !m["FeeOfInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["FeeOfInstance"].type()) {
        vector<ModifyInstanceChargeTypeResponseBodyFeeOfInstancesFeeOfInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FeeOfInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyInstanceChargeTypeResponseBodyFeeOfInstancesFeeOfInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        feeOfInstance = make_shared<vector<ModifyInstanceChargeTypeResponseBodyFeeOfInstancesFeeOfInstance>>(expect1);
      }
    }
  }


  virtual ~ModifyInstanceChargeTypeResponseBodyFeeOfInstances() = default;
};
class ModifyInstanceChargeTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};
  shared_ptr<ModifyInstanceChargeTypeResponseBodyFeeOfInstances> feeOfInstances{};

  ModifyInstanceChargeTypeResponseBody() {}

  explicit ModifyInstanceChargeTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (feeOfInstances) {
      res["FeeOfInstances"] = feeOfInstances ? boost::any(feeOfInstances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("FeeOfInstances") != m.end() && !m["FeeOfInstances"].empty()) {
      if (typeid(map<string, boost::any>) == m["FeeOfInstances"].type()) {
        ModifyInstanceChargeTypeResponseBodyFeeOfInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FeeOfInstances"]));
        feeOfInstances = make_shared<ModifyInstanceChargeTypeResponseBodyFeeOfInstances>(model1);
      }
    }
  }


  virtual ~ModifyInstanceChargeTypeResponseBody() = default;
};
class ModifyInstanceChargeTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyInstanceChargeTypeResponseBody> body{};

  ModifyInstanceChargeTypeResponse() {}

  explicit ModifyInstanceChargeTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceChargeTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceChargeTypeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceChargeTypeResponse() = default;
};
class ModifyInstanceDeploymentRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> deploymentSetId{};
  shared_ptr<long> deploymentSetGroupNo{};
  shared_ptr<bool> force{};
  shared_ptr<string> affinity{};
  shared_ptr<string> tenancy{};
  shared_ptr<string> migrationType{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> dedicatedHostClusterId{};

  ModifyInstanceDeploymentRequest() {}

  explicit ModifyInstanceDeploymentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (deploymentSetId) {
      res["DeploymentSetId"] = boost::any(*deploymentSetId);
    }
    if (deploymentSetGroupNo) {
      res["DeploymentSetGroupNo"] = boost::any(*deploymentSetGroupNo);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (affinity) {
      res["Affinity"] = boost::any(*affinity);
    }
    if (tenancy) {
      res["Tenancy"] = boost::any(*tenancy);
    }
    if (migrationType) {
      res["MigrationType"] = boost::any(*migrationType);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("DeploymentSetId") != m.end() && !m["DeploymentSetId"].empty()) {
      deploymentSetId = make_shared<string>(boost::any_cast<string>(m["DeploymentSetId"]));
    }
    if (m.find("DeploymentSetGroupNo") != m.end() && !m["DeploymentSetGroupNo"].empty()) {
      deploymentSetGroupNo = make_shared<long>(boost::any_cast<long>(m["DeploymentSetGroupNo"]));
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
    if (m.find("Affinity") != m.end() && !m["Affinity"].empty()) {
      affinity = make_shared<string>(boost::any_cast<string>(m["Affinity"]));
    }
    if (m.find("Tenancy") != m.end() && !m["Tenancy"].empty()) {
      tenancy = make_shared<string>(boost::any_cast<string>(m["Tenancy"]));
    }
    if (m.find("MigrationType") != m.end() && !m["MigrationType"].empty()) {
      migrationType = make_shared<string>(boost::any_cast<string>(m["MigrationType"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
  }


  virtual ~ModifyInstanceDeploymentRequest() = default;
};
class ModifyInstanceDeploymentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceDeploymentResponseBody() {}

  explicit ModifyInstanceDeploymentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceDeploymentResponseBody() = default;
};
class ModifyInstanceDeploymentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyInstanceDeploymentResponseBody> body{};

  ModifyInstanceDeploymentResponse() {}

  explicit ModifyInstanceDeploymentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceDeploymentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceDeploymentResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceDeploymentResponse() = default;
};
class ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow() {}

  explicit ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow() = default;
};
class ModifyInstanceMaintenanceAttributesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<vector<ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow>> maintenanceWindow{};
  shared_ptr<string> regionId{};
  shared_ptr<string> actionOnMaintenance{};
  shared_ptr<bool> notifyOnMaintenance{};

  ModifyInstanceMaintenanceAttributesRequest() {}

  explicit ModifyInstanceMaintenanceAttributesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maintenanceWindow) {
      vector<boost::any> temp1;
      for(auto item1:*maintenanceWindow){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MaintenanceWindow"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (actionOnMaintenance) {
      res["ActionOnMaintenance"] = boost::any(*actionOnMaintenance);
    }
    if (notifyOnMaintenance) {
      res["NotifyOnMaintenance"] = boost::any(*notifyOnMaintenance);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaintenanceWindow") != m.end() && !m["MaintenanceWindow"].empty()) {
      if (typeid(vector<boost::any>) == m["MaintenanceWindow"].type()) {
        vector<ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MaintenanceWindow"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        maintenanceWindow = make_shared<vector<ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ActionOnMaintenance") != m.end() && !m["ActionOnMaintenance"].empty()) {
      actionOnMaintenance = make_shared<string>(boost::any_cast<string>(m["ActionOnMaintenance"]));
    }
    if (m.find("NotifyOnMaintenance") != m.end() && !m["NotifyOnMaintenance"].empty()) {
      notifyOnMaintenance = make_shared<bool>(boost::any_cast<bool>(m["NotifyOnMaintenance"]));
    }
  }


  virtual ~ModifyInstanceMaintenanceAttributesRequest() = default;
};
class ModifyInstanceMaintenanceAttributesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceMaintenanceAttributesResponseBody() {}

  explicit ModifyInstanceMaintenanceAttributesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceMaintenanceAttributesResponseBody() = default;
};
class ModifyInstanceMaintenanceAttributesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyInstanceMaintenanceAttributesResponseBody> body{};

  ModifyInstanceMaintenanceAttributesResponse() {}

  explicit ModifyInstanceMaintenanceAttributesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceMaintenanceAttributesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceMaintenanceAttributesResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceMaintenanceAttributesResponse() = default;
};
class ModifyInstanceMetadataOptionsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> httpEndpoint{};
  shared_ptr<string> httpTokens{};
  shared_ptr<long> httpPutResponseHopLimit{};

  ModifyInstanceMetadataOptionsRequest() {}

  explicit ModifyInstanceMetadataOptionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (httpEndpoint) {
      res["HttpEndpoint"] = boost::any(*httpEndpoint);
    }
    if (httpTokens) {
      res["HttpTokens"] = boost::any(*httpTokens);
    }
    if (httpPutResponseHopLimit) {
      res["HttpPutResponseHopLimit"] = boost::any(*httpPutResponseHopLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("HttpEndpoint") != m.end() && !m["HttpEndpoint"].empty()) {
      httpEndpoint = make_shared<string>(boost::any_cast<string>(m["HttpEndpoint"]));
    }
    if (m.find("HttpTokens") != m.end() && !m["HttpTokens"].empty()) {
      httpTokens = make_shared<string>(boost::any_cast<string>(m["HttpTokens"]));
    }
    if (m.find("HttpPutResponseHopLimit") != m.end() && !m["HttpPutResponseHopLimit"].empty()) {
      httpPutResponseHopLimit = make_shared<long>(boost::any_cast<long>(m["HttpPutResponseHopLimit"]));
    }
  }


  virtual ~ModifyInstanceMetadataOptionsRequest() = default;
};
class ModifyInstanceMetadataOptionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceMetadataOptionsResponseBody() {}

  explicit ModifyInstanceMetadataOptionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceMetadataOptionsResponseBody() = default;
};
class ModifyInstanceMetadataOptionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyInstanceMetadataOptionsResponseBody> body{};

  ModifyInstanceMetadataOptionsResponse() {}

  explicit ModifyInstanceMetadataOptionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceMetadataOptionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceMetadataOptionsResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceMetadataOptionsResponse() = default;
};
class ModifyInstanceNetworkSpecRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<long> internetMaxBandwidthIn{};
  shared_ptr<string> ISP{};
  shared_ptr<string> networkChargeType{};
  shared_ptr<bool> allocatePublicIp{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<bool> autoPay{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};

  ModifyInstanceNetworkSpecRequest() {}

  explicit ModifyInstanceNetworkSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (internetMaxBandwidthIn) {
      res["InternetMaxBandwidthIn"] = boost::any(*internetMaxBandwidthIn);
    }
    if (ISP) {
      res["ISP"] = boost::any(*ISP);
    }
    if (networkChargeType) {
      res["NetworkChargeType"] = boost::any(*networkChargeType);
    }
    if (allocatePublicIp) {
      res["AllocatePublicIp"] = boost::any(*allocatePublicIp);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("InternetMaxBandwidthIn") != m.end() && !m["InternetMaxBandwidthIn"].empty()) {
      internetMaxBandwidthIn = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthIn"]));
    }
    if (m.find("ISP") != m.end() && !m["ISP"].empty()) {
      ISP = make_shared<string>(boost::any_cast<string>(m["ISP"]));
    }
    if (m.find("NetworkChargeType") != m.end() && !m["NetworkChargeType"].empty()) {
      networkChargeType = make_shared<string>(boost::any_cast<string>(m["NetworkChargeType"]));
    }
    if (m.find("AllocatePublicIp") != m.end() && !m["AllocatePublicIp"].empty()) {
      allocatePublicIp = make_shared<bool>(boost::any_cast<bool>(m["AllocatePublicIp"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ModifyInstanceNetworkSpecRequest() = default;
};
class ModifyInstanceNetworkSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  ModifyInstanceNetworkSpecResponseBody() {}

  explicit ModifyInstanceNetworkSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceNetworkSpecResponseBody() = default;
};
class ModifyInstanceNetworkSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyInstanceNetworkSpecResponseBody> body{};

  ModifyInstanceNetworkSpecResponse() {}

  explicit ModifyInstanceNetworkSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceNetworkSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceNetworkSpecResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceNetworkSpecResponse() = default;
};
class ModifyInstanceSpecRequestTemporary : public Darabonba::Model {
public:
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> internetMaxBandwidthOut{};

  ModifyInstanceSpecRequestTemporary() {}

  explicit ModifyInstanceSpecRequestTemporary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
  }


  virtual ~ModifyInstanceSpecRequestTemporary() = default;
};
class ModifyInstanceSpecRequestSystemDisk : public Darabonba::Model {
public:
  shared_ptr<string> category{};

  ModifyInstanceSpecRequestSystemDisk() {}

  explicit ModifyInstanceSpecRequestSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
  }


  virtual ~ModifyInstanceSpecRequestSystemDisk() = default;
};
class ModifyInstanceSpecRequest : public Darabonba::Model {
public:
  shared_ptr<ModifyInstanceSpecRequestTemporary> temporary{};
  shared_ptr<ModifyInstanceSpecRequestSystemDisk> systemDisk{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<long> internetMaxBandwidthIn{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<bool> async{};
  shared_ptr<bool> allowMigrateAcrossZone{};
  shared_ptr<string> clientToken{};

  ModifyInstanceSpecRequest() {}

  explicit ModifyInstanceSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (temporary) {
      res["Temporary"] = temporary ? boost::any(temporary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (internetMaxBandwidthIn) {
      res["InternetMaxBandwidthIn"] = boost::any(*internetMaxBandwidthIn);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (allowMigrateAcrossZone) {
      res["AllowMigrateAcrossZone"] = boost::any(*allowMigrateAcrossZone);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Temporary") != m.end() && !m["Temporary"].empty()) {
      if (typeid(map<string, boost::any>) == m["Temporary"].type()) {
        ModifyInstanceSpecRequestTemporary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Temporary"]));
        temporary = make_shared<ModifyInstanceSpecRequestTemporary>(model1);
      }
    }
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        ModifyInstanceSpecRequestSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<ModifyInstanceSpecRequestSystemDisk>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("InternetMaxBandwidthIn") != m.end() && !m["InternetMaxBandwidthIn"].empty()) {
      internetMaxBandwidthIn = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthIn"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("AllowMigrateAcrossZone") != m.end() && !m["AllowMigrateAcrossZone"].empty()) {
      allowMigrateAcrossZone = make_shared<bool>(boost::any_cast<bool>(m["AllowMigrateAcrossZone"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~ModifyInstanceSpecRequest() = default;
};
class ModifyInstanceSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceSpecResponseBody() {}

  explicit ModifyInstanceSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceSpecResponseBody() = default;
};
class ModifyInstanceSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyInstanceSpecResponseBody> body{};

  ModifyInstanceSpecResponse() {}

  explicit ModifyInstanceSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceSpecResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceSpecResponse() = default;
};
class ModifyInstanceVncPasswdRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> vncPassword{};
  shared_ptr<string> ownerAccount{};

  ModifyInstanceVncPasswdRequest() {}

  explicit ModifyInstanceVncPasswdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vncPassword) {
      res["VncPassword"] = boost::any(*vncPassword);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VncPassword") != m.end() && !m["VncPassword"].empty()) {
      vncPassword = make_shared<string>(boost::any_cast<string>(m["VncPassword"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ModifyInstanceVncPasswdRequest() = default;
};
class ModifyInstanceVncPasswdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceVncPasswdResponseBody() {}

  explicit ModifyInstanceVncPasswdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceVncPasswdResponseBody() = default;
};
class ModifyInstanceVncPasswdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyInstanceVncPasswdResponseBody> body{};

  ModifyInstanceVncPasswdResponse() {}

  explicit ModifyInstanceVncPasswdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceVncPasswdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceVncPasswdResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceVncPasswdResponse() = default;
};
class ModifyInstanceVpcAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<vector<string>> securityGroupId{};

  ModifyInstanceVpcAttributeRequest() {}

  explicit ModifyInstanceVpcAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyInstanceVpcAttributeRequest() = default;
};
class ModifyInstanceVpcAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceVpcAttributeResponseBody() {}

  explicit ModifyInstanceVpcAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceVpcAttributeResponseBody() = default;
};
class ModifyInstanceVpcAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyInstanceVpcAttributeResponseBody> body{};

  ModifyInstanceVpcAttributeResponse() {}

  explicit ModifyInstanceVpcAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceVpcAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceVpcAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceVpcAttributeResponse() = default;
};
class ModifyLaunchTemplateDefaultVersionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> launchTemplateId{};
  shared_ptr<string> launchTemplateName{};
  shared_ptr<long> defaultVersionNumber{};

  ModifyLaunchTemplateDefaultVersionRequest() {}

  explicit ModifyLaunchTemplateDefaultVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (launchTemplateId) {
      res["LaunchTemplateId"] = boost::any(*launchTemplateId);
    }
    if (launchTemplateName) {
      res["LaunchTemplateName"] = boost::any(*launchTemplateName);
    }
    if (defaultVersionNumber) {
      res["DefaultVersionNumber"] = boost::any(*defaultVersionNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("LaunchTemplateId") != m.end() && !m["LaunchTemplateId"].empty()) {
      launchTemplateId = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateId"]));
    }
    if (m.find("LaunchTemplateName") != m.end() && !m["LaunchTemplateName"].empty()) {
      launchTemplateName = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateName"]));
    }
    if (m.find("DefaultVersionNumber") != m.end() && !m["DefaultVersionNumber"].empty()) {
      defaultVersionNumber = make_shared<long>(boost::any_cast<long>(m["DefaultVersionNumber"]));
    }
  }


  virtual ~ModifyLaunchTemplateDefaultVersionRequest() = default;
};
class ModifyLaunchTemplateDefaultVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyLaunchTemplateDefaultVersionResponseBody() {}

  explicit ModifyLaunchTemplateDefaultVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyLaunchTemplateDefaultVersionResponseBody() = default;
};
class ModifyLaunchTemplateDefaultVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyLaunchTemplateDefaultVersionResponseBody> body{};

  ModifyLaunchTemplateDefaultVersionResponse() {}

  explicit ModifyLaunchTemplateDefaultVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyLaunchTemplateDefaultVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyLaunchTemplateDefaultVersionResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyLaunchTemplateDefaultVersionResponse() = default;
};
class ModifyManagedInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};

  ModifyManagedInstanceRequest() {}

  explicit ModifyManagedInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
  }


  virtual ~ModifyManagedInstanceRequest() = default;
};
class ModifyManagedInstanceResponseBodyInstance : public Darabonba::Model {
public:
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceId{};

  ModifyManagedInstanceResponseBodyInstance() {}

  explicit ModifyManagedInstanceResponseBodyInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ModifyManagedInstanceResponseBodyInstance() = default;
};
class ModifyManagedInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ModifyManagedInstanceResponseBodyInstance> instance{};

  ModifyManagedInstanceResponseBody() {}

  explicit ModifyManagedInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instance) {
      res["Instance"] = instance ? boost::any(instance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instance"].type()) {
        ModifyManagedInstanceResponseBodyInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instance"]));
        instance = make_shared<ModifyManagedInstanceResponseBodyInstance>(model1);
      }
    }
  }


  virtual ~ModifyManagedInstanceResponseBody() = default;
};
class ModifyManagedInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyManagedInstanceResponseBody> body{};

  ModifyManagedInstanceResponse() {}

  explicit ModifyManagedInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyManagedInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyManagedInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyManagedInstanceResponse() = default;
};
class ModifyNetworkInterfaceAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> securityGroupId{};
  shared_ptr<string> networkInterfaceName{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<long> queueNumber{};
  shared_ptr<string> description{};

  ModifyNetworkInterfaceAttributeRequest() {}

  explicit ModifyNetworkInterfaceAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (networkInterfaceName) {
      res["NetworkInterfaceName"] = boost::any(*networkInterfaceName);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (queueNumber) {
      res["QueueNumber"] = boost::any(*queueNumber);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NetworkInterfaceName") != m.end() && !m["NetworkInterfaceName"].empty()) {
      networkInterfaceName = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceName"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("QueueNumber") != m.end() && !m["QueueNumber"].empty()) {
      queueNumber = make_shared<long>(boost::any_cast<long>(m["QueueNumber"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~ModifyNetworkInterfaceAttributeRequest() = default;
};
class ModifyNetworkInterfaceAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyNetworkInterfaceAttributeResponseBody() {}

  explicit ModifyNetworkInterfaceAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyNetworkInterfaceAttributeResponseBody() = default;
};
class ModifyNetworkInterfaceAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyNetworkInterfaceAttributeResponseBody> body{};

  ModifyNetworkInterfaceAttributeResponse() {}

  explicit ModifyNetworkInterfaceAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyNetworkInterfaceAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyNetworkInterfaceAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyNetworkInterfaceAttributeResponse() = default;
};
class ModifyPhysicalConnectionAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<string> lineOperator{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> peerLocation{};
  shared_ptr<string> portType{};
  shared_ptr<string> redundantPhysicalConnectionId{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> clientToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> userCidr{};
  shared_ptr<string> circuitCode{};

  ModifyPhysicalConnectionAttributeRequest() {}

  explicit ModifyPhysicalConnectionAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (lineOperator) {
      res["LineOperator"] = boost::any(*lineOperator);
    }
    if (bandwidth) {
      res["bandwidth"] = boost::any(*bandwidth);
    }
    if (peerLocation) {
      res["PeerLocation"] = boost::any(*peerLocation);
    }
    if (portType) {
      res["PortType"] = boost::any(*portType);
    }
    if (redundantPhysicalConnectionId) {
      res["RedundantPhysicalConnectionId"] = boost::any(*redundantPhysicalConnectionId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (userCidr) {
      res["UserCidr"] = boost::any(*userCidr);
    }
    if (circuitCode) {
      res["CircuitCode"] = boost::any(*circuitCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("LineOperator") != m.end() && !m["LineOperator"].empty()) {
      lineOperator = make_shared<string>(boost::any_cast<string>(m["LineOperator"]));
    }
    if (m.find("bandwidth") != m.end() && !m["bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["bandwidth"]));
    }
    if (m.find("PeerLocation") != m.end() && !m["PeerLocation"].empty()) {
      peerLocation = make_shared<string>(boost::any_cast<string>(m["PeerLocation"]));
    }
    if (m.find("PortType") != m.end() && !m["PortType"].empty()) {
      portType = make_shared<string>(boost::any_cast<string>(m["PortType"]));
    }
    if (m.find("RedundantPhysicalConnectionId") != m.end() && !m["RedundantPhysicalConnectionId"].empty()) {
      redundantPhysicalConnectionId = make_shared<string>(boost::any_cast<string>(m["RedundantPhysicalConnectionId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("UserCidr") != m.end() && !m["UserCidr"].empty()) {
      userCidr = make_shared<string>(boost::any_cast<string>(m["UserCidr"]));
    }
    if (m.find("CircuitCode") != m.end() && !m["CircuitCode"].empty()) {
      circuitCode = make_shared<string>(boost::any_cast<string>(m["CircuitCode"]));
    }
  }


  virtual ~ModifyPhysicalConnectionAttributeRequest() = default;
};
class ModifyPhysicalConnectionAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyPhysicalConnectionAttributeResponseBody() {}

  explicit ModifyPhysicalConnectionAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyPhysicalConnectionAttributeResponseBody() = default;
};
class ModifyPhysicalConnectionAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyPhysicalConnectionAttributeResponseBody> body{};

  ModifyPhysicalConnectionAttributeResponse() {}

  explicit ModifyPhysicalConnectionAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyPhysicalConnectionAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyPhysicalConnectionAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyPhysicalConnectionAttributeResponse() = default;
};
class ModifyPrefixListRequestAddEntry : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> cidr{};

  ModifyPrefixListRequestAddEntry() {}

  explicit ModifyPrefixListRequestAddEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (cidr) {
      res["Cidr"] = boost::any(*cidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Cidr") != m.end() && !m["Cidr"].empty()) {
      cidr = make_shared<string>(boost::any_cast<string>(m["Cidr"]));
    }
  }


  virtual ~ModifyPrefixListRequestAddEntry() = default;
};
class ModifyPrefixListRequestRemoveEntry : public Darabonba::Model {
public:
  shared_ptr<string> cidr{};

  ModifyPrefixListRequestRemoveEntry() {}

  explicit ModifyPrefixListRequestRemoveEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidr) {
      res["Cidr"] = boost::any(*cidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cidr") != m.end() && !m["Cidr"].empty()) {
      cidr = make_shared<string>(boost::any_cast<string>(m["Cidr"]));
    }
  }


  virtual ~ModifyPrefixListRequestRemoveEntry() = default;
};
class ModifyPrefixListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<ModifyPrefixListRequestAddEntry>> addEntry{};
  shared_ptr<vector<ModifyPrefixListRequestRemoveEntry>> removeEntry{};
  shared_ptr<string> prefixListId{};
  shared_ptr<string> prefixListName{};
  shared_ptr<string> description{};

  ModifyPrefixListRequest() {}

  explicit ModifyPrefixListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (addEntry) {
      vector<boost::any> temp1;
      for(auto item1:*addEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AddEntry"] = boost::any(temp1);
    }
    if (removeEntry) {
      vector<boost::any> temp1;
      for(auto item1:*removeEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RemoveEntry"] = boost::any(temp1);
    }
    if (prefixListId) {
      res["PrefixListId"] = boost::any(*prefixListId);
    }
    if (prefixListName) {
      res["PrefixListName"] = boost::any(*prefixListName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AddEntry") != m.end() && !m["AddEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["AddEntry"].type()) {
        vector<ModifyPrefixListRequestAddEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AddEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyPrefixListRequestAddEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addEntry = make_shared<vector<ModifyPrefixListRequestAddEntry>>(expect1);
      }
    }
    if (m.find("RemoveEntry") != m.end() && !m["RemoveEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["RemoveEntry"].type()) {
        vector<ModifyPrefixListRequestRemoveEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RemoveEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyPrefixListRequestRemoveEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        removeEntry = make_shared<vector<ModifyPrefixListRequestRemoveEntry>>(expect1);
      }
    }
    if (m.find("PrefixListId") != m.end() && !m["PrefixListId"].empty()) {
      prefixListId = make_shared<string>(boost::any_cast<string>(m["PrefixListId"]));
    }
    if (m.find("PrefixListName") != m.end() && !m["PrefixListName"].empty()) {
      prefixListName = make_shared<string>(boost::any_cast<string>(m["PrefixListName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~ModifyPrefixListRequest() = default;
};
class ModifyPrefixListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyPrefixListResponseBody() {}

  explicit ModifyPrefixListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyPrefixListResponseBody() = default;
};
class ModifyPrefixListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyPrefixListResponseBody> body{};

  ModifyPrefixListResponse() {}

  explicit ModifyPrefixListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyPrefixListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyPrefixListResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyPrefixListResponse() = default;
};
class ModifyPrepayInstanceSpecRequestSystemDisk : public Darabonba::Model {
public:
  shared_ptr<string> category{};

  ModifyPrepayInstanceSpecRequestSystemDisk() {}

  explicit ModifyPrepayInstanceSpecRequestSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
  }


  virtual ~ModifyPrepayInstanceSpecRequestSystemDisk() = default;
};
class ModifyPrepayInstanceSpecRequest : public Darabonba::Model {
public:
  shared_ptr<ModifyPrepayInstanceSpecRequestSystemDisk> systemDisk{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> operatorType{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> autoPay{};
  shared_ptr<bool> migrateAcrossZone{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> rebootTime{};
  shared_ptr<string> endTime{};
  shared_ptr<bool> rebootWhenFinished{};

  ModifyPrepayInstanceSpecRequest() {}

  explicit ModifyPrepayInstanceSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (operatorType) {
      res["OperatorType"] = boost::any(*operatorType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (migrateAcrossZone) {
      res["MigrateAcrossZone"] = boost::any(*migrateAcrossZone);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (rebootTime) {
      res["RebootTime"] = boost::any(*rebootTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (rebootWhenFinished) {
      res["RebootWhenFinished"] = boost::any(*rebootWhenFinished);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        ModifyPrepayInstanceSpecRequestSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<ModifyPrepayInstanceSpecRequestSystemDisk>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OperatorType") != m.end() && !m["OperatorType"].empty()) {
      operatorType = make_shared<string>(boost::any_cast<string>(m["OperatorType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("MigrateAcrossZone") != m.end() && !m["MigrateAcrossZone"].empty()) {
      migrateAcrossZone = make_shared<bool>(boost::any_cast<bool>(m["MigrateAcrossZone"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RebootTime") != m.end() && !m["RebootTime"].empty()) {
      rebootTime = make_shared<string>(boost::any_cast<string>(m["RebootTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RebootWhenFinished") != m.end() && !m["RebootWhenFinished"].empty()) {
      rebootWhenFinished = make_shared<bool>(boost::any_cast<bool>(m["RebootWhenFinished"]));
    }
  }


  virtual ~ModifyPrepayInstanceSpecRequest() = default;
};
class ModifyPrepayInstanceSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  ModifyPrepayInstanceSpecResponseBody() {}

  explicit ModifyPrepayInstanceSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyPrepayInstanceSpecResponseBody() = default;
};
class ModifyPrepayInstanceSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyPrepayInstanceSpecResponseBody> body{};

  ModifyPrepayInstanceSpecResponse() {}

  explicit ModifyPrepayInstanceSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyPrepayInstanceSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyPrepayInstanceSpecResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyPrepayInstanceSpecResponse() = default;
};
class ModifyReservedInstanceAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> reservedInstanceId{};
  shared_ptr<string> reservedInstanceName{};
  shared_ptr<string> description{};

  ModifyReservedInstanceAttributeRequest() {}

  explicit ModifyReservedInstanceAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reservedInstanceId) {
      res["ReservedInstanceId"] = boost::any(*reservedInstanceId);
    }
    if (reservedInstanceName) {
      res["ReservedInstanceName"] = boost::any(*reservedInstanceName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReservedInstanceId") != m.end() && !m["ReservedInstanceId"].empty()) {
      reservedInstanceId = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceId"]));
    }
    if (m.find("ReservedInstanceName") != m.end() && !m["ReservedInstanceName"].empty()) {
      reservedInstanceName = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~ModifyReservedInstanceAttributeRequest() = default;
};
class ModifyReservedInstanceAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ModifyReservedInstanceAttributeResponseBody() {}

  explicit ModifyReservedInstanceAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyReservedInstanceAttributeResponseBody() = default;
};
class ModifyReservedInstanceAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyReservedInstanceAttributeResponseBody> body{};

  ModifyReservedInstanceAttributeResponse() {}

  explicit ModifyReservedInstanceAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyReservedInstanceAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyReservedInstanceAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyReservedInstanceAttributeResponse() = default;
};
class ModifyReservedInstancesRequestConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> reservedInstanceName{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> scope{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> instanceAmount{};

  ModifyReservedInstancesRequestConfiguration() {}

  explicit ModifyReservedInstancesRequestConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reservedInstanceName) {
      res["ReservedInstanceName"] = boost::any(*reservedInstanceName);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (instanceAmount) {
      res["InstanceAmount"] = boost::any(*instanceAmount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReservedInstanceName") != m.end() && !m["ReservedInstanceName"].empty()) {
      reservedInstanceName = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceName"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InstanceAmount") != m.end() && !m["InstanceAmount"].empty()) {
      instanceAmount = make_shared<long>(boost::any_cast<long>(m["InstanceAmount"]));
    }
  }


  virtual ~ModifyReservedInstancesRequestConfiguration() = default;
};
class ModifyReservedInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> reservedInstanceId{};
  shared_ptr<vector<ModifyReservedInstancesRequestConfiguration>> configuration{};

  ModifyReservedInstancesRequest() {}

  explicit ModifyReservedInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reservedInstanceId) {
      res["ReservedInstanceId"] = boost::any(*reservedInstanceId);
    }
    if (configuration) {
      vector<boost::any> temp1;
      for(auto item1:*configuration){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configuration"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReservedInstanceId") != m.end() && !m["ReservedInstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReservedInstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReservedInstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      reservedInstanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      if (typeid(vector<boost::any>) == m["Configuration"].type()) {
        vector<ModifyReservedInstancesRequestConfiguration> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configuration"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyReservedInstancesRequestConfiguration model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configuration = make_shared<vector<ModifyReservedInstancesRequestConfiguration>>(expect1);
      }
    }
  }


  virtual ~ModifyReservedInstancesRequest() = default;
};
class ModifyReservedInstancesResponseBodyReservedInstanceIdSets : public Darabonba::Model {
public:
  shared_ptr<vector<string>> reservedInstanceId{};

  ModifyReservedInstancesResponseBodyReservedInstanceIdSets() {}

  explicit ModifyReservedInstancesResponseBodyReservedInstanceIdSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reservedInstanceId) {
      res["ReservedInstanceId"] = boost::any(*reservedInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReservedInstanceId") != m.end() && !m["ReservedInstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReservedInstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReservedInstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      reservedInstanceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyReservedInstancesResponseBodyReservedInstanceIdSets() = default;
};
class ModifyReservedInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ModifyReservedInstancesResponseBodyReservedInstanceIdSets> reservedInstanceIdSets{};

  ModifyReservedInstancesResponseBody() {}

  explicit ModifyReservedInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (reservedInstanceIdSets) {
      res["ReservedInstanceIdSets"] = reservedInstanceIdSets ? boost::any(reservedInstanceIdSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ReservedInstanceIdSets") != m.end() && !m["ReservedInstanceIdSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReservedInstanceIdSets"].type()) {
        ModifyReservedInstancesResponseBodyReservedInstanceIdSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReservedInstanceIdSets"]));
        reservedInstanceIdSets = make_shared<ModifyReservedInstancesResponseBodyReservedInstanceIdSets>(model1);
      }
    }
  }


  virtual ~ModifyReservedInstancesResponseBody() = default;
};
class ModifyReservedInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyReservedInstancesResponseBody> body{};

  ModifyReservedInstancesResponse() {}

  explicit ModifyReservedInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyReservedInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyReservedInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyReservedInstancesResponse() = default;
};
class ModifyRouterInterfaceAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> routerInterfaceId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> oppositeInterfaceId{};
  shared_ptr<string> oppositeRouterId{};
  shared_ptr<string> oppositeRouterType{};
  shared_ptr<long> oppositeInterfaceOwnerId{};
  shared_ptr<string> healthCheckSourceIp{};
  shared_ptr<string> healthCheckTargetIp{};

  ModifyRouterInterfaceAttributeRequest() {}

  explicit ModifyRouterInterfaceAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (routerInterfaceId) {
      res["RouterInterfaceId"] = boost::any(*routerInterfaceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (oppositeInterfaceId) {
      res["OppositeInterfaceId"] = boost::any(*oppositeInterfaceId);
    }
    if (oppositeRouterId) {
      res["OppositeRouterId"] = boost::any(*oppositeRouterId);
    }
    if (oppositeRouterType) {
      res["OppositeRouterType"] = boost::any(*oppositeRouterType);
    }
    if (oppositeInterfaceOwnerId) {
      res["OppositeInterfaceOwnerId"] = boost::any(*oppositeInterfaceOwnerId);
    }
    if (healthCheckSourceIp) {
      res["HealthCheckSourceIp"] = boost::any(*healthCheckSourceIp);
    }
    if (healthCheckTargetIp) {
      res["HealthCheckTargetIp"] = boost::any(*healthCheckTargetIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RouterInterfaceId") != m.end() && !m["RouterInterfaceId"].empty()) {
      routerInterfaceId = make_shared<string>(boost::any_cast<string>(m["RouterInterfaceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("OppositeInterfaceId") != m.end() && !m["OppositeInterfaceId"].empty()) {
      oppositeInterfaceId = make_shared<string>(boost::any_cast<string>(m["OppositeInterfaceId"]));
    }
    if (m.find("OppositeRouterId") != m.end() && !m["OppositeRouterId"].empty()) {
      oppositeRouterId = make_shared<string>(boost::any_cast<string>(m["OppositeRouterId"]));
    }
    if (m.find("OppositeRouterType") != m.end() && !m["OppositeRouterType"].empty()) {
      oppositeRouterType = make_shared<string>(boost::any_cast<string>(m["OppositeRouterType"]));
    }
    if (m.find("OppositeInterfaceOwnerId") != m.end() && !m["OppositeInterfaceOwnerId"].empty()) {
      oppositeInterfaceOwnerId = make_shared<long>(boost::any_cast<long>(m["OppositeInterfaceOwnerId"]));
    }
    if (m.find("HealthCheckSourceIp") != m.end() && !m["HealthCheckSourceIp"].empty()) {
      healthCheckSourceIp = make_shared<string>(boost::any_cast<string>(m["HealthCheckSourceIp"]));
    }
    if (m.find("HealthCheckTargetIp") != m.end() && !m["HealthCheckTargetIp"].empty()) {
      healthCheckTargetIp = make_shared<string>(boost::any_cast<string>(m["HealthCheckTargetIp"]));
    }
  }


  virtual ~ModifyRouterInterfaceAttributeRequest() = default;
};
class ModifyRouterInterfaceAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyRouterInterfaceAttributeResponseBody() {}

  explicit ModifyRouterInterfaceAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyRouterInterfaceAttributeResponseBody() = default;
};
class ModifyRouterInterfaceAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyRouterInterfaceAttributeResponseBody> body{};

  ModifyRouterInterfaceAttributeResponse() {}

  explicit ModifyRouterInterfaceAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyRouterInterfaceAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyRouterInterfaceAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyRouterInterfaceAttributeResponse() = default;
};
class ModifyRouterInterfaceSpecRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> routerInterfaceId{};
  shared_ptr<string> spec{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> userCidr{};

  ModifyRouterInterfaceSpecRequest() {}

  explicit ModifyRouterInterfaceSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (routerInterfaceId) {
      res["RouterInterfaceId"] = boost::any(*routerInterfaceId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (userCidr) {
      res["UserCidr"] = boost::any(*userCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RouterInterfaceId") != m.end() && !m["RouterInterfaceId"].empty()) {
      routerInterfaceId = make_shared<string>(boost::any_cast<string>(m["RouterInterfaceId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("UserCidr") != m.end() && !m["UserCidr"].empty()) {
      userCidr = make_shared<string>(boost::any_cast<string>(m["UserCidr"]));
    }
  }


  virtual ~ModifyRouterInterfaceSpecRequest() = default;
};
class ModifyRouterInterfaceSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> spec{};
  shared_ptr<string> requestId{};

  ModifyRouterInterfaceSpecResponseBody() {}

  explicit ModifyRouterInterfaceSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyRouterInterfaceSpecResponseBody() = default;
};
class ModifyRouterInterfaceSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyRouterInterfaceSpecResponseBody> body{};

  ModifyRouterInterfaceSpecResponse() {}

  explicit ModifyRouterInterfaceSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyRouterInterfaceSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyRouterInterfaceSpecResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyRouterInterfaceSpecResponse() = default;
};
class ModifySecurityGroupAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> description{};
  shared_ptr<string> securityGroupName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ownerAccount{};

  ModifySecurityGroupAttributeRequest() {}

  explicit ModifySecurityGroupAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ModifySecurityGroupAttributeRequest() = default;
};
class ModifySecurityGroupAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySecurityGroupAttributeResponseBody() {}

  explicit ModifySecurityGroupAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySecurityGroupAttributeResponseBody() = default;
};
class ModifySecurityGroupAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySecurityGroupAttributeResponseBody> body{};

  ModifySecurityGroupAttributeResponse() {}

  explicit ModifySecurityGroupAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySecurityGroupAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySecurityGroupAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySecurityGroupAttributeResponse() = default;
};
class ModifySecurityGroupEgressRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> portRange{};
  shared_ptr<string> destGroupId{};
  shared_ptr<long> destGroupOwnerId{};
  shared_ptr<string> destGroupOwnerAccount{};
  shared_ptr<string> destCidrIp{};
  shared_ptr<string> ipv6DestCidrIp{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> ipv6SourceCidrIp{};
  shared_ptr<string> destPrefixListId{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<string> policy{};
  shared_ptr<string> priority{};
  shared_ptr<string> nicType{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};

  ModifySecurityGroupEgressRuleRequest() {}

  explicit ModifySecurityGroupEgressRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (destGroupId) {
      res["DestGroupId"] = boost::any(*destGroupId);
    }
    if (destGroupOwnerId) {
      res["DestGroupOwnerId"] = boost::any(*destGroupOwnerId);
    }
    if (destGroupOwnerAccount) {
      res["DestGroupOwnerAccount"] = boost::any(*destGroupOwnerAccount);
    }
    if (destCidrIp) {
      res["DestCidrIp"] = boost::any(*destCidrIp);
    }
    if (ipv6DestCidrIp) {
      res["Ipv6DestCidrIp"] = boost::any(*ipv6DestCidrIp);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (ipv6SourceCidrIp) {
      res["Ipv6SourceCidrIp"] = boost::any(*ipv6SourceCidrIp);
    }
    if (destPrefixListId) {
      res["DestPrefixListId"] = boost::any(*destPrefixListId);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (nicType) {
      res["NicType"] = boost::any(*nicType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("DestGroupId") != m.end() && !m["DestGroupId"].empty()) {
      destGroupId = make_shared<string>(boost::any_cast<string>(m["DestGroupId"]));
    }
    if (m.find("DestGroupOwnerId") != m.end() && !m["DestGroupOwnerId"].empty()) {
      destGroupOwnerId = make_shared<long>(boost::any_cast<long>(m["DestGroupOwnerId"]));
    }
    if (m.find("DestGroupOwnerAccount") != m.end() && !m["DestGroupOwnerAccount"].empty()) {
      destGroupOwnerAccount = make_shared<string>(boost::any_cast<string>(m["DestGroupOwnerAccount"]));
    }
    if (m.find("DestCidrIp") != m.end() && !m["DestCidrIp"].empty()) {
      destCidrIp = make_shared<string>(boost::any_cast<string>(m["DestCidrIp"]));
    }
    if (m.find("Ipv6DestCidrIp") != m.end() && !m["Ipv6DestCidrIp"].empty()) {
      ipv6DestCidrIp = make_shared<string>(boost::any_cast<string>(m["Ipv6DestCidrIp"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("Ipv6SourceCidrIp") != m.end() && !m["Ipv6SourceCidrIp"].empty()) {
      ipv6SourceCidrIp = make_shared<string>(boost::any_cast<string>(m["Ipv6SourceCidrIp"]));
    }
    if (m.find("DestPrefixListId") != m.end() && !m["DestPrefixListId"].empty()) {
      destPrefixListId = make_shared<string>(boost::any_cast<string>(m["DestPrefixListId"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("NicType") != m.end() && !m["NicType"].empty()) {
      nicType = make_shared<string>(boost::any_cast<string>(m["NicType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~ModifySecurityGroupEgressRuleRequest() = default;
};
class ModifySecurityGroupEgressRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySecurityGroupEgressRuleResponseBody() {}

  explicit ModifySecurityGroupEgressRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySecurityGroupEgressRuleResponseBody() = default;
};
class ModifySecurityGroupEgressRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySecurityGroupEgressRuleResponseBody> body{};

  ModifySecurityGroupEgressRuleResponse() {}

  explicit ModifySecurityGroupEgressRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySecurityGroupEgressRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySecurityGroupEgressRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySecurityGroupEgressRuleResponse() = default;
};
class ModifySecurityGroupPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> innerAccessPolicy{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};

  ModifySecurityGroupPolicyRequest() {}

  explicit ModifySecurityGroupPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (innerAccessPolicy) {
      res["InnerAccessPolicy"] = boost::any(*innerAccessPolicy);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InnerAccessPolicy") != m.end() && !m["InnerAccessPolicy"].empty()) {
      innerAccessPolicy = make_shared<string>(boost::any_cast<string>(m["InnerAccessPolicy"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~ModifySecurityGroupPolicyRequest() = default;
};
class ModifySecurityGroupPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySecurityGroupPolicyResponseBody() {}

  explicit ModifySecurityGroupPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySecurityGroupPolicyResponseBody() = default;
};
class ModifySecurityGroupPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySecurityGroupPolicyResponseBody> body{};

  ModifySecurityGroupPolicyResponse() {}

  explicit ModifySecurityGroupPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySecurityGroupPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySecurityGroupPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySecurityGroupPolicyResponse() = default;
};
class ModifySecurityGroupRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> portRange{};
  shared_ptr<string> sourceGroupId{};
  shared_ptr<long> sourceGroupOwnerId{};
  shared_ptr<string> sourceGroupOwnerAccount{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> ipv6SourceCidrIp{};
  shared_ptr<string> sourcePrefixListId{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<string> destCidrIp{};
  shared_ptr<string> ipv6DestCidrIp{};
  shared_ptr<string> policy{};
  shared_ptr<string> priority{};
  shared_ptr<string> nicType{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};

  ModifySecurityGroupRuleRequest() {}

  explicit ModifySecurityGroupRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (sourceGroupId) {
      res["SourceGroupId"] = boost::any(*sourceGroupId);
    }
    if (sourceGroupOwnerId) {
      res["SourceGroupOwnerId"] = boost::any(*sourceGroupOwnerId);
    }
    if (sourceGroupOwnerAccount) {
      res["SourceGroupOwnerAccount"] = boost::any(*sourceGroupOwnerAccount);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (ipv6SourceCidrIp) {
      res["Ipv6SourceCidrIp"] = boost::any(*ipv6SourceCidrIp);
    }
    if (sourcePrefixListId) {
      res["SourcePrefixListId"] = boost::any(*sourcePrefixListId);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (destCidrIp) {
      res["DestCidrIp"] = boost::any(*destCidrIp);
    }
    if (ipv6DestCidrIp) {
      res["Ipv6DestCidrIp"] = boost::any(*ipv6DestCidrIp);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (nicType) {
      res["NicType"] = boost::any(*nicType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("SourceGroupId") != m.end() && !m["SourceGroupId"].empty()) {
      sourceGroupId = make_shared<string>(boost::any_cast<string>(m["SourceGroupId"]));
    }
    if (m.find("SourceGroupOwnerId") != m.end() && !m["SourceGroupOwnerId"].empty()) {
      sourceGroupOwnerId = make_shared<long>(boost::any_cast<long>(m["SourceGroupOwnerId"]));
    }
    if (m.find("SourceGroupOwnerAccount") != m.end() && !m["SourceGroupOwnerAccount"].empty()) {
      sourceGroupOwnerAccount = make_shared<string>(boost::any_cast<string>(m["SourceGroupOwnerAccount"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("Ipv6SourceCidrIp") != m.end() && !m["Ipv6SourceCidrIp"].empty()) {
      ipv6SourceCidrIp = make_shared<string>(boost::any_cast<string>(m["Ipv6SourceCidrIp"]));
    }
    if (m.find("SourcePrefixListId") != m.end() && !m["SourcePrefixListId"].empty()) {
      sourcePrefixListId = make_shared<string>(boost::any_cast<string>(m["SourcePrefixListId"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("DestCidrIp") != m.end() && !m["DestCidrIp"].empty()) {
      destCidrIp = make_shared<string>(boost::any_cast<string>(m["DestCidrIp"]));
    }
    if (m.find("Ipv6DestCidrIp") != m.end() && !m["Ipv6DestCidrIp"].empty()) {
      ipv6DestCidrIp = make_shared<string>(boost::any_cast<string>(m["Ipv6DestCidrIp"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("NicType") != m.end() && !m["NicType"].empty()) {
      nicType = make_shared<string>(boost::any_cast<string>(m["NicType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~ModifySecurityGroupRuleRequest() = default;
};
class ModifySecurityGroupRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySecurityGroupRuleResponseBody() {}

  explicit ModifySecurityGroupRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySecurityGroupRuleResponseBody() = default;
};
class ModifySecurityGroupRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySecurityGroupRuleResponseBody> body{};

  ModifySecurityGroupRuleResponse() {}

  explicit ModifySecurityGroupRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySecurityGroupRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySecurityGroupRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySecurityGroupRuleResponse() = default;
};
class ModifySnapshotAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> snapshotName{};
  shared_ptr<string> description{};
  shared_ptr<bool> disableInstantAccess{};

  ModifySnapshotAttributeRequest() {}

  explicit ModifySnapshotAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (snapshotName) {
      res["SnapshotName"] = boost::any(*snapshotName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableInstantAccess) {
      res["DisableInstantAccess"] = boost::any(*disableInstantAccess);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("SnapshotName") != m.end() && !m["SnapshotName"].empty()) {
      snapshotName = make_shared<string>(boost::any_cast<string>(m["SnapshotName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableInstantAccess") != m.end() && !m["DisableInstantAccess"].empty()) {
      disableInstantAccess = make_shared<bool>(boost::any_cast<bool>(m["DisableInstantAccess"]));
    }
  }


  virtual ~ModifySnapshotAttributeRequest() = default;
};
class ModifySnapshotAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySnapshotAttributeResponseBody() {}

  explicit ModifySnapshotAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySnapshotAttributeResponseBody() = default;
};
class ModifySnapshotAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySnapshotAttributeResponseBody> body{};

  ModifySnapshotAttributeResponse() {}

  explicit ModifySnapshotAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySnapshotAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySnapshotAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySnapshotAttributeResponse() = default;
};
class ModifySnapshotGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> snapshotGroupId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};

  ModifySnapshotGroupRequest() {}

  explicit ModifySnapshotGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (snapshotGroupId) {
      res["SnapshotGroupId"] = boost::any(*snapshotGroupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SnapshotGroupId") != m.end() && !m["SnapshotGroupId"].empty()) {
      snapshotGroupId = make_shared<string>(boost::any_cast<string>(m["SnapshotGroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~ModifySnapshotGroupRequest() = default;
};
class ModifySnapshotGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySnapshotGroupResponseBody() {}

  explicit ModifySnapshotGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySnapshotGroupResponseBody() = default;
};
class ModifySnapshotGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySnapshotGroupResponseBody> body{};

  ModifySnapshotGroupResponse() {}

  explicit ModifySnapshotGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySnapshotGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySnapshotGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySnapshotGroupResponse() = default;
};
class ModifyStorageCapacityUnitAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> storageCapacityUnitId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};

  ModifyStorageCapacityUnitAttributeRequest() {}

  explicit ModifyStorageCapacityUnitAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (storageCapacityUnitId) {
      res["StorageCapacityUnitId"] = boost::any(*storageCapacityUnitId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StorageCapacityUnitId") != m.end() && !m["StorageCapacityUnitId"].empty()) {
      storageCapacityUnitId = make_shared<string>(boost::any_cast<string>(m["StorageCapacityUnitId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~ModifyStorageCapacityUnitAttributeRequest() = default;
};
class ModifyStorageCapacityUnitAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyStorageCapacityUnitAttributeResponseBody() {}

  explicit ModifyStorageCapacityUnitAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyStorageCapacityUnitAttributeResponseBody() = default;
};
class ModifyStorageCapacityUnitAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyStorageCapacityUnitAttributeResponseBody> body{};

  ModifyStorageCapacityUnitAttributeResponse() {}

  explicit ModifyStorageCapacityUnitAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyStorageCapacityUnitAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyStorageCapacityUnitAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyStorageCapacityUnitAttributeResponse() = default;
};
class ModifyStorageSetAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> storageSetId{};
  shared_ptr<string> storageSetName{};
  shared_ptr<string> description{};

  ModifyStorageSetAttributeRequest() {}

  explicit ModifyStorageSetAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    if (storageSetName) {
      res["StorageSetName"] = boost::any(*storageSetName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
    if (m.find("StorageSetName") != m.end() && !m["StorageSetName"].empty()) {
      storageSetName = make_shared<string>(boost::any_cast<string>(m["StorageSetName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~ModifyStorageSetAttributeRequest() = default;
};
class ModifyStorageSetAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyStorageSetAttributeResponseBody() {}

  explicit ModifyStorageSetAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyStorageSetAttributeResponseBody() = default;
};
class ModifyStorageSetAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyStorageSetAttributeResponseBody> body{};

  ModifyStorageSetAttributeResponse() {}

  explicit ModifyStorageSetAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyStorageSetAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyStorageSetAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyStorageSetAttributeResponse() = default;
};
class ModifyUserBusinessBehaviorRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> statusKey{};
  shared_ptr<string> statusValue{};

  ModifyUserBusinessBehaviorRequest() {}

  explicit ModifyUserBusinessBehaviorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (statusKey) {
      res["statusKey"] = boost::any(*statusKey);
    }
    if (statusValue) {
      res["statusValue"] = boost::any(*statusValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("statusKey") != m.end() && !m["statusKey"].empty()) {
      statusKey = make_shared<string>(boost::any_cast<string>(m["statusKey"]));
    }
    if (m.find("statusValue") != m.end() && !m["statusValue"].empty()) {
      statusValue = make_shared<string>(boost::any_cast<string>(m["statusValue"]));
    }
  }


  virtual ~ModifyUserBusinessBehaviorRequest() = default;
};
class ModifyUserBusinessBehaviorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyUserBusinessBehaviorResponseBody() {}

  explicit ModifyUserBusinessBehaviorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyUserBusinessBehaviorResponseBody() = default;
};
class ModifyUserBusinessBehaviorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyUserBusinessBehaviorResponseBody> body{};

  ModifyUserBusinessBehaviorResponse() {}

  explicit ModifyUserBusinessBehaviorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyUserBusinessBehaviorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyUserBusinessBehaviorResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyUserBusinessBehaviorResponse() = default;
};
class ModifyVirtualBorderRouterAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> vbrId{};
  shared_ptr<long> vlanId{};
  shared_ptr<string> circuitCode{};
  shared_ptr<string> localGatewayIp{};
  shared_ptr<string> peerGatewayIp{};
  shared_ptr<string> peeringSubnetMask{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> userCidr{};

  ModifyVirtualBorderRouterAttributeRequest() {}

  explicit ModifyVirtualBorderRouterAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vbrId) {
      res["VbrId"] = boost::any(*vbrId);
    }
    if (vlanId) {
      res["VlanId"] = boost::any(*vlanId);
    }
    if (circuitCode) {
      res["CircuitCode"] = boost::any(*circuitCode);
    }
    if (localGatewayIp) {
      res["LocalGatewayIp"] = boost::any(*localGatewayIp);
    }
    if (peerGatewayIp) {
      res["PeerGatewayIp"] = boost::any(*peerGatewayIp);
    }
    if (peeringSubnetMask) {
      res["PeeringSubnetMask"] = boost::any(*peeringSubnetMask);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (userCidr) {
      res["UserCidr"] = boost::any(*userCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VbrId") != m.end() && !m["VbrId"].empty()) {
      vbrId = make_shared<string>(boost::any_cast<string>(m["VbrId"]));
    }
    if (m.find("VlanId") != m.end() && !m["VlanId"].empty()) {
      vlanId = make_shared<long>(boost::any_cast<long>(m["VlanId"]));
    }
    if (m.find("CircuitCode") != m.end() && !m["CircuitCode"].empty()) {
      circuitCode = make_shared<string>(boost::any_cast<string>(m["CircuitCode"]));
    }
    if (m.find("LocalGatewayIp") != m.end() && !m["LocalGatewayIp"].empty()) {
      localGatewayIp = make_shared<string>(boost::any_cast<string>(m["LocalGatewayIp"]));
    }
    if (m.find("PeerGatewayIp") != m.end() && !m["PeerGatewayIp"].empty()) {
      peerGatewayIp = make_shared<string>(boost::any_cast<string>(m["PeerGatewayIp"]));
    }
    if (m.find("PeeringSubnetMask") != m.end() && !m["PeeringSubnetMask"].empty()) {
      peeringSubnetMask = make_shared<string>(boost::any_cast<string>(m["PeeringSubnetMask"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("UserCidr") != m.end() && !m["UserCidr"].empty()) {
      userCidr = make_shared<string>(boost::any_cast<string>(m["UserCidr"]));
    }
  }


  virtual ~ModifyVirtualBorderRouterAttributeRequest() = default;
};
class ModifyVirtualBorderRouterAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyVirtualBorderRouterAttributeResponseBody() {}

  explicit ModifyVirtualBorderRouterAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVirtualBorderRouterAttributeResponseBody() = default;
};
class ModifyVirtualBorderRouterAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyVirtualBorderRouterAttributeResponseBody> body{};

  ModifyVirtualBorderRouterAttributeResponse() {}

  explicit ModifyVirtualBorderRouterAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVirtualBorderRouterAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVirtualBorderRouterAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVirtualBorderRouterAttributeResponse() = default;
};
class ModifyVpcAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> description{};
  shared_ptr<string> vpcName{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> userCidr{};

  ModifyVpcAttributeRequest() {}

  explicit ModifyVpcAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (userCidr) {
      res["UserCidr"] = boost::any(*userCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("UserCidr") != m.end() && !m["UserCidr"].empty()) {
      userCidr = make_shared<string>(boost::any_cast<string>(m["UserCidr"]));
    }
  }


  virtual ~ModifyVpcAttributeRequest() = default;
};
class ModifyVpcAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyVpcAttributeResponseBody() {}

  explicit ModifyVpcAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVpcAttributeResponseBody() = default;
};
class ModifyVpcAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyVpcAttributeResponseBody> body{};

  ModifyVpcAttributeResponse() {}

  explicit ModifyVpcAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVpcAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVpcAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVpcAttributeResponse() = default;
};
class ModifyVRouterAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> VRouterId{};
  shared_ptr<string> VRouterName{};
  shared_ptr<string> description{};
  shared_ptr<string> ownerAccount{};

  ModifyVRouterAttributeRequest() {}

  explicit ModifyVRouterAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (VRouterId) {
      res["VRouterId"] = boost::any(*VRouterId);
    }
    if (VRouterName) {
      res["VRouterName"] = boost::any(*VRouterName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VRouterId") != m.end() && !m["VRouterId"].empty()) {
      VRouterId = make_shared<string>(boost::any_cast<string>(m["VRouterId"]));
    }
    if (m.find("VRouterName") != m.end() && !m["VRouterName"].empty()) {
      VRouterName = make_shared<string>(boost::any_cast<string>(m["VRouterName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ModifyVRouterAttributeRequest() = default;
};
class ModifyVRouterAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyVRouterAttributeResponseBody() {}

  explicit ModifyVRouterAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVRouterAttributeResponseBody() = default;
};
class ModifyVRouterAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyVRouterAttributeResponseBody> body{};

  ModifyVRouterAttributeResponse() {}

  explicit ModifyVRouterAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVRouterAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVRouterAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVRouterAttributeResponse() = default;
};
class ModifyVSwitchAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vSwitchName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> description{};
  shared_ptr<string> ownerAccount{};

  ModifyVSwitchAttributeRequest() {}

  explicit ModifyVSwitchAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vSwitchName) {
      res["VSwitchName"] = boost::any(*vSwitchName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VSwitchName") != m.end() && !m["VSwitchName"].empty()) {
      vSwitchName = make_shared<string>(boost::any_cast<string>(m["VSwitchName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ModifyVSwitchAttributeRequest() = default;
};
class ModifyVSwitchAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyVSwitchAttributeResponseBody() {}

  explicit ModifyVSwitchAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVSwitchAttributeResponseBody() = default;
};
class ModifyVSwitchAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyVSwitchAttributeResponseBody> body{};

  ModifyVSwitchAttributeResponse() {}

  explicit ModifyVSwitchAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVSwitchAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVSwitchAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVSwitchAttributeResponse() = default;
};
class PurchaseReservedInstancesOfferingRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  PurchaseReservedInstancesOfferingRequestTag() {}

  explicit PurchaseReservedInstancesOfferingRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~PurchaseReservedInstancesOfferingRequestTag() = default;
};
class PurchaseReservedInstancesOfferingRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<PurchaseReservedInstancesOfferingRequestTag>> tag{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> reservedInstanceName{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> scope{};
  shared_ptr<long> instanceAmount{};
  shared_ptr<string> offeringType{};
  shared_ptr<string> description{};
  shared_ptr<string> platform{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> clientToken{};

  PurchaseReservedInstancesOfferingRequest() {}

  explicit PurchaseReservedInstancesOfferingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (reservedInstanceName) {
      res["ReservedInstanceName"] = boost::any(*reservedInstanceName);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (instanceAmount) {
      res["InstanceAmount"] = boost::any(*instanceAmount);
    }
    if (offeringType) {
      res["OfferingType"] = boost::any(*offeringType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<PurchaseReservedInstancesOfferingRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PurchaseReservedInstancesOfferingRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<PurchaseReservedInstancesOfferingRequestTag>>(expect1);
      }
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("ReservedInstanceName") != m.end() && !m["ReservedInstanceName"].empty()) {
      reservedInstanceName = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceName"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("InstanceAmount") != m.end() && !m["InstanceAmount"].empty()) {
      instanceAmount = make_shared<long>(boost::any_cast<long>(m["InstanceAmount"]));
    }
    if (m.find("OfferingType") != m.end() && !m["OfferingType"].empty()) {
      offeringType = make_shared<string>(boost::any_cast<string>(m["OfferingType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~PurchaseReservedInstancesOfferingRequest() = default;
};
class PurchaseReservedInstancesOfferingResponseBodyReservedInstanceIdSets : public Darabonba::Model {
public:
  shared_ptr<vector<string>> reservedInstanceId{};

  PurchaseReservedInstancesOfferingResponseBodyReservedInstanceIdSets() {}

  explicit PurchaseReservedInstancesOfferingResponseBodyReservedInstanceIdSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reservedInstanceId) {
      res["ReservedInstanceId"] = boost::any(*reservedInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReservedInstanceId") != m.end() && !m["ReservedInstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReservedInstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReservedInstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      reservedInstanceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~PurchaseReservedInstancesOfferingResponseBodyReservedInstanceIdSets() = default;
};
class PurchaseReservedInstancesOfferingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<PurchaseReservedInstancesOfferingResponseBodyReservedInstanceIdSets> reservedInstanceIdSets{};

  PurchaseReservedInstancesOfferingResponseBody() {}

  explicit PurchaseReservedInstancesOfferingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (reservedInstanceIdSets) {
      res["ReservedInstanceIdSets"] = reservedInstanceIdSets ? boost::any(reservedInstanceIdSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ReservedInstanceIdSets") != m.end() && !m["ReservedInstanceIdSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReservedInstanceIdSets"].type()) {
        PurchaseReservedInstancesOfferingResponseBodyReservedInstanceIdSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReservedInstanceIdSets"]));
        reservedInstanceIdSets = make_shared<PurchaseReservedInstancesOfferingResponseBodyReservedInstanceIdSets>(model1);
      }
    }
  }


  virtual ~PurchaseReservedInstancesOfferingResponseBody() = default;
};
class PurchaseReservedInstancesOfferingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PurchaseReservedInstancesOfferingResponseBody> body{};

  PurchaseReservedInstancesOfferingResponse() {}

  explicit PurchaseReservedInstancesOfferingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PurchaseReservedInstancesOfferingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PurchaseReservedInstancesOfferingResponseBody>(model1);
      }
    }
  }


  virtual ~PurchaseReservedInstancesOfferingResponse() = default;
};
class PurchaseStorageCapacityUnitRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  PurchaseStorageCapacityUnitRequestTag() {}

  explicit PurchaseStorageCapacityUnitRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~PurchaseStorageCapacityUnitRequestTag() = default;
};
class PurchaseStorageCapacityUnitRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> name{};
  shared_ptr<long> capacity{};
  shared_ptr<string> description{};
  shared_ptr<string> startTime{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> fromApp{};
  shared_ptr<string> clientToken{};
  shared_ptr<long> amount{};
  shared_ptr<vector<PurchaseStorageCapacityUnitRequestTag>> tag{};

  PurchaseStorageCapacityUnitRequest() {}

  explicit PurchaseStorageCapacityUnitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (capacity) {
      res["Capacity"] = boost::any(*capacity);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (fromApp) {
      res["FromApp"] = boost::any(*fromApp);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Capacity") != m.end() && !m["Capacity"].empty()) {
      capacity = make_shared<long>(boost::any_cast<long>(m["Capacity"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("FromApp") != m.end() && !m["FromApp"].empty()) {
      fromApp = make_shared<string>(boost::any_cast<string>(m["FromApp"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<PurchaseStorageCapacityUnitRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PurchaseStorageCapacityUnitRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<PurchaseStorageCapacityUnitRequestTag>>(expect1);
      }
    }
  }


  virtual ~PurchaseStorageCapacityUnitRequest() = default;
};
class PurchaseStorageCapacityUnitResponseBodyStorageCapacityUnitIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> storageCapacityUnitId{};

  PurchaseStorageCapacityUnitResponseBodyStorageCapacityUnitIds() {}

  explicit PurchaseStorageCapacityUnitResponseBodyStorageCapacityUnitIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (storageCapacityUnitId) {
      res["StorageCapacityUnitId"] = boost::any(*storageCapacityUnitId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StorageCapacityUnitId") != m.end() && !m["StorageCapacityUnitId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StorageCapacityUnitId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StorageCapacityUnitId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      storageCapacityUnitId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~PurchaseStorageCapacityUnitResponseBodyStorageCapacityUnitIds() = default;
};
class PurchaseStorageCapacityUnitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};
  shared_ptr<PurchaseStorageCapacityUnitResponseBodyStorageCapacityUnitIds> storageCapacityUnitIds{};

  PurchaseStorageCapacityUnitResponseBody() {}

  explicit PurchaseStorageCapacityUnitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (storageCapacityUnitIds) {
      res["StorageCapacityUnitIds"] = storageCapacityUnitIds ? boost::any(storageCapacityUnitIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StorageCapacityUnitIds") != m.end() && !m["StorageCapacityUnitIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["StorageCapacityUnitIds"].type()) {
        PurchaseStorageCapacityUnitResponseBodyStorageCapacityUnitIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StorageCapacityUnitIds"]));
        storageCapacityUnitIds = make_shared<PurchaseStorageCapacityUnitResponseBodyStorageCapacityUnitIds>(model1);
      }
    }
  }


  virtual ~PurchaseStorageCapacityUnitResponseBody() = default;
};
class PurchaseStorageCapacityUnitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PurchaseStorageCapacityUnitResponseBody> body{};

  PurchaseStorageCapacityUnitResponse() {}

  explicit PurchaseStorageCapacityUnitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PurchaseStorageCapacityUnitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PurchaseStorageCapacityUnitResponseBody>(model1);
      }
    }
  }


  virtual ~PurchaseStorageCapacityUnitResponse() = default;
};
class ReActivateInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ownerAccount{};

  ReActivateInstancesRequest() {}

  explicit ReActivateInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ReActivateInstancesRequest() = default;
};
class ReActivateInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReActivateInstancesResponseBody() {}

  explicit ReActivateInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReActivateInstancesResponseBody() = default;
};
class ReActivateInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReActivateInstancesResponseBody> body{};

  ReActivateInstancesResponse() {}

  explicit ReActivateInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReActivateInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReActivateInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ReActivateInstancesResponse() = default;
};
class RebootInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> forceStop{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<bool> dryRun{};

  RebootInstanceRequest() {}

  explicit RebootInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (forceStop) {
      res["ForceStop"] = boost::any(*forceStop);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ForceStop") != m.end() && !m["ForceStop"].empty()) {
      forceStop = make_shared<bool>(boost::any_cast<bool>(m["ForceStop"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
  }


  virtual ~RebootInstanceRequest() = default;
};
class RebootInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RebootInstanceResponseBody() {}

  explicit RebootInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RebootInstanceResponseBody() = default;
};
class RebootInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RebootInstanceResponseBody> body{};

  RebootInstanceResponse() {}

  explicit RebootInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RebootInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RebootInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RebootInstanceResponse() = default;
};
class RebootInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<bool> dryRun{};
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> forceReboot{};
  shared_ptr<string> batchOptimization{};

  RebootInstancesRequest() {}

  explicit RebootInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (forceReboot) {
      res["ForceReboot"] = boost::any(*forceReboot);
    }
    if (batchOptimization) {
      res["BatchOptimization"] = boost::any(*batchOptimization);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ForceReboot") != m.end() && !m["ForceReboot"].empty()) {
      forceReboot = make_shared<bool>(boost::any_cast<bool>(m["ForceReboot"]));
    }
    if (m.find("BatchOptimization") != m.end() && !m["BatchOptimization"].empty()) {
      batchOptimization = make_shared<string>(boost::any_cast<string>(m["BatchOptimization"]));
    }
  }


  virtual ~RebootInstancesRequest() = default;
};
class RebootInstancesResponseBodyInstanceResponsesInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> currentStatus{};
  shared_ptr<string> previousStatus{};

  RebootInstancesResponseBodyInstanceResponsesInstanceResponse() {}

  explicit RebootInstancesResponseBodyInstanceResponsesInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (currentStatus) {
      res["CurrentStatus"] = boost::any(*currentStatus);
    }
    if (previousStatus) {
      res["PreviousStatus"] = boost::any(*previousStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CurrentStatus") != m.end() && !m["CurrentStatus"].empty()) {
      currentStatus = make_shared<string>(boost::any_cast<string>(m["CurrentStatus"]));
    }
    if (m.find("PreviousStatus") != m.end() && !m["PreviousStatus"].empty()) {
      previousStatus = make_shared<string>(boost::any_cast<string>(m["PreviousStatus"]));
    }
  }


  virtual ~RebootInstancesResponseBodyInstanceResponsesInstanceResponse() = default;
};
class RebootInstancesResponseBodyInstanceResponses : public Darabonba::Model {
public:
  shared_ptr<vector<RebootInstancesResponseBodyInstanceResponsesInstanceResponse>> instanceResponse{};

  RebootInstancesResponseBodyInstanceResponses() {}

  explicit RebootInstancesResponseBodyInstanceResponses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceResponse) {
      vector<boost::any> temp1;
      for(auto item1:*instanceResponse){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceResponse"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceResponse") != m.end() && !m["InstanceResponse"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceResponse"].type()) {
        vector<RebootInstancesResponseBodyInstanceResponsesInstanceResponse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceResponse"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RebootInstancesResponseBodyInstanceResponsesInstanceResponse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceResponse = make_shared<vector<RebootInstancesResponseBodyInstanceResponsesInstanceResponse>>(expect1);
      }
    }
  }


  virtual ~RebootInstancesResponseBodyInstanceResponses() = default;
};
class RebootInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<RebootInstancesResponseBodyInstanceResponses> instanceResponses{};

  RebootInstancesResponseBody() {}

  explicit RebootInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceResponses) {
      res["InstanceResponses"] = instanceResponses ? boost::any(instanceResponses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceResponses") != m.end() && !m["InstanceResponses"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceResponses"].type()) {
        RebootInstancesResponseBodyInstanceResponses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceResponses"]));
        instanceResponses = make_shared<RebootInstancesResponseBodyInstanceResponses>(model1);
      }
    }
  }


  virtual ~RebootInstancesResponseBody() = default;
};
class RebootInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RebootInstancesResponseBody> body{};

  RebootInstancesResponse() {}

  explicit RebootInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RebootInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RebootInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~RebootInstancesResponse() = default;
};
class RecoverVirtualBorderRouterRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> vbrId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> userCidr{};

  RecoverVirtualBorderRouterRequest() {}

  explicit RecoverVirtualBorderRouterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vbrId) {
      res["VbrId"] = boost::any(*vbrId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (userCidr) {
      res["UserCidr"] = boost::any(*userCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VbrId") != m.end() && !m["VbrId"].empty()) {
      vbrId = make_shared<string>(boost::any_cast<string>(m["VbrId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("UserCidr") != m.end() && !m["UserCidr"].empty()) {
      userCidr = make_shared<string>(boost::any_cast<string>(m["UserCidr"]));
    }
  }


  virtual ~RecoverVirtualBorderRouterRequest() = default;
};
class RecoverVirtualBorderRouterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RecoverVirtualBorderRouterResponseBody() {}

  explicit RecoverVirtualBorderRouterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RecoverVirtualBorderRouterResponseBody() = default;
};
class RecoverVirtualBorderRouterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RecoverVirtualBorderRouterResponseBody> body{};

  RecoverVirtualBorderRouterResponse() {}

  explicit RecoverVirtualBorderRouterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RecoverVirtualBorderRouterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RecoverVirtualBorderRouterResponseBody>(model1);
      }
    }
  }


  virtual ~RecoverVirtualBorderRouterResponse() = default;
};
class RedeployDedicatedHostRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> dedicatedHostId{};

  RedeployDedicatedHostRequest() {}

  explicit RedeployDedicatedHostRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
  }


  virtual ~RedeployDedicatedHostRequest() = default;
};
class RedeployDedicatedHostResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RedeployDedicatedHostResponseBody() {}

  explicit RedeployDedicatedHostResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RedeployDedicatedHostResponseBody() = default;
};
class RedeployDedicatedHostResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RedeployDedicatedHostResponseBody> body{};

  RedeployDedicatedHostResponse() {}

  explicit RedeployDedicatedHostResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RedeployDedicatedHostResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RedeployDedicatedHostResponseBody>(model1);
      }
    }
  }


  virtual ~RedeployDedicatedHostResponse() = default;
};
class RedeployInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> forceStop{};

  RedeployInstanceRequest() {}

  explicit RedeployInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (forceStop) {
      res["ForceStop"] = boost::any(*forceStop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ForceStop") != m.end() && !m["ForceStop"].empty()) {
      forceStop = make_shared<bool>(boost::any_cast<bool>(m["ForceStop"]));
    }
  }


  virtual ~RedeployInstanceRequest() = default;
};
class RedeployInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> requestId{};

  RedeployInstanceResponseBody() {}

  explicit RedeployInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RedeployInstanceResponseBody() = default;
};
class RedeployInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RedeployInstanceResponseBody> body{};

  RedeployInstanceResponse() {}

  explicit RedeployInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RedeployInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RedeployInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RedeployInstanceResponse() = default;
};
class ReInitDiskRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> diskId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> password{};
  shared_ptr<string> keyPairName{};
  shared_ptr<bool> autoStartInstance{};
  shared_ptr<string> securityEnhancementStrategy{};

  ReInitDiskRequest() {}

  explicit ReInitDiskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (autoStartInstance) {
      res["AutoStartInstance"] = boost::any(*autoStartInstance);
    }
    if (securityEnhancementStrategy) {
      res["SecurityEnhancementStrategy"] = boost::any(*securityEnhancementStrategy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("AutoStartInstance") != m.end() && !m["AutoStartInstance"].empty()) {
      autoStartInstance = make_shared<bool>(boost::any_cast<bool>(m["AutoStartInstance"]));
    }
    if (m.find("SecurityEnhancementStrategy") != m.end() && !m["SecurityEnhancementStrategy"].empty()) {
      securityEnhancementStrategy = make_shared<string>(boost::any_cast<string>(m["SecurityEnhancementStrategy"]));
    }
  }


  virtual ~ReInitDiskRequest() = default;
};
class ReInitDiskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReInitDiskResponseBody() {}

  explicit ReInitDiskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReInitDiskResponseBody() = default;
};
class ReInitDiskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReInitDiskResponseBody> body{};

  ReInitDiskResponse() {}

  explicit ReInitDiskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReInitDiskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReInitDiskResponseBody>(model1);
      }
    }
  }


  virtual ~ReInitDiskResponse() = default;
};
class ReleaseCapacityReservationRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  ReleaseCapacityReservationRequestPrivatePoolOptions() {}

  explicit ReleaseCapacityReservationRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ReleaseCapacityReservationRequestPrivatePoolOptions() = default;
};
class ReleaseCapacityReservationRequest : public Darabonba::Model {
public:
  shared_ptr<ReleaseCapacityReservationRequestPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> dryRun{};

  ReleaseCapacityReservationRequest() {}

  explicit ReleaseCapacityReservationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privatePoolOptions) {
      res["PrivatePoolOptions"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolOptions"].type()) {
        ReleaseCapacityReservationRequestPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolOptions"]));
        privatePoolOptions = make_shared<ReleaseCapacityReservationRequestPrivatePoolOptions>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
  }


  virtual ~ReleaseCapacityReservationRequest() = default;
};
class ReleaseCapacityReservationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleaseCapacityReservationResponseBody() {}

  explicit ReleaseCapacityReservationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseCapacityReservationResponseBody() = default;
};
class ReleaseCapacityReservationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReleaseCapacityReservationResponseBody> body{};

  ReleaseCapacityReservationResponse() {}

  explicit ReleaseCapacityReservationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseCapacityReservationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseCapacityReservationResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseCapacityReservationResponse() = default;
};
class ReleaseDedicatedHostRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> dedicatedHostId{};

  ReleaseDedicatedHostRequest() {}

  explicit ReleaseDedicatedHostRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
  }


  virtual ~ReleaseDedicatedHostRequest() = default;
};
class ReleaseDedicatedHostResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleaseDedicatedHostResponseBody() {}

  explicit ReleaseDedicatedHostResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseDedicatedHostResponseBody() = default;
};
class ReleaseDedicatedHostResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReleaseDedicatedHostResponseBody> body{};

  ReleaseDedicatedHostResponse() {}

  explicit ReleaseDedicatedHostResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseDedicatedHostResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseDedicatedHostResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseDedicatedHostResponse() = default;
};
class ReleaseEipAddressRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> allocationId{};
  shared_ptr<string> ownerAccount{};

  ReleaseEipAddressRequest() {}

  explicit ReleaseEipAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ReleaseEipAddressRequest() = default;
};
class ReleaseEipAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleaseEipAddressResponseBody() {}

  explicit ReleaseEipAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseEipAddressResponseBody() = default;
};
class ReleaseEipAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReleaseEipAddressResponseBody> body{};

  ReleaseEipAddressResponse() {}

  explicit ReleaseEipAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseEipAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseEipAddressResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseEipAddressResponse() = default;
};
class ReleasePublicIpAddressRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> publicIpAddress{};
  shared_ptr<string> ownerAccount{};

  ReleasePublicIpAddressRequest() {}

  explicit ReleasePublicIpAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (publicIpAddress) {
      res["PublicIpAddress"] = boost::any(*publicIpAddress);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PublicIpAddress") != m.end() && !m["PublicIpAddress"].empty()) {
      publicIpAddress = make_shared<string>(boost::any_cast<string>(m["PublicIpAddress"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ReleasePublicIpAddressRequest() = default;
};
class ReleasePublicIpAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleasePublicIpAddressResponseBody() {}

  explicit ReleasePublicIpAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleasePublicIpAddressResponseBody() = default;
};
class ReleasePublicIpAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReleasePublicIpAddressResponseBody> body{};

  ReleasePublicIpAddressResponse() {}

  explicit ReleasePublicIpAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleasePublicIpAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleasePublicIpAddressResponseBody>(model1);
      }
    }
  }


  virtual ~ReleasePublicIpAddressResponse() = default;
};
class RemoveBandwidthPackageIpsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<string>> removedIpAddresses{};

  RemoveBandwidthPackageIpsRequest() {}

  explicit RemoveBandwidthPackageIpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (removedIpAddresses) {
      res["RemovedIpAddresses"] = boost::any(*removedIpAddresses);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RemovedIpAddresses") != m.end() && !m["RemovedIpAddresses"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RemovedIpAddresses"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RemovedIpAddresses"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      removedIpAddresses = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RemoveBandwidthPackageIpsRequest() = default;
};
class RemoveBandwidthPackageIpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveBandwidthPackageIpsResponseBody() {}

  explicit RemoveBandwidthPackageIpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveBandwidthPackageIpsResponseBody() = default;
};
class RemoveBandwidthPackageIpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RemoveBandwidthPackageIpsResponseBody> body{};

  RemoveBandwidthPackageIpsResponse() {}

  explicit RemoveBandwidthPackageIpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveBandwidthPackageIpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveBandwidthPackageIpsResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveBandwidthPackageIpsResponse() = default;
};
class RemoveTagsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  RemoveTagsRequestTag() {}

  explicit RemoveTagsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~RemoveTagsRequestTag() = default;
};
class RemoveTagsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceId{};
  shared_ptr<vector<RemoveTagsRequestTag>> tag{};

  RemoveTagsRequest() {}

  explicit RemoveTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<RemoveTagsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RemoveTagsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<RemoveTagsRequestTag>>(expect1);
      }
    }
  }


  virtual ~RemoveTagsRequest() = default;
};
class RemoveTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveTagsResponseBody() {}

  explicit RemoveTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveTagsResponseBody() = default;
};
class RemoveTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RemoveTagsResponseBody> body{};

  RemoveTagsResponse() {}

  explicit RemoveTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveTagsResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveTagsResponse() = default;
};
class RenewDedicatedHostsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> dedicatedHostIds{};
  shared_ptr<string> regionId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> clientToken{};

  RenewDedicatedHostsRequest() {}

  explicit RenewDedicatedHostsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (dedicatedHostIds) {
      res["DedicatedHostIds"] = boost::any(*dedicatedHostIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DedicatedHostIds") != m.end() && !m["DedicatedHostIds"].empty()) {
      dedicatedHostIds = make_shared<string>(boost::any_cast<string>(m["DedicatedHostIds"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~RenewDedicatedHostsRequest() = default;
};
class RenewDedicatedHostsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RenewDedicatedHostsResponseBody() {}

  explicit RenewDedicatedHostsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RenewDedicatedHostsResponseBody() = default;
};
class RenewDedicatedHostsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RenewDedicatedHostsResponseBody> body{};

  RenewDedicatedHostsResponse() {}

  explicit RenewDedicatedHostsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenewDedicatedHostsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenewDedicatedHostsResponseBody>(model1);
      }
    }
  }


  virtual ~RenewDedicatedHostsResponse() = default;
};
class RenewInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<long> expectedRenewDay{};

  RenewInstanceRequest() {}

  explicit RenewInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (expectedRenewDay) {
      res["ExpectedRenewDay"] = boost::any(*expectedRenewDay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("ExpectedRenewDay") != m.end() && !m["ExpectedRenewDay"].empty()) {
      expectedRenewDay = make_shared<long>(boost::any_cast<long>(m["ExpectedRenewDay"]));
    }
  }


  virtual ~RenewInstanceRequest() = default;
};
class RenewInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  RenewInstanceResponseBody() {}

  explicit RenewInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RenewInstanceResponseBody() = default;
};
class RenewInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RenewInstanceResponseBody> body{};

  RenewInstanceResponse() {}

  explicit RenewInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenewInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenewInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RenewInstanceResponse() = default;
};
class ReplaceSystemDiskRequestSystemDisk : public Darabonba::Model {
public:
  shared_ptr<long> size{};

  ReplaceSystemDiskRequestSystemDisk() {}

  explicit ReplaceSystemDiskRequestSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~ReplaceSystemDiskRequestSystemDisk() = default;
};
class ReplaceSystemDiskRequest : public Darabonba::Model {
public:
  shared_ptr<ReplaceSystemDiskRequestSystemDisk> systemDisk{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<bool> useAdditionalService{};
  shared_ptr<string> password{};
  shared_ptr<bool> passwordInherit{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> diskId{};
  shared_ptr<string> platform{};
  shared_ptr<string> architecture{};
  shared_ptr<string> securityEnhancementStrategy{};

  ReplaceSystemDiskRequest() {}

  explicit ReplaceSystemDiskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (useAdditionalService) {
      res["UseAdditionalService"] = boost::any(*useAdditionalService);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (passwordInherit) {
      res["PasswordInherit"] = boost::any(*passwordInherit);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (architecture) {
      res["Architecture"] = boost::any(*architecture);
    }
    if (securityEnhancementStrategy) {
      res["SecurityEnhancementStrategy"] = boost::any(*securityEnhancementStrategy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        ReplaceSystemDiskRequestSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<ReplaceSystemDiskRequestSystemDisk>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("UseAdditionalService") != m.end() && !m["UseAdditionalService"].empty()) {
      useAdditionalService = make_shared<bool>(boost::any_cast<bool>(m["UseAdditionalService"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("PasswordInherit") != m.end() && !m["PasswordInherit"].empty()) {
      passwordInherit = make_shared<bool>(boost::any_cast<bool>(m["PasswordInherit"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("Architecture") != m.end() && !m["Architecture"].empty()) {
      architecture = make_shared<string>(boost::any_cast<string>(m["Architecture"]));
    }
    if (m.find("SecurityEnhancementStrategy") != m.end() && !m["SecurityEnhancementStrategy"].empty()) {
      securityEnhancementStrategy = make_shared<string>(boost::any_cast<string>(m["SecurityEnhancementStrategy"]));
    }
  }


  virtual ~ReplaceSystemDiskRequest() = default;
};
class ReplaceSystemDiskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> diskId{};
  shared_ptr<string> requestId{};

  ReplaceSystemDiskResponseBody() {}

  explicit ReplaceSystemDiskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReplaceSystemDiskResponseBody() = default;
};
class ReplaceSystemDiskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReplaceSystemDiskResponseBody> body{};

  ReplaceSystemDiskResponse() {}

  explicit ReplaceSystemDiskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReplaceSystemDiskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReplaceSystemDiskResponseBody>(model1);
      }
    }
  }


  virtual ~ReplaceSystemDiskResponse() = default;
};
class ReportInstancesStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> reason{};
  shared_ptr<string> description{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> issueCategory{};
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<vector<string>> diskId{};
  shared_ptr<vector<string>> device{};

  ReportInstancesStatusRequest() {}

  explicit ReportInstancesStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (issueCategory) {
      res["IssueCategory"] = boost::any(*issueCategory);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IssueCategory") != m.end() && !m["IssueCategory"].empty()) {
      issueCategory = make_shared<string>(boost::any_cast<string>(m["IssueCategory"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DiskId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DiskId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      diskId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Device"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Device"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      device = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ReportInstancesStatusRequest() = default;
};
class ReportInstancesStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReportInstancesStatusResponseBody() {}

  explicit ReportInstancesStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReportInstancesStatusResponseBody() = default;
};
class ReportInstancesStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReportInstancesStatusResponseBody> body{};

  ReportInstancesStatusResponse() {}

  explicit ReportInstancesStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReportInstancesStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReportInstancesStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ReportInstancesStatusResponse() = default;
};
class ResetDiskRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> diskId{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> ownerAccount{};

  ResetDiskRequest() {}

  explicit ResetDiskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ResetDiskRequest() = default;
};
class ResetDiskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResetDiskResponseBody() {}

  explicit ResetDiskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResetDiskResponseBody() = default;
};
class ResetDiskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ResetDiskResponseBody> body{};

  ResetDiskResponse() {}

  explicit ResetDiskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetDiskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetDiskResponseBody>(model1);
      }
    }
  }


  virtual ~ResetDiskResponse() = default;
};
class ResetDisksRequestDisk : public Darabonba::Model {
public:
  shared_ptr<string> snapshotId{};
  shared_ptr<string> diskId{};

  ResetDisksRequestDisk() {}

  explicit ResetDisksRequestDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
  }


  virtual ~ResetDisksRequestDisk() = default;
};
class ResetDisksRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<ResetDisksRequestDisk>> disk{};

  ResetDisksRequest() {}

  explicit ResetDisksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (disk) {
      vector<boost::any> temp1;
      for(auto item1:*disk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Disk"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Disk") != m.end() && !m["Disk"].empty()) {
      if (typeid(vector<boost::any>) == m["Disk"].type()) {
        vector<ResetDisksRequestDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Disk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ResetDisksRequestDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        disk = make_shared<vector<ResetDisksRequestDisk>>(expect1);
      }
    }
  }


  virtual ~ResetDisksRequest() = default;
};
class ResetDisksResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  ResetDisksResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem() {}

  explicit ResetDisksResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ResetDisksResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem() = default;
};
class ResetDisksResponseBodyOperationProgressSetOperationProgressRelatedItemSet : public Darabonba::Model {
public:
  shared_ptr<vector<ResetDisksResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem>> relatedItem{};

  ResetDisksResponseBodyOperationProgressSetOperationProgressRelatedItemSet() {}

  explicit ResetDisksResponseBodyOperationProgressSetOperationProgressRelatedItemSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (relatedItem) {
      vector<boost::any> temp1;
      for(auto item1:*relatedItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RelatedItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RelatedItem") != m.end() && !m["RelatedItem"].empty()) {
      if (typeid(vector<boost::any>) == m["RelatedItem"].type()) {
        vector<ResetDisksResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RelatedItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ResetDisksResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relatedItem = make_shared<vector<ResetDisksResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem>>(expect1);
      }
    }
  }


  virtual ~ResetDisksResponseBodyOperationProgressSetOperationProgressRelatedItemSet() = default;
};
class ResetDisksResponseBodyOperationProgressSetOperationProgress : public Darabonba::Model {
public:
  shared_ptr<string> errorMsg{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> operationStatus{};
  shared_ptr<ResetDisksResponseBodyOperationProgressSetOperationProgressRelatedItemSet> relatedItemSet{};

  ResetDisksResponseBodyOperationProgressSetOperationProgress() {}

  explicit ResetDisksResponseBodyOperationProgressSetOperationProgress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (operationStatus) {
      res["OperationStatus"] = boost::any(*operationStatus);
    }
    if (relatedItemSet) {
      res["RelatedItemSet"] = relatedItemSet ? boost::any(relatedItemSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("OperationStatus") != m.end() && !m["OperationStatus"].empty()) {
      operationStatus = make_shared<string>(boost::any_cast<string>(m["OperationStatus"]));
    }
    if (m.find("RelatedItemSet") != m.end() && !m["RelatedItemSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["RelatedItemSet"].type()) {
        ResetDisksResponseBodyOperationProgressSetOperationProgressRelatedItemSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RelatedItemSet"]));
        relatedItemSet = make_shared<ResetDisksResponseBodyOperationProgressSetOperationProgressRelatedItemSet>(model1);
      }
    }
  }


  virtual ~ResetDisksResponseBodyOperationProgressSetOperationProgress() = default;
};
class ResetDisksResponseBodyOperationProgressSet : public Darabonba::Model {
public:
  shared_ptr<vector<ResetDisksResponseBodyOperationProgressSetOperationProgress>> operationProgress{};

  ResetDisksResponseBodyOperationProgressSet() {}

  explicit ResetDisksResponseBodyOperationProgressSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationProgress) {
      vector<boost::any> temp1;
      for(auto item1:*operationProgress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperationProgress"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationProgress") != m.end() && !m["OperationProgress"].empty()) {
      if (typeid(vector<boost::any>) == m["OperationProgress"].type()) {
        vector<ResetDisksResponseBodyOperationProgressSetOperationProgress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperationProgress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ResetDisksResponseBodyOperationProgressSetOperationProgress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operationProgress = make_shared<vector<ResetDisksResponseBodyOperationProgressSetOperationProgress>>(expect1);
      }
    }
  }


  virtual ~ResetDisksResponseBodyOperationProgressSet() = default;
};
class ResetDisksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ResetDisksResponseBodyOperationProgressSet> operationProgressSet{};

  ResetDisksResponseBody() {}

  explicit ResetDisksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (operationProgressSet) {
      res["OperationProgressSet"] = operationProgressSet ? boost::any(operationProgressSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OperationProgressSet") != m.end() && !m["OperationProgressSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperationProgressSet"].type()) {
        ResetDisksResponseBodyOperationProgressSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperationProgressSet"]));
        operationProgressSet = make_shared<ResetDisksResponseBodyOperationProgressSet>(model1);
      }
    }
  }


  virtual ~ResetDisksResponseBody() = default;
};
class ResetDisksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ResetDisksResponseBody> body{};

  ResetDisksResponse() {}

  explicit ResetDisksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetDisksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetDisksResponseBody>(model1);
      }
    }
  }


  virtual ~ResetDisksResponse() = default;
};
class ResizeDiskRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> diskId{};
  shared_ptr<string> type{};
  shared_ptr<long> newSize{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};

  ResizeDiskRequest() {}

  explicit ResizeDiskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (newSize) {
      res["NewSize"] = boost::any(*newSize);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("NewSize") != m.end() && !m["NewSize"].empty()) {
      newSize = make_shared<long>(boost::any_cast<long>(m["NewSize"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ResizeDiskRequest() = default;
};
class ResizeDiskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  ResizeDiskResponseBody() {}

  explicit ResizeDiskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResizeDiskResponseBody() = default;
};
class ResizeDiskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ResizeDiskResponseBody> body{};

  ResizeDiskResponse() {}

  explicit ResizeDiskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResizeDiskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResizeDiskResponseBody>(model1);
      }
    }
  }


  virtual ~ResizeDiskResponse() = default;
};
class RevokeSecurityGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> destCidrIp{};
  shared_ptr<string> ipv6DestCidrIp{};
  shared_ptr<string> portRange{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> sourceGroupId{};
  shared_ptr<long> sourceGroupOwnerId{};
  shared_ptr<string> sourceGroupOwnerAccount{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> ipv6SourceCidrIp{};
  shared_ptr<string> sourcePrefixListId{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<string> policy{};
  shared_ptr<string> priority{};
  shared_ptr<string> nicType{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};

  RevokeSecurityGroupRequest() {}

  explicit RevokeSecurityGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (destCidrIp) {
      res["DestCidrIp"] = boost::any(*destCidrIp);
    }
    if (ipv6DestCidrIp) {
      res["Ipv6DestCidrIp"] = boost::any(*ipv6DestCidrIp);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (sourceGroupId) {
      res["SourceGroupId"] = boost::any(*sourceGroupId);
    }
    if (sourceGroupOwnerId) {
      res["SourceGroupOwnerId"] = boost::any(*sourceGroupOwnerId);
    }
    if (sourceGroupOwnerAccount) {
      res["SourceGroupOwnerAccount"] = boost::any(*sourceGroupOwnerAccount);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (ipv6SourceCidrIp) {
      res["Ipv6SourceCidrIp"] = boost::any(*ipv6SourceCidrIp);
    }
    if (sourcePrefixListId) {
      res["SourcePrefixListId"] = boost::any(*sourcePrefixListId);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (nicType) {
      res["NicType"] = boost::any(*nicType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("DestCidrIp") != m.end() && !m["DestCidrIp"].empty()) {
      destCidrIp = make_shared<string>(boost::any_cast<string>(m["DestCidrIp"]));
    }
    if (m.find("Ipv6DestCidrIp") != m.end() && !m["Ipv6DestCidrIp"].empty()) {
      ipv6DestCidrIp = make_shared<string>(boost::any_cast<string>(m["Ipv6DestCidrIp"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("SourceGroupId") != m.end() && !m["SourceGroupId"].empty()) {
      sourceGroupId = make_shared<string>(boost::any_cast<string>(m["SourceGroupId"]));
    }
    if (m.find("SourceGroupOwnerId") != m.end() && !m["SourceGroupOwnerId"].empty()) {
      sourceGroupOwnerId = make_shared<long>(boost::any_cast<long>(m["SourceGroupOwnerId"]));
    }
    if (m.find("SourceGroupOwnerAccount") != m.end() && !m["SourceGroupOwnerAccount"].empty()) {
      sourceGroupOwnerAccount = make_shared<string>(boost::any_cast<string>(m["SourceGroupOwnerAccount"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("Ipv6SourceCidrIp") != m.end() && !m["Ipv6SourceCidrIp"].empty()) {
      ipv6SourceCidrIp = make_shared<string>(boost::any_cast<string>(m["Ipv6SourceCidrIp"]));
    }
    if (m.find("SourcePrefixListId") != m.end() && !m["SourcePrefixListId"].empty()) {
      sourcePrefixListId = make_shared<string>(boost::any_cast<string>(m["SourcePrefixListId"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("NicType") != m.end() && !m["NicType"].empty()) {
      nicType = make_shared<string>(boost::any_cast<string>(m["NicType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~RevokeSecurityGroupRequest() = default;
};
class RevokeSecurityGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RevokeSecurityGroupResponseBody() {}

  explicit RevokeSecurityGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RevokeSecurityGroupResponseBody() = default;
};
class RevokeSecurityGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RevokeSecurityGroupResponseBody> body{};

  RevokeSecurityGroupResponse() {}

  explicit RevokeSecurityGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeSecurityGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeSecurityGroupResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeSecurityGroupResponse() = default;
};
class RevokeSecurityGroupEgressRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> portRange{};
  shared_ptr<string> destGroupId{};
  shared_ptr<long> destGroupOwnerId{};
  shared_ptr<string> destGroupOwnerAccount{};
  shared_ptr<string> destCidrIp{};
  shared_ptr<string> ipv6DestCidrIp{};
  shared_ptr<string> destPrefixListId{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> ipv6SourceCidrIp{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<string> policy{};
  shared_ptr<string> priority{};
  shared_ptr<string> nicType{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};

  RevokeSecurityGroupEgressRequest() {}

  explicit RevokeSecurityGroupEgressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (destGroupId) {
      res["DestGroupId"] = boost::any(*destGroupId);
    }
    if (destGroupOwnerId) {
      res["DestGroupOwnerId"] = boost::any(*destGroupOwnerId);
    }
    if (destGroupOwnerAccount) {
      res["DestGroupOwnerAccount"] = boost::any(*destGroupOwnerAccount);
    }
    if (destCidrIp) {
      res["DestCidrIp"] = boost::any(*destCidrIp);
    }
    if (ipv6DestCidrIp) {
      res["Ipv6DestCidrIp"] = boost::any(*ipv6DestCidrIp);
    }
    if (destPrefixListId) {
      res["DestPrefixListId"] = boost::any(*destPrefixListId);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (ipv6SourceCidrIp) {
      res["Ipv6SourceCidrIp"] = boost::any(*ipv6SourceCidrIp);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (nicType) {
      res["NicType"] = boost::any(*nicType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("DestGroupId") != m.end() && !m["DestGroupId"].empty()) {
      destGroupId = make_shared<string>(boost::any_cast<string>(m["DestGroupId"]));
    }
    if (m.find("DestGroupOwnerId") != m.end() && !m["DestGroupOwnerId"].empty()) {
      destGroupOwnerId = make_shared<long>(boost::any_cast<long>(m["DestGroupOwnerId"]));
    }
    if (m.find("DestGroupOwnerAccount") != m.end() && !m["DestGroupOwnerAccount"].empty()) {
      destGroupOwnerAccount = make_shared<string>(boost::any_cast<string>(m["DestGroupOwnerAccount"]));
    }
    if (m.find("DestCidrIp") != m.end() && !m["DestCidrIp"].empty()) {
      destCidrIp = make_shared<string>(boost::any_cast<string>(m["DestCidrIp"]));
    }
    if (m.find("Ipv6DestCidrIp") != m.end() && !m["Ipv6DestCidrIp"].empty()) {
      ipv6DestCidrIp = make_shared<string>(boost::any_cast<string>(m["Ipv6DestCidrIp"]));
    }
    if (m.find("DestPrefixListId") != m.end() && !m["DestPrefixListId"].empty()) {
      destPrefixListId = make_shared<string>(boost::any_cast<string>(m["DestPrefixListId"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("Ipv6SourceCidrIp") != m.end() && !m["Ipv6SourceCidrIp"].empty()) {
      ipv6SourceCidrIp = make_shared<string>(boost::any_cast<string>(m["Ipv6SourceCidrIp"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("NicType") != m.end() && !m["NicType"].empty()) {
      nicType = make_shared<string>(boost::any_cast<string>(m["NicType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~RevokeSecurityGroupEgressRequest() = default;
};
class RevokeSecurityGroupEgressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RevokeSecurityGroupEgressResponseBody() {}

  explicit RevokeSecurityGroupEgressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RevokeSecurityGroupEgressResponseBody() = default;
};
class RevokeSecurityGroupEgressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RevokeSecurityGroupEgressResponseBody> body{};

  RevokeSecurityGroupEgressResponse() {}

  explicit RevokeSecurityGroupEgressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeSecurityGroupEgressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeSecurityGroupEgressResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeSecurityGroupEgressResponse() = default;
};
class RunCommandRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> type{};
  shared_ptr<string> commandContent{};
  shared_ptr<string> workingDir{};
  shared_ptr<long> timeout{};
  shared_ptr<bool> enableParameter{};
  shared_ptr<string> repeatMode{};
  shared_ptr<bool> timed{};
  shared_ptr<string> frequency{};
  shared_ptr<map<string, boost::any>> parameters{};
  shared_ptr<bool> keepCommand{};
  shared_ptr<string> contentEncoding{};
  shared_ptr<string> username{};
  shared_ptr<string> windowsPasswordName{};

  RunCommandRequest() {}

  explicit RunCommandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (commandContent) {
      res["CommandContent"] = boost::any(*commandContent);
    }
    if (workingDir) {
      res["WorkingDir"] = boost::any(*workingDir);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (enableParameter) {
      res["EnableParameter"] = boost::any(*enableParameter);
    }
    if (repeatMode) {
      res["RepeatMode"] = boost::any(*repeatMode);
    }
    if (timed) {
      res["Timed"] = boost::any(*timed);
    }
    if (frequency) {
      res["Frequency"] = boost::any(*frequency);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (keepCommand) {
      res["KeepCommand"] = boost::any(*keepCommand);
    }
    if (contentEncoding) {
      res["ContentEncoding"] = boost::any(*contentEncoding);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    if (windowsPasswordName) {
      res["WindowsPasswordName"] = boost::any(*windowsPasswordName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("CommandContent") != m.end() && !m["CommandContent"].empty()) {
      commandContent = make_shared<string>(boost::any_cast<string>(m["CommandContent"]));
    }
    if (m.find("WorkingDir") != m.end() && !m["WorkingDir"].empty()) {
      workingDir = make_shared<string>(boost::any_cast<string>(m["WorkingDir"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("EnableParameter") != m.end() && !m["EnableParameter"].empty()) {
      enableParameter = make_shared<bool>(boost::any_cast<bool>(m["EnableParameter"]));
    }
    if (m.find("RepeatMode") != m.end() && !m["RepeatMode"].empty()) {
      repeatMode = make_shared<string>(boost::any_cast<string>(m["RepeatMode"]));
    }
    if (m.find("Timed") != m.end() && !m["Timed"].empty()) {
      timed = make_shared<bool>(boost::any_cast<bool>(m["Timed"]));
    }
    if (m.find("Frequency") != m.end() && !m["Frequency"].empty()) {
      frequency = make_shared<string>(boost::any_cast<string>(m["Frequency"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Parameters"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      parameters = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("KeepCommand") != m.end() && !m["KeepCommand"].empty()) {
      keepCommand = make_shared<bool>(boost::any_cast<bool>(m["KeepCommand"]));
    }
    if (m.find("ContentEncoding") != m.end() && !m["ContentEncoding"].empty()) {
      contentEncoding = make_shared<string>(boost::any_cast<string>(m["ContentEncoding"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
    if (m.find("WindowsPasswordName") != m.end() && !m["WindowsPasswordName"].empty()) {
      windowsPasswordName = make_shared<string>(boost::any_cast<string>(m["WindowsPasswordName"]));
    }
  }


  virtual ~RunCommandRequest() = default;
};
class RunCommandShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> type{};
  shared_ptr<string> commandContent{};
  shared_ptr<string> workingDir{};
  shared_ptr<long> timeout{};
  shared_ptr<bool> enableParameter{};
  shared_ptr<string> repeatMode{};
  shared_ptr<bool> timed{};
  shared_ptr<string> frequency{};
  shared_ptr<string> parametersShrink{};
  shared_ptr<bool> keepCommand{};
  shared_ptr<string> contentEncoding{};
  shared_ptr<string> username{};
  shared_ptr<string> windowsPasswordName{};

  RunCommandShrinkRequest() {}

  explicit RunCommandShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (commandContent) {
      res["CommandContent"] = boost::any(*commandContent);
    }
    if (workingDir) {
      res["WorkingDir"] = boost::any(*workingDir);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (enableParameter) {
      res["EnableParameter"] = boost::any(*enableParameter);
    }
    if (repeatMode) {
      res["RepeatMode"] = boost::any(*repeatMode);
    }
    if (timed) {
      res["Timed"] = boost::any(*timed);
    }
    if (frequency) {
      res["Frequency"] = boost::any(*frequency);
    }
    if (parametersShrink) {
      res["Parameters"] = boost::any(*parametersShrink);
    }
    if (keepCommand) {
      res["KeepCommand"] = boost::any(*keepCommand);
    }
    if (contentEncoding) {
      res["ContentEncoding"] = boost::any(*contentEncoding);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    if (windowsPasswordName) {
      res["WindowsPasswordName"] = boost::any(*windowsPasswordName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("CommandContent") != m.end() && !m["CommandContent"].empty()) {
      commandContent = make_shared<string>(boost::any_cast<string>(m["CommandContent"]));
    }
    if (m.find("WorkingDir") != m.end() && !m["WorkingDir"].empty()) {
      workingDir = make_shared<string>(boost::any_cast<string>(m["WorkingDir"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("EnableParameter") != m.end() && !m["EnableParameter"].empty()) {
      enableParameter = make_shared<bool>(boost::any_cast<bool>(m["EnableParameter"]));
    }
    if (m.find("RepeatMode") != m.end() && !m["RepeatMode"].empty()) {
      repeatMode = make_shared<string>(boost::any_cast<string>(m["RepeatMode"]));
    }
    if (m.find("Timed") != m.end() && !m["Timed"].empty()) {
      timed = make_shared<bool>(boost::any_cast<bool>(m["Timed"]));
    }
    if (m.find("Frequency") != m.end() && !m["Frequency"].empty()) {
      frequency = make_shared<string>(boost::any_cast<string>(m["Frequency"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parametersShrink = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
    if (m.find("KeepCommand") != m.end() && !m["KeepCommand"].empty()) {
      keepCommand = make_shared<bool>(boost::any_cast<bool>(m["KeepCommand"]));
    }
    if (m.find("ContentEncoding") != m.end() && !m["ContentEncoding"].empty()) {
      contentEncoding = make_shared<string>(boost::any_cast<string>(m["ContentEncoding"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
    if (m.find("WindowsPasswordName") != m.end() && !m["WindowsPasswordName"].empty()) {
      windowsPasswordName = make_shared<string>(boost::any_cast<string>(m["WindowsPasswordName"]));
    }
  }


  virtual ~RunCommandShrinkRequest() = default;
};
class RunCommandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> commandId{};
  shared_ptr<string> invokeId{};

  RunCommandResponseBody() {}

  explicit RunCommandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (commandId) {
      res["CommandId"] = boost::any(*commandId);
    }
    if (invokeId) {
      res["InvokeId"] = boost::any(*invokeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CommandId") != m.end() && !m["CommandId"].empty()) {
      commandId = make_shared<string>(boost::any_cast<string>(m["CommandId"]));
    }
    if (m.find("InvokeId") != m.end() && !m["InvokeId"].empty()) {
      invokeId = make_shared<string>(boost::any_cast<string>(m["InvokeId"]));
    }
  }


  virtual ~RunCommandResponseBody() = default;
};
class RunCommandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RunCommandResponseBody> body{};

  RunCommandResponse() {}

  explicit RunCommandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunCommandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunCommandResponseBody>(model1);
      }
    }
  }


  virtual ~RunCommandResponse() = default;
};
class RunInstancesRequestSystemDisk : public Darabonba::Model {
public:
  shared_ptr<string> size{};
  shared_ptr<string> category{};
  shared_ptr<string> diskName{};
  shared_ptr<string> description{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<string> autoSnapshotPolicyId{};

  RunInstancesRequestSystemDisk() {}

  explicit RunInstancesRequestSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (autoSnapshotPolicyId) {
      res["AutoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("AutoSnapshotPolicyId") != m.end() && !m["AutoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["AutoSnapshotPolicyId"]));
    }
  }


  virtual ~RunInstancesRequestSystemDisk() = default;
};
class RunInstancesRequestHibernationOptions : public Darabonba::Model {
public:
  shared_ptr<bool> configured{};

  RunInstancesRequestHibernationOptions() {}

  explicit RunInstancesRequestHibernationOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configured) {
      res["Configured"] = boost::any(*configured);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configured") != m.end() && !m["Configured"].empty()) {
      configured = make_shared<bool>(boost::any_cast<bool>(m["Configured"]));
    }
  }


  virtual ~RunInstancesRequestHibernationOptions() = default;
};
class RunInstancesRequestCpuOptions : public Darabonba::Model {
public:
  shared_ptr<long> core{};
  shared_ptr<long> threadsPerCore{};
  shared_ptr<string> numa{};

  RunInstancesRequestCpuOptions() {}

  explicit RunInstancesRequestCpuOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (core) {
      res["Core"] = boost::any(*core);
    }
    if (threadsPerCore) {
      res["ThreadsPerCore"] = boost::any(*threadsPerCore);
    }
    if (numa) {
      res["Numa"] = boost::any(*numa);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Core") != m.end() && !m["Core"].empty()) {
      core = make_shared<long>(boost::any_cast<long>(m["Core"]));
    }
    if (m.find("ThreadsPerCore") != m.end() && !m["ThreadsPerCore"].empty()) {
      threadsPerCore = make_shared<long>(boost::any_cast<long>(m["ThreadsPerCore"]));
    }
    if (m.find("Numa") != m.end() && !m["Numa"].empty()) {
      numa = make_shared<string>(boost::any_cast<string>(m["Numa"]));
    }
  }


  virtual ~RunInstancesRequestCpuOptions() = default;
};
class RunInstancesRequestSecurityOptions : public Darabonba::Model {
public:
  shared_ptr<string> trustedSystemMode{};
  shared_ptr<string> confidentialComputingMode{};

  RunInstancesRequestSecurityOptions() {}

  explicit RunInstancesRequestSecurityOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trustedSystemMode) {
      res["TrustedSystemMode"] = boost::any(*trustedSystemMode);
    }
    if (confidentialComputingMode) {
      res["ConfidentialComputingMode"] = boost::any(*confidentialComputingMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TrustedSystemMode") != m.end() && !m["TrustedSystemMode"].empty()) {
      trustedSystemMode = make_shared<string>(boost::any_cast<string>(m["TrustedSystemMode"]));
    }
    if (m.find("ConfidentialComputingMode") != m.end() && !m["ConfidentialComputingMode"].empty()) {
      confidentialComputingMode = make_shared<string>(boost::any_cast<string>(m["ConfidentialComputingMode"]));
    }
  }


  virtual ~RunInstancesRequestSecurityOptions() = default;
};
class RunInstancesRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> matchCriteria{};
  shared_ptr<string> id{};

  RunInstancesRequestPrivatePoolOptions() {}

  explicit RunInstancesRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchCriteria) {
      res["MatchCriteria"] = boost::any(*matchCriteria);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MatchCriteria") != m.end() && !m["MatchCriteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["MatchCriteria"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~RunInstancesRequestPrivatePoolOptions() = default;
};
class RunInstancesRequestSchedulerOptions : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedHostClusterId{};

  RunInstancesRequestSchedulerOptions() {}

  explicit RunInstancesRequestSchedulerOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
  }


  virtual ~RunInstancesRequestSchedulerOptions() = default;
};
class RunInstancesRequestDataDisk : public Darabonba::Model {
public:
  shared_ptr<string> performanceLevel{};
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<string> encrypted{};
  shared_ptr<string> description{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> device{};
  shared_ptr<long> size{};
  shared_ptr<string> diskName{};
  shared_ptr<string> category{};
  shared_ptr<string> encryptAlgorithm{};
  shared_ptr<bool> deleteWithInstance{};
  shared_ptr<string> KMSKeyId{};

  RunInstancesRequestDataDisk() {}

  explicit RunInstancesRequestDataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (autoSnapshotPolicyId) {
      res["AutoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (encryptAlgorithm) {
      res["EncryptAlgorithm"] = boost::any(*encryptAlgorithm);
    }
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("AutoSnapshotPolicyId") != m.end() && !m["AutoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["AutoSnapshotPolicyId"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<string>(boost::any_cast<string>(m["Encrypted"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("EncryptAlgorithm") != m.end() && !m["EncryptAlgorithm"].empty()) {
      encryptAlgorithm = make_shared<string>(boost::any_cast<string>(m["EncryptAlgorithm"]));
    }
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<bool>(boost::any_cast<bool>(m["DeleteWithInstance"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
  }


  virtual ~RunInstancesRequestDataDisk() = default;
};
class RunInstancesRequestArn : public Darabonba::Model {
public:
  shared_ptr<string> roleType{};
  shared_ptr<string> rolearn{};
  shared_ptr<long> assumeRoleFor{};

  RunInstancesRequestArn() {}

  explicit RunInstancesRequestArn(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleType) {
      res["RoleType"] = boost::any(*roleType);
    }
    if (rolearn) {
      res["Rolearn"] = boost::any(*rolearn);
    }
    if (assumeRoleFor) {
      res["AssumeRoleFor"] = boost::any(*assumeRoleFor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleType") != m.end() && !m["RoleType"].empty()) {
      roleType = make_shared<string>(boost::any_cast<string>(m["RoleType"]));
    }
    if (m.find("Rolearn") != m.end() && !m["Rolearn"].empty()) {
      rolearn = make_shared<string>(boost::any_cast<string>(m["Rolearn"]));
    }
    if (m.find("AssumeRoleFor") != m.end() && !m["AssumeRoleFor"].empty()) {
      assumeRoleFor = make_shared<long>(boost::any_cast<long>(m["AssumeRoleFor"]));
    }
  }


  virtual ~RunInstancesRequestArn() = default;
};
class RunInstancesRequestNetworkInterface : public Darabonba::Model {
public:
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> networkInterfaceName{};
  shared_ptr<string> description{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> primaryIpAddress{};
  shared_ptr<long> queueNumber{};
  shared_ptr<vector<string>> securityGroupIds{};

  RunInstancesRequestNetworkInterface() {}

  explicit RunInstancesRequestNetworkInterface(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (networkInterfaceName) {
      res["NetworkInterfaceName"] = boost::any(*networkInterfaceName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (primaryIpAddress) {
      res["PrimaryIpAddress"] = boost::any(*primaryIpAddress);
    }
    if (queueNumber) {
      res["QueueNumber"] = boost::any(*queueNumber);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("NetworkInterfaceName") != m.end() && !m["NetworkInterfaceName"].empty()) {
      networkInterfaceName = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("PrimaryIpAddress") != m.end() && !m["PrimaryIpAddress"].empty()) {
      primaryIpAddress = make_shared<string>(boost::any_cast<string>(m["PrimaryIpAddress"]));
    }
    if (m.find("QueueNumber") != m.end() && !m["QueueNumber"].empty()) {
      queueNumber = make_shared<long>(boost::any_cast<long>(m["QueueNumber"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RunInstancesRequestNetworkInterface() = default;
};
class RunInstancesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  RunInstancesRequestTag() {}

  explicit RunInstancesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~RunInstancesRequestTag() = default;
};
class RunInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<RunInstancesRequestSystemDisk> systemDisk{};
  shared_ptr<RunInstancesRequestHibernationOptions> hibernationOptions{};
  shared_ptr<RunInstancesRequestCpuOptions> cpuOptions{};
  shared_ptr<RunInstancesRequestSecurityOptions> securityOptions{};
  shared_ptr<RunInstancesRequestPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<RunInstancesRequestSchedulerOptions> schedulerOptions{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageFamily{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> description{};
  shared_ptr<long> internetMaxBandwidthIn{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> hostName{};
  shared_ptr<bool> uniqueSuffix{};
  shared_ptr<string> password{};
  shared_ptr<bool> passwordInherit{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> ioOptimized{};
  shared_ptr<string> userData{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> ramRoleName{};
  shared_ptr<long> amount{};
  shared_ptr<long> minAmount{};
  shared_ptr<string> autoReleaseTime{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<long> spotDuration{};
  shared_ptr<double> spotPriceLimit{};
  shared_ptr<string> spotInterruptionBehavior{};
  shared_ptr<string> securityEnhancementStrategy{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> hpcClusterId{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> launchTemplateId{};
  shared_ptr<string> launchTemplateName{};
  shared_ptr<long> launchTemplateVersion{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewPeriod{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> deploymentSetId{};
  shared_ptr<long> deploymentSetGroupNo{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> creditSpecification{};
  shared_ptr<long> ipv6AddressCount{};
  shared_ptr<long> networkInterfaceQueueNumber{};
  shared_ptr<bool> deletionProtection{};
  shared_ptr<string> affinity{};
  shared_ptr<string> tenancy{};
  shared_ptr<string> storageSetId{};
  shared_ptr<long> storageSetPartitionNumber{};
  shared_ptr<string> httpEndpoint{};
  shared_ptr<string> httpTokens{};
  shared_ptr<long> httpPutResponseHopLimit{};
  shared_ptr<string> isp{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<vector<string>> hostNames{};
  shared_ptr<vector<RunInstancesRequestDataDisk>> dataDisk{};
  shared_ptr<vector<RunInstancesRequestArn>> arn{};
  shared_ptr<vector<RunInstancesRequestNetworkInterface>> networkInterface{};
  shared_ptr<vector<RunInstancesRequestTag>> tag{};
  shared_ptr<vector<string>> ipv6Address{};

  RunInstancesRequest() {}

  explicit RunInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hibernationOptions) {
      res["HibernationOptions"] = hibernationOptions ? boost::any(hibernationOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cpuOptions) {
      res["CpuOptions"] = cpuOptions ? boost::any(cpuOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (securityOptions) {
      res["SecurityOptions"] = securityOptions ? boost::any(securityOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (privatePoolOptions) {
      res["PrivatePoolOptions"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (schedulerOptions) {
      res["SchedulerOptions"] = schedulerOptions ? boost::any(schedulerOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageFamily) {
      res["ImageFamily"] = boost::any(*imageFamily);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (internetMaxBandwidthIn) {
      res["InternetMaxBandwidthIn"] = boost::any(*internetMaxBandwidthIn);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (uniqueSuffix) {
      res["UniqueSuffix"] = boost::any(*uniqueSuffix);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (passwordInherit) {
      res["PasswordInherit"] = boost::any(*passwordInherit);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (minAmount) {
      res["MinAmount"] = boost::any(*minAmount);
    }
    if (autoReleaseTime) {
      res["AutoReleaseTime"] = boost::any(*autoReleaseTime);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (spotDuration) {
      res["SpotDuration"] = boost::any(*spotDuration);
    }
    if (spotPriceLimit) {
      res["SpotPriceLimit"] = boost::any(*spotPriceLimit);
    }
    if (spotInterruptionBehavior) {
      res["SpotInterruptionBehavior"] = boost::any(*spotInterruptionBehavior);
    }
    if (securityEnhancementStrategy) {
      res["SecurityEnhancementStrategy"] = boost::any(*securityEnhancementStrategy);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (hpcClusterId) {
      res["HpcClusterId"] = boost::any(*hpcClusterId);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (launchTemplateId) {
      res["LaunchTemplateId"] = boost::any(*launchTemplateId);
    }
    if (launchTemplateName) {
      res["LaunchTemplateName"] = boost::any(*launchTemplateName);
    }
    if (launchTemplateVersion) {
      res["LaunchTemplateVersion"] = boost::any(*launchTemplateVersion);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoRenewPeriod) {
      res["AutoRenewPeriod"] = boost::any(*autoRenewPeriod);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (deploymentSetId) {
      res["DeploymentSetId"] = boost::any(*deploymentSetId);
    }
    if (deploymentSetGroupNo) {
      res["DeploymentSetGroupNo"] = boost::any(*deploymentSetGroupNo);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (creditSpecification) {
      res["CreditSpecification"] = boost::any(*creditSpecification);
    }
    if (ipv6AddressCount) {
      res["Ipv6AddressCount"] = boost::any(*ipv6AddressCount);
    }
    if (networkInterfaceQueueNumber) {
      res["NetworkInterfaceQueueNumber"] = boost::any(*networkInterfaceQueueNumber);
    }
    if (deletionProtection) {
      res["DeletionProtection"] = boost::any(*deletionProtection);
    }
    if (affinity) {
      res["Affinity"] = boost::any(*affinity);
    }
    if (tenancy) {
      res["Tenancy"] = boost::any(*tenancy);
    }
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    if (storageSetPartitionNumber) {
      res["StorageSetPartitionNumber"] = boost::any(*storageSetPartitionNumber);
    }
    if (httpEndpoint) {
      res["HttpEndpoint"] = boost::any(*httpEndpoint);
    }
    if (httpTokens) {
      res["HttpTokens"] = boost::any(*httpTokens);
    }
    if (httpPutResponseHopLimit) {
      res["HttpPutResponseHopLimit"] = boost::any(*httpPutResponseHopLimit);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    if (hostNames) {
      res["HostNames"] = boost::any(*hostNames);
    }
    if (dataDisk) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisk"] = boost::any(temp1);
    }
    if (arn) {
      vector<boost::any> temp1;
      for(auto item1:*arn){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Arn"] = boost::any(temp1);
    }
    if (networkInterface) {
      vector<boost::any> temp1;
      for(auto item1:*networkInterface){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkInterface"] = boost::any(temp1);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (ipv6Address) {
      res["Ipv6Address"] = boost::any(*ipv6Address);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        RunInstancesRequestSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<RunInstancesRequestSystemDisk>(model1);
      }
    }
    if (m.find("HibernationOptions") != m.end() && !m["HibernationOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["HibernationOptions"].type()) {
        RunInstancesRequestHibernationOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HibernationOptions"]));
        hibernationOptions = make_shared<RunInstancesRequestHibernationOptions>(model1);
      }
    }
    if (m.find("CpuOptions") != m.end() && !m["CpuOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["CpuOptions"].type()) {
        RunInstancesRequestCpuOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CpuOptions"]));
        cpuOptions = make_shared<RunInstancesRequestCpuOptions>(model1);
      }
    }
    if (m.find("SecurityOptions") != m.end() && !m["SecurityOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityOptions"].type()) {
        RunInstancesRequestSecurityOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityOptions"]));
        securityOptions = make_shared<RunInstancesRequestSecurityOptions>(model1);
      }
    }
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolOptions"].type()) {
        RunInstancesRequestPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolOptions"]));
        privatePoolOptions = make_shared<RunInstancesRequestPrivatePoolOptions>(model1);
      }
    }
    if (m.find("SchedulerOptions") != m.end() && !m["SchedulerOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["SchedulerOptions"].type()) {
        RunInstancesRequestSchedulerOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SchedulerOptions"]));
        schedulerOptions = make_shared<RunInstancesRequestSchedulerOptions>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageFamily") != m.end() && !m["ImageFamily"].empty()) {
      imageFamily = make_shared<string>(boost::any_cast<string>(m["ImageFamily"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InternetMaxBandwidthIn") != m.end() && !m["InternetMaxBandwidthIn"].empty()) {
      internetMaxBandwidthIn = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthIn"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("UniqueSuffix") != m.end() && !m["UniqueSuffix"].empty()) {
      uniqueSuffix = make_shared<bool>(boost::any_cast<bool>(m["UniqueSuffix"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("PasswordInherit") != m.end() && !m["PasswordInherit"].empty()) {
      passwordInherit = make_shared<bool>(boost::any_cast<bool>(m["PasswordInherit"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("MinAmount") != m.end() && !m["MinAmount"].empty()) {
      minAmount = make_shared<long>(boost::any_cast<long>(m["MinAmount"]));
    }
    if (m.find("AutoReleaseTime") != m.end() && !m["AutoReleaseTime"].empty()) {
      autoReleaseTime = make_shared<string>(boost::any_cast<string>(m["AutoReleaseTime"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("SpotDuration") != m.end() && !m["SpotDuration"].empty()) {
      spotDuration = make_shared<long>(boost::any_cast<long>(m["SpotDuration"]));
    }
    if (m.find("SpotPriceLimit") != m.end() && !m["SpotPriceLimit"].empty()) {
      spotPriceLimit = make_shared<double>(boost::any_cast<double>(m["SpotPriceLimit"]));
    }
    if (m.find("SpotInterruptionBehavior") != m.end() && !m["SpotInterruptionBehavior"].empty()) {
      spotInterruptionBehavior = make_shared<string>(boost::any_cast<string>(m["SpotInterruptionBehavior"]));
    }
    if (m.find("SecurityEnhancementStrategy") != m.end() && !m["SecurityEnhancementStrategy"].empty()) {
      securityEnhancementStrategy = make_shared<string>(boost::any_cast<string>(m["SecurityEnhancementStrategy"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("HpcClusterId") != m.end() && !m["HpcClusterId"].empty()) {
      hpcClusterId = make_shared<string>(boost::any_cast<string>(m["HpcClusterId"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("LaunchTemplateId") != m.end() && !m["LaunchTemplateId"].empty()) {
      launchTemplateId = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateId"]));
    }
    if (m.find("LaunchTemplateName") != m.end() && !m["LaunchTemplateName"].empty()) {
      launchTemplateName = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateName"]));
    }
    if (m.find("LaunchTemplateVersion") != m.end() && !m["LaunchTemplateVersion"].empty()) {
      launchTemplateVersion = make_shared<long>(boost::any_cast<long>(m["LaunchTemplateVersion"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("AutoRenewPeriod") != m.end() && !m["AutoRenewPeriod"].empty()) {
      autoRenewPeriod = make_shared<long>(boost::any_cast<long>(m["AutoRenewPeriod"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("DeploymentSetId") != m.end() && !m["DeploymentSetId"].empty()) {
      deploymentSetId = make_shared<string>(boost::any_cast<string>(m["DeploymentSetId"]));
    }
    if (m.find("DeploymentSetGroupNo") != m.end() && !m["DeploymentSetGroupNo"].empty()) {
      deploymentSetGroupNo = make_shared<long>(boost::any_cast<long>(m["DeploymentSetGroupNo"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("CreditSpecification") != m.end() && !m["CreditSpecification"].empty()) {
      creditSpecification = make_shared<string>(boost::any_cast<string>(m["CreditSpecification"]));
    }
    if (m.find("Ipv6AddressCount") != m.end() && !m["Ipv6AddressCount"].empty()) {
      ipv6AddressCount = make_shared<long>(boost::any_cast<long>(m["Ipv6AddressCount"]));
    }
    if (m.find("NetworkInterfaceQueueNumber") != m.end() && !m["NetworkInterfaceQueueNumber"].empty()) {
      networkInterfaceQueueNumber = make_shared<long>(boost::any_cast<long>(m["NetworkInterfaceQueueNumber"]));
    }
    if (m.find("DeletionProtection") != m.end() && !m["DeletionProtection"].empty()) {
      deletionProtection = make_shared<bool>(boost::any_cast<bool>(m["DeletionProtection"]));
    }
    if (m.find("Affinity") != m.end() && !m["Affinity"].empty()) {
      affinity = make_shared<string>(boost::any_cast<string>(m["Affinity"]));
    }
    if (m.find("Tenancy") != m.end() && !m["Tenancy"].empty()) {
      tenancy = make_shared<string>(boost::any_cast<string>(m["Tenancy"]));
    }
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
    if (m.find("StorageSetPartitionNumber") != m.end() && !m["StorageSetPartitionNumber"].empty()) {
      storageSetPartitionNumber = make_shared<long>(boost::any_cast<long>(m["StorageSetPartitionNumber"]));
    }
    if (m.find("HttpEndpoint") != m.end() && !m["HttpEndpoint"].empty()) {
      httpEndpoint = make_shared<string>(boost::any_cast<string>(m["HttpEndpoint"]));
    }
    if (m.find("HttpTokens") != m.end() && !m["HttpTokens"].empty()) {
      httpTokens = make_shared<string>(boost::any_cast<string>(m["HttpTokens"]));
    }
    if (m.find("HttpPutResponseHopLimit") != m.end() && !m["HttpPutResponseHopLimit"].empty()) {
      httpPutResponseHopLimit = make_shared<long>(boost::any_cast<long>(m["HttpPutResponseHopLimit"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HostNames") != m.end() && !m["HostNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HostNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HostNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisk"].type()) {
        vector<RunInstancesRequestDataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunInstancesRequestDataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisk = make_shared<vector<RunInstancesRequestDataDisk>>(expect1);
      }
    }
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      if (typeid(vector<boost::any>) == m["Arn"].type()) {
        vector<RunInstancesRequestArn> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Arn"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunInstancesRequestArn model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        arn = make_shared<vector<RunInstancesRequestArn>>(expect1);
      }
    }
    if (m.find("NetworkInterface") != m.end() && !m["NetworkInterface"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkInterface"].type()) {
        vector<RunInstancesRequestNetworkInterface> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkInterface"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunInstancesRequestNetworkInterface model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkInterface = make_shared<vector<RunInstancesRequestNetworkInterface>>(expect1);
      }
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<RunInstancesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunInstancesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<RunInstancesRequestTag>>(expect1);
      }
    }
    if (m.find("Ipv6Address") != m.end() && !m["Ipv6Address"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ipv6Address"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ipv6Address"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipv6Address = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RunInstancesRequest() = default;
};
class RunInstancesResponseBodyInstanceIdSets : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIdSet{};

  RunInstancesResponseBodyInstanceIdSets() {}

  explicit RunInstancesResponseBodyInstanceIdSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIdSet) {
      res["InstanceIdSet"] = boost::any(*instanceIdSet);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIdSet") != m.end() && !m["InstanceIdSet"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIdSet"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIdSet"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIdSet = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RunInstancesResponseBodyInstanceIdSets() = default;
};
class RunInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> orderId{};
  shared_ptr<double> tradePrice{};
  shared_ptr<RunInstancesResponseBodyInstanceIdSets> instanceIdSets{};

  RunInstancesResponseBody() {}

  explicit RunInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    if (instanceIdSets) {
      res["InstanceIdSets"] = instanceIdSets ? boost::any(instanceIdSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
    if (m.find("InstanceIdSets") != m.end() && !m["InstanceIdSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceIdSets"].type()) {
        RunInstancesResponseBodyInstanceIdSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceIdSets"]));
        instanceIdSets = make_shared<RunInstancesResponseBodyInstanceIdSets>(model1);
      }
    }
  }


  virtual ~RunInstancesResponseBody() = default;
};
class RunInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RunInstancesResponseBody> body{};

  RunInstancesResponse() {}

  explicit RunInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~RunInstancesResponse() = default;
};
class SendFileRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<long> timeout{};
  shared_ptr<string> targetDir{};
  shared_ptr<string> contentType{};
  shared_ptr<string> content{};
  shared_ptr<string> fileOwner{};
  shared_ptr<string> fileGroup{};
  shared_ptr<string> fileMode{};
  shared_ptr<bool> overwrite{};

  SendFileRequest() {}

  explicit SendFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (targetDir) {
      res["TargetDir"] = boost::any(*targetDir);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (fileOwner) {
      res["FileOwner"] = boost::any(*fileOwner);
    }
    if (fileGroup) {
      res["FileGroup"] = boost::any(*fileGroup);
    }
    if (fileMode) {
      res["FileMode"] = boost::any(*fileMode);
    }
    if (overwrite) {
      res["Overwrite"] = boost::any(*overwrite);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("TargetDir") != m.end() && !m["TargetDir"].empty()) {
      targetDir = make_shared<string>(boost::any_cast<string>(m["TargetDir"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("FileOwner") != m.end() && !m["FileOwner"].empty()) {
      fileOwner = make_shared<string>(boost::any_cast<string>(m["FileOwner"]));
    }
    if (m.find("FileGroup") != m.end() && !m["FileGroup"].empty()) {
      fileGroup = make_shared<string>(boost::any_cast<string>(m["FileGroup"]));
    }
    if (m.find("FileMode") != m.end() && !m["FileMode"].empty()) {
      fileMode = make_shared<string>(boost::any_cast<string>(m["FileMode"]));
    }
    if (m.find("Overwrite") != m.end() && !m["Overwrite"].empty()) {
      overwrite = make_shared<bool>(boost::any_cast<bool>(m["Overwrite"]));
    }
  }


  virtual ~SendFileRequest() = default;
};
class SendFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> invokeId{};
  shared_ptr<string> requestId{};

  SendFileResponseBody() {}

  explicit SendFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invokeId) {
      res["InvokeId"] = boost::any(*invokeId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InvokeId") != m.end() && !m["InvokeId"].empty()) {
      invokeId = make_shared<string>(boost::any_cast<string>(m["InvokeId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SendFileResponseBody() = default;
};
class SendFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SendFileResponseBody> body{};

  SendFileResponse() {}

  explicit SendFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendFileResponseBody>(model1);
      }
    }
  }


  virtual ~SendFileResponse() = default;
};
class StartDiskReplicaPairRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> replicaPairId{};

  StartDiskReplicaPairRequest() {}

  explicit StartDiskReplicaPairRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (replicaPairId) {
      res["ReplicaPairId"] = boost::any(*replicaPairId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReplicaPairId") != m.end() && !m["ReplicaPairId"].empty()) {
      replicaPairId = make_shared<string>(boost::any_cast<string>(m["ReplicaPairId"]));
    }
  }


  virtual ~StartDiskReplicaPairRequest() = default;
};
class StartDiskReplicaPairResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartDiskReplicaPairResponseBody() {}

  explicit StartDiskReplicaPairResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartDiskReplicaPairResponseBody() = default;
};
class StartDiskReplicaPairResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StartDiskReplicaPairResponseBody> body{};

  StartDiskReplicaPairResponse() {}

  explicit StartDiskReplicaPairResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartDiskReplicaPairResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartDiskReplicaPairResponseBody>(model1);
      }
    }
  }


  virtual ~StartDiskReplicaPairResponse() = default;
};
class StartElasticityAssuranceRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  StartElasticityAssuranceRequestPrivatePoolOptions() {}

  explicit StartElasticityAssuranceRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~StartElasticityAssuranceRequestPrivatePoolOptions() = default;
};
class StartElasticityAssuranceRequest : public Darabonba::Model {
public:
  shared_ptr<StartElasticityAssuranceRequestPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};

  StartElasticityAssuranceRequest() {}

  explicit StartElasticityAssuranceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privatePoolOptions) {
      res["PrivatePoolOptions"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolOptions"].type()) {
        StartElasticityAssuranceRequestPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolOptions"]));
        privatePoolOptions = make_shared<StartElasticityAssuranceRequestPrivatePoolOptions>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~StartElasticityAssuranceRequest() = default;
};
class StartElasticityAssuranceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartElasticityAssuranceResponseBody() {}

  explicit StartElasticityAssuranceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartElasticityAssuranceResponseBody() = default;
};
class StartElasticityAssuranceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StartElasticityAssuranceResponseBody> body{};

  StartElasticityAssuranceResponse() {}

  explicit StartElasticityAssuranceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartElasticityAssuranceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartElasticityAssuranceResponseBody>(model1);
      }
    }
  }


  virtual ~StartElasticityAssuranceResponse() = default;
};
class StartImagePipelineExecutionRequestTemplateTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  StartImagePipelineExecutionRequestTemplateTag() {}

  explicit StartImagePipelineExecutionRequestTemplateTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~StartImagePipelineExecutionRequestTemplateTag() = default;
};
class StartImagePipelineExecutionRequest : public Darabonba::Model {
public:
  shared_ptr<vector<StartImagePipelineExecutionRequestTemplateTag>> templateTag{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> imagePipelineId{};
  shared_ptr<string> clientToken{};

  StartImagePipelineExecutionRequest() {}

  explicit StartImagePipelineExecutionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateTag) {
      vector<boost::any> temp1;
      for(auto item1:*templateTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TemplateTag"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (imagePipelineId) {
      res["ImagePipelineId"] = boost::any(*imagePipelineId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateTag") != m.end() && !m["TemplateTag"].empty()) {
      if (typeid(vector<boost::any>) == m["TemplateTag"].type()) {
        vector<StartImagePipelineExecutionRequestTemplateTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TemplateTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartImagePipelineExecutionRequestTemplateTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templateTag = make_shared<vector<StartImagePipelineExecutionRequestTemplateTag>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ImagePipelineId") != m.end() && !m["ImagePipelineId"].empty()) {
      imagePipelineId = make_shared<string>(boost::any_cast<string>(m["ImagePipelineId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~StartImagePipelineExecutionRequest() = default;
};
class StartImagePipelineExecutionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> executionId{};
  shared_ptr<string> requestId{};

  StartImagePipelineExecutionResponseBody() {}

  explicit StartImagePipelineExecutionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (executionId) {
      res["ExecutionId"] = boost::any(*executionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExecutionId") != m.end() && !m["ExecutionId"].empty()) {
      executionId = make_shared<string>(boost::any_cast<string>(m["ExecutionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartImagePipelineExecutionResponseBody() = default;
};
class StartImagePipelineExecutionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StartImagePipelineExecutionResponseBody> body{};

  StartImagePipelineExecutionResponse() {}

  explicit StartImagePipelineExecutionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartImagePipelineExecutionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartImagePipelineExecutionResponseBody>(model1);
      }
    }
  }


  virtual ~StartImagePipelineExecutionResponse() = default;
};
class StartInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceRegionId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> initLocalDisk{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<bool> dryRun{};

  StartInstanceRequest() {}

  explicit StartInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceRegionId) {
      res["SourceRegionId"] = boost::any(*sourceRegionId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (initLocalDisk) {
      res["InitLocalDisk"] = boost::any(*initLocalDisk);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceRegionId") != m.end() && !m["SourceRegionId"].empty()) {
      sourceRegionId = make_shared<string>(boost::any_cast<string>(m["SourceRegionId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InitLocalDisk") != m.end() && !m["InitLocalDisk"].empty()) {
      initLocalDisk = make_shared<bool>(boost::any_cast<bool>(m["InitLocalDisk"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
  }


  virtual ~StartInstanceRequest() = default;
};
class StartInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartInstanceResponseBody() {}

  explicit StartInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartInstanceResponseBody() = default;
};
class StartInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StartInstanceResponseBody> body{};

  StartInstanceResponse() {}

  explicit StartInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~StartInstanceResponse() = default;
};
class StartInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> regionId{};
  shared_ptr<string> batchOptimization{};
  shared_ptr<vector<string>> instanceId{};

  StartInstancesRequest() {}

  explicit StartInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (batchOptimization) {
      res["BatchOptimization"] = boost::any(*batchOptimization);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("BatchOptimization") != m.end() && !m["BatchOptimization"].empty()) {
      batchOptimization = make_shared<string>(boost::any_cast<string>(m["BatchOptimization"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~StartInstancesRequest() = default;
};
class StartInstancesResponseBodyInstanceResponsesInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> currentStatus{};
  shared_ptr<string> previousStatus{};

  StartInstancesResponseBodyInstanceResponsesInstanceResponse() {}

  explicit StartInstancesResponseBodyInstanceResponsesInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (currentStatus) {
      res["CurrentStatus"] = boost::any(*currentStatus);
    }
    if (previousStatus) {
      res["PreviousStatus"] = boost::any(*previousStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CurrentStatus") != m.end() && !m["CurrentStatus"].empty()) {
      currentStatus = make_shared<string>(boost::any_cast<string>(m["CurrentStatus"]));
    }
    if (m.find("PreviousStatus") != m.end() && !m["PreviousStatus"].empty()) {
      previousStatus = make_shared<string>(boost::any_cast<string>(m["PreviousStatus"]));
    }
  }


  virtual ~StartInstancesResponseBodyInstanceResponsesInstanceResponse() = default;
};
class StartInstancesResponseBodyInstanceResponses : public Darabonba::Model {
public:
  shared_ptr<vector<StartInstancesResponseBodyInstanceResponsesInstanceResponse>> instanceResponse{};

  StartInstancesResponseBodyInstanceResponses() {}

  explicit StartInstancesResponseBodyInstanceResponses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceResponse) {
      vector<boost::any> temp1;
      for(auto item1:*instanceResponse){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceResponse"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceResponse") != m.end() && !m["InstanceResponse"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceResponse"].type()) {
        vector<StartInstancesResponseBodyInstanceResponsesInstanceResponse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceResponse"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartInstancesResponseBodyInstanceResponsesInstanceResponse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceResponse = make_shared<vector<StartInstancesResponseBodyInstanceResponsesInstanceResponse>>(expect1);
      }
    }
  }


  virtual ~StartInstancesResponseBodyInstanceResponses() = default;
};
class StartInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<StartInstancesResponseBodyInstanceResponses> instanceResponses{};

  StartInstancesResponseBody() {}

  explicit StartInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceResponses) {
      res["InstanceResponses"] = instanceResponses ? boost::any(instanceResponses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceResponses") != m.end() && !m["InstanceResponses"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceResponses"].type()) {
        StartInstancesResponseBodyInstanceResponses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceResponses"]));
        instanceResponses = make_shared<StartInstancesResponseBodyInstanceResponses>(model1);
      }
    }
  }


  virtual ~StartInstancesResponseBody() = default;
};
class StartInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StartInstancesResponseBody> body{};

  StartInstancesResponse() {}

  explicit StartInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~StartInstancesResponse() = default;
};
class StartTerminalSessionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> instanceId{};

  StartTerminalSessionRequest() {}

  explicit StartTerminalSessionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~StartTerminalSessionRequest() = default;
};
class StartTerminalSessionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> webSocketUrl{};

  StartTerminalSessionResponseBody() {}

  explicit StartTerminalSessionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (webSocketUrl) {
      res["WebSocketUrl"] = boost::any(*webSocketUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("WebSocketUrl") != m.end() && !m["WebSocketUrl"].empty()) {
      webSocketUrl = make_shared<string>(boost::any_cast<string>(m["WebSocketUrl"]));
    }
  }


  virtual ~StartTerminalSessionResponseBody() = default;
};
class StartTerminalSessionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StartTerminalSessionResponseBody> body{};

  StartTerminalSessionResponse() {}

  explicit StartTerminalSessionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartTerminalSessionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartTerminalSessionResponseBody>(model1);
      }
    }
  }


  virtual ~StartTerminalSessionResponse() = default;
};
class StopDiskReplicaPairRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> replicaPairId{};

  StopDiskReplicaPairRequest() {}

  explicit StopDiskReplicaPairRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (replicaPairId) {
      res["ReplicaPairId"] = boost::any(*replicaPairId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReplicaPairId") != m.end() && !m["ReplicaPairId"].empty()) {
      replicaPairId = make_shared<string>(boost::any_cast<string>(m["ReplicaPairId"]));
    }
  }


  virtual ~StopDiskReplicaPairRequest() = default;
};
class StopDiskReplicaPairResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopDiskReplicaPairResponseBody() {}

  explicit StopDiskReplicaPairResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopDiskReplicaPairResponseBody() = default;
};
class StopDiskReplicaPairResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StopDiskReplicaPairResponseBody> body{};

  StopDiskReplicaPairResponse() {}

  explicit StopDiskReplicaPairResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopDiskReplicaPairResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopDiskReplicaPairResponseBody>(model1);
      }
    }
  }


  virtual ~StopDiskReplicaPairResponse() = default;
};
class StopInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> confirmStop{};
  shared_ptr<bool> forceStop{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> stoppedMode{};
  shared_ptr<bool> dryRun{};
  shared_ptr<bool> hibernate{};

  StopInstanceRequest() {}

  explicit StopInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (confirmStop) {
      res["ConfirmStop"] = boost::any(*confirmStop);
    }
    if (forceStop) {
      res["ForceStop"] = boost::any(*forceStop);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (stoppedMode) {
      res["StoppedMode"] = boost::any(*stoppedMode);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (hibernate) {
      res["Hibernate"] = boost::any(*hibernate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ConfirmStop") != m.end() && !m["ConfirmStop"].empty()) {
      confirmStop = make_shared<bool>(boost::any_cast<bool>(m["ConfirmStop"]));
    }
    if (m.find("ForceStop") != m.end() && !m["ForceStop"].empty()) {
      forceStop = make_shared<bool>(boost::any_cast<bool>(m["ForceStop"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("StoppedMode") != m.end() && !m["StoppedMode"].empty()) {
      stoppedMode = make_shared<string>(boost::any_cast<string>(m["StoppedMode"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("Hibernate") != m.end() && !m["Hibernate"].empty()) {
      hibernate = make_shared<bool>(boost::any_cast<bool>(m["Hibernate"]));
    }
  }


  virtual ~StopInstanceRequest() = default;
};
class StopInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopInstanceResponseBody() {}

  explicit StopInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopInstanceResponseBody() = default;
};
class StopInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StopInstanceResponseBody> body{};

  StopInstanceResponse() {}

  explicit StopInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~StopInstanceResponse() = default;
};
class StopInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<bool> dryRun{};
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> forceStop{};
  shared_ptr<string> stoppedMode{};
  shared_ptr<string> batchOptimization{};

  StopInstancesRequest() {}

  explicit StopInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (forceStop) {
      res["ForceStop"] = boost::any(*forceStop);
    }
    if (stoppedMode) {
      res["StoppedMode"] = boost::any(*stoppedMode);
    }
    if (batchOptimization) {
      res["BatchOptimization"] = boost::any(*batchOptimization);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ForceStop") != m.end() && !m["ForceStop"].empty()) {
      forceStop = make_shared<bool>(boost::any_cast<bool>(m["ForceStop"]));
    }
    if (m.find("StoppedMode") != m.end() && !m["StoppedMode"].empty()) {
      stoppedMode = make_shared<string>(boost::any_cast<string>(m["StoppedMode"]));
    }
    if (m.find("BatchOptimization") != m.end() && !m["BatchOptimization"].empty()) {
      batchOptimization = make_shared<string>(boost::any_cast<string>(m["BatchOptimization"]));
    }
  }


  virtual ~StopInstancesRequest() = default;
};
class StopInstancesResponseBodyInstanceResponsesInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> currentStatus{};
  shared_ptr<string> previousStatus{};

  StopInstancesResponseBodyInstanceResponsesInstanceResponse() {}

  explicit StopInstancesResponseBodyInstanceResponsesInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (currentStatus) {
      res["CurrentStatus"] = boost::any(*currentStatus);
    }
    if (previousStatus) {
      res["PreviousStatus"] = boost::any(*previousStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CurrentStatus") != m.end() && !m["CurrentStatus"].empty()) {
      currentStatus = make_shared<string>(boost::any_cast<string>(m["CurrentStatus"]));
    }
    if (m.find("PreviousStatus") != m.end() && !m["PreviousStatus"].empty()) {
      previousStatus = make_shared<string>(boost::any_cast<string>(m["PreviousStatus"]));
    }
  }


  virtual ~StopInstancesResponseBodyInstanceResponsesInstanceResponse() = default;
};
class StopInstancesResponseBodyInstanceResponses : public Darabonba::Model {
public:
  shared_ptr<vector<StopInstancesResponseBodyInstanceResponsesInstanceResponse>> instanceResponse{};

  StopInstancesResponseBodyInstanceResponses() {}

  explicit StopInstancesResponseBodyInstanceResponses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceResponse) {
      vector<boost::any> temp1;
      for(auto item1:*instanceResponse){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceResponse"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceResponse") != m.end() && !m["InstanceResponse"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceResponse"].type()) {
        vector<StopInstancesResponseBodyInstanceResponsesInstanceResponse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceResponse"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StopInstancesResponseBodyInstanceResponsesInstanceResponse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceResponse = make_shared<vector<StopInstancesResponseBodyInstanceResponsesInstanceResponse>>(expect1);
      }
    }
  }


  virtual ~StopInstancesResponseBodyInstanceResponses() = default;
};
class StopInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<StopInstancesResponseBodyInstanceResponses> instanceResponses{};

  StopInstancesResponseBody() {}

  explicit StopInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceResponses) {
      res["InstanceResponses"] = instanceResponses ? boost::any(instanceResponses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceResponses") != m.end() && !m["InstanceResponses"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceResponses"].type()) {
        StopInstancesResponseBodyInstanceResponses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceResponses"]));
        instanceResponses = make_shared<StopInstancesResponseBodyInstanceResponses>(model1);
      }
    }
  }


  virtual ~StopInstancesResponseBody() = default;
};
class StopInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StopInstancesResponseBody> body{};

  StopInstancesResponse() {}

  explicit StopInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~StopInstancesResponse() = default;
};
class StopInvocationRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<string> invokeId{};

  StopInvocationRequest() {}

  explicit StopInvocationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (invokeId) {
      res["InvokeId"] = boost::any(*invokeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InvokeId") != m.end() && !m["InvokeId"].empty()) {
      invokeId = make_shared<string>(boost::any_cast<string>(m["InvokeId"]));
    }
  }


  virtual ~StopInvocationRequest() = default;
};
class StopInvocationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopInvocationResponseBody() {}

  explicit StopInvocationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopInvocationResponseBody() = default;
};
class StopInvocationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StopInvocationResponseBody> body{};

  StopInvocationResponse() {}

  explicit StopInvocationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopInvocationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopInvocationResponseBody>(model1);
      }
    }
  }


  virtual ~StopInvocationResponse() = default;
};
class TagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesRequestTag() {}

  explicit TagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesRequestTag() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<vector<TagResourcesRequestTag>> tag{};
  shared_ptr<string> resourceType{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesRequestTag>>(expect1);
      }
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class TerminatePhysicalConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> userCidr{};

  TerminatePhysicalConnectionRequest() {}

  explicit TerminatePhysicalConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (userCidr) {
      res["UserCidr"] = boost::any(*userCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("UserCidr") != m.end() && !m["UserCidr"].empty()) {
      userCidr = make_shared<string>(boost::any_cast<string>(m["UserCidr"]));
    }
  }


  virtual ~TerminatePhysicalConnectionRequest() = default;
};
class TerminatePhysicalConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TerminatePhysicalConnectionResponseBody() {}

  explicit TerminatePhysicalConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TerminatePhysicalConnectionResponseBody() = default;
};
class TerminatePhysicalConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<TerminatePhysicalConnectionResponseBody> body{};

  TerminatePhysicalConnectionResponse() {}

  explicit TerminatePhysicalConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TerminatePhysicalConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TerminatePhysicalConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~TerminatePhysicalConnectionResponse() = default;
};
class TerminateVirtualBorderRouterRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> vbrId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> userCidr{};

  TerminateVirtualBorderRouterRequest() {}

  explicit TerminateVirtualBorderRouterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vbrId) {
      res["VbrId"] = boost::any(*vbrId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (userCidr) {
      res["UserCidr"] = boost::any(*userCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VbrId") != m.end() && !m["VbrId"].empty()) {
      vbrId = make_shared<string>(boost::any_cast<string>(m["VbrId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("UserCidr") != m.end() && !m["UserCidr"].empty()) {
      userCidr = make_shared<string>(boost::any_cast<string>(m["UserCidr"]));
    }
  }


  virtual ~TerminateVirtualBorderRouterRequest() = default;
};
class TerminateVirtualBorderRouterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TerminateVirtualBorderRouterResponseBody() {}

  explicit TerminateVirtualBorderRouterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TerminateVirtualBorderRouterResponseBody() = default;
};
class TerminateVirtualBorderRouterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<TerminateVirtualBorderRouterResponseBody> body{};

  TerminateVirtualBorderRouterResponse() {}

  explicit TerminateVirtualBorderRouterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TerminateVirtualBorderRouterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TerminateVirtualBorderRouterResponseBody>(model1);
      }
    }
  }


  virtual ~TerminateVirtualBorderRouterResponse() = default;
};
class UnassignIpv6AddressesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> ipv6Address{};
  shared_ptr<string> networkInterfaceId{};

  UnassignIpv6AddressesRequest() {}

  explicit UnassignIpv6AddressesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ipv6Address) {
      res["Ipv6Address"] = boost::any(*ipv6Address);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Ipv6Address") != m.end() && !m["Ipv6Address"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ipv6Address"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ipv6Address"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipv6Address = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
  }


  virtual ~UnassignIpv6AddressesRequest() = default;
};
class UnassignIpv6AddressesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnassignIpv6AddressesResponseBody() {}

  explicit UnassignIpv6AddressesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnassignIpv6AddressesResponseBody() = default;
};
class UnassignIpv6AddressesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UnassignIpv6AddressesResponseBody> body{};

  UnassignIpv6AddressesResponse() {}

  explicit UnassignIpv6AddressesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnassignIpv6AddressesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnassignIpv6AddressesResponseBody>(model1);
      }
    }
  }


  virtual ~UnassignIpv6AddressesResponse() = default;
};
class UnassignPrivateIpAddressesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> privateIpAddress{};
  shared_ptr<string> networkInterfaceId{};

  UnassignPrivateIpAddressesRequest() {}

  explicit UnassignPrivateIpAddressesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrivateIpAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrivateIpAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      privateIpAddress = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
  }


  virtual ~UnassignPrivateIpAddressesRequest() = default;
};
class UnassignPrivateIpAddressesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnassignPrivateIpAddressesResponseBody() {}

  explicit UnassignPrivateIpAddressesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnassignPrivateIpAddressesResponseBody() = default;
};
class UnassignPrivateIpAddressesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UnassignPrivateIpAddressesResponseBody> body{};

  UnassignPrivateIpAddressesResponse() {}

  explicit UnassignPrivateIpAddressesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnassignPrivateIpAddressesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnassignPrivateIpAddressesResponseBody>(model1);
      }
    }
  }


  virtual ~UnassignPrivateIpAddressesResponse() = default;
};
class UnassociateEipAddressRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> allocationId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> instanceType{};

  UnassociateEipAddressRequest() {}

  explicit UnassociateEipAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
  }


  virtual ~UnassociateEipAddressRequest() = default;
};
class UnassociateEipAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnassociateEipAddressResponseBody() {}

  explicit UnassociateEipAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnassociateEipAddressResponseBody() = default;
};
class UnassociateEipAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UnassociateEipAddressResponseBody> body{};

  UnassociateEipAddressResponse() {}

  explicit UnassociateEipAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnassociateEipAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnassociateEipAddressResponseBody>(model1);
      }
    }
  }


  virtual ~UnassociateEipAddressResponse() = default;
};
class UnassociateHaVipRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> haVipId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> force{};

  UnassociateHaVipRequest() {}

  explicit UnassociateHaVipRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (haVipId) {
      res["HaVipId"] = boost::any(*haVipId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("HaVipId") != m.end() && !m["HaVipId"].empty()) {
      haVipId = make_shared<string>(boost::any_cast<string>(m["HaVipId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<string>(boost::any_cast<string>(m["Force"]));
    }
  }


  virtual ~UnassociateHaVipRequest() = default;
};
class UnassociateHaVipResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnassociateHaVipResponseBody() {}

  explicit UnassociateHaVipResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnassociateHaVipResponseBody() = default;
};
class UnassociateHaVipResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UnassociateHaVipResponseBody> body{};

  UnassociateHaVipResponse() {}

  explicit UnassociateHaVipResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnassociateHaVipResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnassociateHaVipResponseBody>(model1);
      }
    }
  }


  virtual ~UnassociateHaVipResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<vector<string>> tagKey{};
  shared_ptr<string> resourceType{};
  shared_ptr<bool> all{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (all) {
      res["All"] = boost::any(*all);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AcceptInquiredSystemEventResponse acceptInquiredSystemEventWithOptions(shared_ptr<AcceptInquiredSystemEventRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AcceptInquiredSystemEventResponse acceptInquiredSystemEvent(shared_ptr<AcceptInquiredSystemEventRequest> request);
  ActivateRouterInterfaceResponse activateRouterInterfaceWithOptions(shared_ptr<ActivateRouterInterfaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ActivateRouterInterfaceResponse activateRouterInterface(shared_ptr<ActivateRouterInterfaceRequest> request);
  AddBandwidthPackageIpsResponse addBandwidthPackageIpsWithOptions(shared_ptr<AddBandwidthPackageIpsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddBandwidthPackageIpsResponse addBandwidthPackageIps(shared_ptr<AddBandwidthPackageIpsRequest> request);
  AddTagsResponse addTagsWithOptions(shared_ptr<AddTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddTagsResponse addTags(shared_ptr<AddTagsRequest> request);
  AllocateDedicatedHostsResponse allocateDedicatedHostsWithOptions(shared_ptr<AllocateDedicatedHostsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AllocateDedicatedHostsResponse allocateDedicatedHosts(shared_ptr<AllocateDedicatedHostsRequest> request);
  AllocateEipAddressResponse allocateEipAddressWithOptions(shared_ptr<AllocateEipAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AllocateEipAddressResponse allocateEipAddress(shared_ptr<AllocateEipAddressRequest> request);
  AllocatePublicIpAddressResponse allocatePublicIpAddressWithOptions(shared_ptr<AllocatePublicIpAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AllocatePublicIpAddressResponse allocatePublicIpAddress(shared_ptr<AllocatePublicIpAddressRequest> request);
  ApplyAutoSnapshotPolicyResponse applyAutoSnapshotPolicyWithOptions(shared_ptr<ApplyAutoSnapshotPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyAutoSnapshotPolicyResponse applyAutoSnapshotPolicy(shared_ptr<ApplyAutoSnapshotPolicyRequest> request);
  AssignIpv6AddressesResponse assignIpv6AddressesWithOptions(shared_ptr<AssignIpv6AddressesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssignIpv6AddressesResponse assignIpv6Addresses(shared_ptr<AssignIpv6AddressesRequest> request);
  AssignPrivateIpAddressesResponse assignPrivateIpAddressesWithOptions(shared_ptr<AssignPrivateIpAddressesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssignPrivateIpAddressesResponse assignPrivateIpAddresses(shared_ptr<AssignPrivateIpAddressesRequest> request);
  AssociateEipAddressResponse associateEipAddressWithOptions(shared_ptr<AssociateEipAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociateEipAddressResponse associateEipAddress(shared_ptr<AssociateEipAddressRequest> request);
  AssociateHaVipResponse associateHaVipWithOptions(shared_ptr<AssociateHaVipRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociateHaVipResponse associateHaVip(shared_ptr<AssociateHaVipRequest> request);
  AttachClassicLinkVpcResponse attachClassicLinkVpcWithOptions(shared_ptr<AttachClassicLinkVpcRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachClassicLinkVpcResponse attachClassicLinkVpc(shared_ptr<AttachClassicLinkVpcRequest> request);
  AttachDiskResponse attachDiskWithOptions(shared_ptr<AttachDiskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachDiskResponse attachDisk(shared_ptr<AttachDiskRequest> request);
  AttachInstanceRamRoleResponse attachInstanceRamRoleWithOptions(shared_ptr<AttachInstanceRamRoleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachInstanceRamRoleResponse attachInstanceRamRole(shared_ptr<AttachInstanceRamRoleRequest> request);
  AttachKeyPairResponse attachKeyPairWithOptions(shared_ptr<AttachKeyPairRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachKeyPairResponse attachKeyPair(shared_ptr<AttachKeyPairRequest> request);
  AttachNetworkInterfaceResponse attachNetworkInterfaceWithOptions(shared_ptr<AttachNetworkInterfaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachNetworkInterfaceResponse attachNetworkInterface(shared_ptr<AttachNetworkInterfaceRequest> request);
  AuthorizeSecurityGroupResponse authorizeSecurityGroupWithOptions(shared_ptr<AuthorizeSecurityGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AuthorizeSecurityGroupResponse authorizeSecurityGroup(shared_ptr<AuthorizeSecurityGroupRequest> request);
  AuthorizeSecurityGroupEgressResponse authorizeSecurityGroupEgressWithOptions(shared_ptr<AuthorizeSecurityGroupEgressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AuthorizeSecurityGroupEgressResponse authorizeSecurityGroupEgress(shared_ptr<AuthorizeSecurityGroupEgressRequest> request);
  CancelAutoSnapshotPolicyResponse cancelAutoSnapshotPolicyWithOptions(shared_ptr<CancelAutoSnapshotPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelAutoSnapshotPolicyResponse cancelAutoSnapshotPolicy(shared_ptr<CancelAutoSnapshotPolicyRequest> request);
  CancelCopyImageResponse cancelCopyImageWithOptions(shared_ptr<CancelCopyImageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelCopyImageResponse cancelCopyImage(shared_ptr<CancelCopyImageRequest> request);
  CancelImagePipelineExecutionResponse cancelImagePipelineExecutionWithOptions(shared_ptr<CancelImagePipelineExecutionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelImagePipelineExecutionResponse cancelImagePipelineExecution(shared_ptr<CancelImagePipelineExecutionRequest> request);
  CancelPhysicalConnectionResponse cancelPhysicalConnectionWithOptions(shared_ptr<CancelPhysicalConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelPhysicalConnectionResponse cancelPhysicalConnection(shared_ptr<CancelPhysicalConnectionRequest> request);
  CancelSimulatedSystemEventsResponse cancelSimulatedSystemEventsWithOptions(shared_ptr<CancelSimulatedSystemEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelSimulatedSystemEventsResponse cancelSimulatedSystemEvents(shared_ptr<CancelSimulatedSystemEventsRequest> request);
  CancelTaskResponse cancelTaskWithOptions(shared_ptr<CancelTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelTaskResponse cancelTask(shared_ptr<CancelTaskRequest> request);
  ConnectRouterInterfaceResponse connectRouterInterfaceWithOptions(shared_ptr<ConnectRouterInterfaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConnectRouterInterfaceResponse connectRouterInterface(shared_ptr<ConnectRouterInterfaceRequest> request);
  ConvertNatPublicIpToEipResponse convertNatPublicIpToEipWithOptions(shared_ptr<ConvertNatPublicIpToEipRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConvertNatPublicIpToEipResponse convertNatPublicIpToEip(shared_ptr<ConvertNatPublicIpToEipRequest> request);
  CopyImageResponse copyImageWithOptions(shared_ptr<CopyImageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopyImageResponse copyImage(shared_ptr<CopyImageRequest> request);
  CopySnapshotResponse copySnapshotWithOptions(shared_ptr<CopySnapshotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopySnapshotResponse copySnapshot(shared_ptr<CopySnapshotRequest> request);
  CreateActivationResponse createActivationWithOptions(shared_ptr<CreateActivationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateActivationResponse createActivation(shared_ptr<CreateActivationRequest> request);
  CreateAutoProvisioningGroupResponse createAutoProvisioningGroupWithOptions(shared_ptr<CreateAutoProvisioningGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAutoProvisioningGroupResponse createAutoProvisioningGroup(shared_ptr<CreateAutoProvisioningGroupRequest> request);
  CreateAutoSnapshotPolicyResponse createAutoSnapshotPolicyWithOptions(shared_ptr<CreateAutoSnapshotPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAutoSnapshotPolicyResponse createAutoSnapshotPolicy(shared_ptr<CreateAutoSnapshotPolicyRequest> request);
  CreateCapacityReservationResponse createCapacityReservationWithOptions(shared_ptr<CreateCapacityReservationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCapacityReservationResponse createCapacityReservation(shared_ptr<CreateCapacityReservationRequest> request);
  CreateCommandResponse createCommandWithOptions(shared_ptr<CreateCommandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCommandResponse createCommand(shared_ptr<CreateCommandRequest> request);
  CreateDedicatedBlockStorageClusterResponse createDedicatedBlockStorageClusterWithOptions(shared_ptr<CreateDedicatedBlockStorageClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDedicatedBlockStorageClusterResponse createDedicatedBlockStorageCluster(shared_ptr<CreateDedicatedBlockStorageClusterRequest> request);
  CreateDedicatedHostClusterResponse createDedicatedHostClusterWithOptions(shared_ptr<CreateDedicatedHostClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDedicatedHostClusterResponse createDedicatedHostCluster(shared_ptr<CreateDedicatedHostClusterRequest> request);
  CreateDemandResponse createDemandWithOptions(shared_ptr<CreateDemandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDemandResponse createDemand(shared_ptr<CreateDemandRequest> request);
  CreateDeploymentSetResponse createDeploymentSetWithOptions(shared_ptr<CreateDeploymentSetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDeploymentSetResponse createDeploymentSet(shared_ptr<CreateDeploymentSetRequest> request);
  CreateDiskResponse createDiskWithOptions(shared_ptr<CreateDiskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDiskResponse createDisk(shared_ptr<CreateDiskRequest> request);
  CreateDiskReplicaPairResponse createDiskReplicaPairWithOptions(shared_ptr<CreateDiskReplicaPairRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDiskReplicaPairResponse createDiskReplicaPair(shared_ptr<CreateDiskReplicaPairRequest> request);
  CreateElasticityAssuranceResponse createElasticityAssuranceWithOptions(shared_ptr<CreateElasticityAssuranceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateElasticityAssuranceResponse createElasticityAssurance(shared_ptr<CreateElasticityAssuranceRequest> request);
  CreateForwardEntryResponse createForwardEntryWithOptions(shared_ptr<CreateForwardEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateForwardEntryResponse createForwardEntry(shared_ptr<CreateForwardEntryRequest> request);
  CreateHaVipResponse createHaVipWithOptions(shared_ptr<CreateHaVipRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateHaVipResponse createHaVip(shared_ptr<CreateHaVipRequest> request);
  CreateHpcClusterResponse createHpcClusterWithOptions(shared_ptr<CreateHpcClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateHpcClusterResponse createHpcCluster(shared_ptr<CreateHpcClusterRequest> request);
  CreateImageResponse createImageWithOptions(shared_ptr<CreateImageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateImageResponse createImage(shared_ptr<CreateImageRequest> request);
  CreateImageComponentResponse createImageComponentWithOptions(shared_ptr<CreateImageComponentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateImageComponentResponse createImageComponent(shared_ptr<CreateImageComponentRequest> request);
  CreateImagePipelineResponse createImagePipelineWithOptions(shared_ptr<CreateImagePipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateImagePipelineResponse createImagePipeline(shared_ptr<CreateImagePipelineRequest> request);
  CreateInstanceResponse createInstanceWithOptions(shared_ptr<CreateInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateInstanceResponse createInstance(shared_ptr<CreateInstanceRequest> request);
  CreateKeyPairResponse createKeyPairWithOptions(shared_ptr<CreateKeyPairRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateKeyPairResponse createKeyPair(shared_ptr<CreateKeyPairRequest> request);
  CreateLaunchTemplateResponse createLaunchTemplateWithOptions(shared_ptr<CreateLaunchTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLaunchTemplateResponse createLaunchTemplate(shared_ptr<CreateLaunchTemplateRequest> request);
  CreateLaunchTemplateVersionResponse createLaunchTemplateVersionWithOptions(shared_ptr<CreateLaunchTemplateVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLaunchTemplateVersionResponse createLaunchTemplateVersion(shared_ptr<CreateLaunchTemplateVersionRequest> request);
  CreateNatGatewayResponse createNatGatewayWithOptions(shared_ptr<CreateNatGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNatGatewayResponse createNatGateway(shared_ptr<CreateNatGatewayRequest> request);
  CreateNetworkInterfaceResponse createNetworkInterfaceWithOptions(shared_ptr<CreateNetworkInterfaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNetworkInterfaceResponse createNetworkInterface(shared_ptr<CreateNetworkInterfaceRequest> request);
  CreateNetworkInterfacePermissionResponse createNetworkInterfacePermissionWithOptions(shared_ptr<CreateNetworkInterfacePermissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNetworkInterfacePermissionResponse createNetworkInterfacePermission(shared_ptr<CreateNetworkInterfacePermissionRequest> request);
  CreatePhysicalConnectionResponse createPhysicalConnectionWithOptions(shared_ptr<CreatePhysicalConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePhysicalConnectionResponse createPhysicalConnection(shared_ptr<CreatePhysicalConnectionRequest> request);
  CreatePrefixListResponse createPrefixListWithOptions(shared_ptr<CreatePrefixListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePrefixListResponse createPrefixList(shared_ptr<CreatePrefixListRequest> request);
  CreateResource02Response createResource02WithOptions(shared_ptr<CreateResource02Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateResource02Response createResource02(shared_ptr<CreateResource02Request> request);
  CreateRouteEntryResponse createRouteEntryWithOptions(shared_ptr<CreateRouteEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRouteEntryResponse createRouteEntry(shared_ptr<CreateRouteEntryRequest> request);
  CreateRouterInterfaceResponse createRouterInterfaceWithOptions(shared_ptr<CreateRouterInterfaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRouterInterfaceResponse createRouterInterface(shared_ptr<CreateRouterInterfaceRequest> request);
  CreateSecurityGroupResponse createSecurityGroupWithOptions(shared_ptr<CreateSecurityGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSecurityGroupResponse createSecurityGroup(shared_ptr<CreateSecurityGroupRequest> request);
  CreateSimulatedSystemEventsResponse createSimulatedSystemEventsWithOptions(shared_ptr<CreateSimulatedSystemEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSimulatedSystemEventsResponse createSimulatedSystemEvents(shared_ptr<CreateSimulatedSystemEventsRequest> request);
  CreateSnapshotResponse createSnapshotWithOptions(shared_ptr<CreateSnapshotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSnapshotResponse createSnapshot(shared_ptr<CreateSnapshotRequest> request);
  CreateSnapshotGroupResponse createSnapshotGroupWithOptions(shared_ptr<CreateSnapshotGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSnapshotGroupResponse createSnapshotGroup(shared_ptr<CreateSnapshotGroupRequest> request);
  CreateStorageSetResponse createStorageSetWithOptions(shared_ptr<CreateStorageSetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateStorageSetResponse createStorageSet(shared_ptr<CreateStorageSetRequest> request);
  CreateVirtualBorderRouterResponse createVirtualBorderRouterWithOptions(shared_ptr<CreateVirtualBorderRouterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVirtualBorderRouterResponse createVirtualBorderRouter(shared_ptr<CreateVirtualBorderRouterRequest> request);
  CreateVpcResponse createVpcWithOptions(shared_ptr<CreateVpcRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVpcResponse createVpc(shared_ptr<CreateVpcRequest> request);
  CreateVSwitchResponse createVSwitchWithOptions(shared_ptr<CreateVSwitchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVSwitchResponse createVSwitch(shared_ptr<CreateVSwitchRequest> request);
  DeactivateRouterInterfaceResponse deactivateRouterInterfaceWithOptions(shared_ptr<DeactivateRouterInterfaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeactivateRouterInterfaceResponse deactivateRouterInterface(shared_ptr<DeactivateRouterInterfaceRequest> request);
  DeleteActivationResponse deleteActivationWithOptions(shared_ptr<DeleteActivationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteActivationResponse deleteActivation(shared_ptr<DeleteActivationRequest> request);
  DeleteAutoProvisioningGroupResponse deleteAutoProvisioningGroupWithOptions(shared_ptr<DeleteAutoProvisioningGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAutoProvisioningGroupResponse deleteAutoProvisioningGroup(shared_ptr<DeleteAutoProvisioningGroupRequest> request);
  DeleteAutoSnapshotPolicyResponse deleteAutoSnapshotPolicyWithOptions(shared_ptr<DeleteAutoSnapshotPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAutoSnapshotPolicyResponse deleteAutoSnapshotPolicy(shared_ptr<DeleteAutoSnapshotPolicyRequest> request);
  DeleteBandwidthPackageResponse deleteBandwidthPackageWithOptions(shared_ptr<DeleteBandwidthPackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBandwidthPackageResponse deleteBandwidthPackage(shared_ptr<DeleteBandwidthPackageRequest> request);
  DeleteCommandResponse deleteCommandWithOptions(shared_ptr<DeleteCommandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCommandResponse deleteCommand(shared_ptr<DeleteCommandRequest> request);
  DeleteDedicatedHostClusterResponse deleteDedicatedHostClusterWithOptions(shared_ptr<DeleteDedicatedHostClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDedicatedHostClusterResponse deleteDedicatedHostCluster(shared_ptr<DeleteDedicatedHostClusterRequest> request);
  DeleteDemandResponse deleteDemandWithOptions(shared_ptr<DeleteDemandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDemandResponse deleteDemand(shared_ptr<DeleteDemandRequest> request);
  DeleteDeploymentSetResponse deleteDeploymentSetWithOptions(shared_ptr<DeleteDeploymentSetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeploymentSetResponse deleteDeploymentSet(shared_ptr<DeleteDeploymentSetRequest> request);
  DeleteDiskResponse deleteDiskWithOptions(shared_ptr<DeleteDiskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDiskResponse deleteDisk(shared_ptr<DeleteDiskRequest> request);
  DeleteDiskReplicaPairResponse deleteDiskReplicaPairWithOptions(shared_ptr<DeleteDiskReplicaPairRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDiskReplicaPairResponse deleteDiskReplicaPair(shared_ptr<DeleteDiskReplicaPairRequest> request);
  DeleteForwardEntryResponse deleteForwardEntryWithOptions(shared_ptr<DeleteForwardEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteForwardEntryResponse deleteForwardEntry(shared_ptr<DeleteForwardEntryRequest> request);
  DeleteHaVipResponse deleteHaVipWithOptions(shared_ptr<DeleteHaVipRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteHaVipResponse deleteHaVip(shared_ptr<DeleteHaVipRequest> request);
  DeleteHpcClusterResponse deleteHpcClusterWithOptions(shared_ptr<DeleteHpcClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteHpcClusterResponse deleteHpcCluster(shared_ptr<DeleteHpcClusterRequest> request);
  DeleteImageResponse deleteImageWithOptions(shared_ptr<DeleteImageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteImageResponse deleteImage(shared_ptr<DeleteImageRequest> request);
  DeleteImageComponentResponse deleteImageComponentWithOptions(shared_ptr<DeleteImageComponentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteImageComponentResponse deleteImageComponent(shared_ptr<DeleteImageComponentRequest> request);
  DeleteImagePipelineResponse deleteImagePipelineWithOptions(shared_ptr<DeleteImagePipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteImagePipelineResponse deleteImagePipeline(shared_ptr<DeleteImagePipelineRequest> request);
  DeleteInstanceResponse deleteInstanceWithOptions(shared_ptr<DeleteInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteInstanceResponse deleteInstance(shared_ptr<DeleteInstanceRequest> request);
  DeleteInstancesResponse deleteInstancesWithOptions(shared_ptr<DeleteInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteInstancesResponse deleteInstances(shared_ptr<DeleteInstancesRequest> request);
  DeleteKeyPairsResponse deleteKeyPairsWithOptions(shared_ptr<DeleteKeyPairsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteKeyPairsResponse deleteKeyPairs(shared_ptr<DeleteKeyPairsRequest> request);
  DeleteLaunchTemplateResponse deleteLaunchTemplateWithOptions(shared_ptr<DeleteLaunchTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLaunchTemplateResponse deleteLaunchTemplate(shared_ptr<DeleteLaunchTemplateRequest> request);
  DeleteLaunchTemplateVersionResponse deleteLaunchTemplateVersionWithOptions(shared_ptr<DeleteLaunchTemplateVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLaunchTemplateVersionResponse deleteLaunchTemplateVersion(shared_ptr<DeleteLaunchTemplateVersionRequest> request);
  DeleteNatGatewayResponse deleteNatGatewayWithOptions(shared_ptr<DeleteNatGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNatGatewayResponse deleteNatGateway(shared_ptr<DeleteNatGatewayRequest> request);
  DeleteNetworkInterfaceResponse deleteNetworkInterfaceWithOptions(shared_ptr<DeleteNetworkInterfaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNetworkInterfaceResponse deleteNetworkInterface(shared_ptr<DeleteNetworkInterfaceRequest> request);
  DeleteNetworkInterfacePermissionResponse deleteNetworkInterfacePermissionWithOptions(shared_ptr<DeleteNetworkInterfacePermissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNetworkInterfacePermissionResponse deleteNetworkInterfacePermission(shared_ptr<DeleteNetworkInterfacePermissionRequest> request);
  DeletePhysicalConnectionResponse deletePhysicalConnectionWithOptions(shared_ptr<DeletePhysicalConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePhysicalConnectionResponse deletePhysicalConnection(shared_ptr<DeletePhysicalConnectionRequest> request);
  DeletePrefixListResponse deletePrefixListWithOptions(shared_ptr<DeletePrefixListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePrefixListResponse deletePrefixList(shared_ptr<DeletePrefixListRequest> request);
  DeleteReplicaPairResponse deleteReplicaPairWithOptions(shared_ptr<DeleteReplicaPairRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteReplicaPairResponse deleteReplicaPair(shared_ptr<DeleteReplicaPairRequest> request);
  DeleteRouteEntryResponse deleteRouteEntryWithOptions(shared_ptr<DeleteRouteEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRouteEntryResponse deleteRouteEntry(shared_ptr<DeleteRouteEntryRequest> request);
  DeleteRouterInterfaceResponse deleteRouterInterfaceWithOptions(shared_ptr<DeleteRouterInterfaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRouterInterfaceResponse deleteRouterInterface(shared_ptr<DeleteRouterInterfaceRequest> request);
  DeleteSecurityGroupResponse deleteSecurityGroupWithOptions(shared_ptr<DeleteSecurityGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSecurityGroupResponse deleteSecurityGroup(shared_ptr<DeleteSecurityGroupRequest> request);
  DeleteSnapshotResponse deleteSnapshotWithOptions(shared_ptr<DeleteSnapshotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSnapshotResponse deleteSnapshot(shared_ptr<DeleteSnapshotRequest> request);
  DeleteSnapshotGroupResponse deleteSnapshotGroupWithOptions(shared_ptr<DeleteSnapshotGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSnapshotGroupResponse deleteSnapshotGroup(shared_ptr<DeleteSnapshotGroupRequest> request);
  DeleteStorageSetResponse deleteStorageSetWithOptions(shared_ptr<DeleteStorageSetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteStorageSetResponse deleteStorageSet(shared_ptr<DeleteStorageSetRequest> request);
  DeleteVirtualBorderRouterResponse deleteVirtualBorderRouterWithOptions(shared_ptr<DeleteVirtualBorderRouterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVirtualBorderRouterResponse deleteVirtualBorderRouter(shared_ptr<DeleteVirtualBorderRouterRequest> request);
  DeleteVpcResponse deleteVpcWithOptions(shared_ptr<DeleteVpcRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVpcResponse deleteVpc(shared_ptr<DeleteVpcRequest> request);
  DeleteVSwitchResponse deleteVSwitchWithOptions(shared_ptr<DeleteVSwitchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVSwitchResponse deleteVSwitch(shared_ptr<DeleteVSwitchRequest> request);
  DeregisterManagedInstanceResponse deregisterManagedInstanceWithOptions(shared_ptr<DeregisterManagedInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeregisterManagedInstanceResponse deregisterManagedInstance(shared_ptr<DeregisterManagedInstanceRequest> request);
  DescribeAccessPointsResponse describeAccessPointsWithOptions(shared_ptr<DescribeAccessPointsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAccessPointsResponse describeAccessPoints(shared_ptr<DescribeAccessPointsRequest> request);
  DescribeAccountAttributesResponse describeAccountAttributesWithOptions(shared_ptr<DescribeAccountAttributesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAccountAttributesResponse describeAccountAttributes(shared_ptr<DescribeAccountAttributesRequest> request);
  DescribeActivationsResponse describeActivationsWithOptions(shared_ptr<DescribeActivationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeActivationsResponse describeActivations(shared_ptr<DescribeActivationsRequest> request);
  DescribeAutoProvisioningGroupHistoryResponse describeAutoProvisioningGroupHistoryWithOptions(shared_ptr<DescribeAutoProvisioningGroupHistoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAutoProvisioningGroupHistoryResponse describeAutoProvisioningGroupHistory(shared_ptr<DescribeAutoProvisioningGroupHistoryRequest> request);
  DescribeAutoProvisioningGroupInstancesResponse describeAutoProvisioningGroupInstancesWithOptions(shared_ptr<DescribeAutoProvisioningGroupInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAutoProvisioningGroupInstancesResponse describeAutoProvisioningGroupInstances(shared_ptr<DescribeAutoProvisioningGroupInstancesRequest> request);
  DescribeAutoProvisioningGroupsResponse describeAutoProvisioningGroupsWithOptions(shared_ptr<DescribeAutoProvisioningGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAutoProvisioningGroupsResponse describeAutoProvisioningGroups(shared_ptr<DescribeAutoProvisioningGroupsRequest> request);
  DescribeAutoSnapshotPolicyExResponse describeAutoSnapshotPolicyExWithOptions(shared_ptr<DescribeAutoSnapshotPolicyExRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAutoSnapshotPolicyExResponse describeAutoSnapshotPolicyEx(shared_ptr<DescribeAutoSnapshotPolicyExRequest> request);
  DescribeAvailableResourceResponse describeAvailableResourceWithOptions(shared_ptr<DescribeAvailableResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAvailableResourceResponse describeAvailableResource(shared_ptr<DescribeAvailableResourceRequest> request);
  DescribeBandwidthLimitationResponse describeBandwidthLimitationWithOptions(shared_ptr<DescribeBandwidthLimitationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBandwidthLimitationResponse describeBandwidthLimitation(shared_ptr<DescribeBandwidthLimitationRequest> request);
  DescribeBandwidthPackagesResponse describeBandwidthPackagesWithOptions(shared_ptr<DescribeBandwidthPackagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBandwidthPackagesResponse describeBandwidthPackages(shared_ptr<DescribeBandwidthPackagesRequest> request);
  DescribeCapacityReservationInstancesResponse describeCapacityReservationInstancesWithOptions(shared_ptr<DescribeCapacityReservationInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCapacityReservationInstancesResponse describeCapacityReservationInstances(shared_ptr<DescribeCapacityReservationInstancesRequest> request);
  DescribeCapacityReservationsResponse describeCapacityReservationsWithOptions(shared_ptr<DescribeCapacityReservationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCapacityReservationsResponse describeCapacityReservations(shared_ptr<DescribeCapacityReservationsRequest> request);
  DescribeClassicLinkInstancesResponse describeClassicLinkInstancesWithOptions(shared_ptr<DescribeClassicLinkInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClassicLinkInstancesResponse describeClassicLinkInstances(shared_ptr<DescribeClassicLinkInstancesRequest> request);
  DescribeCloudAssistantStatusResponse describeCloudAssistantStatusWithOptions(shared_ptr<DescribeCloudAssistantStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudAssistantStatusResponse describeCloudAssistantStatus(shared_ptr<DescribeCloudAssistantStatusRequest> request);
  DescribeClustersResponse describeClustersWithOptions(shared_ptr<DescribeClustersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClustersResponse describeClusters(shared_ptr<DescribeClustersRequest> request);
  DescribeCommandsResponse describeCommandsWithOptions(shared_ptr<DescribeCommandsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCommandsResponse describeCommands(shared_ptr<DescribeCommandsRequest> request);
  DescribeDedicatedBlockStorageClustersResponse describeDedicatedBlockStorageClustersWithOptions(shared_ptr<DescribeDedicatedBlockStorageClustersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDedicatedBlockStorageClustersResponse describeDedicatedBlockStorageClusters(shared_ptr<DescribeDedicatedBlockStorageClustersRequest> request);
  DescribeDedicatedHostAutoRenewResponse describeDedicatedHostAutoRenewWithOptions(shared_ptr<DescribeDedicatedHostAutoRenewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDedicatedHostAutoRenewResponse describeDedicatedHostAutoRenew(shared_ptr<DescribeDedicatedHostAutoRenewRequest> request);
  DescribeDedicatedHostClustersResponse describeDedicatedHostClustersWithOptions(shared_ptr<DescribeDedicatedHostClustersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDedicatedHostClustersResponse describeDedicatedHostClusters(shared_ptr<DescribeDedicatedHostClustersRequest> request);
  DescribeDedicatedHostsResponse describeDedicatedHostsWithOptions(shared_ptr<DescribeDedicatedHostsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDedicatedHostsResponse describeDedicatedHosts(shared_ptr<DescribeDedicatedHostsRequest> request);
  DescribeDedicatedHostTypesResponse describeDedicatedHostTypesWithOptions(shared_ptr<DescribeDedicatedHostTypesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDedicatedHostTypesResponse describeDedicatedHostTypes(shared_ptr<DescribeDedicatedHostTypesRequest> request);
  DescribeDemandsResponse describeDemandsWithOptions(shared_ptr<DescribeDemandsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDemandsResponse describeDemands(shared_ptr<DescribeDemandsRequest> request);
  DescribeDeploymentSetsResponse describeDeploymentSetsWithOptions(shared_ptr<DescribeDeploymentSetsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeploymentSetsResponse describeDeploymentSets(shared_ptr<DescribeDeploymentSetsRequest> request);
  DescribeDeploymentSetSupportedInstanceTypeFamilyResponse describeDeploymentSetSupportedInstanceTypeFamilyWithOptions(shared_ptr<DescribeDeploymentSetSupportedInstanceTypeFamilyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeploymentSetSupportedInstanceTypeFamilyResponse describeDeploymentSetSupportedInstanceTypeFamily(shared_ptr<DescribeDeploymentSetSupportedInstanceTypeFamilyRequest> request);
  DescribeDiskMonitorDataResponse describeDiskMonitorDataWithOptions(shared_ptr<DescribeDiskMonitorDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDiskMonitorDataResponse describeDiskMonitorData(shared_ptr<DescribeDiskMonitorDataRequest> request);
  DescribeDiskReplicaPairsResponse describeDiskReplicaPairsWithOptions(shared_ptr<DescribeDiskReplicaPairsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDiskReplicaPairsResponse describeDiskReplicaPairs(shared_ptr<DescribeDiskReplicaPairsRequest> request);
  DescribeDisksResponse describeDisksWithOptions(shared_ptr<DescribeDisksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDisksResponse describeDisks(shared_ptr<DescribeDisksRequest> request);
  DescribeDisksFullStatusResponse describeDisksFullStatusWithOptions(shared_ptr<DescribeDisksFullStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDisksFullStatusResponse describeDisksFullStatus(shared_ptr<DescribeDisksFullStatusRequest> request);
  DescribeEipAddressesResponse describeEipAddressesWithOptions(shared_ptr<DescribeEipAddressesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEipAddressesResponse describeEipAddresses(shared_ptr<DescribeEipAddressesRequest> request);
  DescribeEipMonitorDataResponse describeEipMonitorDataWithOptions(shared_ptr<DescribeEipMonitorDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEipMonitorDataResponse describeEipMonitorData(shared_ptr<DescribeEipMonitorDataRequest> request);
  DescribeElasticityAssuranceInstancesResponse describeElasticityAssuranceInstancesWithOptions(shared_ptr<DescribeElasticityAssuranceInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeElasticityAssuranceInstancesResponse describeElasticityAssuranceInstances(shared_ptr<DescribeElasticityAssuranceInstancesRequest> request);
  DescribeElasticityAssurancesResponse describeElasticityAssurancesWithOptions(shared_ptr<DescribeElasticityAssurancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeElasticityAssurancesResponse describeElasticityAssurances(shared_ptr<DescribeElasticityAssurancesRequest> request);
  DescribeEniMonitorDataResponse describeEniMonitorDataWithOptions(shared_ptr<DescribeEniMonitorDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEniMonitorDataResponse describeEniMonitorData(shared_ptr<DescribeEniMonitorDataRequest> request);
  DescribeForwardTableEntriesResponse describeForwardTableEntriesWithOptions(shared_ptr<DescribeForwardTableEntriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeForwardTableEntriesResponse describeForwardTableEntries(shared_ptr<DescribeForwardTableEntriesRequest> request);
  DescribeHaVipsResponse describeHaVipsWithOptions(shared_ptr<DescribeHaVipsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHaVipsResponse describeHaVips(shared_ptr<DescribeHaVipsRequest> request);
  DescribeHpcClustersResponse describeHpcClustersWithOptions(shared_ptr<DescribeHpcClustersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHpcClustersResponse describeHpcClusters(shared_ptr<DescribeHpcClustersRequest> request);
  DescribeImageComponentsResponse describeImageComponentsWithOptions(shared_ptr<DescribeImageComponentsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageComponentsResponse describeImageComponents(shared_ptr<DescribeImageComponentsRequest> request);
  DescribeImageFromFamilyResponse describeImageFromFamilyWithOptions(shared_ptr<DescribeImageFromFamilyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageFromFamilyResponse describeImageFromFamily(shared_ptr<DescribeImageFromFamilyRequest> request);
  DescribeImagePipelineExecutionsResponse describeImagePipelineExecutionsWithOptions(shared_ptr<DescribeImagePipelineExecutionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImagePipelineExecutionsResponse describeImagePipelineExecutions(shared_ptr<DescribeImagePipelineExecutionsRequest> request);
  DescribeImagePipelinesResponse describeImagePipelinesWithOptions(shared_ptr<DescribeImagePipelinesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImagePipelinesResponse describeImagePipelines(shared_ptr<DescribeImagePipelinesRequest> request);
  DescribeImagesResponse describeImagesWithOptions(shared_ptr<DescribeImagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImagesResponse describeImages(shared_ptr<DescribeImagesRequest> request);
  DescribeImageSharePermissionResponse describeImageSharePermissionWithOptions(shared_ptr<DescribeImageSharePermissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageSharePermissionResponse describeImageSharePermission(shared_ptr<DescribeImageSharePermissionRequest> request);
  DescribeImageSupportInstanceTypesResponse describeImageSupportInstanceTypesWithOptions(shared_ptr<DescribeImageSupportInstanceTypesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageSupportInstanceTypesResponse describeImageSupportInstanceTypes(shared_ptr<DescribeImageSupportInstanceTypesRequest> request);
  DescribeInstanceAttachmentAttributesResponse describeInstanceAttachmentAttributesWithOptions(shared_ptr<DescribeInstanceAttachmentAttributesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceAttachmentAttributesResponse describeInstanceAttachmentAttributes(shared_ptr<DescribeInstanceAttachmentAttributesRequest> request);
  DescribeInstanceAttributeResponse describeInstanceAttributeWithOptions(shared_ptr<DescribeInstanceAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceAttributeResponse describeInstanceAttribute(shared_ptr<DescribeInstanceAttributeRequest> request);
  DescribeInstanceAutoRenewAttributeResponse describeInstanceAutoRenewAttributeWithOptions(shared_ptr<DescribeInstanceAutoRenewAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceAutoRenewAttributeResponse describeInstanceAutoRenewAttribute(shared_ptr<DescribeInstanceAutoRenewAttributeRequest> request);
  DescribeInstanceHistoryEventsResponse describeInstanceHistoryEventsWithOptions(shared_ptr<DescribeInstanceHistoryEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceHistoryEventsResponse describeInstanceHistoryEvents(shared_ptr<DescribeInstanceHistoryEventsRequest> request);
  DescribeInstanceMaintenanceAttributesResponse describeInstanceMaintenanceAttributesWithOptions(shared_ptr<DescribeInstanceMaintenanceAttributesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceMaintenanceAttributesResponse describeInstanceMaintenanceAttributes(shared_ptr<DescribeInstanceMaintenanceAttributesRequest> request);
  DescribeInstanceModificationPriceResponse describeInstanceModificationPriceWithOptions(shared_ptr<DescribeInstanceModificationPriceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceModificationPriceResponse describeInstanceModificationPrice(shared_ptr<DescribeInstanceModificationPriceRequest> request);
  DescribeInstanceMonitorDataResponse describeInstanceMonitorDataWithOptions(shared_ptr<DescribeInstanceMonitorDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceMonitorDataResponse describeInstanceMonitorData(shared_ptr<DescribeInstanceMonitorDataRequest> request);
  DescribeInstanceRamRoleResponse describeInstanceRamRoleWithOptions(shared_ptr<DescribeInstanceRamRoleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceRamRoleResponse describeInstanceRamRole(shared_ptr<DescribeInstanceRamRoleRequest> request);
  DescribeInstancesResponse describeInstancesWithOptions(shared_ptr<DescribeInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstancesResponse describeInstances(shared_ptr<DescribeInstancesRequest> request);
  DescribeInstancesFullStatusResponse describeInstancesFullStatusWithOptions(shared_ptr<DescribeInstancesFullStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstancesFullStatusResponse describeInstancesFullStatus(shared_ptr<DescribeInstancesFullStatusRequest> request);
  DescribeInstanceStatusResponse describeInstanceStatusWithOptions(shared_ptr<DescribeInstanceStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceStatusResponse describeInstanceStatus(shared_ptr<DescribeInstanceStatusRequest> request);
  DescribeInstanceTopologyResponse describeInstanceTopologyWithOptions(shared_ptr<DescribeInstanceTopologyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceTopologyResponse describeInstanceTopology(shared_ptr<DescribeInstanceTopologyRequest> request);
  DescribeInstanceTypeFamiliesResponse describeInstanceTypeFamiliesWithOptions(shared_ptr<DescribeInstanceTypeFamiliesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceTypeFamiliesResponse describeInstanceTypeFamilies(shared_ptr<DescribeInstanceTypeFamiliesRequest> request);
  DescribeInstanceTypesResponse describeInstanceTypesWithOptions(shared_ptr<DescribeInstanceTypesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceTypesResponse describeInstanceTypes(shared_ptr<DescribeInstanceTypesRequest> request);
  DescribeInstanceVncPasswdResponse describeInstanceVncPasswdWithOptions(shared_ptr<DescribeInstanceVncPasswdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceVncPasswdResponse describeInstanceVncPasswd(shared_ptr<DescribeInstanceVncPasswdRequest> request);
  DescribeInstanceVncUrlResponse describeInstanceVncUrlWithOptions(shared_ptr<DescribeInstanceVncUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceVncUrlResponse describeInstanceVncUrl(shared_ptr<DescribeInstanceVncUrlRequest> request);
  DescribeInvocationResultsResponse describeInvocationResultsWithOptions(shared_ptr<DescribeInvocationResultsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInvocationResultsResponse describeInvocationResults(shared_ptr<DescribeInvocationResultsRequest> request);
  DescribeInvocationsResponse describeInvocationsWithOptions(shared_ptr<DescribeInvocationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInvocationsResponse describeInvocations(shared_ptr<DescribeInvocationsRequest> request);
  DescribeKeyPairsResponse describeKeyPairsWithOptions(shared_ptr<DescribeKeyPairsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeKeyPairsResponse describeKeyPairs(shared_ptr<DescribeKeyPairsRequest> request);
  DescribeLaunchTemplatesResponse describeLaunchTemplatesWithOptions(shared_ptr<DescribeLaunchTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLaunchTemplatesResponse describeLaunchTemplates(shared_ptr<DescribeLaunchTemplatesRequest> request);
  DescribeLaunchTemplateVersionsResponse describeLaunchTemplateVersionsWithOptions(shared_ptr<DescribeLaunchTemplateVersionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLaunchTemplateVersionsResponse describeLaunchTemplateVersions(shared_ptr<DescribeLaunchTemplateVersionsRequest> request);
  DescribeLimitationResponse describeLimitationWithOptions(shared_ptr<DescribeLimitationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLimitationResponse describeLimitation(shared_ptr<DescribeLimitationRequest> request);
  DescribeManagedInstancesResponse describeManagedInstancesWithOptions(shared_ptr<DescribeManagedInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeManagedInstancesResponse describeManagedInstances(shared_ptr<DescribeManagedInstancesRequest> request);
  DescribeNatGatewaysResponse describeNatGatewaysWithOptions(shared_ptr<DescribeNatGatewaysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNatGatewaysResponse describeNatGateways(shared_ptr<DescribeNatGatewaysRequest> request);
  DescribeNetworkInterfaceAttributeResponse describeNetworkInterfaceAttributeWithOptions(shared_ptr<DescribeNetworkInterfaceAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNetworkInterfaceAttributeResponse describeNetworkInterfaceAttribute(shared_ptr<DescribeNetworkInterfaceAttributeRequest> request);
  DescribeNetworkInterfacePermissionsResponse describeNetworkInterfacePermissionsWithOptions(shared_ptr<DescribeNetworkInterfacePermissionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNetworkInterfacePermissionsResponse describeNetworkInterfacePermissions(shared_ptr<DescribeNetworkInterfacePermissionsRequest> request);
  DescribeNetworkInterfacesResponse describeNetworkInterfacesWithOptions(shared_ptr<DescribeNetworkInterfacesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNetworkInterfacesResponse describeNetworkInterfaces(shared_ptr<DescribeNetworkInterfacesRequest> request);
  DescribeNewProjectEipMonitorDataResponse describeNewProjectEipMonitorDataWithOptions(shared_ptr<DescribeNewProjectEipMonitorDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNewProjectEipMonitorDataResponse describeNewProjectEipMonitorData(shared_ptr<DescribeNewProjectEipMonitorDataRequest> request);
  DescribePhysicalConnectionsResponse describePhysicalConnectionsWithOptions(shared_ptr<DescribePhysicalConnectionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePhysicalConnectionsResponse describePhysicalConnections(shared_ptr<DescribePhysicalConnectionsRequest> request);
  DescribePrefixListAssociationsResponse describePrefixListAssociationsWithOptions(shared_ptr<DescribePrefixListAssociationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePrefixListAssociationsResponse describePrefixListAssociations(shared_ptr<DescribePrefixListAssociationsRequest> request);
  DescribePrefixListAttributesResponse describePrefixListAttributesWithOptions(shared_ptr<DescribePrefixListAttributesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePrefixListAttributesResponse describePrefixListAttributes(shared_ptr<DescribePrefixListAttributesRequest> request);
  DescribePrefixListsResponse describePrefixListsWithOptions(shared_ptr<DescribePrefixListsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePrefixListsResponse describePrefixLists(shared_ptr<DescribePrefixListsRequest> request);
  DescribePriceResponse describePriceWithOptions(shared_ptr<DescribePriceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePriceResponse describePrice(shared_ptr<DescribePriceRequest> request);
  DescribeRecommendInstanceTypeResponse describeRecommendInstanceTypeWithOptions(shared_ptr<DescribeRecommendInstanceTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRecommendInstanceTypeResponse describeRecommendInstanceType(shared_ptr<DescribeRecommendInstanceTypeRequest> request);
  DescribeRegionsResponse describeRegionsWithOptions(shared_ptr<DescribeRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRegionsResponse describeRegions(shared_ptr<DescribeRegionsRequest> request);
  DescribeRenewalPriceResponse describeRenewalPriceWithOptions(shared_ptr<DescribeRenewalPriceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRenewalPriceResponse describeRenewalPrice(shared_ptr<DescribeRenewalPriceRequest> request);
  DescribeReservedInstancesResponse describeReservedInstancesWithOptions(shared_ptr<DescribeReservedInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeReservedInstancesResponse describeReservedInstances(shared_ptr<DescribeReservedInstancesRequest> request);
  DescribeResourceByTagsResponse describeResourceByTagsWithOptions(shared_ptr<DescribeResourceByTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeResourceByTagsResponse describeResourceByTags(shared_ptr<DescribeResourceByTagsRequest> request);
  DescribeResourcesModificationResponse describeResourcesModificationWithOptions(shared_ptr<DescribeResourcesModificationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeResourcesModificationResponse describeResourcesModification(shared_ptr<DescribeResourcesModificationRequest> request);
  DescribeRouterInterfacesResponse describeRouterInterfacesWithOptions(shared_ptr<DescribeRouterInterfacesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRouterInterfacesResponse describeRouterInterfaces(shared_ptr<DescribeRouterInterfacesRequest> request);
  DescribeRouteTablesResponse describeRouteTablesWithOptions(shared_ptr<DescribeRouteTablesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRouteTablesResponse describeRouteTables(shared_ptr<DescribeRouteTablesRequest> request);
  DescribeSecurityGroupAttributeResponse describeSecurityGroupAttributeWithOptions(shared_ptr<DescribeSecurityGroupAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecurityGroupAttributeResponse describeSecurityGroupAttribute(shared_ptr<DescribeSecurityGroupAttributeRequest> request);
  DescribeSecurityGroupReferencesResponse describeSecurityGroupReferencesWithOptions(shared_ptr<DescribeSecurityGroupReferencesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecurityGroupReferencesResponse describeSecurityGroupReferences(shared_ptr<DescribeSecurityGroupReferencesRequest> request);
  DescribeSecurityGroupsResponse describeSecurityGroupsWithOptions(shared_ptr<DescribeSecurityGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecurityGroupsResponse describeSecurityGroups(shared_ptr<DescribeSecurityGroupsRequest> request);
  DescribeSendFileResultsResponse describeSendFileResultsWithOptions(shared_ptr<DescribeSendFileResultsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSendFileResultsResponse describeSendFileResults(shared_ptr<DescribeSendFileResultsRequest> request);
  DescribeSnapshotGroupsResponse describeSnapshotGroupsWithOptions(shared_ptr<DescribeSnapshotGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSnapshotGroupsResponse describeSnapshotGroups(shared_ptr<DescribeSnapshotGroupsRequest> request);
  DescribeSnapshotLinksResponse describeSnapshotLinksWithOptions(shared_ptr<DescribeSnapshotLinksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSnapshotLinksResponse describeSnapshotLinks(shared_ptr<DescribeSnapshotLinksRequest> request);
  DescribeSnapshotMonitorDataResponse describeSnapshotMonitorDataWithOptions(shared_ptr<DescribeSnapshotMonitorDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSnapshotMonitorDataResponse describeSnapshotMonitorData(shared_ptr<DescribeSnapshotMonitorDataRequest> request);
  DescribeSnapshotPackageResponse describeSnapshotPackageWithOptions(shared_ptr<DescribeSnapshotPackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSnapshotPackageResponse describeSnapshotPackage(shared_ptr<DescribeSnapshotPackageRequest> request);
  DescribeSnapshotsResponse describeSnapshotsWithOptions(shared_ptr<DescribeSnapshotsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSnapshotsResponse describeSnapshots(shared_ptr<DescribeSnapshotsRequest> request);
  DescribeSnapshotsUsageResponse describeSnapshotsUsageWithOptions(shared_ptr<DescribeSnapshotsUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSnapshotsUsageResponse describeSnapshotsUsage(shared_ptr<DescribeSnapshotsUsageRequest> request);
  DescribeSpotAdviceResponse describeSpotAdviceWithOptions(shared_ptr<DescribeSpotAdviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSpotAdviceResponse describeSpotAdvice(shared_ptr<DescribeSpotAdviceRequest> request);
  DescribeSpotPriceHistoryResponse describeSpotPriceHistoryWithOptions(shared_ptr<DescribeSpotPriceHistoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSpotPriceHistoryResponse describeSpotPriceHistory(shared_ptr<DescribeSpotPriceHistoryRequest> request);
  DescribeStorageCapacityUnitsResponse describeStorageCapacityUnitsWithOptions(shared_ptr<DescribeStorageCapacityUnitsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStorageCapacityUnitsResponse describeStorageCapacityUnits(shared_ptr<DescribeStorageCapacityUnitsRequest> request);
  DescribeStorageSetDetailsResponse describeStorageSetDetailsWithOptions(shared_ptr<DescribeStorageSetDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStorageSetDetailsResponse describeStorageSetDetails(shared_ptr<DescribeStorageSetDetailsRequest> request);
  DescribeStorageSetsResponse describeStorageSetsWithOptions(shared_ptr<DescribeStorageSetsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStorageSetsResponse describeStorageSets(shared_ptr<DescribeStorageSetsRequest> request);
  DescribeTagsResponse describeTagsWithOptions(shared_ptr<DescribeTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTagsResponse describeTags(shared_ptr<DescribeTagsRequest> request);
  DescribeTaskAttributeResponse describeTaskAttributeWithOptions(shared_ptr<DescribeTaskAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTaskAttributeResponse describeTaskAttribute(shared_ptr<DescribeTaskAttributeRequest> request);
  DescribeTasksResponse describeTasksWithOptions(shared_ptr<DescribeTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTasksResponse describeTasks(shared_ptr<DescribeTasksRequest> request);
  DescribeUserBusinessBehaviorResponse describeUserBusinessBehaviorWithOptions(shared_ptr<DescribeUserBusinessBehaviorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserBusinessBehaviorResponse describeUserBusinessBehavior(shared_ptr<DescribeUserBusinessBehaviorRequest> request);
  DescribeUserDataResponse describeUserDataWithOptions(shared_ptr<DescribeUserDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserDataResponse describeUserData(shared_ptr<DescribeUserDataRequest> request);
  DescribeVirtualBorderRoutersResponse describeVirtualBorderRoutersWithOptions(shared_ptr<DescribeVirtualBorderRoutersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVirtualBorderRoutersResponse describeVirtualBorderRouters(shared_ptr<DescribeVirtualBorderRoutersRequest> request);
  DescribeVirtualBorderRoutersForPhysicalConnectionResponse describeVirtualBorderRoutersForPhysicalConnectionWithOptions(shared_ptr<DescribeVirtualBorderRoutersForPhysicalConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVirtualBorderRoutersForPhysicalConnectionResponse describeVirtualBorderRoutersForPhysicalConnection(shared_ptr<DescribeVirtualBorderRoutersForPhysicalConnectionRequest> request);
  DescribeVpcsResponse describeVpcsWithOptions(shared_ptr<DescribeVpcsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVpcsResponse describeVpcs(shared_ptr<DescribeVpcsRequest> request);
  DescribeVRoutersResponse describeVRoutersWithOptions(shared_ptr<DescribeVRoutersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVRoutersResponse describeVRouters(shared_ptr<DescribeVRoutersRequest> request);
  DescribeVSwitchesResponse describeVSwitchesWithOptions(shared_ptr<DescribeVSwitchesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVSwitchesResponse describeVSwitches(shared_ptr<DescribeVSwitchesRequest> request);
  DescribeZonesResponse describeZonesWithOptions(shared_ptr<DescribeZonesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeZonesResponse describeZones(shared_ptr<DescribeZonesRequest> request);
  DetachClassicLinkVpcResponse detachClassicLinkVpcWithOptions(shared_ptr<DetachClassicLinkVpcRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachClassicLinkVpcResponse detachClassicLinkVpc(shared_ptr<DetachClassicLinkVpcRequest> request);
  DetachDiskResponse detachDiskWithOptions(shared_ptr<DetachDiskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachDiskResponse detachDisk(shared_ptr<DetachDiskRequest> request);
  DetachInstanceRamRoleResponse detachInstanceRamRoleWithOptions(shared_ptr<DetachInstanceRamRoleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachInstanceRamRoleResponse detachInstanceRamRole(shared_ptr<DetachInstanceRamRoleRequest> request);
  DetachKeyPairResponse detachKeyPairWithOptions(shared_ptr<DetachKeyPairRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachKeyPairResponse detachKeyPair(shared_ptr<DetachKeyPairRequest> request);
  DetachNetworkInterfaceResponse detachNetworkInterfaceWithOptions(shared_ptr<DetachNetworkInterfaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachNetworkInterfaceResponse detachNetworkInterface(shared_ptr<DetachNetworkInterfaceRequest> request);
  DisableActivationResponse disableActivationWithOptions(shared_ptr<DisableActivationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableActivationResponse disableActivation(shared_ptr<DisableActivationRequest> request);
  EipFillParamsResponse eipFillParamsWithOptions(shared_ptr<EipFillParamsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EipFillParamsResponse eipFillParams(shared_ptr<EipFillParamsRequest> request);
  EipFillProductResponse eipFillProductWithOptions(shared_ptr<EipFillProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EipFillProductResponse eipFillProduct(shared_ptr<EipFillProductRequest> request);
  EipNotifyPaidResponse eipNotifyPaidWithOptions(shared_ptr<EipNotifyPaidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EipNotifyPaidResponse eipNotifyPaid(shared_ptr<EipNotifyPaidRequest> request);
  EnablePhysicalConnectionResponse enablePhysicalConnectionWithOptions(shared_ptr<EnablePhysicalConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnablePhysicalConnectionResponse enablePhysicalConnection(shared_ptr<EnablePhysicalConnectionRequest> request);
  ExportImageResponse exportImageWithOptions(shared_ptr<ExportImageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportImageResponse exportImage(shared_ptr<ExportImageRequest> request);
  ExportSnapshotResponse exportSnapshotWithOptions(shared_ptr<ExportSnapshotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportSnapshotResponse exportSnapshot(shared_ptr<ExportSnapshotRequest> request);
  GetInstanceConsoleOutputResponse getInstanceConsoleOutputWithOptions(shared_ptr<GetInstanceConsoleOutputRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceConsoleOutputResponse getInstanceConsoleOutput(shared_ptr<GetInstanceConsoleOutputRequest> request);
  GetInstanceScreenshotResponse getInstanceScreenshotWithOptions(shared_ptr<GetInstanceScreenshotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceScreenshotResponse getInstanceScreenshot(shared_ptr<GetInstanceScreenshotRequest> request);
  ImportImageResponse importImageWithOptions(shared_ptr<ImportImageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportImageResponse importImage(shared_ptr<ImportImageRequest> request);
  ImportKeyPairResponse importKeyPairWithOptions(shared_ptr<ImportKeyPairRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportKeyPairResponse importKeyPair(shared_ptr<ImportKeyPairRequest> request);
  ImportSnapshotResponse importSnapshotWithOptions(shared_ptr<ImportSnapshotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportSnapshotResponse importSnapshot(shared_ptr<ImportSnapshotRequest> request);
  InstallCloudAssistantResponse installCloudAssistantWithOptions(shared_ptr<InstallCloudAssistantRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallCloudAssistantResponse installCloudAssistant(shared_ptr<InstallCloudAssistantRequest> request);
  InvokeCommandResponse invokeCommandWithOptions(shared_ptr<InvokeCommandRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvokeCommandResponse invokeCommand(shared_ptr<InvokeCommandRequest> request);
  JoinResourceGroupResponse joinResourceGroupWithOptions(shared_ptr<JoinResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  JoinResourceGroupResponse joinResourceGroup(shared_ptr<JoinResourceGroupRequest> request);
  JoinSecurityGroupResponse joinSecurityGroupWithOptions(shared_ptr<JoinSecurityGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  JoinSecurityGroupResponse joinSecurityGroup(shared_ptr<JoinSecurityGroupRequest> request);
  LeaveSecurityGroupResponse leaveSecurityGroupWithOptions(shared_ptr<LeaveSecurityGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  LeaveSecurityGroupResponse leaveSecurityGroup(shared_ptr<LeaveSecurityGroupRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ModifyAutoProvisioningGroupResponse modifyAutoProvisioningGroupWithOptions(shared_ptr<ModifyAutoProvisioningGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAutoProvisioningGroupResponse modifyAutoProvisioningGroup(shared_ptr<ModifyAutoProvisioningGroupRequest> request);
  ModifyAutoSnapshotPolicyResponse modifyAutoSnapshotPolicyWithOptions(shared_ptr<ModifyAutoSnapshotPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAutoSnapshotPolicyResponse modifyAutoSnapshotPolicy(shared_ptr<ModifyAutoSnapshotPolicyRequest> request);
  ModifyAutoSnapshotPolicyExResponse modifyAutoSnapshotPolicyExWithOptions(shared_ptr<ModifyAutoSnapshotPolicyExRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAutoSnapshotPolicyExResponse modifyAutoSnapshotPolicyEx(shared_ptr<ModifyAutoSnapshotPolicyExRequest> request);
  ModifyBandwidthPackageSpecResponse modifyBandwidthPackageSpecWithOptions(shared_ptr<ModifyBandwidthPackageSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyBandwidthPackageSpecResponse modifyBandwidthPackageSpec(shared_ptr<ModifyBandwidthPackageSpecRequest> request);
  ModifyCapacityReservationResponse modifyCapacityReservationWithOptions(shared_ptr<ModifyCapacityReservationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCapacityReservationResponse modifyCapacityReservation(shared_ptr<ModifyCapacityReservationRequest> request);
  ModifyCommandResponse modifyCommandWithOptions(shared_ptr<ModifyCommandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCommandResponse modifyCommand(shared_ptr<ModifyCommandRequest> request);
  ModifyDedicatedHostAttributeResponse modifyDedicatedHostAttributeWithOptions(shared_ptr<ModifyDedicatedHostAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDedicatedHostAttributeResponse modifyDedicatedHostAttribute(shared_ptr<ModifyDedicatedHostAttributeRequest> request);
  ModifyDedicatedHostAutoReleaseTimeResponse modifyDedicatedHostAutoReleaseTimeWithOptions(shared_ptr<ModifyDedicatedHostAutoReleaseTimeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDedicatedHostAutoReleaseTimeResponse modifyDedicatedHostAutoReleaseTime(shared_ptr<ModifyDedicatedHostAutoReleaseTimeRequest> request);
  ModifyDedicatedHostAutoRenewAttributeResponse modifyDedicatedHostAutoRenewAttributeWithOptions(shared_ptr<ModifyDedicatedHostAutoRenewAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDedicatedHostAutoRenewAttributeResponse modifyDedicatedHostAutoRenewAttribute(shared_ptr<ModifyDedicatedHostAutoRenewAttributeRequest> request);
  ModifyDedicatedHostClusterAttributeResponse modifyDedicatedHostClusterAttributeWithOptions(shared_ptr<ModifyDedicatedHostClusterAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDedicatedHostClusterAttributeResponse modifyDedicatedHostClusterAttribute(shared_ptr<ModifyDedicatedHostClusterAttributeRequest> request);
  ModifyDedicatedHostsChargeTypeResponse modifyDedicatedHostsChargeTypeWithOptions(shared_ptr<ModifyDedicatedHostsChargeTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDedicatedHostsChargeTypeResponse modifyDedicatedHostsChargeType(shared_ptr<ModifyDedicatedHostsChargeTypeRequest> request);
  ModifyDemandResponse modifyDemandWithOptions(shared_ptr<ModifyDemandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDemandResponse modifyDemand(shared_ptr<ModifyDemandRequest> request);
  ModifyDeploymentSetAttributeResponse modifyDeploymentSetAttributeWithOptions(shared_ptr<ModifyDeploymentSetAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDeploymentSetAttributeResponse modifyDeploymentSetAttribute(shared_ptr<ModifyDeploymentSetAttributeRequest> request);
  ModifyDiskAttributeResponse modifyDiskAttributeWithOptions(shared_ptr<ModifyDiskAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDiskAttributeResponse modifyDiskAttribute(shared_ptr<ModifyDiskAttributeRequest> request);
  ModifyDiskChargeTypeResponse modifyDiskChargeTypeWithOptions(shared_ptr<ModifyDiskChargeTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDiskChargeTypeResponse modifyDiskChargeType(shared_ptr<ModifyDiskChargeTypeRequest> request);
  ModifyDiskSpecResponse modifyDiskSpecWithOptions(shared_ptr<ModifyDiskSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDiskSpecResponse modifyDiskSpec(shared_ptr<ModifyDiskSpecRequest> request);
  ModifyEipAddressAttributeResponse modifyEipAddressAttributeWithOptions(shared_ptr<ModifyEipAddressAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyEipAddressAttributeResponse modifyEipAddressAttribute(shared_ptr<ModifyEipAddressAttributeRequest> request);
  ModifyElasticityAssuranceResponse modifyElasticityAssuranceWithOptions(shared_ptr<ModifyElasticityAssuranceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyElasticityAssuranceResponse modifyElasticityAssurance(shared_ptr<ModifyElasticityAssuranceRequest> request);
  ModifyForwardEntryResponse modifyForwardEntryWithOptions(shared_ptr<ModifyForwardEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyForwardEntryResponse modifyForwardEntry(shared_ptr<ModifyForwardEntryRequest> request);
  ModifyHaVipAttributeResponse modifyHaVipAttributeWithOptions(shared_ptr<ModifyHaVipAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHaVipAttributeResponse modifyHaVipAttribute(shared_ptr<ModifyHaVipAttributeRequest> request);
  ModifyHpcClusterAttributeResponse modifyHpcClusterAttributeWithOptions(shared_ptr<ModifyHpcClusterAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHpcClusterAttributeResponse modifyHpcClusterAttribute(shared_ptr<ModifyHpcClusterAttributeRequest> request);
  ModifyImageAttributeResponse modifyImageAttributeWithOptions(shared_ptr<ModifyImageAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyImageAttributeResponse modifyImageAttribute(shared_ptr<ModifyImageAttributeRequest> request);
  ModifyImageShareGroupPermissionResponse modifyImageShareGroupPermissionWithOptions(shared_ptr<ModifyImageShareGroupPermissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyImageShareGroupPermissionResponse modifyImageShareGroupPermission(shared_ptr<ModifyImageShareGroupPermissionRequest> request);
  ModifyImageSharePermissionResponse modifyImageSharePermissionWithOptions(shared_ptr<ModifyImageSharePermissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyImageSharePermissionResponse modifyImageSharePermission(shared_ptr<ModifyImageSharePermissionRequest> request);
  ModifyInstanceAttachmentAttributesResponse modifyInstanceAttachmentAttributesWithOptions(shared_ptr<ModifyInstanceAttachmentAttributesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceAttachmentAttributesResponse modifyInstanceAttachmentAttributes(shared_ptr<ModifyInstanceAttachmentAttributesRequest> request);
  ModifyInstanceAttributeResponse modifyInstanceAttributeWithOptions(shared_ptr<ModifyInstanceAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceAttributeResponse modifyInstanceAttribute(shared_ptr<ModifyInstanceAttributeRequest> request);
  ModifyInstanceAutoReleaseTimeResponse modifyInstanceAutoReleaseTimeWithOptions(shared_ptr<ModifyInstanceAutoReleaseTimeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceAutoReleaseTimeResponse modifyInstanceAutoReleaseTime(shared_ptr<ModifyInstanceAutoReleaseTimeRequest> request);
  ModifyInstanceAutoRenewAttributeResponse modifyInstanceAutoRenewAttributeWithOptions(shared_ptr<ModifyInstanceAutoRenewAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceAutoRenewAttributeResponse modifyInstanceAutoRenewAttribute(shared_ptr<ModifyInstanceAutoRenewAttributeRequest> request);
  ModifyInstanceChargeTypeResponse modifyInstanceChargeTypeWithOptions(shared_ptr<ModifyInstanceChargeTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceChargeTypeResponse modifyInstanceChargeType(shared_ptr<ModifyInstanceChargeTypeRequest> request);
  ModifyInstanceDeploymentResponse modifyInstanceDeploymentWithOptions(shared_ptr<ModifyInstanceDeploymentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceDeploymentResponse modifyInstanceDeployment(shared_ptr<ModifyInstanceDeploymentRequest> request);
  ModifyInstanceMaintenanceAttributesResponse modifyInstanceMaintenanceAttributesWithOptions(shared_ptr<ModifyInstanceMaintenanceAttributesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceMaintenanceAttributesResponse modifyInstanceMaintenanceAttributes(shared_ptr<ModifyInstanceMaintenanceAttributesRequest> request);
  ModifyInstanceMetadataOptionsResponse modifyInstanceMetadataOptionsWithOptions(shared_ptr<ModifyInstanceMetadataOptionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceMetadataOptionsResponse modifyInstanceMetadataOptions(shared_ptr<ModifyInstanceMetadataOptionsRequest> request);
  ModifyInstanceNetworkSpecResponse modifyInstanceNetworkSpecWithOptions(shared_ptr<ModifyInstanceNetworkSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceNetworkSpecResponse modifyInstanceNetworkSpec(shared_ptr<ModifyInstanceNetworkSpecRequest> request);
  ModifyInstanceSpecResponse modifyInstanceSpecWithOptions(shared_ptr<ModifyInstanceSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceSpecResponse modifyInstanceSpec(shared_ptr<ModifyInstanceSpecRequest> request);
  ModifyInstanceVncPasswdResponse modifyInstanceVncPasswdWithOptions(shared_ptr<ModifyInstanceVncPasswdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceVncPasswdResponse modifyInstanceVncPasswd(shared_ptr<ModifyInstanceVncPasswdRequest> request);
  ModifyInstanceVpcAttributeResponse modifyInstanceVpcAttributeWithOptions(shared_ptr<ModifyInstanceVpcAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceVpcAttributeResponse modifyInstanceVpcAttribute(shared_ptr<ModifyInstanceVpcAttributeRequest> request);
  ModifyLaunchTemplateDefaultVersionResponse modifyLaunchTemplateDefaultVersionWithOptions(shared_ptr<ModifyLaunchTemplateDefaultVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyLaunchTemplateDefaultVersionResponse modifyLaunchTemplateDefaultVersion(shared_ptr<ModifyLaunchTemplateDefaultVersionRequest> request);
  ModifyManagedInstanceResponse modifyManagedInstanceWithOptions(shared_ptr<ModifyManagedInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyManagedInstanceResponse modifyManagedInstance(shared_ptr<ModifyManagedInstanceRequest> request);
  ModifyNetworkInterfaceAttributeResponse modifyNetworkInterfaceAttributeWithOptions(shared_ptr<ModifyNetworkInterfaceAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyNetworkInterfaceAttributeResponse modifyNetworkInterfaceAttribute(shared_ptr<ModifyNetworkInterfaceAttributeRequest> request);
  ModifyPhysicalConnectionAttributeResponse modifyPhysicalConnectionAttributeWithOptions(shared_ptr<ModifyPhysicalConnectionAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyPhysicalConnectionAttributeResponse modifyPhysicalConnectionAttribute(shared_ptr<ModifyPhysicalConnectionAttributeRequest> request);
  ModifyPrefixListResponse modifyPrefixListWithOptions(shared_ptr<ModifyPrefixListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyPrefixListResponse modifyPrefixList(shared_ptr<ModifyPrefixListRequest> request);
  ModifyPrepayInstanceSpecResponse modifyPrepayInstanceSpecWithOptions(shared_ptr<ModifyPrepayInstanceSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyPrepayInstanceSpecResponse modifyPrepayInstanceSpec(shared_ptr<ModifyPrepayInstanceSpecRequest> request);
  ModifyReservedInstanceAttributeResponse modifyReservedInstanceAttributeWithOptions(shared_ptr<ModifyReservedInstanceAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyReservedInstanceAttributeResponse modifyReservedInstanceAttribute(shared_ptr<ModifyReservedInstanceAttributeRequest> request);
  ModifyReservedInstancesResponse modifyReservedInstancesWithOptions(shared_ptr<ModifyReservedInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyReservedInstancesResponse modifyReservedInstances(shared_ptr<ModifyReservedInstancesRequest> request);
  ModifyRouterInterfaceAttributeResponse modifyRouterInterfaceAttributeWithOptions(shared_ptr<ModifyRouterInterfaceAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyRouterInterfaceAttributeResponse modifyRouterInterfaceAttribute(shared_ptr<ModifyRouterInterfaceAttributeRequest> request);
  ModifyRouterInterfaceSpecResponse modifyRouterInterfaceSpecWithOptions(shared_ptr<ModifyRouterInterfaceSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyRouterInterfaceSpecResponse modifyRouterInterfaceSpec(shared_ptr<ModifyRouterInterfaceSpecRequest> request);
  ModifySecurityGroupAttributeResponse modifySecurityGroupAttributeWithOptions(shared_ptr<ModifySecurityGroupAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySecurityGroupAttributeResponse modifySecurityGroupAttribute(shared_ptr<ModifySecurityGroupAttributeRequest> request);
  ModifySecurityGroupEgressRuleResponse modifySecurityGroupEgressRuleWithOptions(shared_ptr<ModifySecurityGroupEgressRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySecurityGroupEgressRuleResponse modifySecurityGroupEgressRule(shared_ptr<ModifySecurityGroupEgressRuleRequest> request);
  ModifySecurityGroupPolicyResponse modifySecurityGroupPolicyWithOptions(shared_ptr<ModifySecurityGroupPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySecurityGroupPolicyResponse modifySecurityGroupPolicy(shared_ptr<ModifySecurityGroupPolicyRequest> request);
  ModifySecurityGroupRuleResponse modifySecurityGroupRuleWithOptions(shared_ptr<ModifySecurityGroupRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySecurityGroupRuleResponse modifySecurityGroupRule(shared_ptr<ModifySecurityGroupRuleRequest> request);
  ModifySnapshotAttributeResponse modifySnapshotAttributeWithOptions(shared_ptr<ModifySnapshotAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySnapshotAttributeResponse modifySnapshotAttribute(shared_ptr<ModifySnapshotAttributeRequest> request);
  ModifySnapshotGroupResponse modifySnapshotGroupWithOptions(shared_ptr<ModifySnapshotGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySnapshotGroupResponse modifySnapshotGroup(shared_ptr<ModifySnapshotGroupRequest> request);
  ModifyStorageCapacityUnitAttributeResponse modifyStorageCapacityUnitAttributeWithOptions(shared_ptr<ModifyStorageCapacityUnitAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyStorageCapacityUnitAttributeResponse modifyStorageCapacityUnitAttribute(shared_ptr<ModifyStorageCapacityUnitAttributeRequest> request);
  ModifyStorageSetAttributeResponse modifyStorageSetAttributeWithOptions(shared_ptr<ModifyStorageSetAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyStorageSetAttributeResponse modifyStorageSetAttribute(shared_ptr<ModifyStorageSetAttributeRequest> request);
  ModifyUserBusinessBehaviorResponse modifyUserBusinessBehaviorWithOptions(shared_ptr<ModifyUserBusinessBehaviorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyUserBusinessBehaviorResponse modifyUserBusinessBehavior(shared_ptr<ModifyUserBusinessBehaviorRequest> request);
  ModifyVirtualBorderRouterAttributeResponse modifyVirtualBorderRouterAttributeWithOptions(shared_ptr<ModifyVirtualBorderRouterAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVirtualBorderRouterAttributeResponse modifyVirtualBorderRouterAttribute(shared_ptr<ModifyVirtualBorderRouterAttributeRequest> request);
  ModifyVpcAttributeResponse modifyVpcAttributeWithOptions(shared_ptr<ModifyVpcAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVpcAttributeResponse modifyVpcAttribute(shared_ptr<ModifyVpcAttributeRequest> request);
  ModifyVRouterAttributeResponse modifyVRouterAttributeWithOptions(shared_ptr<ModifyVRouterAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVRouterAttributeResponse modifyVRouterAttribute(shared_ptr<ModifyVRouterAttributeRequest> request);
  ModifyVSwitchAttributeResponse modifyVSwitchAttributeWithOptions(shared_ptr<ModifyVSwitchAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVSwitchAttributeResponse modifyVSwitchAttribute(shared_ptr<ModifyVSwitchAttributeRequest> request);
  PurchaseReservedInstancesOfferingResponse purchaseReservedInstancesOfferingWithOptions(shared_ptr<PurchaseReservedInstancesOfferingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PurchaseReservedInstancesOfferingResponse purchaseReservedInstancesOffering(shared_ptr<PurchaseReservedInstancesOfferingRequest> request);
  PurchaseStorageCapacityUnitResponse purchaseStorageCapacityUnitWithOptions(shared_ptr<PurchaseStorageCapacityUnitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PurchaseStorageCapacityUnitResponse purchaseStorageCapacityUnit(shared_ptr<PurchaseStorageCapacityUnitRequest> request);
  ReActivateInstancesResponse reActivateInstancesWithOptions(shared_ptr<ReActivateInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReActivateInstancesResponse reActivateInstances(shared_ptr<ReActivateInstancesRequest> request);
  RebootInstanceResponse rebootInstanceWithOptions(shared_ptr<RebootInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RebootInstanceResponse rebootInstance(shared_ptr<RebootInstanceRequest> request);
  RebootInstancesResponse rebootInstancesWithOptions(shared_ptr<RebootInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RebootInstancesResponse rebootInstances(shared_ptr<RebootInstancesRequest> request);
  RecoverVirtualBorderRouterResponse recoverVirtualBorderRouterWithOptions(shared_ptr<RecoverVirtualBorderRouterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RecoverVirtualBorderRouterResponse recoverVirtualBorderRouter(shared_ptr<RecoverVirtualBorderRouterRequest> request);
  RedeployDedicatedHostResponse redeployDedicatedHostWithOptions(shared_ptr<RedeployDedicatedHostRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RedeployDedicatedHostResponse redeployDedicatedHost(shared_ptr<RedeployDedicatedHostRequest> request);
  RedeployInstanceResponse redeployInstanceWithOptions(shared_ptr<RedeployInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RedeployInstanceResponse redeployInstance(shared_ptr<RedeployInstanceRequest> request);
  ReInitDiskResponse reInitDiskWithOptions(shared_ptr<ReInitDiskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReInitDiskResponse reInitDisk(shared_ptr<ReInitDiskRequest> request);
  ReleaseCapacityReservationResponse releaseCapacityReservationWithOptions(shared_ptr<ReleaseCapacityReservationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseCapacityReservationResponse releaseCapacityReservation(shared_ptr<ReleaseCapacityReservationRequest> request);
  ReleaseDedicatedHostResponse releaseDedicatedHostWithOptions(shared_ptr<ReleaseDedicatedHostRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseDedicatedHostResponse releaseDedicatedHost(shared_ptr<ReleaseDedicatedHostRequest> request);
  ReleaseEipAddressResponse releaseEipAddressWithOptions(shared_ptr<ReleaseEipAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseEipAddressResponse releaseEipAddress(shared_ptr<ReleaseEipAddressRequest> request);
  ReleasePublicIpAddressResponse releasePublicIpAddressWithOptions(shared_ptr<ReleasePublicIpAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleasePublicIpAddressResponse releasePublicIpAddress(shared_ptr<ReleasePublicIpAddressRequest> request);
  RemoveBandwidthPackageIpsResponse removeBandwidthPackageIpsWithOptions(shared_ptr<RemoveBandwidthPackageIpsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveBandwidthPackageIpsResponse removeBandwidthPackageIps(shared_ptr<RemoveBandwidthPackageIpsRequest> request);
  RemoveTagsResponse removeTagsWithOptions(shared_ptr<RemoveTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveTagsResponse removeTags(shared_ptr<RemoveTagsRequest> request);
  RenewDedicatedHostsResponse renewDedicatedHostsWithOptions(shared_ptr<RenewDedicatedHostsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenewDedicatedHostsResponse renewDedicatedHosts(shared_ptr<RenewDedicatedHostsRequest> request);
  RenewInstanceResponse renewInstanceWithOptions(shared_ptr<RenewInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenewInstanceResponse renewInstance(shared_ptr<RenewInstanceRequest> request);
  ReplaceSystemDiskResponse replaceSystemDiskWithOptions(shared_ptr<ReplaceSystemDiskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReplaceSystemDiskResponse replaceSystemDisk(shared_ptr<ReplaceSystemDiskRequest> request);
  ReportInstancesStatusResponse reportInstancesStatusWithOptions(shared_ptr<ReportInstancesStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReportInstancesStatusResponse reportInstancesStatus(shared_ptr<ReportInstancesStatusRequest> request);
  ResetDiskResponse resetDiskWithOptions(shared_ptr<ResetDiskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetDiskResponse resetDisk(shared_ptr<ResetDiskRequest> request);
  ResetDisksResponse resetDisksWithOptions(shared_ptr<ResetDisksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetDisksResponse resetDisks(shared_ptr<ResetDisksRequest> request);
  ResizeDiskResponse resizeDiskWithOptions(shared_ptr<ResizeDiskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResizeDiskResponse resizeDisk(shared_ptr<ResizeDiskRequest> request);
  RevokeSecurityGroupResponse revokeSecurityGroupWithOptions(shared_ptr<RevokeSecurityGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeSecurityGroupResponse revokeSecurityGroup(shared_ptr<RevokeSecurityGroupRequest> request);
  RevokeSecurityGroupEgressResponse revokeSecurityGroupEgressWithOptions(shared_ptr<RevokeSecurityGroupEgressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeSecurityGroupEgressResponse revokeSecurityGroupEgress(shared_ptr<RevokeSecurityGroupEgressRequest> request);
  RunCommandResponse runCommandWithOptions(shared_ptr<RunCommandRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunCommandResponse runCommand(shared_ptr<RunCommandRequest> request);
  RunInstancesResponse runInstancesWithOptions(shared_ptr<RunInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunInstancesResponse runInstances(shared_ptr<RunInstancesRequest> request);
  SendFileResponse sendFileWithOptions(shared_ptr<SendFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendFileResponse sendFile(shared_ptr<SendFileRequest> request);
  StartDiskReplicaPairResponse startDiskReplicaPairWithOptions(shared_ptr<StartDiskReplicaPairRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartDiskReplicaPairResponse startDiskReplicaPair(shared_ptr<StartDiskReplicaPairRequest> request);
  StartElasticityAssuranceResponse startElasticityAssuranceWithOptions(shared_ptr<StartElasticityAssuranceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartElasticityAssuranceResponse startElasticityAssurance(shared_ptr<StartElasticityAssuranceRequest> request);
  StartImagePipelineExecutionResponse startImagePipelineExecutionWithOptions(shared_ptr<StartImagePipelineExecutionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartImagePipelineExecutionResponse startImagePipelineExecution(shared_ptr<StartImagePipelineExecutionRequest> request);
  StartInstanceResponse startInstanceWithOptions(shared_ptr<StartInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartInstanceResponse startInstance(shared_ptr<StartInstanceRequest> request);
  StartInstancesResponse startInstancesWithOptions(shared_ptr<StartInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartInstancesResponse startInstances(shared_ptr<StartInstancesRequest> request);
  StartTerminalSessionResponse startTerminalSessionWithOptions(shared_ptr<StartTerminalSessionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartTerminalSessionResponse startTerminalSession(shared_ptr<StartTerminalSessionRequest> request);
  StopDiskReplicaPairResponse stopDiskReplicaPairWithOptions(shared_ptr<StopDiskReplicaPairRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopDiskReplicaPairResponse stopDiskReplicaPair(shared_ptr<StopDiskReplicaPairRequest> request);
  StopInstanceResponse stopInstanceWithOptions(shared_ptr<StopInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopInstanceResponse stopInstance(shared_ptr<StopInstanceRequest> request);
  StopInstancesResponse stopInstancesWithOptions(shared_ptr<StopInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopInstancesResponse stopInstances(shared_ptr<StopInstancesRequest> request);
  StopInvocationResponse stopInvocationWithOptions(shared_ptr<StopInvocationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopInvocationResponse stopInvocation(shared_ptr<StopInvocationRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  TerminatePhysicalConnectionResponse terminatePhysicalConnectionWithOptions(shared_ptr<TerminatePhysicalConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TerminatePhysicalConnectionResponse terminatePhysicalConnection(shared_ptr<TerminatePhysicalConnectionRequest> request);
  TerminateVirtualBorderRouterResponse terminateVirtualBorderRouterWithOptions(shared_ptr<TerminateVirtualBorderRouterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TerminateVirtualBorderRouterResponse terminateVirtualBorderRouter(shared_ptr<TerminateVirtualBorderRouterRequest> request);
  UnassignIpv6AddressesResponse unassignIpv6AddressesWithOptions(shared_ptr<UnassignIpv6AddressesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnassignIpv6AddressesResponse unassignIpv6Addresses(shared_ptr<UnassignIpv6AddressesRequest> request);
  UnassignPrivateIpAddressesResponse unassignPrivateIpAddressesWithOptions(shared_ptr<UnassignPrivateIpAddressesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnassignPrivateIpAddressesResponse unassignPrivateIpAddresses(shared_ptr<UnassignPrivateIpAddressesRequest> request);
  UnassociateEipAddressResponse unassociateEipAddressWithOptions(shared_ptr<UnassociateEipAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnassociateEipAddressResponse unassociateEipAddress(shared_ptr<UnassociateEipAddressRequest> request);
  UnassociateHaVipResponse unassociateHaVipWithOptions(shared_ptr<UnassociateHaVipRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnassociateHaVipResponse unassociateHaVip(shared_ptr<UnassociateHaVipRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Ecs20140526

#endif
