// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_ESS20220222_H_
#define ALIBABACLOUD_ESS20220222_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Ess20220222 {
class ApplyEciScalingConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> format{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scalingConfigurationId{};
  shared_ptr<string> scalingGroupId{};

  ApplyEciScalingConfigurationRequest() {}

  explicit ApplyEciScalingConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scalingConfigurationId) {
      res["ScalingConfigurationId"] = boost::any(*scalingConfigurationId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScalingConfigurationId") != m.end() && !m["ScalingConfigurationId"].empty()) {
      scalingConfigurationId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~ApplyEciScalingConfigurationRequest() = default;
};
class ApplyEciScalingConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> scalingConfigurationId{};

  ApplyEciScalingConfigurationResponseBody() {}

  explicit ApplyEciScalingConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingConfigurationId) {
      res["ScalingConfigurationId"] = boost::any(*scalingConfigurationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingConfigurationId") != m.end() && !m["ScalingConfigurationId"].empty()) {
      scalingConfigurationId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationId"]));
    }
  }


  virtual ~ApplyEciScalingConfigurationResponseBody() = default;
};
class ApplyEciScalingConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyEciScalingConfigurationResponseBody> body{};

  ApplyEciScalingConfigurationResponse() {}

  explicit ApplyEciScalingConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyEciScalingConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyEciScalingConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyEciScalingConfigurationResponse() = default;
};
class ApplyScalingGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> format{};
  shared_ptr<string> regionId{};

  ApplyScalingGroupRequest() {}

  explicit ApplyScalingGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ApplyScalingGroupRequest() = default;
};
class ApplyScalingGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> scalingGroupId{};

  ApplyScalingGroupResponseBody() {}

  explicit ApplyScalingGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~ApplyScalingGroupResponseBody() = default;
};
class ApplyScalingGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyScalingGroupResponseBody> body{};

  ApplyScalingGroupResponse() {}

  explicit ApplyScalingGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyScalingGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyScalingGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyScalingGroupResponse() = default;
};
class AttachAlbServerGroupsRequestAlbServerGroups : public Darabonba::Model {
public:
  shared_ptr<string> albServerGroupId{};
  shared_ptr<long> port{};
  shared_ptr<long> weight{};

  AttachAlbServerGroupsRequestAlbServerGroups() {}

  explicit AttachAlbServerGroupsRequestAlbServerGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (albServerGroupId) {
      res["AlbServerGroupId"] = boost::any(*albServerGroupId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlbServerGroupId") != m.end() && !m["AlbServerGroupId"].empty()) {
      albServerGroupId = make_shared<string>(boost::any_cast<string>(m["AlbServerGroupId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~AttachAlbServerGroupsRequestAlbServerGroups() = default;
};
class AttachAlbServerGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<AttachAlbServerGroupsRequestAlbServerGroups>> albServerGroups{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> forceAttach{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};

  AttachAlbServerGroupsRequest() {}

  explicit AttachAlbServerGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (albServerGroups) {
      vector<boost::any> temp1;
      for(auto item1:*albServerGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlbServerGroups"] = boost::any(temp1);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (forceAttach) {
      res["ForceAttach"] = boost::any(*forceAttach);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlbServerGroups") != m.end() && !m["AlbServerGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["AlbServerGroups"].type()) {
        vector<AttachAlbServerGroupsRequestAlbServerGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlbServerGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachAlbServerGroupsRequestAlbServerGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        albServerGroups = make_shared<vector<AttachAlbServerGroupsRequestAlbServerGroups>>(expect1);
      }
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ForceAttach") != m.end() && !m["ForceAttach"].empty()) {
      forceAttach = make_shared<bool>(boost::any_cast<bool>(m["ForceAttach"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~AttachAlbServerGroupsRequest() = default;
};
class AttachAlbServerGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> scalingActivityId{};

  AttachAlbServerGroupsResponseBody() {}

  explicit AttachAlbServerGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingActivityId) {
      res["ScalingActivityId"] = boost::any(*scalingActivityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingActivityId") != m.end() && !m["ScalingActivityId"].empty()) {
      scalingActivityId = make_shared<string>(boost::any_cast<string>(m["ScalingActivityId"]));
    }
  }


  virtual ~AttachAlbServerGroupsResponseBody() = default;
};
class AttachAlbServerGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachAlbServerGroupsResponseBody> body{};

  AttachAlbServerGroupsResponse() {}

  explicit AttachAlbServerGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachAlbServerGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachAlbServerGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~AttachAlbServerGroupsResponse() = default;
};
class AttachDBInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> attachMode{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<string>> DBInstances{};
  shared_ptr<bool> forceAttach{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> type{};

  AttachDBInstancesRequest() {}

  explicit AttachDBInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachMode) {
      res["AttachMode"] = boost::any(*attachMode);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstances) {
      res["DBInstances"] = boost::any(*DBInstances);
    }
    if (forceAttach) {
      res["ForceAttach"] = boost::any(*forceAttach);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachMode") != m.end() && !m["AttachMode"].empty()) {
      attachMode = make_shared<string>(boost::any_cast<string>(m["AttachMode"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstances") != m.end() && !m["DBInstances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DBInstances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DBInstances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      DBInstances = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ForceAttach") != m.end() && !m["ForceAttach"].empty()) {
      forceAttach = make_shared<bool>(boost::any_cast<bool>(m["ForceAttach"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AttachDBInstancesRequest() = default;
};
class AttachDBInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AttachDBInstancesResponseBody() {}

  explicit AttachDBInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AttachDBInstancesResponseBody() = default;
};
class AttachDBInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachDBInstancesResponseBody> body{};

  AttachDBInstancesResponse() {}

  explicit AttachDBInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachDBInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachDBInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~AttachDBInstancesResponse() = default;
};
class AttachInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> entrusted{};
  shared_ptr<bool> ignoreInvalidInstance{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<bool> lifecycleHook{};
  shared_ptr<vector<long>> loadBalancerWeights{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scalingGroupId{};

  AttachInstancesRequest() {}

  explicit AttachInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (entrusted) {
      res["Entrusted"] = boost::any(*entrusted);
    }
    if (ignoreInvalidInstance) {
      res["IgnoreInvalidInstance"] = boost::any(*ignoreInvalidInstance);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (lifecycleHook) {
      res["LifecycleHook"] = boost::any(*lifecycleHook);
    }
    if (loadBalancerWeights) {
      res["LoadBalancerWeights"] = boost::any(*loadBalancerWeights);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Entrusted") != m.end() && !m["Entrusted"].empty()) {
      entrusted = make_shared<bool>(boost::any_cast<bool>(m["Entrusted"]));
    }
    if (m.find("IgnoreInvalidInstance") != m.end() && !m["IgnoreInvalidInstance"].empty()) {
      ignoreInvalidInstance = make_shared<bool>(boost::any_cast<bool>(m["IgnoreInvalidInstance"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LifecycleHook") != m.end() && !m["LifecycleHook"].empty()) {
      lifecycleHook = make_shared<bool>(boost::any_cast<bool>(m["LifecycleHook"]));
    }
    if (m.find("LoadBalancerWeights") != m.end() && !m["LoadBalancerWeights"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["LoadBalancerWeights"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LoadBalancerWeights"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      loadBalancerWeights = make_shared<vector<long>>(toVec1);
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~AttachInstancesRequest() = default;
};
class AttachInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> scalingActivityId{};

  AttachInstancesResponseBody() {}

  explicit AttachInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingActivityId) {
      res["ScalingActivityId"] = boost::any(*scalingActivityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingActivityId") != m.end() && !m["ScalingActivityId"].empty()) {
      scalingActivityId = make_shared<string>(boost::any_cast<string>(m["ScalingActivityId"]));
    }
  }


  virtual ~AttachInstancesResponseBody() = default;
};
class AttachInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachInstancesResponseBody> body{};

  AttachInstancesResponse() {}

  explicit AttachInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~AttachInstancesResponse() = default;
};
class AttachLoadBalancersRequestLoadBalancerConfigs : public Darabonba::Model {
public:
  shared_ptr<string> loadBalancerId{};
  shared_ptr<long> weight{};

  AttachLoadBalancersRequestLoadBalancerConfigs() {}

  explicit AttachLoadBalancersRequestLoadBalancerConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~AttachLoadBalancersRequestLoadBalancerConfigs() = default;
};
class AttachLoadBalancersRequest : public Darabonba::Model {
public:
  shared_ptr<bool> async{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> forceAttach{};
  shared_ptr<vector<AttachLoadBalancersRequestLoadBalancerConfigs>> loadBalancerConfigs{};
  shared_ptr<vector<string>> loadBalancers{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};

  AttachLoadBalancersRequest() {}

  explicit AttachLoadBalancersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (forceAttach) {
      res["ForceAttach"] = boost::any(*forceAttach);
    }
    if (loadBalancerConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*loadBalancerConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LoadBalancerConfigs"] = boost::any(temp1);
    }
    if (loadBalancers) {
      res["LoadBalancers"] = boost::any(*loadBalancers);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ForceAttach") != m.end() && !m["ForceAttach"].empty()) {
      forceAttach = make_shared<bool>(boost::any_cast<bool>(m["ForceAttach"]));
    }
    if (m.find("LoadBalancerConfigs") != m.end() && !m["LoadBalancerConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["LoadBalancerConfigs"].type()) {
        vector<AttachLoadBalancersRequestLoadBalancerConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LoadBalancerConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachLoadBalancersRequestLoadBalancerConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        loadBalancerConfigs = make_shared<vector<AttachLoadBalancersRequestLoadBalancerConfigs>>(expect1);
      }
    }
    if (m.find("LoadBalancers") != m.end() && !m["LoadBalancers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LoadBalancers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LoadBalancers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      loadBalancers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~AttachLoadBalancersRequest() = default;
};
class AttachLoadBalancersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> scalingActivityId{};

  AttachLoadBalancersResponseBody() {}

  explicit AttachLoadBalancersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingActivityId) {
      res["ScalingActivityId"] = boost::any(*scalingActivityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingActivityId") != m.end() && !m["ScalingActivityId"].empty()) {
      scalingActivityId = make_shared<string>(boost::any_cast<string>(m["ScalingActivityId"]));
    }
  }


  virtual ~AttachLoadBalancersResponseBody() = default;
};
class AttachLoadBalancersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachLoadBalancersResponseBody> body{};

  AttachLoadBalancersResponse() {}

  explicit AttachLoadBalancersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachLoadBalancersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachLoadBalancersResponseBody>(model1);
      }
    }
  }


  virtual ~AttachLoadBalancersResponse() = default;
};
class AttachServerGroupsRequestServerGroups : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> serverGroupId{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  AttachServerGroupsRequestServerGroups() {}

  explicit AttachServerGroupsRequestServerGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (serverGroupId) {
      res["ServerGroupId"] = boost::any(*serverGroupId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("ServerGroupId") != m.end() && !m["ServerGroupId"].empty()) {
      serverGroupId = make_shared<string>(boost::any_cast<string>(m["ServerGroupId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~AttachServerGroupsRequestServerGroups() = default;
};
class AttachServerGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> forceAttach{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<vector<AttachServerGroupsRequestServerGroups>> serverGroups{};

  AttachServerGroupsRequest() {}

  explicit AttachServerGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (forceAttach) {
      res["ForceAttach"] = boost::any(*forceAttach);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (serverGroups) {
      vector<boost::any> temp1;
      for(auto item1:*serverGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServerGroups"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ForceAttach") != m.end() && !m["ForceAttach"].empty()) {
      forceAttach = make_shared<bool>(boost::any_cast<bool>(m["ForceAttach"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("ServerGroups") != m.end() && !m["ServerGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["ServerGroups"].type()) {
        vector<AttachServerGroupsRequestServerGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServerGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachServerGroupsRequestServerGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serverGroups = make_shared<vector<AttachServerGroupsRequestServerGroups>>(expect1);
      }
    }
  }


  virtual ~AttachServerGroupsRequest() = default;
};
class AttachServerGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> scalingActivityId{};

  AttachServerGroupsResponseBody() {}

  explicit AttachServerGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingActivityId) {
      res["ScalingActivityId"] = boost::any(*scalingActivityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingActivityId") != m.end() && !m["ScalingActivityId"].empty()) {
      scalingActivityId = make_shared<string>(boost::any_cast<string>(m["ScalingActivityId"]));
    }
  }


  virtual ~AttachServerGroupsResponseBody() = default;
};
class AttachServerGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachServerGroupsResponseBody> body{};

  AttachServerGroupsResponse() {}

  explicit AttachServerGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachServerGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachServerGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~AttachServerGroupsResponse() = default;
};
class AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> VServerGroupId{};
  shared_ptr<long> weight{};

  AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes() {}

  explicit AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (VServerGroupId) {
      res["VServerGroupId"] = boost::any(*VServerGroupId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("VServerGroupId") != m.end() && !m["VServerGroupId"].empty()) {
      VServerGroupId = make_shared<string>(boost::any_cast<string>(m["VServerGroupId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes() = default;
};
class AttachVServerGroupsRequestVServerGroups : public Darabonba::Model {
public:
  shared_ptr<string> loadBalancerId{};
  shared_ptr<vector<AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes>> VServerGroupAttributes{};

  AttachVServerGroupsRequestVServerGroups() {}

  explicit AttachVServerGroupsRequestVServerGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (VServerGroupAttributes) {
      vector<boost::any> temp1;
      for(auto item1:*VServerGroupAttributes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VServerGroupAttributes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("VServerGroupAttributes") != m.end() && !m["VServerGroupAttributes"].empty()) {
      if (typeid(vector<boost::any>) == m["VServerGroupAttributes"].type()) {
        vector<AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VServerGroupAttributes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        VServerGroupAttributes = make_shared<vector<AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes>>(expect1);
      }
    }
  }


  virtual ~AttachVServerGroupsRequestVServerGroups() = default;
};
class AttachVServerGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> forceAttach{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<vector<AttachVServerGroupsRequestVServerGroups>> VServerGroups{};

  AttachVServerGroupsRequest() {}

  explicit AttachVServerGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (forceAttach) {
      res["ForceAttach"] = boost::any(*forceAttach);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (VServerGroups) {
      vector<boost::any> temp1;
      for(auto item1:*VServerGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VServerGroups"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ForceAttach") != m.end() && !m["ForceAttach"].empty()) {
      forceAttach = make_shared<bool>(boost::any_cast<bool>(m["ForceAttach"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("VServerGroups") != m.end() && !m["VServerGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["VServerGroups"].type()) {
        vector<AttachVServerGroupsRequestVServerGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VServerGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachVServerGroupsRequestVServerGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        VServerGroups = make_shared<vector<AttachVServerGroupsRequestVServerGroups>>(expect1);
      }
    }
  }


  virtual ~AttachVServerGroupsRequest() = default;
};
class AttachVServerGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AttachVServerGroupsResponseBody() {}

  explicit AttachVServerGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AttachVServerGroupsResponseBody() = default;
};
class AttachVServerGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachVServerGroupsResponseBody> body{};

  AttachVServerGroupsResponse() {}

  explicit AttachVServerGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachVServerGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachVServerGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~AttachVServerGroupsResponse() = default;
};
class CancelInstanceRefreshRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceRefreshTaskId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};

  CancelInstanceRefreshRequest() {}

  explicit CancelInstanceRefreshRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceRefreshTaskId) {
      res["InstanceRefreshTaskId"] = boost::any(*instanceRefreshTaskId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceRefreshTaskId") != m.end() && !m["InstanceRefreshTaskId"].empty()) {
      instanceRefreshTaskId = make_shared<string>(boost::any_cast<string>(m["InstanceRefreshTaskId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~CancelInstanceRefreshRequest() = default;
};
class CancelInstanceRefreshResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CancelInstanceRefreshResponseBody() {}

  explicit CancelInstanceRefreshResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelInstanceRefreshResponseBody() = default;
};
class CancelInstanceRefreshResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelInstanceRefreshResponseBody> body{};

  CancelInstanceRefreshResponse() {}

  explicit CancelInstanceRefreshResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelInstanceRefreshResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelInstanceRefreshResponseBody>(model1);
      }
    }
  }


  virtual ~CancelInstanceRefreshResponse() = default;
};
class ChangeResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> newResourceGroupId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceType{};

  ChangeResourceGroupRequest() {}

  explicit ChangeResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (newResourceGroupId) {
      res["NewResourceGroupId"] = boost::any(*newResourceGroupId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NewResourceGroupId") != m.end() && !m["NewResourceGroupId"].empty()) {
      newResourceGroupId = make_shared<string>(boost::any_cast<string>(m["NewResourceGroupId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ChangeResourceGroupRequest() = default;
};
class ChangeResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ChangeResourceGroupResponseBody() {}

  explicit ChangeResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ChangeResourceGroupResponseBody() = default;
};
class ChangeResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeResourceGroupResponseBody> body{};

  ChangeResourceGroupResponse() {}

  explicit ChangeResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeResourceGroupResponse() = default;
};
class CompleteLifecycleActionRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> lifecycleActionResult{};
  shared_ptr<string> lifecycleActionToken{};
  shared_ptr<string> lifecycleHookId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};

  CompleteLifecycleActionRequest() {}

  explicit CompleteLifecycleActionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (lifecycleActionResult) {
      res["LifecycleActionResult"] = boost::any(*lifecycleActionResult);
    }
    if (lifecycleActionToken) {
      res["LifecycleActionToken"] = boost::any(*lifecycleActionToken);
    }
    if (lifecycleHookId) {
      res["LifecycleHookId"] = boost::any(*lifecycleHookId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("LifecycleActionResult") != m.end() && !m["LifecycleActionResult"].empty()) {
      lifecycleActionResult = make_shared<string>(boost::any_cast<string>(m["LifecycleActionResult"]));
    }
    if (m.find("LifecycleActionToken") != m.end() && !m["LifecycleActionToken"].empty()) {
      lifecycleActionToken = make_shared<string>(boost::any_cast<string>(m["LifecycleActionToken"]));
    }
    if (m.find("LifecycleHookId") != m.end() && !m["LifecycleHookId"].empty()) {
      lifecycleHookId = make_shared<string>(boost::any_cast<string>(m["LifecycleHookId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
  }


  virtual ~CompleteLifecycleActionRequest() = default;
};
class CompleteLifecycleActionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CompleteLifecycleActionResponseBody() {}

  explicit CompleteLifecycleActionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CompleteLifecycleActionResponseBody() = default;
};
class CompleteLifecycleActionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CompleteLifecycleActionResponseBody> body{};

  CompleteLifecycleActionResponse() {}

  explicit CompleteLifecycleActionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CompleteLifecycleActionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CompleteLifecycleActionResponseBody>(model1);
      }
    }
  }


  virtual ~CompleteLifecycleActionResponse() = default;
};
class CreateAlarmRequestDimensions : public Darabonba::Model {
public:
  shared_ptr<string> dimensionKey{};
  shared_ptr<string> dimensionValue{};

  CreateAlarmRequestDimensions() {}

  explicit CreateAlarmRequestDimensions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimensionKey) {
      res["DimensionKey"] = boost::any(*dimensionKey);
    }
    if (dimensionValue) {
      res["DimensionValue"] = boost::any(*dimensionValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DimensionKey") != m.end() && !m["DimensionKey"].empty()) {
      dimensionKey = make_shared<string>(boost::any_cast<string>(m["DimensionKey"]));
    }
    if (m.find("DimensionValue") != m.end() && !m["DimensionValue"].empty()) {
      dimensionValue = make_shared<string>(boost::any_cast<string>(m["DimensionValue"]));
    }
  }


  virtual ~CreateAlarmRequestDimensions() = default;
};
class CreateAlarmRequestExpressions : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> metricName{};
  shared_ptr<long> period{};
  shared_ptr<string> statistics{};
  shared_ptr<double> threshold{};

  CreateAlarmRequestExpressions() {}

  explicit CreateAlarmRequestExpressions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
  }


  virtual ~CreateAlarmRequestExpressions() = default;
};
class CreateAlarmRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> alarmActions{};
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> description{};
  shared_ptr<vector<CreateAlarmRequestDimensions>> dimensions{};
  shared_ptr<string> effective{};
  shared_ptr<long> evaluationCount{};
  shared_ptr<vector<CreateAlarmRequestExpressions>> expressions{};
  shared_ptr<string> expressionsLogicOperator{};
  shared_ptr<long> groupId{};
  shared_ptr<string> metricName{};
  shared_ptr<string> metricType{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> period{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> statistics{};
  shared_ptr<double> threshold{};

  CreateAlarmRequest() {}

  explicit CreateAlarmRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmActions) {
      res["AlarmActions"] = boost::any(*alarmActions);
    }
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dimensions) {
      vector<boost::any> temp1;
      for(auto item1:*dimensions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dimensions"] = boost::any(temp1);
    }
    if (effective) {
      res["Effective"] = boost::any(*effective);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (expressions) {
      vector<boost::any> temp1;
      for(auto item1:*expressions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Expressions"] = boost::any(temp1);
    }
    if (expressionsLogicOperator) {
      res["ExpressionsLogicOperator"] = boost::any(*expressionsLogicOperator);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmActions") != m.end() && !m["AlarmActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AlarmActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AlarmActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      alarmActions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      if (typeid(vector<boost::any>) == m["Dimensions"].type()) {
        vector<CreateAlarmRequestDimensions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dimensions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAlarmRequestDimensions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dimensions = make_shared<vector<CreateAlarmRequestDimensions>>(expect1);
      }
    }
    if (m.find("Effective") != m.end() && !m["Effective"].empty()) {
      effective = make_shared<string>(boost::any_cast<string>(m["Effective"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("Expressions") != m.end() && !m["Expressions"].empty()) {
      if (typeid(vector<boost::any>) == m["Expressions"].type()) {
        vector<CreateAlarmRequestExpressions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Expressions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAlarmRequestExpressions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        expressions = make_shared<vector<CreateAlarmRequestExpressions>>(expect1);
      }
    }
    if (m.find("ExpressionsLogicOperator") != m.end() && !m["ExpressionsLogicOperator"].empty()) {
      expressionsLogicOperator = make_shared<string>(boost::any_cast<string>(m["ExpressionsLogicOperator"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
  }


  virtual ~CreateAlarmRequest() = default;
};
class CreateAlarmResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> alarmTaskId{};
  shared_ptr<string> requestId{};

  CreateAlarmResponseBody() {}

  explicit CreateAlarmResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmTaskId) {
      res["AlarmTaskId"] = boost::any(*alarmTaskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmTaskId") != m.end() && !m["AlarmTaskId"].empty()) {
      alarmTaskId = make_shared<string>(boost::any_cast<string>(m["AlarmTaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAlarmResponseBody() = default;
};
class CreateAlarmResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAlarmResponseBody> body{};

  CreateAlarmResponse() {}

  explicit CreateAlarmResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAlarmResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAlarmResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAlarmResponse() = default;
};
class CreateDiagnoseReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> scalingGroupId{};

  CreateDiagnoseReportRequest() {}

  explicit CreateDiagnoseReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~CreateDiagnoseReportRequest() = default;
};
class CreateDiagnoseReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> reportId{};
  shared_ptr<string> requestId{};

  CreateDiagnoseReportResponseBody() {}

  explicit CreateDiagnoseReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDiagnoseReportResponseBody() = default;
};
class CreateDiagnoseReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDiagnoseReportResponseBody> body{};

  CreateDiagnoseReportResponse() {}

  explicit CreateDiagnoseReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDiagnoseReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDiagnoseReportResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDiagnoseReportResponse() = default;
};
class CreateEciScalingConfigurationRequestAcrRegistryInfos : public Darabonba::Model {
public:
  shared_ptr<vector<string>> domains{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> regionId{};

  CreateEciScalingConfigurationRequestAcrRegistryInfos() {}

  explicit CreateEciScalingConfigurationRequestAcrRegistryInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = boost::any(*domains);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Domains"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domains = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestAcrRegistryInfos() = default;
};
class CreateEciScalingConfigurationRequestContainersLivenessProbeExec : public Darabonba::Model {
public:
  shared_ptr<vector<string>> commands{};

  CreateEciScalingConfigurationRequestContainersLivenessProbeExec() {}

  explicit CreateEciScalingConfigurationRequestContainersLivenessProbeExec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commands) {
      res["Commands"] = boost::any(*commands);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Commands") != m.end() && !m["Commands"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Commands"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Commands"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      commands = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateEciScalingConfigurationRequestContainersLivenessProbeExec() = default;
};
class CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet : public Darabonba::Model {
public:
  shared_ptr<string> path{};
  shared_ptr<long> port{};
  shared_ptr<string> scheme{};

  CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet() {}

  explicit CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (scheme) {
      res["Scheme"] = boost::any(*scheme);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Scheme") != m.end() && !m["Scheme"].empty()) {
      scheme = make_shared<string>(boost::any_cast<string>(m["Scheme"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet() = default;
};
class CreateEciScalingConfigurationRequestContainersLivenessProbeTcpSocket : public Darabonba::Model {
public:
  shared_ptr<long> port{};

  CreateEciScalingConfigurationRequestContainersLivenessProbeTcpSocket() {}

  explicit CreateEciScalingConfigurationRequestContainersLivenessProbeTcpSocket(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestContainersLivenessProbeTcpSocket() = default;
};
class CreateEciScalingConfigurationRequestContainersLivenessProbe : public Darabonba::Model {
public:
  shared_ptr<CreateEciScalingConfigurationRequestContainersLivenessProbeExec> exec{};
  shared_ptr<long> failureThreshold{};
  shared_ptr<CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet> httpGet{};
  shared_ptr<long> initialDelaySeconds{};
  shared_ptr<long> periodSeconds{};
  shared_ptr<long> successThreshold{};
  shared_ptr<CreateEciScalingConfigurationRequestContainersLivenessProbeTcpSocket> tcpSocket{};
  shared_ptr<long> timeoutSeconds{};

  CreateEciScalingConfigurationRequestContainersLivenessProbe() {}

  explicit CreateEciScalingConfigurationRequestContainersLivenessProbe(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exec) {
      res["Exec"] = exec ? boost::any(exec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failureThreshold) {
      res["FailureThreshold"] = boost::any(*failureThreshold);
    }
    if (httpGet) {
      res["HttpGet"] = httpGet ? boost::any(httpGet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (initialDelaySeconds) {
      res["InitialDelaySeconds"] = boost::any(*initialDelaySeconds);
    }
    if (periodSeconds) {
      res["PeriodSeconds"] = boost::any(*periodSeconds);
    }
    if (successThreshold) {
      res["SuccessThreshold"] = boost::any(*successThreshold);
    }
    if (tcpSocket) {
      res["TcpSocket"] = tcpSocket ? boost::any(tcpSocket->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Exec") != m.end() && !m["Exec"].empty()) {
      if (typeid(map<string, boost::any>) == m["Exec"].type()) {
        CreateEciScalingConfigurationRequestContainersLivenessProbeExec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Exec"]));
        exec = make_shared<CreateEciScalingConfigurationRequestContainersLivenessProbeExec>(model1);
      }
    }
    if (m.find("FailureThreshold") != m.end() && !m["FailureThreshold"].empty()) {
      failureThreshold = make_shared<long>(boost::any_cast<long>(m["FailureThreshold"]));
    }
    if (m.find("HttpGet") != m.end() && !m["HttpGet"].empty()) {
      if (typeid(map<string, boost::any>) == m["HttpGet"].type()) {
        CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HttpGet"]));
        httpGet = make_shared<CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet>(model1);
      }
    }
    if (m.find("InitialDelaySeconds") != m.end() && !m["InitialDelaySeconds"].empty()) {
      initialDelaySeconds = make_shared<long>(boost::any_cast<long>(m["InitialDelaySeconds"]));
    }
    if (m.find("PeriodSeconds") != m.end() && !m["PeriodSeconds"].empty()) {
      periodSeconds = make_shared<long>(boost::any_cast<long>(m["PeriodSeconds"]));
    }
    if (m.find("SuccessThreshold") != m.end() && !m["SuccessThreshold"].empty()) {
      successThreshold = make_shared<long>(boost::any_cast<long>(m["SuccessThreshold"]));
    }
    if (m.find("TcpSocket") != m.end() && !m["TcpSocket"].empty()) {
      if (typeid(map<string, boost::any>) == m["TcpSocket"].type()) {
        CreateEciScalingConfigurationRequestContainersLivenessProbeTcpSocket model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TcpSocket"]));
        tcpSocket = make_shared<CreateEciScalingConfigurationRequestContainersLivenessProbeTcpSocket>(model1);
      }
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestContainersLivenessProbe() = default;
};
class CreateEciScalingConfigurationRequestContainersReadinessProbeExec : public Darabonba::Model {
public:
  shared_ptr<vector<string>> commands{};

  CreateEciScalingConfigurationRequestContainersReadinessProbeExec() {}

  explicit CreateEciScalingConfigurationRequestContainersReadinessProbeExec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commands) {
      res["Commands"] = boost::any(*commands);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Commands") != m.end() && !m["Commands"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Commands"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Commands"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      commands = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateEciScalingConfigurationRequestContainersReadinessProbeExec() = default;
};
class CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet : public Darabonba::Model {
public:
  shared_ptr<string> path{};
  shared_ptr<long> port{};
  shared_ptr<string> scheme{};

  CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet() {}

  explicit CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (scheme) {
      res["Scheme"] = boost::any(*scheme);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Scheme") != m.end() && !m["Scheme"].empty()) {
      scheme = make_shared<string>(boost::any_cast<string>(m["Scheme"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet() = default;
};
class CreateEciScalingConfigurationRequestContainersReadinessProbeTcpSocket : public Darabonba::Model {
public:
  shared_ptr<long> port{};

  CreateEciScalingConfigurationRequestContainersReadinessProbeTcpSocket() {}

  explicit CreateEciScalingConfigurationRequestContainersReadinessProbeTcpSocket(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestContainersReadinessProbeTcpSocket() = default;
};
class CreateEciScalingConfigurationRequestContainersReadinessProbe : public Darabonba::Model {
public:
  shared_ptr<CreateEciScalingConfigurationRequestContainersReadinessProbeExec> exec{};
  shared_ptr<long> failureThreshold{};
  shared_ptr<CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet> httpGet{};
  shared_ptr<long> initialDelaySeconds{};
  shared_ptr<long> periodSeconds{};
  shared_ptr<long> successThreshold{};
  shared_ptr<CreateEciScalingConfigurationRequestContainersReadinessProbeTcpSocket> tcpSocket{};
  shared_ptr<long> timeoutSeconds{};

  CreateEciScalingConfigurationRequestContainersReadinessProbe() {}

  explicit CreateEciScalingConfigurationRequestContainersReadinessProbe(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exec) {
      res["Exec"] = exec ? boost::any(exec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failureThreshold) {
      res["FailureThreshold"] = boost::any(*failureThreshold);
    }
    if (httpGet) {
      res["HttpGet"] = httpGet ? boost::any(httpGet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (initialDelaySeconds) {
      res["InitialDelaySeconds"] = boost::any(*initialDelaySeconds);
    }
    if (periodSeconds) {
      res["PeriodSeconds"] = boost::any(*periodSeconds);
    }
    if (successThreshold) {
      res["SuccessThreshold"] = boost::any(*successThreshold);
    }
    if (tcpSocket) {
      res["TcpSocket"] = tcpSocket ? boost::any(tcpSocket->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Exec") != m.end() && !m["Exec"].empty()) {
      if (typeid(map<string, boost::any>) == m["Exec"].type()) {
        CreateEciScalingConfigurationRequestContainersReadinessProbeExec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Exec"]));
        exec = make_shared<CreateEciScalingConfigurationRequestContainersReadinessProbeExec>(model1);
      }
    }
    if (m.find("FailureThreshold") != m.end() && !m["FailureThreshold"].empty()) {
      failureThreshold = make_shared<long>(boost::any_cast<long>(m["FailureThreshold"]));
    }
    if (m.find("HttpGet") != m.end() && !m["HttpGet"].empty()) {
      if (typeid(map<string, boost::any>) == m["HttpGet"].type()) {
        CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HttpGet"]));
        httpGet = make_shared<CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet>(model1);
      }
    }
    if (m.find("InitialDelaySeconds") != m.end() && !m["InitialDelaySeconds"].empty()) {
      initialDelaySeconds = make_shared<long>(boost::any_cast<long>(m["InitialDelaySeconds"]));
    }
    if (m.find("PeriodSeconds") != m.end() && !m["PeriodSeconds"].empty()) {
      periodSeconds = make_shared<long>(boost::any_cast<long>(m["PeriodSeconds"]));
    }
    if (m.find("SuccessThreshold") != m.end() && !m["SuccessThreshold"].empty()) {
      successThreshold = make_shared<long>(boost::any_cast<long>(m["SuccessThreshold"]));
    }
    if (m.find("TcpSocket") != m.end() && !m["TcpSocket"].empty()) {
      if (typeid(map<string, boost::any>) == m["TcpSocket"].type()) {
        CreateEciScalingConfigurationRequestContainersReadinessProbeTcpSocket model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TcpSocket"]));
        tcpSocket = make_shared<CreateEciScalingConfigurationRequestContainersReadinessProbeTcpSocket>(model1);
      }
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestContainersReadinessProbe() = default;
};
class CreateEciScalingConfigurationRequestContainersSecurityContextCapability : public Darabonba::Model {
public:
  shared_ptr<vector<string>> add{};

  CreateEciScalingConfigurationRequestContainersSecurityContextCapability() {}

  explicit CreateEciScalingConfigurationRequestContainersSecurityContextCapability(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (add) {
      res["Add"] = boost::any(*add);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Add") != m.end() && !m["Add"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Add"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Add"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      add = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateEciScalingConfigurationRequestContainersSecurityContextCapability() = default;
};
class CreateEciScalingConfigurationRequestContainersSecurityContext : public Darabonba::Model {
public:
  shared_ptr<CreateEciScalingConfigurationRequestContainersSecurityContextCapability> capability{};
  shared_ptr<bool> readOnlyRootFilesystem{};
  shared_ptr<long> runAsUser{};

  CreateEciScalingConfigurationRequestContainersSecurityContext() {}

  explicit CreateEciScalingConfigurationRequestContainersSecurityContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capability) {
      res["Capability"] = capability ? boost::any(capability->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (readOnlyRootFilesystem) {
      res["ReadOnlyRootFilesystem"] = boost::any(*readOnlyRootFilesystem);
    }
    if (runAsUser) {
      res["RunAsUser"] = boost::any(*runAsUser);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Capability") != m.end() && !m["Capability"].empty()) {
      if (typeid(map<string, boost::any>) == m["Capability"].type()) {
        CreateEciScalingConfigurationRequestContainersSecurityContextCapability model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Capability"]));
        capability = make_shared<CreateEciScalingConfigurationRequestContainersSecurityContextCapability>(model1);
      }
    }
    if (m.find("ReadOnlyRootFilesystem") != m.end() && !m["ReadOnlyRootFilesystem"].empty()) {
      readOnlyRootFilesystem = make_shared<bool>(boost::any_cast<bool>(m["ReadOnlyRootFilesystem"]));
    }
    if (m.find("RunAsUser") != m.end() && !m["RunAsUser"].empty()) {
      runAsUser = make_shared<long>(boost::any_cast<long>(m["RunAsUser"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestContainersSecurityContext() = default;
};
class CreateEciScalingConfigurationRequestContainersEnvironmentVars : public Darabonba::Model {
public:
  shared_ptr<string> fieldRefFieldPath{};
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateEciScalingConfigurationRequestContainersEnvironmentVars() {}

  explicit CreateEciScalingConfigurationRequestContainersEnvironmentVars(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldRefFieldPath) {
      res["FieldRefFieldPath"] = boost::any(*fieldRefFieldPath);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldRefFieldPath") != m.end() && !m["FieldRefFieldPath"].empty()) {
      fieldRefFieldPath = make_shared<string>(boost::any_cast<string>(m["FieldRefFieldPath"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestContainersEnvironmentVars() = default;
};
class CreateEciScalingConfigurationRequestContainersPorts : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> protocol{};

  CreateEciScalingConfigurationRequestContainersPorts() {}

  explicit CreateEciScalingConfigurationRequestContainersPorts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestContainersPorts() = default;
};
class CreateEciScalingConfigurationRequestContainersVolumeMounts : public Darabonba::Model {
public:
  shared_ptr<string> mountPath{};
  shared_ptr<string> mountPropagation{};
  shared_ptr<string> name{};
  shared_ptr<bool> readOnly{};
  shared_ptr<string> subPath{};

  CreateEciScalingConfigurationRequestContainersVolumeMounts() {}

  explicit CreateEciScalingConfigurationRequestContainersVolumeMounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountPath) {
      res["MountPath"] = boost::any(*mountPath);
    }
    if (mountPropagation) {
      res["MountPropagation"] = boost::any(*mountPropagation);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    if (subPath) {
      res["SubPath"] = boost::any(*subPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MountPath") != m.end() && !m["MountPath"].empty()) {
      mountPath = make_shared<string>(boost::any_cast<string>(m["MountPath"]));
    }
    if (m.find("MountPropagation") != m.end() && !m["MountPropagation"].empty()) {
      mountPropagation = make_shared<string>(boost::any_cast<string>(m["MountPropagation"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
    if (m.find("SubPath") != m.end() && !m["SubPath"].empty()) {
      subPath = make_shared<string>(boost::any_cast<string>(m["SubPath"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestContainersVolumeMounts() = default;
};
class CreateEciScalingConfigurationRequestContainers : public Darabonba::Model {
public:
  shared_ptr<CreateEciScalingConfigurationRequestContainersLivenessProbe> livenessProbe{};
  shared_ptr<CreateEciScalingConfigurationRequestContainersReadinessProbe> readinessProbe{};
  shared_ptr<CreateEciScalingConfigurationRequestContainersSecurityContext> securityContext{};
  shared_ptr<vector<string>> args{};
  shared_ptr<vector<string>> commands{};
  shared_ptr<double> cpu{};
  shared_ptr<vector<CreateEciScalingConfigurationRequestContainersEnvironmentVars>> environmentVars{};
  shared_ptr<long> gpu{};
  shared_ptr<string> image{};
  shared_ptr<string> imagePullPolicy{};
  shared_ptr<vector<string>> lifecyclePostStartHandlerExecs{};
  shared_ptr<string> lifecyclePostStartHandlerHttpGetHost{};
  shared_ptr<string> lifecyclePostStartHandlerHttpGetPath{};
  shared_ptr<long> lifecyclePostStartHandlerHttpGetPort{};
  shared_ptr<string> lifecyclePostStartHandlerHttpGetScheme{};
  shared_ptr<string> lifecyclePostStartHandlerTcpSocketHost{};
  shared_ptr<long> lifecyclePostStartHandlerTcpSocketPort{};
  shared_ptr<vector<string>> lifecyclePreStopHandlerExecs{};
  shared_ptr<string> lifecyclePreStopHandlerHttpGetHost{};
  shared_ptr<string> lifecyclePreStopHandlerHttpGetPath{};
  shared_ptr<long> lifecyclePreStopHandlerHttpGetPort{};
  shared_ptr<string> lifecyclePreStopHandlerHttpGetScheme{};
  shared_ptr<string> lifecyclePreStopHandlerTcpSocketHost{};
  shared_ptr<long> lifecyclePreStopHandlerTcpSocketPort{};
  shared_ptr<double> memory{};
  shared_ptr<string> name{};
  shared_ptr<vector<CreateEciScalingConfigurationRequestContainersPorts>> ports{};
  shared_ptr<bool> stdin{};
  shared_ptr<bool> stdinOnce{};
  shared_ptr<bool> tty{};
  shared_ptr<vector<CreateEciScalingConfigurationRequestContainersVolumeMounts>> volumeMounts{};
  shared_ptr<string> workingDir{};

  CreateEciScalingConfigurationRequestContainers() {}

  explicit CreateEciScalingConfigurationRequestContainers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (livenessProbe) {
      res["LivenessProbe"] = livenessProbe ? boost::any(livenessProbe->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (readinessProbe) {
      res["ReadinessProbe"] = readinessProbe ? boost::any(readinessProbe->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (securityContext) {
      res["SecurityContext"] = securityContext ? boost::any(securityContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (args) {
      res["Args"] = boost::any(*args);
    }
    if (commands) {
      res["Commands"] = boost::any(*commands);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (environmentVars) {
      vector<boost::any> temp1;
      for(auto item1:*environmentVars){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnvironmentVars"] = boost::any(temp1);
    }
    if (gpu) {
      res["Gpu"] = boost::any(*gpu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (imagePullPolicy) {
      res["ImagePullPolicy"] = boost::any(*imagePullPolicy);
    }
    if (lifecyclePostStartHandlerExecs) {
      res["LifecyclePostStartHandlerExecs"] = boost::any(*lifecyclePostStartHandlerExecs);
    }
    if (lifecyclePostStartHandlerHttpGetHost) {
      res["LifecyclePostStartHandlerHttpGetHost"] = boost::any(*lifecyclePostStartHandlerHttpGetHost);
    }
    if (lifecyclePostStartHandlerHttpGetPath) {
      res["LifecyclePostStartHandlerHttpGetPath"] = boost::any(*lifecyclePostStartHandlerHttpGetPath);
    }
    if (lifecyclePostStartHandlerHttpGetPort) {
      res["LifecyclePostStartHandlerHttpGetPort"] = boost::any(*lifecyclePostStartHandlerHttpGetPort);
    }
    if (lifecyclePostStartHandlerHttpGetScheme) {
      res["LifecyclePostStartHandlerHttpGetScheme"] = boost::any(*lifecyclePostStartHandlerHttpGetScheme);
    }
    if (lifecyclePostStartHandlerTcpSocketHost) {
      res["LifecyclePostStartHandlerTcpSocketHost"] = boost::any(*lifecyclePostStartHandlerTcpSocketHost);
    }
    if (lifecyclePostStartHandlerTcpSocketPort) {
      res["LifecyclePostStartHandlerTcpSocketPort"] = boost::any(*lifecyclePostStartHandlerTcpSocketPort);
    }
    if (lifecyclePreStopHandlerExecs) {
      res["LifecyclePreStopHandlerExecs"] = boost::any(*lifecyclePreStopHandlerExecs);
    }
    if (lifecyclePreStopHandlerHttpGetHost) {
      res["LifecyclePreStopHandlerHttpGetHost"] = boost::any(*lifecyclePreStopHandlerHttpGetHost);
    }
    if (lifecyclePreStopHandlerHttpGetPath) {
      res["LifecyclePreStopHandlerHttpGetPath"] = boost::any(*lifecyclePreStopHandlerHttpGetPath);
    }
    if (lifecyclePreStopHandlerHttpGetPort) {
      res["LifecyclePreStopHandlerHttpGetPort"] = boost::any(*lifecyclePreStopHandlerHttpGetPort);
    }
    if (lifecyclePreStopHandlerHttpGetScheme) {
      res["LifecyclePreStopHandlerHttpGetScheme"] = boost::any(*lifecyclePreStopHandlerHttpGetScheme);
    }
    if (lifecyclePreStopHandlerTcpSocketHost) {
      res["LifecyclePreStopHandlerTcpSocketHost"] = boost::any(*lifecyclePreStopHandlerTcpSocketHost);
    }
    if (lifecyclePreStopHandlerTcpSocketPort) {
      res["LifecyclePreStopHandlerTcpSocketPort"] = boost::any(*lifecyclePreStopHandlerTcpSocketPort);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ports) {
      vector<boost::any> temp1;
      for(auto item1:*ports){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ports"] = boost::any(temp1);
    }
    if (stdin) {
      res["Stdin"] = boost::any(*stdin);
    }
    if (stdinOnce) {
      res["StdinOnce"] = boost::any(*stdinOnce);
    }
    if (tty) {
      res["Tty"] = boost::any(*tty);
    }
    if (volumeMounts) {
      vector<boost::any> temp1;
      for(auto item1:*volumeMounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VolumeMounts"] = boost::any(temp1);
    }
    if (workingDir) {
      res["WorkingDir"] = boost::any(*workingDir);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LivenessProbe") != m.end() && !m["LivenessProbe"].empty()) {
      if (typeid(map<string, boost::any>) == m["LivenessProbe"].type()) {
        CreateEciScalingConfigurationRequestContainersLivenessProbe model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LivenessProbe"]));
        livenessProbe = make_shared<CreateEciScalingConfigurationRequestContainersLivenessProbe>(model1);
      }
    }
    if (m.find("ReadinessProbe") != m.end() && !m["ReadinessProbe"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReadinessProbe"].type()) {
        CreateEciScalingConfigurationRequestContainersReadinessProbe model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReadinessProbe"]));
        readinessProbe = make_shared<CreateEciScalingConfigurationRequestContainersReadinessProbe>(model1);
      }
    }
    if (m.find("SecurityContext") != m.end() && !m["SecurityContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityContext"].type()) {
        CreateEciScalingConfigurationRequestContainersSecurityContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityContext"]));
        securityContext = make_shared<CreateEciScalingConfigurationRequestContainersSecurityContext>(model1);
      }
    }
    if (m.find("Args") != m.end() && !m["Args"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Args"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Args"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      args = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Commands") != m.end() && !m["Commands"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Commands"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Commands"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      commands = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<double>(boost::any_cast<double>(m["Cpu"]));
    }
    if (m.find("EnvironmentVars") != m.end() && !m["EnvironmentVars"].empty()) {
      if (typeid(vector<boost::any>) == m["EnvironmentVars"].type()) {
        vector<CreateEciScalingConfigurationRequestContainersEnvironmentVars> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnvironmentVars"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEciScalingConfigurationRequestContainersEnvironmentVars model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        environmentVars = make_shared<vector<CreateEciScalingConfigurationRequestContainersEnvironmentVars>>(expect1);
      }
    }
    if (m.find("Gpu") != m.end() && !m["Gpu"].empty()) {
      gpu = make_shared<long>(boost::any_cast<long>(m["Gpu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ImagePullPolicy") != m.end() && !m["ImagePullPolicy"].empty()) {
      imagePullPolicy = make_shared<string>(boost::any_cast<string>(m["ImagePullPolicy"]));
    }
    if (m.find("LifecyclePostStartHandlerExecs") != m.end() && !m["LifecyclePostStartHandlerExecs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LifecyclePostStartHandlerExecs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LifecyclePostStartHandlerExecs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      lifecyclePostStartHandlerExecs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LifecyclePostStartHandlerHttpGetHost") != m.end() && !m["LifecyclePostStartHandlerHttpGetHost"].empty()) {
      lifecyclePostStartHandlerHttpGetHost = make_shared<string>(boost::any_cast<string>(m["LifecyclePostStartHandlerHttpGetHost"]));
    }
    if (m.find("LifecyclePostStartHandlerHttpGetPath") != m.end() && !m["LifecyclePostStartHandlerHttpGetPath"].empty()) {
      lifecyclePostStartHandlerHttpGetPath = make_shared<string>(boost::any_cast<string>(m["LifecyclePostStartHandlerHttpGetPath"]));
    }
    if (m.find("LifecyclePostStartHandlerHttpGetPort") != m.end() && !m["LifecyclePostStartHandlerHttpGetPort"].empty()) {
      lifecyclePostStartHandlerHttpGetPort = make_shared<long>(boost::any_cast<long>(m["LifecyclePostStartHandlerHttpGetPort"]));
    }
    if (m.find("LifecyclePostStartHandlerHttpGetScheme") != m.end() && !m["LifecyclePostStartHandlerHttpGetScheme"].empty()) {
      lifecyclePostStartHandlerHttpGetScheme = make_shared<string>(boost::any_cast<string>(m["LifecyclePostStartHandlerHttpGetScheme"]));
    }
    if (m.find("LifecyclePostStartHandlerTcpSocketHost") != m.end() && !m["LifecyclePostStartHandlerTcpSocketHost"].empty()) {
      lifecyclePostStartHandlerTcpSocketHost = make_shared<string>(boost::any_cast<string>(m["LifecyclePostStartHandlerTcpSocketHost"]));
    }
    if (m.find("LifecyclePostStartHandlerTcpSocketPort") != m.end() && !m["LifecyclePostStartHandlerTcpSocketPort"].empty()) {
      lifecyclePostStartHandlerTcpSocketPort = make_shared<long>(boost::any_cast<long>(m["LifecyclePostStartHandlerTcpSocketPort"]));
    }
    if (m.find("LifecyclePreStopHandlerExecs") != m.end() && !m["LifecyclePreStopHandlerExecs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LifecyclePreStopHandlerExecs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LifecyclePreStopHandlerExecs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      lifecyclePreStopHandlerExecs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LifecyclePreStopHandlerHttpGetHost") != m.end() && !m["LifecyclePreStopHandlerHttpGetHost"].empty()) {
      lifecyclePreStopHandlerHttpGetHost = make_shared<string>(boost::any_cast<string>(m["LifecyclePreStopHandlerHttpGetHost"]));
    }
    if (m.find("LifecyclePreStopHandlerHttpGetPath") != m.end() && !m["LifecyclePreStopHandlerHttpGetPath"].empty()) {
      lifecyclePreStopHandlerHttpGetPath = make_shared<string>(boost::any_cast<string>(m["LifecyclePreStopHandlerHttpGetPath"]));
    }
    if (m.find("LifecyclePreStopHandlerHttpGetPort") != m.end() && !m["LifecyclePreStopHandlerHttpGetPort"].empty()) {
      lifecyclePreStopHandlerHttpGetPort = make_shared<long>(boost::any_cast<long>(m["LifecyclePreStopHandlerHttpGetPort"]));
    }
    if (m.find("LifecyclePreStopHandlerHttpGetScheme") != m.end() && !m["LifecyclePreStopHandlerHttpGetScheme"].empty()) {
      lifecyclePreStopHandlerHttpGetScheme = make_shared<string>(boost::any_cast<string>(m["LifecyclePreStopHandlerHttpGetScheme"]));
    }
    if (m.find("LifecyclePreStopHandlerTcpSocketHost") != m.end() && !m["LifecyclePreStopHandlerTcpSocketHost"].empty()) {
      lifecyclePreStopHandlerTcpSocketHost = make_shared<string>(boost::any_cast<string>(m["LifecyclePreStopHandlerTcpSocketHost"]));
    }
    if (m.find("LifecyclePreStopHandlerTcpSocketPort") != m.end() && !m["LifecyclePreStopHandlerTcpSocketPort"].empty()) {
      lifecyclePreStopHandlerTcpSocketPort = make_shared<long>(boost::any_cast<long>(m["LifecyclePreStopHandlerTcpSocketPort"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Ports") != m.end() && !m["Ports"].empty()) {
      if (typeid(vector<boost::any>) == m["Ports"].type()) {
        vector<CreateEciScalingConfigurationRequestContainersPorts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ports"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEciScalingConfigurationRequestContainersPorts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ports = make_shared<vector<CreateEciScalingConfigurationRequestContainersPorts>>(expect1);
      }
    }
    if (m.find("Stdin") != m.end() && !m["Stdin"].empty()) {
      stdin = make_shared<bool>(boost::any_cast<bool>(m["Stdin"]));
    }
    if (m.find("StdinOnce") != m.end() && !m["StdinOnce"].empty()) {
      stdinOnce = make_shared<bool>(boost::any_cast<bool>(m["StdinOnce"]));
    }
    if (m.find("Tty") != m.end() && !m["Tty"].empty()) {
      tty = make_shared<bool>(boost::any_cast<bool>(m["Tty"]));
    }
    if (m.find("VolumeMounts") != m.end() && !m["VolumeMounts"].empty()) {
      if (typeid(vector<boost::any>) == m["VolumeMounts"].type()) {
        vector<CreateEciScalingConfigurationRequestContainersVolumeMounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VolumeMounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEciScalingConfigurationRequestContainersVolumeMounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        volumeMounts = make_shared<vector<CreateEciScalingConfigurationRequestContainersVolumeMounts>>(expect1);
      }
    }
    if (m.find("WorkingDir") != m.end() && !m["WorkingDir"].empty()) {
      workingDir = make_shared<string>(boost::any_cast<string>(m["WorkingDir"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestContainers() = default;
};
class CreateEciScalingConfigurationRequestDnsConfigOptions : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  CreateEciScalingConfigurationRequestDnsConfigOptions() {}

  explicit CreateEciScalingConfigurationRequestDnsConfigOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestDnsConfigOptions() = default;
};
class CreateEciScalingConfigurationRequestHostAliases : public Darabonba::Model {
public:
  shared_ptr<vector<string>> hostnames{};
  shared_ptr<string> ip{};

  CreateEciScalingConfigurationRequestHostAliases() {}

  explicit CreateEciScalingConfigurationRequestHostAliases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostnames) {
      res["Hostnames"] = boost::any(*hostnames);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Hostnames") != m.end() && !m["Hostnames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Hostnames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Hostnames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostnames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestHostAliases() = default;
};
class CreateEciScalingConfigurationRequestImageRegistryCredentials : public Darabonba::Model {
public:
  shared_ptr<string> password{};
  shared_ptr<string> server{};
  shared_ptr<string> userName{};

  CreateEciScalingConfigurationRequestImageRegistryCredentials() {}

  explicit CreateEciScalingConfigurationRequestImageRegistryCredentials(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (server) {
      res["Server"] = boost::any(*server);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Server") != m.end() && !m["Server"].empty()) {
      server = make_shared<string>(boost::any_cast<string>(m["Server"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestImageRegistryCredentials() = default;
};
class CreateEciScalingConfigurationRequestInitContainersSecurityContextCapability : public Darabonba::Model {
public:
  shared_ptr<vector<string>> adds{};

  CreateEciScalingConfigurationRequestInitContainersSecurityContextCapability() {}

  explicit CreateEciScalingConfigurationRequestInitContainersSecurityContextCapability(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adds) {
      res["Adds"] = boost::any(*adds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Adds") != m.end() && !m["Adds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Adds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Adds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      adds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateEciScalingConfigurationRequestInitContainersSecurityContextCapability() = default;
};
class CreateEciScalingConfigurationRequestInitContainersSecurityContext : public Darabonba::Model {
public:
  shared_ptr<CreateEciScalingConfigurationRequestInitContainersSecurityContextCapability> capability{};
  shared_ptr<bool> readOnlyRootFilesystem{};
  shared_ptr<long> runAsUser{};

  CreateEciScalingConfigurationRequestInitContainersSecurityContext() {}

  explicit CreateEciScalingConfigurationRequestInitContainersSecurityContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capability) {
      res["Capability"] = capability ? boost::any(capability->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (readOnlyRootFilesystem) {
      res["ReadOnlyRootFilesystem"] = boost::any(*readOnlyRootFilesystem);
    }
    if (runAsUser) {
      res["RunAsUser"] = boost::any(*runAsUser);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Capability") != m.end() && !m["Capability"].empty()) {
      if (typeid(map<string, boost::any>) == m["Capability"].type()) {
        CreateEciScalingConfigurationRequestInitContainersSecurityContextCapability model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Capability"]));
        capability = make_shared<CreateEciScalingConfigurationRequestInitContainersSecurityContextCapability>(model1);
      }
    }
    if (m.find("ReadOnlyRootFilesystem") != m.end() && !m["ReadOnlyRootFilesystem"].empty()) {
      readOnlyRootFilesystem = make_shared<bool>(boost::any_cast<bool>(m["ReadOnlyRootFilesystem"]));
    }
    if (m.find("RunAsUser") != m.end() && !m["RunAsUser"].empty()) {
      runAsUser = make_shared<long>(boost::any_cast<long>(m["RunAsUser"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestInitContainersSecurityContext() = default;
};
class CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars : public Darabonba::Model {
public:
  shared_ptr<string> fieldRefFieldPath{};
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars() {}

  explicit CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldRefFieldPath) {
      res["FieldRefFieldPath"] = boost::any(*fieldRefFieldPath);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldRefFieldPath") != m.end() && !m["FieldRefFieldPath"].empty()) {
      fieldRefFieldPath = make_shared<string>(boost::any_cast<string>(m["FieldRefFieldPath"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars() = default;
};
class CreateEciScalingConfigurationRequestInitContainersInitContainerPorts : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> protocol{};

  CreateEciScalingConfigurationRequestInitContainersInitContainerPorts() {}

  explicit CreateEciScalingConfigurationRequestInitContainersInitContainerPorts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestInitContainersInitContainerPorts() = default;
};
class CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts : public Darabonba::Model {
public:
  shared_ptr<string> mountPath{};
  shared_ptr<string> mountPropagation{};
  shared_ptr<string> name{};
  shared_ptr<bool> readOnly{};
  shared_ptr<string> subPath{};

  CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts() {}

  explicit CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountPath) {
      res["MountPath"] = boost::any(*mountPath);
    }
    if (mountPropagation) {
      res["MountPropagation"] = boost::any(*mountPropagation);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    if (subPath) {
      res["SubPath"] = boost::any(*subPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MountPath") != m.end() && !m["MountPath"].empty()) {
      mountPath = make_shared<string>(boost::any_cast<string>(m["MountPath"]));
    }
    if (m.find("MountPropagation") != m.end() && !m["MountPropagation"].empty()) {
      mountPropagation = make_shared<string>(boost::any_cast<string>(m["MountPropagation"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
    if (m.find("SubPath") != m.end() && !m["SubPath"].empty()) {
      subPath = make_shared<string>(boost::any_cast<string>(m["SubPath"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts() = default;
};
class CreateEciScalingConfigurationRequestInitContainers : public Darabonba::Model {
public:
  shared_ptr<CreateEciScalingConfigurationRequestInitContainersSecurityContext> securityContext{};
  shared_ptr<vector<string>> args{};
  shared_ptr<vector<string>> commands{};
  shared_ptr<double> cpu{};
  shared_ptr<long> gpu{};
  shared_ptr<string> image{};
  shared_ptr<string> imagePullPolicy{};
  shared_ptr<vector<CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars>> initContainerEnvironmentVars{};
  shared_ptr<vector<CreateEciScalingConfigurationRequestInitContainersInitContainerPorts>> initContainerPorts{};
  shared_ptr<vector<CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts>> initContainerVolumeMounts{};
  shared_ptr<double> memory{};
  shared_ptr<string> name{};
  shared_ptr<string> workingDir{};

  CreateEciScalingConfigurationRequestInitContainers() {}

  explicit CreateEciScalingConfigurationRequestInitContainers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityContext) {
      res["SecurityContext"] = securityContext ? boost::any(securityContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (args) {
      res["Args"] = boost::any(*args);
    }
    if (commands) {
      res["Commands"] = boost::any(*commands);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (gpu) {
      res["Gpu"] = boost::any(*gpu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (imagePullPolicy) {
      res["ImagePullPolicy"] = boost::any(*imagePullPolicy);
    }
    if (initContainerEnvironmentVars) {
      vector<boost::any> temp1;
      for(auto item1:*initContainerEnvironmentVars){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InitContainerEnvironmentVars"] = boost::any(temp1);
    }
    if (initContainerPorts) {
      vector<boost::any> temp1;
      for(auto item1:*initContainerPorts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InitContainerPorts"] = boost::any(temp1);
    }
    if (initContainerVolumeMounts) {
      vector<boost::any> temp1;
      for(auto item1:*initContainerVolumeMounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InitContainerVolumeMounts"] = boost::any(temp1);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (workingDir) {
      res["WorkingDir"] = boost::any(*workingDir);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityContext") != m.end() && !m["SecurityContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityContext"].type()) {
        CreateEciScalingConfigurationRequestInitContainersSecurityContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityContext"]));
        securityContext = make_shared<CreateEciScalingConfigurationRequestInitContainersSecurityContext>(model1);
      }
    }
    if (m.find("Args") != m.end() && !m["Args"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Args"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Args"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      args = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Commands") != m.end() && !m["Commands"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Commands"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Commands"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      commands = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<double>(boost::any_cast<double>(m["Cpu"]));
    }
    if (m.find("Gpu") != m.end() && !m["Gpu"].empty()) {
      gpu = make_shared<long>(boost::any_cast<long>(m["Gpu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ImagePullPolicy") != m.end() && !m["ImagePullPolicy"].empty()) {
      imagePullPolicy = make_shared<string>(boost::any_cast<string>(m["ImagePullPolicy"]));
    }
    if (m.find("InitContainerEnvironmentVars") != m.end() && !m["InitContainerEnvironmentVars"].empty()) {
      if (typeid(vector<boost::any>) == m["InitContainerEnvironmentVars"].type()) {
        vector<CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InitContainerEnvironmentVars"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        initContainerEnvironmentVars = make_shared<vector<CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars>>(expect1);
      }
    }
    if (m.find("InitContainerPorts") != m.end() && !m["InitContainerPorts"].empty()) {
      if (typeid(vector<boost::any>) == m["InitContainerPorts"].type()) {
        vector<CreateEciScalingConfigurationRequestInitContainersInitContainerPorts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InitContainerPorts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEciScalingConfigurationRequestInitContainersInitContainerPorts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        initContainerPorts = make_shared<vector<CreateEciScalingConfigurationRequestInitContainersInitContainerPorts>>(expect1);
      }
    }
    if (m.find("InitContainerVolumeMounts") != m.end() && !m["InitContainerVolumeMounts"].empty()) {
      if (typeid(vector<boost::any>) == m["InitContainerVolumeMounts"].type()) {
        vector<CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InitContainerVolumeMounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        initContainerVolumeMounts = make_shared<vector<CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts>>(expect1);
      }
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("WorkingDir") != m.end() && !m["WorkingDir"].empty()) {
      workingDir = make_shared<string>(boost::any_cast<string>(m["WorkingDir"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestInitContainers() = default;
};
class CreateEciScalingConfigurationRequestSecurityContextSysctls : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  CreateEciScalingConfigurationRequestSecurityContextSysctls() {}

  explicit CreateEciScalingConfigurationRequestSecurityContextSysctls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestSecurityContextSysctls() = default;
};
class CreateEciScalingConfigurationRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateEciScalingConfigurationRequestTags() {}

  explicit CreateEciScalingConfigurationRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestTags() = default;
};
class CreateEciScalingConfigurationRequestVolumesDiskVolume : public Darabonba::Model {
public:
  shared_ptr<string> diskId{};
  shared_ptr<long> diskSize{};
  shared_ptr<string> fsType{};

  CreateEciScalingConfigurationRequestVolumesDiskVolume() {}

  explicit CreateEciScalingConfigurationRequestVolumesDiskVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (diskSize) {
      res["DiskSize"] = boost::any(*diskSize);
    }
    if (fsType) {
      res["FsType"] = boost::any(*fsType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("DiskSize") != m.end() && !m["DiskSize"].empty()) {
      diskSize = make_shared<long>(boost::any_cast<long>(m["DiskSize"]));
    }
    if (m.find("FsType") != m.end() && !m["FsType"].empty()) {
      fsType = make_shared<string>(boost::any_cast<string>(m["FsType"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestVolumesDiskVolume() = default;
};
class CreateEciScalingConfigurationRequestVolumesEmptyDirVolume : public Darabonba::Model {
public:
  shared_ptr<string> medium{};
  shared_ptr<string> sizeLimit{};

  CreateEciScalingConfigurationRequestVolumesEmptyDirVolume() {}

  explicit CreateEciScalingConfigurationRequestVolumesEmptyDirVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (medium) {
      res["Medium"] = boost::any(*medium);
    }
    if (sizeLimit) {
      res["SizeLimit"] = boost::any(*sizeLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Medium") != m.end() && !m["Medium"].empty()) {
      medium = make_shared<string>(boost::any_cast<string>(m["Medium"]));
    }
    if (m.find("SizeLimit") != m.end() && !m["SizeLimit"].empty()) {
      sizeLimit = make_shared<string>(boost::any_cast<string>(m["SizeLimit"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestVolumesEmptyDirVolume() = default;
};
class CreateEciScalingConfigurationRequestVolumesFlexVolume : public Darabonba::Model {
public:
  shared_ptr<string> driver{};
  shared_ptr<string> fsType{};
  shared_ptr<string> options{};

  CreateEciScalingConfigurationRequestVolumesFlexVolume() {}

  explicit CreateEciScalingConfigurationRequestVolumesFlexVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driver) {
      res["Driver"] = boost::any(*driver);
    }
    if (fsType) {
      res["FsType"] = boost::any(*fsType);
    }
    if (options) {
      res["Options"] = boost::any(*options);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Driver") != m.end() && !m["Driver"].empty()) {
      driver = make_shared<string>(boost::any_cast<string>(m["Driver"]));
    }
    if (m.find("FsType") != m.end() && !m["FsType"].empty()) {
      fsType = make_shared<string>(boost::any_cast<string>(m["FsType"]));
    }
    if (m.find("Options") != m.end() && !m["Options"].empty()) {
      options = make_shared<string>(boost::any_cast<string>(m["Options"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestVolumesFlexVolume() = default;
};
class CreateEciScalingConfigurationRequestVolumesHostPathVolume : public Darabonba::Model {
public:
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  CreateEciScalingConfigurationRequestVolumesHostPathVolume() {}

  explicit CreateEciScalingConfigurationRequestVolumesHostPathVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestVolumesHostPathVolume() = default;
};
class CreateEciScalingConfigurationRequestVolumesNFSVolume : public Darabonba::Model {
public:
  shared_ptr<string> path{};
  shared_ptr<bool> readOnly{};
  shared_ptr<string> server{};

  CreateEciScalingConfigurationRequestVolumesNFSVolume() {}

  explicit CreateEciScalingConfigurationRequestVolumesNFSVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    if (server) {
      res["Server"] = boost::any(*server);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
    if (m.find("Server") != m.end() && !m["Server"].empty()) {
      server = make_shared<string>(boost::any_cast<string>(m["Server"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestVolumesNFSVolume() = default;
};
class CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> mode{};
  shared_ptr<string> path{};

  CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths() {}

  explicit CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<long>(boost::any_cast<long>(m["Mode"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths() = default;
};
class CreateEciScalingConfigurationRequestVolumes : public Darabonba::Model {
public:
  shared_ptr<CreateEciScalingConfigurationRequestVolumesDiskVolume> diskVolume{};
  shared_ptr<CreateEciScalingConfigurationRequestVolumesEmptyDirVolume> emptyDirVolume{};
  shared_ptr<CreateEciScalingConfigurationRequestVolumesFlexVolume> flexVolume{};
  shared_ptr<CreateEciScalingConfigurationRequestVolumesHostPathVolume> hostPathVolume{};
  shared_ptr<CreateEciScalingConfigurationRequestVolumesNFSVolume> NFSVolume{};
  shared_ptr<vector<CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths>> configFileVolumeConfigFileToPaths{};
  shared_ptr<long> configFileVolumeDefaultMode{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  CreateEciScalingConfigurationRequestVolumes() {}

  explicit CreateEciScalingConfigurationRequestVolumes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskVolume) {
      res["DiskVolume"] = diskVolume ? boost::any(diskVolume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyDirVolume) {
      res["EmptyDirVolume"] = emptyDirVolume ? boost::any(emptyDirVolume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flexVolume) {
      res["FlexVolume"] = flexVolume ? boost::any(flexVolume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hostPathVolume) {
      res["HostPathVolume"] = hostPathVolume ? boost::any(hostPathVolume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (NFSVolume) {
      res["NFSVolume"] = NFSVolume ? boost::any(NFSVolume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (configFileVolumeConfigFileToPaths) {
      vector<boost::any> temp1;
      for(auto item1:*configFileVolumeConfigFileToPaths){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigFileVolumeConfigFileToPaths"] = boost::any(temp1);
    }
    if (configFileVolumeDefaultMode) {
      res["ConfigFileVolumeDefaultMode"] = boost::any(*configFileVolumeDefaultMode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskVolume") != m.end() && !m["DiskVolume"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskVolume"].type()) {
        CreateEciScalingConfigurationRequestVolumesDiskVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskVolume"]));
        diskVolume = make_shared<CreateEciScalingConfigurationRequestVolumesDiskVolume>(model1);
      }
    }
    if (m.find("EmptyDirVolume") != m.end() && !m["EmptyDirVolume"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyDirVolume"].type()) {
        CreateEciScalingConfigurationRequestVolumesEmptyDirVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyDirVolume"]));
        emptyDirVolume = make_shared<CreateEciScalingConfigurationRequestVolumesEmptyDirVolume>(model1);
      }
    }
    if (m.find("FlexVolume") != m.end() && !m["FlexVolume"].empty()) {
      if (typeid(map<string, boost::any>) == m["FlexVolume"].type()) {
        CreateEciScalingConfigurationRequestVolumesFlexVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FlexVolume"]));
        flexVolume = make_shared<CreateEciScalingConfigurationRequestVolumesFlexVolume>(model1);
      }
    }
    if (m.find("HostPathVolume") != m.end() && !m["HostPathVolume"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostPathVolume"].type()) {
        CreateEciScalingConfigurationRequestVolumesHostPathVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostPathVolume"]));
        hostPathVolume = make_shared<CreateEciScalingConfigurationRequestVolumesHostPathVolume>(model1);
      }
    }
    if (m.find("NFSVolume") != m.end() && !m["NFSVolume"].empty()) {
      if (typeid(map<string, boost::any>) == m["NFSVolume"].type()) {
        CreateEciScalingConfigurationRequestVolumesNFSVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NFSVolume"]));
        NFSVolume = make_shared<CreateEciScalingConfigurationRequestVolumesNFSVolume>(model1);
      }
    }
    if (m.find("ConfigFileVolumeConfigFileToPaths") != m.end() && !m["ConfigFileVolumeConfigFileToPaths"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigFileVolumeConfigFileToPaths"].type()) {
        vector<CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigFileVolumeConfigFileToPaths"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configFileVolumeConfigFileToPaths = make_shared<vector<CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths>>(expect1);
      }
    }
    if (m.find("ConfigFileVolumeDefaultMode") != m.end() && !m["ConfigFileVolumeDefaultMode"].empty()) {
      configFileVolumeDefaultMode = make_shared<long>(boost::any_cast<long>(m["ConfigFileVolumeDefaultMode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateEciScalingConfigurationRequestVolumes() = default;
};
class CreateEciScalingConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateEciScalingConfigurationRequestAcrRegistryInfos>> acrRegistryInfos{};
  shared_ptr<long> activeDeadlineSeconds{};
  shared_ptr<bool> autoCreateEip{};
  shared_ptr<bool> autoMatchImageCache{};
  shared_ptr<string> containerGroupName{};
  shared_ptr<vector<CreateEciScalingConfigurationRequestContainers>> containers{};
  shared_ptr<bool> costOptimization{};
  shared_ptr<double> cpu{};
  shared_ptr<long> cpuOptionsCore{};
  shared_ptr<long> cpuOptionsThreadsPerCore{};
  shared_ptr<string> dataCacheBucket{};
  shared_ptr<bool> dataCacheBurstingEnabled{};
  shared_ptr<string> dataCachePL{};
  shared_ptr<long> dataCacheProvisionedIops{};
  shared_ptr<string> description{};
  shared_ptr<vector<string>> dnsConfigNameServers{};
  shared_ptr<vector<CreateEciScalingConfigurationRequestDnsConfigOptions>> dnsConfigOptions{};
  shared_ptr<vector<string>> dnsConfigSearchs{};
  shared_ptr<string> dnsPolicy{};
  shared_ptr<long> egressBandwidth{};
  shared_ptr<long> eipBandwidth{};
  shared_ptr<bool> enableSls{};
  shared_ptr<long> ephemeralStorage{};
  shared_ptr<string> gpuDriverVersion{};
  shared_ptr<vector<CreateEciScalingConfigurationRequestHostAliases>> hostAliases{};
  shared_ptr<string> hostName{};
  shared_ptr<vector<CreateEciScalingConfigurationRequestImageRegistryCredentials>> imageRegistryCredentials{};
  shared_ptr<string> imageSnapshotId{};
  shared_ptr<long> ingressBandwidth{};
  shared_ptr<vector<CreateEciScalingConfigurationRequestInitContainers>> initContainers{};
  shared_ptr<string> instanceFamilyLevel{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<long> ipv6AddressCount{};
  shared_ptr<long> loadBalancerWeight{};
  shared_ptr<double> memory{};
  shared_ptr<vector<string>> ntpServers{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> ramRoleName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> restartPolicy{};
  shared_ptr<string> scalingConfigurationName{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<vector<CreateEciScalingConfigurationRequestSecurityContextSysctls>> securityContextSysctls{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<double> spotPriceLimit{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<vector<CreateEciScalingConfigurationRequestTags>> tags{};
  shared_ptr<long> terminationGracePeriodSeconds{};
  shared_ptr<vector<CreateEciScalingConfigurationRequestVolumes>> volumes{};

  CreateEciScalingConfigurationRequest() {}

  explicit CreateEciScalingConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acrRegistryInfos) {
      vector<boost::any> temp1;
      for(auto item1:*acrRegistryInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AcrRegistryInfos"] = boost::any(temp1);
    }
    if (activeDeadlineSeconds) {
      res["ActiveDeadlineSeconds"] = boost::any(*activeDeadlineSeconds);
    }
    if (autoCreateEip) {
      res["AutoCreateEip"] = boost::any(*autoCreateEip);
    }
    if (autoMatchImageCache) {
      res["AutoMatchImageCache"] = boost::any(*autoMatchImageCache);
    }
    if (containerGroupName) {
      res["ContainerGroupName"] = boost::any(*containerGroupName);
    }
    if (containers) {
      vector<boost::any> temp1;
      for(auto item1:*containers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Containers"] = boost::any(temp1);
    }
    if (costOptimization) {
      res["CostOptimization"] = boost::any(*costOptimization);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (cpuOptionsCore) {
      res["CpuOptionsCore"] = boost::any(*cpuOptionsCore);
    }
    if (cpuOptionsThreadsPerCore) {
      res["CpuOptionsThreadsPerCore"] = boost::any(*cpuOptionsThreadsPerCore);
    }
    if (dataCacheBucket) {
      res["DataCacheBucket"] = boost::any(*dataCacheBucket);
    }
    if (dataCacheBurstingEnabled) {
      res["DataCacheBurstingEnabled"] = boost::any(*dataCacheBurstingEnabled);
    }
    if (dataCachePL) {
      res["DataCachePL"] = boost::any(*dataCachePL);
    }
    if (dataCacheProvisionedIops) {
      res["DataCacheProvisionedIops"] = boost::any(*dataCacheProvisionedIops);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dnsConfigNameServers) {
      res["DnsConfigNameServers"] = boost::any(*dnsConfigNameServers);
    }
    if (dnsConfigOptions) {
      vector<boost::any> temp1;
      for(auto item1:*dnsConfigOptions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DnsConfigOptions"] = boost::any(temp1);
    }
    if (dnsConfigSearchs) {
      res["DnsConfigSearchs"] = boost::any(*dnsConfigSearchs);
    }
    if (dnsPolicy) {
      res["DnsPolicy"] = boost::any(*dnsPolicy);
    }
    if (egressBandwidth) {
      res["EgressBandwidth"] = boost::any(*egressBandwidth);
    }
    if (eipBandwidth) {
      res["EipBandwidth"] = boost::any(*eipBandwidth);
    }
    if (enableSls) {
      res["EnableSls"] = boost::any(*enableSls);
    }
    if (ephemeralStorage) {
      res["EphemeralStorage"] = boost::any(*ephemeralStorage);
    }
    if (gpuDriverVersion) {
      res["GpuDriverVersion"] = boost::any(*gpuDriverVersion);
    }
    if (hostAliases) {
      vector<boost::any> temp1;
      for(auto item1:*hostAliases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostAliases"] = boost::any(temp1);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (imageRegistryCredentials) {
      vector<boost::any> temp1;
      for(auto item1:*imageRegistryCredentials){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageRegistryCredentials"] = boost::any(temp1);
    }
    if (imageSnapshotId) {
      res["ImageSnapshotId"] = boost::any(*imageSnapshotId);
    }
    if (ingressBandwidth) {
      res["IngressBandwidth"] = boost::any(*ingressBandwidth);
    }
    if (initContainers) {
      vector<boost::any> temp1;
      for(auto item1:*initContainers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InitContainers"] = boost::any(temp1);
    }
    if (instanceFamilyLevel) {
      res["InstanceFamilyLevel"] = boost::any(*instanceFamilyLevel);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = boost::any(*instanceTypes);
    }
    if (ipv6AddressCount) {
      res["Ipv6AddressCount"] = boost::any(*ipv6AddressCount);
    }
    if (loadBalancerWeight) {
      res["LoadBalancerWeight"] = boost::any(*loadBalancerWeight);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (ntpServers) {
      res["NtpServers"] = boost::any(*ntpServers);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (restartPolicy) {
      res["RestartPolicy"] = boost::any(*restartPolicy);
    }
    if (scalingConfigurationName) {
      res["ScalingConfigurationName"] = boost::any(*scalingConfigurationName);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (securityContextSysctls) {
      vector<boost::any> temp1;
      for(auto item1:*securityContextSysctls){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityContextSysctls"] = boost::any(temp1);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (spotPriceLimit) {
      res["SpotPriceLimit"] = boost::any(*spotPriceLimit);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (terminationGracePeriodSeconds) {
      res["TerminationGracePeriodSeconds"] = boost::any(*terminationGracePeriodSeconds);
    }
    if (volumes) {
      vector<boost::any> temp1;
      for(auto item1:*volumes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Volumes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcrRegistryInfos") != m.end() && !m["AcrRegistryInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["AcrRegistryInfos"].type()) {
        vector<CreateEciScalingConfigurationRequestAcrRegistryInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AcrRegistryInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEciScalingConfigurationRequestAcrRegistryInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        acrRegistryInfos = make_shared<vector<CreateEciScalingConfigurationRequestAcrRegistryInfos>>(expect1);
      }
    }
    if (m.find("ActiveDeadlineSeconds") != m.end() && !m["ActiveDeadlineSeconds"].empty()) {
      activeDeadlineSeconds = make_shared<long>(boost::any_cast<long>(m["ActiveDeadlineSeconds"]));
    }
    if (m.find("AutoCreateEip") != m.end() && !m["AutoCreateEip"].empty()) {
      autoCreateEip = make_shared<bool>(boost::any_cast<bool>(m["AutoCreateEip"]));
    }
    if (m.find("AutoMatchImageCache") != m.end() && !m["AutoMatchImageCache"].empty()) {
      autoMatchImageCache = make_shared<bool>(boost::any_cast<bool>(m["AutoMatchImageCache"]));
    }
    if (m.find("ContainerGroupName") != m.end() && !m["ContainerGroupName"].empty()) {
      containerGroupName = make_shared<string>(boost::any_cast<string>(m["ContainerGroupName"]));
    }
    if (m.find("Containers") != m.end() && !m["Containers"].empty()) {
      if (typeid(vector<boost::any>) == m["Containers"].type()) {
        vector<CreateEciScalingConfigurationRequestContainers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Containers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEciScalingConfigurationRequestContainers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        containers = make_shared<vector<CreateEciScalingConfigurationRequestContainers>>(expect1);
      }
    }
    if (m.find("CostOptimization") != m.end() && !m["CostOptimization"].empty()) {
      costOptimization = make_shared<bool>(boost::any_cast<bool>(m["CostOptimization"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<double>(boost::any_cast<double>(m["Cpu"]));
    }
    if (m.find("CpuOptionsCore") != m.end() && !m["CpuOptionsCore"].empty()) {
      cpuOptionsCore = make_shared<long>(boost::any_cast<long>(m["CpuOptionsCore"]));
    }
    if (m.find("CpuOptionsThreadsPerCore") != m.end() && !m["CpuOptionsThreadsPerCore"].empty()) {
      cpuOptionsThreadsPerCore = make_shared<long>(boost::any_cast<long>(m["CpuOptionsThreadsPerCore"]));
    }
    if (m.find("DataCacheBucket") != m.end() && !m["DataCacheBucket"].empty()) {
      dataCacheBucket = make_shared<string>(boost::any_cast<string>(m["DataCacheBucket"]));
    }
    if (m.find("DataCacheBurstingEnabled") != m.end() && !m["DataCacheBurstingEnabled"].empty()) {
      dataCacheBurstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["DataCacheBurstingEnabled"]));
    }
    if (m.find("DataCachePL") != m.end() && !m["DataCachePL"].empty()) {
      dataCachePL = make_shared<string>(boost::any_cast<string>(m["DataCachePL"]));
    }
    if (m.find("DataCacheProvisionedIops") != m.end() && !m["DataCacheProvisionedIops"].empty()) {
      dataCacheProvisionedIops = make_shared<long>(boost::any_cast<long>(m["DataCacheProvisionedIops"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DnsConfigNameServers") != m.end() && !m["DnsConfigNameServers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DnsConfigNameServers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DnsConfigNameServers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dnsConfigNameServers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DnsConfigOptions") != m.end() && !m["DnsConfigOptions"].empty()) {
      if (typeid(vector<boost::any>) == m["DnsConfigOptions"].type()) {
        vector<CreateEciScalingConfigurationRequestDnsConfigOptions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DnsConfigOptions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEciScalingConfigurationRequestDnsConfigOptions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dnsConfigOptions = make_shared<vector<CreateEciScalingConfigurationRequestDnsConfigOptions>>(expect1);
      }
    }
    if (m.find("DnsConfigSearchs") != m.end() && !m["DnsConfigSearchs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DnsConfigSearchs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DnsConfigSearchs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dnsConfigSearchs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DnsPolicy") != m.end() && !m["DnsPolicy"].empty()) {
      dnsPolicy = make_shared<string>(boost::any_cast<string>(m["DnsPolicy"]));
    }
    if (m.find("EgressBandwidth") != m.end() && !m["EgressBandwidth"].empty()) {
      egressBandwidth = make_shared<long>(boost::any_cast<long>(m["EgressBandwidth"]));
    }
    if (m.find("EipBandwidth") != m.end() && !m["EipBandwidth"].empty()) {
      eipBandwidth = make_shared<long>(boost::any_cast<long>(m["EipBandwidth"]));
    }
    if (m.find("EnableSls") != m.end() && !m["EnableSls"].empty()) {
      enableSls = make_shared<bool>(boost::any_cast<bool>(m["EnableSls"]));
    }
    if (m.find("EphemeralStorage") != m.end() && !m["EphemeralStorage"].empty()) {
      ephemeralStorage = make_shared<long>(boost::any_cast<long>(m["EphemeralStorage"]));
    }
    if (m.find("GpuDriverVersion") != m.end() && !m["GpuDriverVersion"].empty()) {
      gpuDriverVersion = make_shared<string>(boost::any_cast<string>(m["GpuDriverVersion"]));
    }
    if (m.find("HostAliases") != m.end() && !m["HostAliases"].empty()) {
      if (typeid(vector<boost::any>) == m["HostAliases"].type()) {
        vector<CreateEciScalingConfigurationRequestHostAliases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostAliases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEciScalingConfigurationRequestHostAliases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostAliases = make_shared<vector<CreateEciScalingConfigurationRequestHostAliases>>(expect1);
      }
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ImageRegistryCredentials") != m.end() && !m["ImageRegistryCredentials"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageRegistryCredentials"].type()) {
        vector<CreateEciScalingConfigurationRequestImageRegistryCredentials> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageRegistryCredentials"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEciScalingConfigurationRequestImageRegistryCredentials model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageRegistryCredentials = make_shared<vector<CreateEciScalingConfigurationRequestImageRegistryCredentials>>(expect1);
      }
    }
    if (m.find("ImageSnapshotId") != m.end() && !m["ImageSnapshotId"].empty()) {
      imageSnapshotId = make_shared<string>(boost::any_cast<string>(m["ImageSnapshotId"]));
    }
    if (m.find("IngressBandwidth") != m.end() && !m["IngressBandwidth"].empty()) {
      ingressBandwidth = make_shared<long>(boost::any_cast<long>(m["IngressBandwidth"]));
    }
    if (m.find("InitContainers") != m.end() && !m["InitContainers"].empty()) {
      if (typeid(vector<boost::any>) == m["InitContainers"].type()) {
        vector<CreateEciScalingConfigurationRequestInitContainers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InitContainers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEciScalingConfigurationRequestInitContainers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        initContainers = make_shared<vector<CreateEciScalingConfigurationRequestInitContainers>>(expect1);
      }
    }
    if (m.find("InstanceFamilyLevel") != m.end() && !m["InstanceFamilyLevel"].empty()) {
      instanceFamilyLevel = make_shared<string>(boost::any_cast<string>(m["InstanceFamilyLevel"]));
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Ipv6AddressCount") != m.end() && !m["Ipv6AddressCount"].empty()) {
      ipv6AddressCount = make_shared<long>(boost::any_cast<long>(m["Ipv6AddressCount"]));
    }
    if (m.find("LoadBalancerWeight") != m.end() && !m["LoadBalancerWeight"].empty()) {
      loadBalancerWeight = make_shared<long>(boost::any_cast<long>(m["LoadBalancerWeight"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("NtpServers") != m.end() && !m["NtpServers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NtpServers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NtpServers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ntpServers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("RestartPolicy") != m.end() && !m["RestartPolicy"].empty()) {
      restartPolicy = make_shared<string>(boost::any_cast<string>(m["RestartPolicy"]));
    }
    if (m.find("ScalingConfigurationName") != m.end() && !m["ScalingConfigurationName"].empty()) {
      scalingConfigurationName = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationName"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("SecurityContextSysctls") != m.end() && !m["SecurityContextSysctls"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityContextSysctls"].type()) {
        vector<CreateEciScalingConfigurationRequestSecurityContextSysctls> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityContextSysctls"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEciScalingConfigurationRequestSecurityContextSysctls model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityContextSysctls = make_shared<vector<CreateEciScalingConfigurationRequestSecurityContextSysctls>>(expect1);
      }
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SpotPriceLimit") != m.end() && !m["SpotPriceLimit"].empty()) {
      spotPriceLimit = make_shared<double>(boost::any_cast<double>(m["SpotPriceLimit"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<CreateEciScalingConfigurationRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEciScalingConfigurationRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<CreateEciScalingConfigurationRequestTags>>(expect1);
      }
    }
    if (m.find("TerminationGracePeriodSeconds") != m.end() && !m["TerminationGracePeriodSeconds"].empty()) {
      terminationGracePeriodSeconds = make_shared<long>(boost::any_cast<long>(m["TerminationGracePeriodSeconds"]));
    }
    if (m.find("Volumes") != m.end() && !m["Volumes"].empty()) {
      if (typeid(vector<boost::any>) == m["Volumes"].type()) {
        vector<CreateEciScalingConfigurationRequestVolumes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Volumes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEciScalingConfigurationRequestVolumes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        volumes = make_shared<vector<CreateEciScalingConfigurationRequestVolumes>>(expect1);
      }
    }
  }


  virtual ~CreateEciScalingConfigurationRequest() = default;
};
class CreateEciScalingConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> scalingConfigurationId{};

  CreateEciScalingConfigurationResponseBody() {}

  explicit CreateEciScalingConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingConfigurationId) {
      res["ScalingConfigurationId"] = boost::any(*scalingConfigurationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingConfigurationId") != m.end() && !m["ScalingConfigurationId"].empty()) {
      scalingConfigurationId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationId"]));
    }
  }


  virtual ~CreateEciScalingConfigurationResponseBody() = default;
};
class CreateEciScalingConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEciScalingConfigurationResponseBody> body{};

  CreateEciScalingConfigurationResponse() {}

  explicit CreateEciScalingConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEciScalingConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEciScalingConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEciScalingConfigurationResponse() = default;
};
class CreateLifecycleHookRequest : public Darabonba::Model {
public:
  shared_ptr<string> defaultResult{};
  shared_ptr<long> heartbeatTimeout{};
  shared_ptr<string> lifecycleHookName{};
  shared_ptr<string> lifecycleTransition{};
  shared_ptr<string> notificationArn{};
  shared_ptr<string> notificationMetadata{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};

  CreateLifecycleHookRequest() {}

  explicit CreateLifecycleHookRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultResult) {
      res["DefaultResult"] = boost::any(*defaultResult);
    }
    if (heartbeatTimeout) {
      res["HeartbeatTimeout"] = boost::any(*heartbeatTimeout);
    }
    if (lifecycleHookName) {
      res["LifecycleHookName"] = boost::any(*lifecycleHookName);
    }
    if (lifecycleTransition) {
      res["LifecycleTransition"] = boost::any(*lifecycleTransition);
    }
    if (notificationArn) {
      res["NotificationArn"] = boost::any(*notificationArn);
    }
    if (notificationMetadata) {
      res["NotificationMetadata"] = boost::any(*notificationMetadata);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultResult") != m.end() && !m["DefaultResult"].empty()) {
      defaultResult = make_shared<string>(boost::any_cast<string>(m["DefaultResult"]));
    }
    if (m.find("HeartbeatTimeout") != m.end() && !m["HeartbeatTimeout"].empty()) {
      heartbeatTimeout = make_shared<long>(boost::any_cast<long>(m["HeartbeatTimeout"]));
    }
    if (m.find("LifecycleHookName") != m.end() && !m["LifecycleHookName"].empty()) {
      lifecycleHookName = make_shared<string>(boost::any_cast<string>(m["LifecycleHookName"]));
    }
    if (m.find("LifecycleTransition") != m.end() && !m["LifecycleTransition"].empty()) {
      lifecycleTransition = make_shared<string>(boost::any_cast<string>(m["LifecycleTransition"]));
    }
    if (m.find("NotificationArn") != m.end() && !m["NotificationArn"].empty()) {
      notificationArn = make_shared<string>(boost::any_cast<string>(m["NotificationArn"]));
    }
    if (m.find("NotificationMetadata") != m.end() && !m["NotificationMetadata"].empty()) {
      notificationMetadata = make_shared<string>(boost::any_cast<string>(m["NotificationMetadata"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~CreateLifecycleHookRequest() = default;
};
class CreateLifecycleHookResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> lifecycleHookId{};
  shared_ptr<string> requestId{};

  CreateLifecycleHookResponseBody() {}

  explicit CreateLifecycleHookResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lifecycleHookId) {
      res["LifecycleHookId"] = boost::any(*lifecycleHookId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LifecycleHookId") != m.end() && !m["LifecycleHookId"].empty()) {
      lifecycleHookId = make_shared<string>(boost::any_cast<string>(m["LifecycleHookId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLifecycleHookResponseBody() = default;
};
class CreateLifecycleHookResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLifecycleHookResponseBody> body{};

  CreateLifecycleHookResponse() {}

  explicit CreateLifecycleHookResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLifecycleHookResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLifecycleHookResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLifecycleHookResponse() = default;
};
class CreateNotificationConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> notificationArn{};
  shared_ptr<vector<string>> notificationTypes{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> timeZone{};

  CreateNotificationConfigurationRequest() {}

  explicit CreateNotificationConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notificationArn) {
      res["NotificationArn"] = boost::any(*notificationArn);
    }
    if (notificationTypes) {
      res["NotificationTypes"] = boost::any(*notificationTypes);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotificationArn") != m.end() && !m["NotificationArn"].empty()) {
      notificationArn = make_shared<string>(boost::any_cast<string>(m["NotificationArn"]));
    }
    if (m.find("NotificationTypes") != m.end() && !m["NotificationTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NotificationTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NotificationTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      notificationTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~CreateNotificationConfigurationRequest() = default;
};
class CreateNotificationConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateNotificationConfigurationResponseBody() {}

  explicit CreateNotificationConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateNotificationConfigurationResponseBody() = default;
};
class CreateNotificationConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNotificationConfigurationResponseBody> body{};

  CreateNotificationConfigurationResponse() {}

  explicit CreateNotificationConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNotificationConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNotificationConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNotificationConfigurationResponse() = default;
};
class CreateScalingConfigurationRequestImageOptions : public Darabonba::Model {
public:
  shared_ptr<bool> loginAsNonRoot{};

  CreateScalingConfigurationRequestImageOptions() {}

  explicit CreateScalingConfigurationRequestImageOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loginAsNonRoot) {
      res["LoginAsNonRoot"] = boost::any(*loginAsNonRoot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoginAsNonRoot") != m.end() && !m["LoginAsNonRoot"].empty()) {
      loginAsNonRoot = make_shared<bool>(boost::any_cast<bool>(m["LoginAsNonRoot"]));
    }
  }


  virtual ~CreateScalingConfigurationRequestImageOptions() = default;
};
class CreateScalingConfigurationRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> matchCriteria{};

  CreateScalingConfigurationRequestPrivatePoolOptions() {}

  explicit CreateScalingConfigurationRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (matchCriteria) {
      res["MatchCriteria"] = boost::any(*matchCriteria);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MatchCriteria") != m.end() && !m["MatchCriteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["MatchCriteria"]));
    }
  }


  virtual ~CreateScalingConfigurationRequestPrivatePoolOptions() = default;
};
class CreateScalingConfigurationRequestSystemDisk : public Darabonba::Model {
public:
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<bool> burstingEnabled{};
  shared_ptr<string> category{};
  shared_ptr<string> description{};
  shared_ptr<string> diskName{};
  shared_ptr<string> encryptAlgorithm{};
  shared_ptr<bool> encrypted{};
  shared_ptr<string> KMSKeyId{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<long> provisionedIops{};
  shared_ptr<long> size{};

  CreateScalingConfigurationRequestSystemDisk() {}

  explicit CreateScalingConfigurationRequestSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoSnapshotPolicyId) {
      res["AutoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    if (burstingEnabled) {
      res["BurstingEnabled"] = boost::any(*burstingEnabled);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (encryptAlgorithm) {
      res["EncryptAlgorithm"] = boost::any(*encryptAlgorithm);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (provisionedIops) {
      res["ProvisionedIops"] = boost::any(*provisionedIops);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoSnapshotPolicyId") != m.end() && !m["AutoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["AutoSnapshotPolicyId"]));
    }
    if (m.find("BurstingEnabled") != m.end() && !m["BurstingEnabled"].empty()) {
      burstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["BurstingEnabled"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("EncryptAlgorithm") != m.end() && !m["EncryptAlgorithm"].empty()) {
      encryptAlgorithm = make_shared<string>(boost::any_cast<string>(m["EncryptAlgorithm"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<bool>(boost::any_cast<bool>(m["Encrypted"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("ProvisionedIops") != m.end() && !m["ProvisionedIops"].empty()) {
      provisionedIops = make_shared<long>(boost::any_cast<long>(m["ProvisionedIops"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~CreateScalingConfigurationRequestSystemDisk() = default;
};
class CreateScalingConfigurationRequestCustomPriorities : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<string> vswitchId{};

  CreateScalingConfigurationRequestCustomPriorities() {}

  explicit CreateScalingConfigurationRequestCustomPriorities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~CreateScalingConfigurationRequestCustomPriorities() = default;
};
class CreateScalingConfigurationRequestDataDisks : public Darabonba::Model {
public:
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<bool> burstingEnabled{};
  shared_ptr<vector<string>> categories{};
  shared_ptr<string> category{};
  shared_ptr<bool> deleteWithInstance{};
  shared_ptr<string> description{};
  shared_ptr<string> device{};
  shared_ptr<string> diskName{};
  shared_ptr<string> encrypted{};
  shared_ptr<string> KMSKeyId{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<long> provisionedIops{};
  shared_ptr<long> size{};
  shared_ptr<string> snapshotId{};

  CreateScalingConfigurationRequestDataDisks() {}

  explicit CreateScalingConfigurationRequestDataDisks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoSnapshotPolicyId) {
      res["AutoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    if (burstingEnabled) {
      res["BurstingEnabled"] = boost::any(*burstingEnabled);
    }
    if (categories) {
      res["Categories"] = boost::any(*categories);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (provisionedIops) {
      res["ProvisionedIops"] = boost::any(*provisionedIops);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoSnapshotPolicyId") != m.end() && !m["AutoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["AutoSnapshotPolicyId"]));
    }
    if (m.find("BurstingEnabled") != m.end() && !m["BurstingEnabled"].empty()) {
      burstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["BurstingEnabled"]));
    }
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Categories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      categories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<bool>(boost::any_cast<bool>(m["DeleteWithInstance"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<string>(boost::any_cast<string>(m["Encrypted"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("ProvisionedIops") != m.end() && !m["ProvisionedIops"].empty()) {
      provisionedIops = make_shared<long>(boost::any_cast<long>(m["ProvisionedIops"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
  }


  virtual ~CreateScalingConfigurationRequestDataDisks() = default;
};
class CreateScalingConfigurationRequestInstancePatternInfos : public Darabonba::Model {
public:
  shared_ptr<vector<string>> architectures{};
  shared_ptr<string> burstablePerformance{};
  shared_ptr<long> cores{};
  shared_ptr<vector<string>> cpuArchitectures{};
  shared_ptr<vector<string>> excludedInstanceTypes{};
  shared_ptr<vector<string>> gpuSpecs{};
  shared_ptr<vector<string>> instanceCategories{};
  shared_ptr<string> instanceFamilyLevel{};
  shared_ptr<vector<string>> instanceTypeFamilies{};
  shared_ptr<double> maxPrice{};
  shared_ptr<long> maximumCpuCoreCount{};
  shared_ptr<long> maximumGpuAmount{};
  shared_ptr<double> maximumMemorySize{};
  shared_ptr<double> memory{};
  shared_ptr<long> minimumBaselineCredit{};
  shared_ptr<long> minimumCpuCoreCount{};
  shared_ptr<long> minimumEniIpv6AddressQuantity{};
  shared_ptr<long> minimumEniPrivateIpAddressQuantity{};
  shared_ptr<long> minimumEniQuantity{};
  shared_ptr<long> minimumGpuAmount{};
  shared_ptr<long> minimumInitialCredit{};
  shared_ptr<double> minimumMemorySize{};
  shared_ptr<vector<string>> physicalProcessorModels{};

  CreateScalingConfigurationRequestInstancePatternInfos() {}

  explicit CreateScalingConfigurationRequestInstancePatternInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architectures) {
      res["Architectures"] = boost::any(*architectures);
    }
    if (burstablePerformance) {
      res["BurstablePerformance"] = boost::any(*burstablePerformance);
    }
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (cpuArchitectures) {
      res["CpuArchitectures"] = boost::any(*cpuArchitectures);
    }
    if (excludedInstanceTypes) {
      res["ExcludedInstanceTypes"] = boost::any(*excludedInstanceTypes);
    }
    if (gpuSpecs) {
      res["GpuSpecs"] = boost::any(*gpuSpecs);
    }
    if (instanceCategories) {
      res["InstanceCategories"] = boost::any(*instanceCategories);
    }
    if (instanceFamilyLevel) {
      res["InstanceFamilyLevel"] = boost::any(*instanceFamilyLevel);
    }
    if (instanceTypeFamilies) {
      res["InstanceTypeFamilies"] = boost::any(*instanceTypeFamilies);
    }
    if (maxPrice) {
      res["MaxPrice"] = boost::any(*maxPrice);
    }
    if (maximumCpuCoreCount) {
      res["MaximumCpuCoreCount"] = boost::any(*maximumCpuCoreCount);
    }
    if (maximumGpuAmount) {
      res["MaximumGpuAmount"] = boost::any(*maximumGpuAmount);
    }
    if (maximumMemorySize) {
      res["MaximumMemorySize"] = boost::any(*maximumMemorySize);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (minimumBaselineCredit) {
      res["MinimumBaselineCredit"] = boost::any(*minimumBaselineCredit);
    }
    if (minimumCpuCoreCount) {
      res["MinimumCpuCoreCount"] = boost::any(*minimumCpuCoreCount);
    }
    if (minimumEniIpv6AddressQuantity) {
      res["MinimumEniIpv6AddressQuantity"] = boost::any(*minimumEniIpv6AddressQuantity);
    }
    if (minimumEniPrivateIpAddressQuantity) {
      res["MinimumEniPrivateIpAddressQuantity"] = boost::any(*minimumEniPrivateIpAddressQuantity);
    }
    if (minimumEniQuantity) {
      res["MinimumEniQuantity"] = boost::any(*minimumEniQuantity);
    }
    if (minimumGpuAmount) {
      res["MinimumGpuAmount"] = boost::any(*minimumGpuAmount);
    }
    if (minimumInitialCredit) {
      res["MinimumInitialCredit"] = boost::any(*minimumInitialCredit);
    }
    if (minimumMemorySize) {
      res["MinimumMemorySize"] = boost::any(*minimumMemorySize);
    }
    if (physicalProcessorModels) {
      res["PhysicalProcessorModels"] = boost::any(*physicalProcessorModels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Architectures") != m.end() && !m["Architectures"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Architectures"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Architectures"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      architectures = make_shared<vector<string>>(toVec1);
    }
    if (m.find("BurstablePerformance") != m.end() && !m["BurstablePerformance"].empty()) {
      burstablePerformance = make_shared<string>(boost::any_cast<string>(m["BurstablePerformance"]));
    }
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("CpuArchitectures") != m.end() && !m["CpuArchitectures"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CpuArchitectures"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CpuArchitectures"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cpuArchitectures = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExcludedInstanceTypes") != m.end() && !m["ExcludedInstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludedInstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludedInstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludedInstanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GpuSpecs") != m.end() && !m["GpuSpecs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GpuSpecs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GpuSpecs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      gpuSpecs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceCategories") != m.end() && !m["InstanceCategories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceCategories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceCategories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceCategories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceFamilyLevel") != m.end() && !m["InstanceFamilyLevel"].empty()) {
      instanceFamilyLevel = make_shared<string>(boost::any_cast<string>(m["InstanceFamilyLevel"]));
    }
    if (m.find("InstanceTypeFamilies") != m.end() && !m["InstanceTypeFamilies"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypeFamilies"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypeFamilies"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypeFamilies = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxPrice") != m.end() && !m["MaxPrice"].empty()) {
      maxPrice = make_shared<double>(boost::any_cast<double>(m["MaxPrice"]));
    }
    if (m.find("MaximumCpuCoreCount") != m.end() && !m["MaximumCpuCoreCount"].empty()) {
      maximumCpuCoreCount = make_shared<long>(boost::any_cast<long>(m["MaximumCpuCoreCount"]));
    }
    if (m.find("MaximumGpuAmount") != m.end() && !m["MaximumGpuAmount"].empty()) {
      maximumGpuAmount = make_shared<long>(boost::any_cast<long>(m["MaximumGpuAmount"]));
    }
    if (m.find("MaximumMemorySize") != m.end() && !m["MaximumMemorySize"].empty()) {
      maximumMemorySize = make_shared<double>(boost::any_cast<double>(m["MaximumMemorySize"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("MinimumBaselineCredit") != m.end() && !m["MinimumBaselineCredit"].empty()) {
      minimumBaselineCredit = make_shared<long>(boost::any_cast<long>(m["MinimumBaselineCredit"]));
    }
    if (m.find("MinimumCpuCoreCount") != m.end() && !m["MinimumCpuCoreCount"].empty()) {
      minimumCpuCoreCount = make_shared<long>(boost::any_cast<long>(m["MinimumCpuCoreCount"]));
    }
    if (m.find("MinimumEniIpv6AddressQuantity") != m.end() && !m["MinimumEniIpv6AddressQuantity"].empty()) {
      minimumEniIpv6AddressQuantity = make_shared<long>(boost::any_cast<long>(m["MinimumEniIpv6AddressQuantity"]));
    }
    if (m.find("MinimumEniPrivateIpAddressQuantity") != m.end() && !m["MinimumEniPrivateIpAddressQuantity"].empty()) {
      minimumEniPrivateIpAddressQuantity = make_shared<long>(boost::any_cast<long>(m["MinimumEniPrivateIpAddressQuantity"]));
    }
    if (m.find("MinimumEniQuantity") != m.end() && !m["MinimumEniQuantity"].empty()) {
      minimumEniQuantity = make_shared<long>(boost::any_cast<long>(m["MinimumEniQuantity"]));
    }
    if (m.find("MinimumGpuAmount") != m.end() && !m["MinimumGpuAmount"].empty()) {
      minimumGpuAmount = make_shared<long>(boost::any_cast<long>(m["MinimumGpuAmount"]));
    }
    if (m.find("MinimumInitialCredit") != m.end() && !m["MinimumInitialCredit"].empty()) {
      minimumInitialCredit = make_shared<long>(boost::any_cast<long>(m["MinimumInitialCredit"]));
    }
    if (m.find("MinimumMemorySize") != m.end() && !m["MinimumMemorySize"].empty()) {
      minimumMemorySize = make_shared<double>(boost::any_cast<double>(m["MinimumMemorySize"]));
    }
    if (m.find("PhysicalProcessorModels") != m.end() && !m["PhysicalProcessorModels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PhysicalProcessorModels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PhysicalProcessorModels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      physicalProcessorModels = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateScalingConfigurationRequestInstancePatternInfos() = default;
};
class CreateScalingConfigurationRequestInstanceTypeOverrides : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<long> weightedCapacity{};

  CreateScalingConfigurationRequestInstanceTypeOverrides() {}

  explicit CreateScalingConfigurationRequestInstanceTypeOverrides(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (weightedCapacity) {
      res["WeightedCapacity"] = boost::any(*weightedCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("WeightedCapacity") != m.end() && !m["WeightedCapacity"].empty()) {
      weightedCapacity = make_shared<long>(boost::any_cast<long>(m["WeightedCapacity"]));
    }
  }


  virtual ~CreateScalingConfigurationRequestInstanceTypeOverrides() = default;
};
class CreateScalingConfigurationRequestNetworkInterfaces : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<long> ipv6AddressCount{};
  shared_ptr<string> networkInterfaceTrafficMode{};
  shared_ptr<vector<string>> securityGroupIds{};

  CreateScalingConfigurationRequestNetworkInterfaces() {}

  explicit CreateScalingConfigurationRequestNetworkInterfaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ipv6AddressCount) {
      res["Ipv6AddressCount"] = boost::any(*ipv6AddressCount);
    }
    if (networkInterfaceTrafficMode) {
      res["NetworkInterfaceTrafficMode"] = boost::any(*networkInterfaceTrafficMode);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ipv6AddressCount") != m.end() && !m["Ipv6AddressCount"].empty()) {
      ipv6AddressCount = make_shared<long>(boost::any_cast<long>(m["Ipv6AddressCount"]));
    }
    if (m.find("NetworkInterfaceTrafficMode") != m.end() && !m["NetworkInterfaceTrafficMode"].empty()) {
      networkInterfaceTrafficMode = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceTrafficMode"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateScalingConfigurationRequestNetworkInterfaces() = default;
};
class CreateScalingConfigurationRequestSecurityOptions : public Darabonba::Model {
public:
  shared_ptr<string> confidentialComputingMode{};

  CreateScalingConfigurationRequestSecurityOptions() {}

  explicit CreateScalingConfigurationRequestSecurityOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (confidentialComputingMode) {
      res["ConfidentialComputingMode"] = boost::any(*confidentialComputingMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfidentialComputingMode") != m.end() && !m["ConfidentialComputingMode"].empty()) {
      confidentialComputingMode = make_shared<string>(boost::any_cast<string>(m["ConfidentialComputingMode"]));
    }
  }


  virtual ~CreateScalingConfigurationRequestSecurityOptions() = default;
};
class CreateScalingConfigurationRequestSpotPriceLimits : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<double> priceLimit{};

  CreateScalingConfigurationRequestSpotPriceLimits() {}

  explicit CreateScalingConfigurationRequestSpotPriceLimits(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (priceLimit) {
      res["PriceLimit"] = boost::any(*priceLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("PriceLimit") != m.end() && !m["PriceLimit"].empty()) {
      priceLimit = make_shared<double>(boost::any_cast<double>(m["PriceLimit"]));
    }
  }


  virtual ~CreateScalingConfigurationRequestSpotPriceLimits() = default;
};
class CreateScalingConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<CreateScalingConfigurationRequestImageOptions> imageOptions{};
  shared_ptr<CreateScalingConfigurationRequestPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<CreateScalingConfigurationRequestSystemDisk> systemDisk{};
  shared_ptr<string> affinity{};
  shared_ptr<string> clientToken{};
  shared_ptr<long> cpu{};
  shared_ptr<string> creditSpecification{};
  shared_ptr<vector<CreateScalingConfigurationRequestCustomPriorities>> customPriorities{};
  shared_ptr<vector<CreateScalingConfigurationRequestDataDisks>> dataDisks{};
  shared_ptr<string> dedicatedHostClusterId{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<bool> deletionProtection{};
  shared_ptr<string> deploymentSetId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> hpcClusterId{};
  shared_ptr<string> httpEndpoint{};
  shared_ptr<string> httpTokens{};
  shared_ptr<string> imageFamily{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<string> instanceDescription{};
  shared_ptr<string> instanceName{};
  shared_ptr<vector<CreateScalingConfigurationRequestInstancePatternInfos>> instancePatternInfos{};
  shared_ptr<string> instanceType{};
  shared_ptr<vector<CreateScalingConfigurationRequestInstanceTypeOverrides>> instanceTypeOverrides{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidthIn{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> ioOptimized{};
  shared_ptr<long> ipv6AddressCount{};
  shared_ptr<string> keyPairName{};
  shared_ptr<long> loadBalancerWeight{};
  shared_ptr<long> memory{};
  shared_ptr<vector<CreateScalingConfigurationRequestNetworkInterfaces>> networkInterfaces{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> password{};
  shared_ptr<bool> passwordInherit{};
  shared_ptr<string> ramRoleName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingConfigurationName{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<map<string, boost::any>> schedulerOptions{};
  shared_ptr<string> securityEnhancementStrategy{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<CreateScalingConfigurationRequestSecurityOptions> securityOptions{};
  shared_ptr<long> spotDuration{};
  shared_ptr<string> spotInterruptionBehavior{};
  shared_ptr<vector<CreateScalingConfigurationRequestSpotPriceLimits>> spotPriceLimits{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<string> storageSetId{};
  shared_ptr<long> storageSetPartitionNumber{};
  shared_ptr<vector<string>> systemDiskCategories{};
  shared_ptr<string> tags{};
  shared_ptr<string> tenancy{};
  shared_ptr<string> userData{};
  shared_ptr<string> zoneId{};

  CreateScalingConfigurationRequest() {}

  explicit CreateScalingConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageOptions) {
      res["ImageOptions"] = imageOptions ? boost::any(imageOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (privatePoolOptions) {
      res["PrivatePoolOptions"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (affinity) {
      res["Affinity"] = boost::any(*affinity);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (creditSpecification) {
      res["CreditSpecification"] = boost::any(*creditSpecification);
    }
    if (customPriorities) {
      vector<boost::any> temp1;
      for(auto item1:*customPriorities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomPriorities"] = boost::any(temp1);
    }
    if (dataDisks) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisks"] = boost::any(temp1);
    }
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (deletionProtection) {
      res["DeletionProtection"] = boost::any(*deletionProtection);
    }
    if (deploymentSetId) {
      res["DeploymentSetId"] = boost::any(*deploymentSetId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (hpcClusterId) {
      res["HpcClusterId"] = boost::any(*hpcClusterId);
    }
    if (httpEndpoint) {
      res["HttpEndpoint"] = boost::any(*httpEndpoint);
    }
    if (httpTokens) {
      res["HttpTokens"] = boost::any(*httpTokens);
    }
    if (imageFamily) {
      res["ImageFamily"] = boost::any(*imageFamily);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (instanceDescription) {
      res["InstanceDescription"] = boost::any(*instanceDescription);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instancePatternInfos) {
      vector<boost::any> temp1;
      for(auto item1:*instancePatternInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstancePatternInfos"] = boost::any(temp1);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (instanceTypeOverrides) {
      vector<boost::any> temp1;
      for(auto item1:*instanceTypeOverrides){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceTypeOverrides"] = boost::any(temp1);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = boost::any(*instanceTypes);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidthIn) {
      res["InternetMaxBandwidthIn"] = boost::any(*internetMaxBandwidthIn);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (ipv6AddressCount) {
      res["Ipv6AddressCount"] = boost::any(*ipv6AddressCount);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (loadBalancerWeight) {
      res["LoadBalancerWeight"] = boost::any(*loadBalancerWeight);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (networkInterfaces) {
      vector<boost::any> temp1;
      for(auto item1:*networkInterfaces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkInterfaces"] = boost::any(temp1);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (passwordInherit) {
      res["PasswordInherit"] = boost::any(*passwordInherit);
    }
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingConfigurationName) {
      res["ScalingConfigurationName"] = boost::any(*scalingConfigurationName);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (schedulerOptions) {
      res["SchedulerOptions"] = boost::any(*schedulerOptions);
    }
    if (securityEnhancementStrategy) {
      res["SecurityEnhancementStrategy"] = boost::any(*securityEnhancementStrategy);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    if (securityOptions) {
      res["SecurityOptions"] = securityOptions ? boost::any(securityOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spotDuration) {
      res["SpotDuration"] = boost::any(*spotDuration);
    }
    if (spotInterruptionBehavior) {
      res["SpotInterruptionBehavior"] = boost::any(*spotInterruptionBehavior);
    }
    if (spotPriceLimits) {
      vector<boost::any> temp1;
      for(auto item1:*spotPriceLimits){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpotPriceLimits"] = boost::any(temp1);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    if (storageSetPartitionNumber) {
      res["StorageSetPartitionNumber"] = boost::any(*storageSetPartitionNumber);
    }
    if (systemDiskCategories) {
      res["SystemDiskCategories"] = boost::any(*systemDiskCategories);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (tenancy) {
      res["Tenancy"] = boost::any(*tenancy);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageOptions") != m.end() && !m["ImageOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageOptions"].type()) {
        CreateScalingConfigurationRequestImageOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageOptions"]));
        imageOptions = make_shared<CreateScalingConfigurationRequestImageOptions>(model1);
      }
    }
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolOptions"].type()) {
        CreateScalingConfigurationRequestPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolOptions"]));
        privatePoolOptions = make_shared<CreateScalingConfigurationRequestPrivatePoolOptions>(model1);
      }
    }
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        CreateScalingConfigurationRequestSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<CreateScalingConfigurationRequestSystemDisk>(model1);
      }
    }
    if (m.find("Affinity") != m.end() && !m["Affinity"].empty()) {
      affinity = make_shared<string>(boost::any_cast<string>(m["Affinity"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CreditSpecification") != m.end() && !m["CreditSpecification"].empty()) {
      creditSpecification = make_shared<string>(boost::any_cast<string>(m["CreditSpecification"]));
    }
    if (m.find("CustomPriorities") != m.end() && !m["CustomPriorities"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomPriorities"].type()) {
        vector<CreateScalingConfigurationRequestCustomPriorities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomPriorities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingConfigurationRequestCustomPriorities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customPriorities = make_shared<vector<CreateScalingConfigurationRequestCustomPriorities>>(expect1);
      }
    }
    if (m.find("DataDisks") != m.end() && !m["DataDisks"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisks"].type()) {
        vector<CreateScalingConfigurationRequestDataDisks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingConfigurationRequestDataDisks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisks = make_shared<vector<CreateScalingConfigurationRequestDataDisks>>(expect1);
      }
    }
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("DeletionProtection") != m.end() && !m["DeletionProtection"].empty()) {
      deletionProtection = make_shared<bool>(boost::any_cast<bool>(m["DeletionProtection"]));
    }
    if (m.find("DeploymentSetId") != m.end() && !m["DeploymentSetId"].empty()) {
      deploymentSetId = make_shared<string>(boost::any_cast<string>(m["DeploymentSetId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("HpcClusterId") != m.end() && !m["HpcClusterId"].empty()) {
      hpcClusterId = make_shared<string>(boost::any_cast<string>(m["HpcClusterId"]));
    }
    if (m.find("HttpEndpoint") != m.end() && !m["HttpEndpoint"].empty()) {
      httpEndpoint = make_shared<string>(boost::any_cast<string>(m["HttpEndpoint"]));
    }
    if (m.find("HttpTokens") != m.end() && !m["HttpTokens"].empty()) {
      httpTokens = make_shared<string>(boost::any_cast<string>(m["HttpTokens"]));
    }
    if (m.find("ImageFamily") != m.end() && !m["ImageFamily"].empty()) {
      imageFamily = make_shared<string>(boost::any_cast<string>(m["ImageFamily"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("InstanceDescription") != m.end() && !m["InstanceDescription"].empty()) {
      instanceDescription = make_shared<string>(boost::any_cast<string>(m["InstanceDescription"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstancePatternInfos") != m.end() && !m["InstancePatternInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["InstancePatternInfos"].type()) {
        vector<CreateScalingConfigurationRequestInstancePatternInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstancePatternInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingConfigurationRequestInstancePatternInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instancePatternInfos = make_shared<vector<CreateScalingConfigurationRequestInstancePatternInfos>>(expect1);
      }
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InstanceTypeOverrides") != m.end() && !m["InstanceTypeOverrides"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceTypeOverrides"].type()) {
        vector<CreateScalingConfigurationRequestInstanceTypeOverrides> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceTypeOverrides"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingConfigurationRequestInstanceTypeOverrides model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceTypeOverrides = make_shared<vector<CreateScalingConfigurationRequestInstanceTypeOverrides>>(expect1);
      }
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("InternetMaxBandwidthIn") != m.end() && !m["InternetMaxBandwidthIn"].empty()) {
      internetMaxBandwidthIn = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthIn"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("Ipv6AddressCount") != m.end() && !m["Ipv6AddressCount"].empty()) {
      ipv6AddressCount = make_shared<long>(boost::any_cast<long>(m["Ipv6AddressCount"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("LoadBalancerWeight") != m.end() && !m["LoadBalancerWeight"].empty()) {
      loadBalancerWeight = make_shared<long>(boost::any_cast<long>(m["LoadBalancerWeight"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("NetworkInterfaces") != m.end() && !m["NetworkInterfaces"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkInterfaces"].type()) {
        vector<CreateScalingConfigurationRequestNetworkInterfaces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkInterfaces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingConfigurationRequestNetworkInterfaces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkInterfaces = make_shared<vector<CreateScalingConfigurationRequestNetworkInterfaces>>(expect1);
      }
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("PasswordInherit") != m.end() && !m["PasswordInherit"].empty()) {
      passwordInherit = make_shared<bool>(boost::any_cast<bool>(m["PasswordInherit"]));
    }
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingConfigurationName") != m.end() && !m["ScalingConfigurationName"].empty()) {
      scalingConfigurationName = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationName"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("SchedulerOptions") != m.end() && !m["SchedulerOptions"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SchedulerOptions"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      schedulerOptions = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("SecurityEnhancementStrategy") != m.end() && !m["SecurityEnhancementStrategy"].empty()) {
      securityEnhancementStrategy = make_shared<string>(boost::any_cast<string>(m["SecurityEnhancementStrategy"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SecurityOptions") != m.end() && !m["SecurityOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityOptions"].type()) {
        CreateScalingConfigurationRequestSecurityOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityOptions"]));
        securityOptions = make_shared<CreateScalingConfigurationRequestSecurityOptions>(model1);
      }
    }
    if (m.find("SpotDuration") != m.end() && !m["SpotDuration"].empty()) {
      spotDuration = make_shared<long>(boost::any_cast<long>(m["SpotDuration"]));
    }
    if (m.find("SpotInterruptionBehavior") != m.end() && !m["SpotInterruptionBehavior"].empty()) {
      spotInterruptionBehavior = make_shared<string>(boost::any_cast<string>(m["SpotInterruptionBehavior"]));
    }
    if (m.find("SpotPriceLimits") != m.end() && !m["SpotPriceLimits"].empty()) {
      if (typeid(vector<boost::any>) == m["SpotPriceLimits"].type()) {
        vector<CreateScalingConfigurationRequestSpotPriceLimits> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpotPriceLimits"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingConfigurationRequestSpotPriceLimits model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spotPriceLimits = make_shared<vector<CreateScalingConfigurationRequestSpotPriceLimits>>(expect1);
      }
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
    if (m.find("StorageSetPartitionNumber") != m.end() && !m["StorageSetPartitionNumber"].empty()) {
      storageSetPartitionNumber = make_shared<long>(boost::any_cast<long>(m["StorageSetPartitionNumber"]));
    }
    if (m.find("SystemDiskCategories") != m.end() && !m["SystemDiskCategories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SystemDiskCategories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SystemDiskCategories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      systemDiskCategories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Tenancy") != m.end() && !m["Tenancy"].empty()) {
      tenancy = make_shared<string>(boost::any_cast<string>(m["Tenancy"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateScalingConfigurationRequest() = default;
};
class CreateScalingConfigurationShrinkRequestImageOptions : public Darabonba::Model {
public:
  shared_ptr<bool> loginAsNonRoot{};

  CreateScalingConfigurationShrinkRequestImageOptions() {}

  explicit CreateScalingConfigurationShrinkRequestImageOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loginAsNonRoot) {
      res["LoginAsNonRoot"] = boost::any(*loginAsNonRoot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoginAsNonRoot") != m.end() && !m["LoginAsNonRoot"].empty()) {
      loginAsNonRoot = make_shared<bool>(boost::any_cast<bool>(m["LoginAsNonRoot"]));
    }
  }


  virtual ~CreateScalingConfigurationShrinkRequestImageOptions() = default;
};
class CreateScalingConfigurationShrinkRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> matchCriteria{};

  CreateScalingConfigurationShrinkRequestPrivatePoolOptions() {}

  explicit CreateScalingConfigurationShrinkRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (matchCriteria) {
      res["MatchCriteria"] = boost::any(*matchCriteria);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MatchCriteria") != m.end() && !m["MatchCriteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["MatchCriteria"]));
    }
  }


  virtual ~CreateScalingConfigurationShrinkRequestPrivatePoolOptions() = default;
};
class CreateScalingConfigurationShrinkRequestSystemDisk : public Darabonba::Model {
public:
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<bool> burstingEnabled{};
  shared_ptr<string> category{};
  shared_ptr<string> description{};
  shared_ptr<string> diskName{};
  shared_ptr<string> encryptAlgorithm{};
  shared_ptr<bool> encrypted{};
  shared_ptr<string> KMSKeyId{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<long> provisionedIops{};
  shared_ptr<long> size{};

  CreateScalingConfigurationShrinkRequestSystemDisk() {}

  explicit CreateScalingConfigurationShrinkRequestSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoSnapshotPolicyId) {
      res["AutoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    if (burstingEnabled) {
      res["BurstingEnabled"] = boost::any(*burstingEnabled);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (encryptAlgorithm) {
      res["EncryptAlgorithm"] = boost::any(*encryptAlgorithm);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (provisionedIops) {
      res["ProvisionedIops"] = boost::any(*provisionedIops);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoSnapshotPolicyId") != m.end() && !m["AutoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["AutoSnapshotPolicyId"]));
    }
    if (m.find("BurstingEnabled") != m.end() && !m["BurstingEnabled"].empty()) {
      burstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["BurstingEnabled"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("EncryptAlgorithm") != m.end() && !m["EncryptAlgorithm"].empty()) {
      encryptAlgorithm = make_shared<string>(boost::any_cast<string>(m["EncryptAlgorithm"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<bool>(boost::any_cast<bool>(m["Encrypted"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("ProvisionedIops") != m.end() && !m["ProvisionedIops"].empty()) {
      provisionedIops = make_shared<long>(boost::any_cast<long>(m["ProvisionedIops"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~CreateScalingConfigurationShrinkRequestSystemDisk() = default;
};
class CreateScalingConfigurationShrinkRequestCustomPriorities : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<string> vswitchId{};

  CreateScalingConfigurationShrinkRequestCustomPriorities() {}

  explicit CreateScalingConfigurationShrinkRequestCustomPriorities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~CreateScalingConfigurationShrinkRequestCustomPriorities() = default;
};
class CreateScalingConfigurationShrinkRequestDataDisks : public Darabonba::Model {
public:
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<bool> burstingEnabled{};
  shared_ptr<vector<string>> categories{};
  shared_ptr<string> category{};
  shared_ptr<bool> deleteWithInstance{};
  shared_ptr<string> description{};
  shared_ptr<string> device{};
  shared_ptr<string> diskName{};
  shared_ptr<string> encrypted{};
  shared_ptr<string> KMSKeyId{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<long> provisionedIops{};
  shared_ptr<long> size{};
  shared_ptr<string> snapshotId{};

  CreateScalingConfigurationShrinkRequestDataDisks() {}

  explicit CreateScalingConfigurationShrinkRequestDataDisks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoSnapshotPolicyId) {
      res["AutoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    if (burstingEnabled) {
      res["BurstingEnabled"] = boost::any(*burstingEnabled);
    }
    if (categories) {
      res["Categories"] = boost::any(*categories);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (provisionedIops) {
      res["ProvisionedIops"] = boost::any(*provisionedIops);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoSnapshotPolicyId") != m.end() && !m["AutoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["AutoSnapshotPolicyId"]));
    }
    if (m.find("BurstingEnabled") != m.end() && !m["BurstingEnabled"].empty()) {
      burstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["BurstingEnabled"]));
    }
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Categories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      categories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<bool>(boost::any_cast<bool>(m["DeleteWithInstance"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<string>(boost::any_cast<string>(m["Encrypted"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("ProvisionedIops") != m.end() && !m["ProvisionedIops"].empty()) {
      provisionedIops = make_shared<long>(boost::any_cast<long>(m["ProvisionedIops"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
  }


  virtual ~CreateScalingConfigurationShrinkRequestDataDisks() = default;
};
class CreateScalingConfigurationShrinkRequestInstancePatternInfos : public Darabonba::Model {
public:
  shared_ptr<vector<string>> architectures{};
  shared_ptr<string> burstablePerformance{};
  shared_ptr<long> cores{};
  shared_ptr<vector<string>> cpuArchitectures{};
  shared_ptr<vector<string>> excludedInstanceTypes{};
  shared_ptr<vector<string>> gpuSpecs{};
  shared_ptr<vector<string>> instanceCategories{};
  shared_ptr<string> instanceFamilyLevel{};
  shared_ptr<vector<string>> instanceTypeFamilies{};
  shared_ptr<double> maxPrice{};
  shared_ptr<long> maximumCpuCoreCount{};
  shared_ptr<long> maximumGpuAmount{};
  shared_ptr<double> maximumMemorySize{};
  shared_ptr<double> memory{};
  shared_ptr<long> minimumBaselineCredit{};
  shared_ptr<long> minimumCpuCoreCount{};
  shared_ptr<long> minimumEniIpv6AddressQuantity{};
  shared_ptr<long> minimumEniPrivateIpAddressQuantity{};
  shared_ptr<long> minimumEniQuantity{};
  shared_ptr<long> minimumGpuAmount{};
  shared_ptr<long> minimumInitialCredit{};
  shared_ptr<double> minimumMemorySize{};
  shared_ptr<vector<string>> physicalProcessorModels{};

  CreateScalingConfigurationShrinkRequestInstancePatternInfos() {}

  explicit CreateScalingConfigurationShrinkRequestInstancePatternInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architectures) {
      res["Architectures"] = boost::any(*architectures);
    }
    if (burstablePerformance) {
      res["BurstablePerformance"] = boost::any(*burstablePerformance);
    }
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (cpuArchitectures) {
      res["CpuArchitectures"] = boost::any(*cpuArchitectures);
    }
    if (excludedInstanceTypes) {
      res["ExcludedInstanceTypes"] = boost::any(*excludedInstanceTypes);
    }
    if (gpuSpecs) {
      res["GpuSpecs"] = boost::any(*gpuSpecs);
    }
    if (instanceCategories) {
      res["InstanceCategories"] = boost::any(*instanceCategories);
    }
    if (instanceFamilyLevel) {
      res["InstanceFamilyLevel"] = boost::any(*instanceFamilyLevel);
    }
    if (instanceTypeFamilies) {
      res["InstanceTypeFamilies"] = boost::any(*instanceTypeFamilies);
    }
    if (maxPrice) {
      res["MaxPrice"] = boost::any(*maxPrice);
    }
    if (maximumCpuCoreCount) {
      res["MaximumCpuCoreCount"] = boost::any(*maximumCpuCoreCount);
    }
    if (maximumGpuAmount) {
      res["MaximumGpuAmount"] = boost::any(*maximumGpuAmount);
    }
    if (maximumMemorySize) {
      res["MaximumMemorySize"] = boost::any(*maximumMemorySize);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (minimumBaselineCredit) {
      res["MinimumBaselineCredit"] = boost::any(*minimumBaselineCredit);
    }
    if (minimumCpuCoreCount) {
      res["MinimumCpuCoreCount"] = boost::any(*minimumCpuCoreCount);
    }
    if (minimumEniIpv6AddressQuantity) {
      res["MinimumEniIpv6AddressQuantity"] = boost::any(*minimumEniIpv6AddressQuantity);
    }
    if (minimumEniPrivateIpAddressQuantity) {
      res["MinimumEniPrivateIpAddressQuantity"] = boost::any(*minimumEniPrivateIpAddressQuantity);
    }
    if (minimumEniQuantity) {
      res["MinimumEniQuantity"] = boost::any(*minimumEniQuantity);
    }
    if (minimumGpuAmount) {
      res["MinimumGpuAmount"] = boost::any(*minimumGpuAmount);
    }
    if (minimumInitialCredit) {
      res["MinimumInitialCredit"] = boost::any(*minimumInitialCredit);
    }
    if (minimumMemorySize) {
      res["MinimumMemorySize"] = boost::any(*minimumMemorySize);
    }
    if (physicalProcessorModels) {
      res["PhysicalProcessorModels"] = boost::any(*physicalProcessorModels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Architectures") != m.end() && !m["Architectures"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Architectures"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Architectures"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      architectures = make_shared<vector<string>>(toVec1);
    }
    if (m.find("BurstablePerformance") != m.end() && !m["BurstablePerformance"].empty()) {
      burstablePerformance = make_shared<string>(boost::any_cast<string>(m["BurstablePerformance"]));
    }
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("CpuArchitectures") != m.end() && !m["CpuArchitectures"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CpuArchitectures"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CpuArchitectures"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cpuArchitectures = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExcludedInstanceTypes") != m.end() && !m["ExcludedInstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludedInstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludedInstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludedInstanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GpuSpecs") != m.end() && !m["GpuSpecs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GpuSpecs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GpuSpecs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      gpuSpecs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceCategories") != m.end() && !m["InstanceCategories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceCategories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceCategories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceCategories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceFamilyLevel") != m.end() && !m["InstanceFamilyLevel"].empty()) {
      instanceFamilyLevel = make_shared<string>(boost::any_cast<string>(m["InstanceFamilyLevel"]));
    }
    if (m.find("InstanceTypeFamilies") != m.end() && !m["InstanceTypeFamilies"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypeFamilies"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypeFamilies"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypeFamilies = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxPrice") != m.end() && !m["MaxPrice"].empty()) {
      maxPrice = make_shared<double>(boost::any_cast<double>(m["MaxPrice"]));
    }
    if (m.find("MaximumCpuCoreCount") != m.end() && !m["MaximumCpuCoreCount"].empty()) {
      maximumCpuCoreCount = make_shared<long>(boost::any_cast<long>(m["MaximumCpuCoreCount"]));
    }
    if (m.find("MaximumGpuAmount") != m.end() && !m["MaximumGpuAmount"].empty()) {
      maximumGpuAmount = make_shared<long>(boost::any_cast<long>(m["MaximumGpuAmount"]));
    }
    if (m.find("MaximumMemorySize") != m.end() && !m["MaximumMemorySize"].empty()) {
      maximumMemorySize = make_shared<double>(boost::any_cast<double>(m["MaximumMemorySize"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("MinimumBaselineCredit") != m.end() && !m["MinimumBaselineCredit"].empty()) {
      minimumBaselineCredit = make_shared<long>(boost::any_cast<long>(m["MinimumBaselineCredit"]));
    }
    if (m.find("MinimumCpuCoreCount") != m.end() && !m["MinimumCpuCoreCount"].empty()) {
      minimumCpuCoreCount = make_shared<long>(boost::any_cast<long>(m["MinimumCpuCoreCount"]));
    }
    if (m.find("MinimumEniIpv6AddressQuantity") != m.end() && !m["MinimumEniIpv6AddressQuantity"].empty()) {
      minimumEniIpv6AddressQuantity = make_shared<long>(boost::any_cast<long>(m["MinimumEniIpv6AddressQuantity"]));
    }
    if (m.find("MinimumEniPrivateIpAddressQuantity") != m.end() && !m["MinimumEniPrivateIpAddressQuantity"].empty()) {
      minimumEniPrivateIpAddressQuantity = make_shared<long>(boost::any_cast<long>(m["MinimumEniPrivateIpAddressQuantity"]));
    }
    if (m.find("MinimumEniQuantity") != m.end() && !m["MinimumEniQuantity"].empty()) {
      minimumEniQuantity = make_shared<long>(boost::any_cast<long>(m["MinimumEniQuantity"]));
    }
    if (m.find("MinimumGpuAmount") != m.end() && !m["MinimumGpuAmount"].empty()) {
      minimumGpuAmount = make_shared<long>(boost::any_cast<long>(m["MinimumGpuAmount"]));
    }
    if (m.find("MinimumInitialCredit") != m.end() && !m["MinimumInitialCredit"].empty()) {
      minimumInitialCredit = make_shared<long>(boost::any_cast<long>(m["MinimumInitialCredit"]));
    }
    if (m.find("MinimumMemorySize") != m.end() && !m["MinimumMemorySize"].empty()) {
      minimumMemorySize = make_shared<double>(boost::any_cast<double>(m["MinimumMemorySize"]));
    }
    if (m.find("PhysicalProcessorModels") != m.end() && !m["PhysicalProcessorModels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PhysicalProcessorModels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PhysicalProcessorModels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      physicalProcessorModels = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateScalingConfigurationShrinkRequestInstancePatternInfos() = default;
};
class CreateScalingConfigurationShrinkRequestInstanceTypeOverrides : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<long> weightedCapacity{};

  CreateScalingConfigurationShrinkRequestInstanceTypeOverrides() {}

  explicit CreateScalingConfigurationShrinkRequestInstanceTypeOverrides(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (weightedCapacity) {
      res["WeightedCapacity"] = boost::any(*weightedCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("WeightedCapacity") != m.end() && !m["WeightedCapacity"].empty()) {
      weightedCapacity = make_shared<long>(boost::any_cast<long>(m["WeightedCapacity"]));
    }
  }


  virtual ~CreateScalingConfigurationShrinkRequestInstanceTypeOverrides() = default;
};
class CreateScalingConfigurationShrinkRequestNetworkInterfaces : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<long> ipv6AddressCount{};
  shared_ptr<string> networkInterfaceTrafficMode{};
  shared_ptr<vector<string>> securityGroupIds{};

  CreateScalingConfigurationShrinkRequestNetworkInterfaces() {}

  explicit CreateScalingConfigurationShrinkRequestNetworkInterfaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ipv6AddressCount) {
      res["Ipv6AddressCount"] = boost::any(*ipv6AddressCount);
    }
    if (networkInterfaceTrafficMode) {
      res["NetworkInterfaceTrafficMode"] = boost::any(*networkInterfaceTrafficMode);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ipv6AddressCount") != m.end() && !m["Ipv6AddressCount"].empty()) {
      ipv6AddressCount = make_shared<long>(boost::any_cast<long>(m["Ipv6AddressCount"]));
    }
    if (m.find("NetworkInterfaceTrafficMode") != m.end() && !m["NetworkInterfaceTrafficMode"].empty()) {
      networkInterfaceTrafficMode = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceTrafficMode"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateScalingConfigurationShrinkRequestNetworkInterfaces() = default;
};
class CreateScalingConfigurationShrinkRequestSecurityOptions : public Darabonba::Model {
public:
  shared_ptr<string> confidentialComputingMode{};

  CreateScalingConfigurationShrinkRequestSecurityOptions() {}

  explicit CreateScalingConfigurationShrinkRequestSecurityOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (confidentialComputingMode) {
      res["ConfidentialComputingMode"] = boost::any(*confidentialComputingMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfidentialComputingMode") != m.end() && !m["ConfidentialComputingMode"].empty()) {
      confidentialComputingMode = make_shared<string>(boost::any_cast<string>(m["ConfidentialComputingMode"]));
    }
  }


  virtual ~CreateScalingConfigurationShrinkRequestSecurityOptions() = default;
};
class CreateScalingConfigurationShrinkRequestSpotPriceLimits : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<double> priceLimit{};

  CreateScalingConfigurationShrinkRequestSpotPriceLimits() {}

  explicit CreateScalingConfigurationShrinkRequestSpotPriceLimits(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (priceLimit) {
      res["PriceLimit"] = boost::any(*priceLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("PriceLimit") != m.end() && !m["PriceLimit"].empty()) {
      priceLimit = make_shared<double>(boost::any_cast<double>(m["PriceLimit"]));
    }
  }


  virtual ~CreateScalingConfigurationShrinkRequestSpotPriceLimits() = default;
};
class CreateScalingConfigurationShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<CreateScalingConfigurationShrinkRequestImageOptions> imageOptions{};
  shared_ptr<CreateScalingConfigurationShrinkRequestPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<CreateScalingConfigurationShrinkRequestSystemDisk> systemDisk{};
  shared_ptr<string> affinity{};
  shared_ptr<string> clientToken{};
  shared_ptr<long> cpu{};
  shared_ptr<string> creditSpecification{};
  shared_ptr<vector<CreateScalingConfigurationShrinkRequestCustomPriorities>> customPriorities{};
  shared_ptr<vector<CreateScalingConfigurationShrinkRequestDataDisks>> dataDisks{};
  shared_ptr<string> dedicatedHostClusterId{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<bool> deletionProtection{};
  shared_ptr<string> deploymentSetId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> hpcClusterId{};
  shared_ptr<string> httpEndpoint{};
  shared_ptr<string> httpTokens{};
  shared_ptr<string> imageFamily{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<string> instanceDescription{};
  shared_ptr<string> instanceName{};
  shared_ptr<vector<CreateScalingConfigurationShrinkRequestInstancePatternInfos>> instancePatternInfos{};
  shared_ptr<string> instanceType{};
  shared_ptr<vector<CreateScalingConfigurationShrinkRequestInstanceTypeOverrides>> instanceTypeOverrides{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidthIn{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> ioOptimized{};
  shared_ptr<long> ipv6AddressCount{};
  shared_ptr<string> keyPairName{};
  shared_ptr<long> loadBalancerWeight{};
  shared_ptr<long> memory{};
  shared_ptr<vector<CreateScalingConfigurationShrinkRequestNetworkInterfaces>> networkInterfaces{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> password{};
  shared_ptr<bool> passwordInherit{};
  shared_ptr<string> ramRoleName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingConfigurationName{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> schedulerOptionsShrink{};
  shared_ptr<string> securityEnhancementStrategy{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<CreateScalingConfigurationShrinkRequestSecurityOptions> securityOptions{};
  shared_ptr<long> spotDuration{};
  shared_ptr<string> spotInterruptionBehavior{};
  shared_ptr<vector<CreateScalingConfigurationShrinkRequestSpotPriceLimits>> spotPriceLimits{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<string> storageSetId{};
  shared_ptr<long> storageSetPartitionNumber{};
  shared_ptr<vector<string>> systemDiskCategories{};
  shared_ptr<string> tags{};
  shared_ptr<string> tenancy{};
  shared_ptr<string> userData{};
  shared_ptr<string> zoneId{};

  CreateScalingConfigurationShrinkRequest() {}

  explicit CreateScalingConfigurationShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageOptions) {
      res["ImageOptions"] = imageOptions ? boost::any(imageOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (privatePoolOptions) {
      res["PrivatePoolOptions"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (affinity) {
      res["Affinity"] = boost::any(*affinity);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (creditSpecification) {
      res["CreditSpecification"] = boost::any(*creditSpecification);
    }
    if (customPriorities) {
      vector<boost::any> temp1;
      for(auto item1:*customPriorities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomPriorities"] = boost::any(temp1);
    }
    if (dataDisks) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisks"] = boost::any(temp1);
    }
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (deletionProtection) {
      res["DeletionProtection"] = boost::any(*deletionProtection);
    }
    if (deploymentSetId) {
      res["DeploymentSetId"] = boost::any(*deploymentSetId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (hpcClusterId) {
      res["HpcClusterId"] = boost::any(*hpcClusterId);
    }
    if (httpEndpoint) {
      res["HttpEndpoint"] = boost::any(*httpEndpoint);
    }
    if (httpTokens) {
      res["HttpTokens"] = boost::any(*httpTokens);
    }
    if (imageFamily) {
      res["ImageFamily"] = boost::any(*imageFamily);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (instanceDescription) {
      res["InstanceDescription"] = boost::any(*instanceDescription);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instancePatternInfos) {
      vector<boost::any> temp1;
      for(auto item1:*instancePatternInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstancePatternInfos"] = boost::any(temp1);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (instanceTypeOverrides) {
      vector<boost::any> temp1;
      for(auto item1:*instanceTypeOverrides){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceTypeOverrides"] = boost::any(temp1);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = boost::any(*instanceTypes);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidthIn) {
      res["InternetMaxBandwidthIn"] = boost::any(*internetMaxBandwidthIn);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (ipv6AddressCount) {
      res["Ipv6AddressCount"] = boost::any(*ipv6AddressCount);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (loadBalancerWeight) {
      res["LoadBalancerWeight"] = boost::any(*loadBalancerWeight);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (networkInterfaces) {
      vector<boost::any> temp1;
      for(auto item1:*networkInterfaces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkInterfaces"] = boost::any(temp1);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (passwordInherit) {
      res["PasswordInherit"] = boost::any(*passwordInherit);
    }
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingConfigurationName) {
      res["ScalingConfigurationName"] = boost::any(*scalingConfigurationName);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (schedulerOptionsShrink) {
      res["SchedulerOptions"] = boost::any(*schedulerOptionsShrink);
    }
    if (securityEnhancementStrategy) {
      res["SecurityEnhancementStrategy"] = boost::any(*securityEnhancementStrategy);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    if (securityOptions) {
      res["SecurityOptions"] = securityOptions ? boost::any(securityOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spotDuration) {
      res["SpotDuration"] = boost::any(*spotDuration);
    }
    if (spotInterruptionBehavior) {
      res["SpotInterruptionBehavior"] = boost::any(*spotInterruptionBehavior);
    }
    if (spotPriceLimits) {
      vector<boost::any> temp1;
      for(auto item1:*spotPriceLimits){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpotPriceLimits"] = boost::any(temp1);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    if (storageSetPartitionNumber) {
      res["StorageSetPartitionNumber"] = boost::any(*storageSetPartitionNumber);
    }
    if (systemDiskCategories) {
      res["SystemDiskCategories"] = boost::any(*systemDiskCategories);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (tenancy) {
      res["Tenancy"] = boost::any(*tenancy);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageOptions") != m.end() && !m["ImageOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageOptions"].type()) {
        CreateScalingConfigurationShrinkRequestImageOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageOptions"]));
        imageOptions = make_shared<CreateScalingConfigurationShrinkRequestImageOptions>(model1);
      }
    }
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolOptions"].type()) {
        CreateScalingConfigurationShrinkRequestPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolOptions"]));
        privatePoolOptions = make_shared<CreateScalingConfigurationShrinkRequestPrivatePoolOptions>(model1);
      }
    }
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        CreateScalingConfigurationShrinkRequestSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<CreateScalingConfigurationShrinkRequestSystemDisk>(model1);
      }
    }
    if (m.find("Affinity") != m.end() && !m["Affinity"].empty()) {
      affinity = make_shared<string>(boost::any_cast<string>(m["Affinity"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CreditSpecification") != m.end() && !m["CreditSpecification"].empty()) {
      creditSpecification = make_shared<string>(boost::any_cast<string>(m["CreditSpecification"]));
    }
    if (m.find("CustomPriorities") != m.end() && !m["CustomPriorities"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomPriorities"].type()) {
        vector<CreateScalingConfigurationShrinkRequestCustomPriorities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomPriorities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingConfigurationShrinkRequestCustomPriorities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customPriorities = make_shared<vector<CreateScalingConfigurationShrinkRequestCustomPriorities>>(expect1);
      }
    }
    if (m.find("DataDisks") != m.end() && !m["DataDisks"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisks"].type()) {
        vector<CreateScalingConfigurationShrinkRequestDataDisks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingConfigurationShrinkRequestDataDisks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisks = make_shared<vector<CreateScalingConfigurationShrinkRequestDataDisks>>(expect1);
      }
    }
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("DeletionProtection") != m.end() && !m["DeletionProtection"].empty()) {
      deletionProtection = make_shared<bool>(boost::any_cast<bool>(m["DeletionProtection"]));
    }
    if (m.find("DeploymentSetId") != m.end() && !m["DeploymentSetId"].empty()) {
      deploymentSetId = make_shared<string>(boost::any_cast<string>(m["DeploymentSetId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("HpcClusterId") != m.end() && !m["HpcClusterId"].empty()) {
      hpcClusterId = make_shared<string>(boost::any_cast<string>(m["HpcClusterId"]));
    }
    if (m.find("HttpEndpoint") != m.end() && !m["HttpEndpoint"].empty()) {
      httpEndpoint = make_shared<string>(boost::any_cast<string>(m["HttpEndpoint"]));
    }
    if (m.find("HttpTokens") != m.end() && !m["HttpTokens"].empty()) {
      httpTokens = make_shared<string>(boost::any_cast<string>(m["HttpTokens"]));
    }
    if (m.find("ImageFamily") != m.end() && !m["ImageFamily"].empty()) {
      imageFamily = make_shared<string>(boost::any_cast<string>(m["ImageFamily"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("InstanceDescription") != m.end() && !m["InstanceDescription"].empty()) {
      instanceDescription = make_shared<string>(boost::any_cast<string>(m["InstanceDescription"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstancePatternInfos") != m.end() && !m["InstancePatternInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["InstancePatternInfos"].type()) {
        vector<CreateScalingConfigurationShrinkRequestInstancePatternInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstancePatternInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingConfigurationShrinkRequestInstancePatternInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instancePatternInfos = make_shared<vector<CreateScalingConfigurationShrinkRequestInstancePatternInfos>>(expect1);
      }
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InstanceTypeOverrides") != m.end() && !m["InstanceTypeOverrides"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceTypeOverrides"].type()) {
        vector<CreateScalingConfigurationShrinkRequestInstanceTypeOverrides> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceTypeOverrides"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingConfigurationShrinkRequestInstanceTypeOverrides model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceTypeOverrides = make_shared<vector<CreateScalingConfigurationShrinkRequestInstanceTypeOverrides>>(expect1);
      }
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("InternetMaxBandwidthIn") != m.end() && !m["InternetMaxBandwidthIn"].empty()) {
      internetMaxBandwidthIn = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthIn"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("Ipv6AddressCount") != m.end() && !m["Ipv6AddressCount"].empty()) {
      ipv6AddressCount = make_shared<long>(boost::any_cast<long>(m["Ipv6AddressCount"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("LoadBalancerWeight") != m.end() && !m["LoadBalancerWeight"].empty()) {
      loadBalancerWeight = make_shared<long>(boost::any_cast<long>(m["LoadBalancerWeight"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("NetworkInterfaces") != m.end() && !m["NetworkInterfaces"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkInterfaces"].type()) {
        vector<CreateScalingConfigurationShrinkRequestNetworkInterfaces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkInterfaces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingConfigurationShrinkRequestNetworkInterfaces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkInterfaces = make_shared<vector<CreateScalingConfigurationShrinkRequestNetworkInterfaces>>(expect1);
      }
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("PasswordInherit") != m.end() && !m["PasswordInherit"].empty()) {
      passwordInherit = make_shared<bool>(boost::any_cast<bool>(m["PasswordInherit"]));
    }
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingConfigurationName") != m.end() && !m["ScalingConfigurationName"].empty()) {
      scalingConfigurationName = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationName"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("SchedulerOptions") != m.end() && !m["SchedulerOptions"].empty()) {
      schedulerOptionsShrink = make_shared<string>(boost::any_cast<string>(m["SchedulerOptions"]));
    }
    if (m.find("SecurityEnhancementStrategy") != m.end() && !m["SecurityEnhancementStrategy"].empty()) {
      securityEnhancementStrategy = make_shared<string>(boost::any_cast<string>(m["SecurityEnhancementStrategy"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SecurityOptions") != m.end() && !m["SecurityOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityOptions"].type()) {
        CreateScalingConfigurationShrinkRequestSecurityOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityOptions"]));
        securityOptions = make_shared<CreateScalingConfigurationShrinkRequestSecurityOptions>(model1);
      }
    }
    if (m.find("SpotDuration") != m.end() && !m["SpotDuration"].empty()) {
      spotDuration = make_shared<long>(boost::any_cast<long>(m["SpotDuration"]));
    }
    if (m.find("SpotInterruptionBehavior") != m.end() && !m["SpotInterruptionBehavior"].empty()) {
      spotInterruptionBehavior = make_shared<string>(boost::any_cast<string>(m["SpotInterruptionBehavior"]));
    }
    if (m.find("SpotPriceLimits") != m.end() && !m["SpotPriceLimits"].empty()) {
      if (typeid(vector<boost::any>) == m["SpotPriceLimits"].type()) {
        vector<CreateScalingConfigurationShrinkRequestSpotPriceLimits> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpotPriceLimits"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingConfigurationShrinkRequestSpotPriceLimits model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spotPriceLimits = make_shared<vector<CreateScalingConfigurationShrinkRequestSpotPriceLimits>>(expect1);
      }
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
    if (m.find("StorageSetPartitionNumber") != m.end() && !m["StorageSetPartitionNumber"].empty()) {
      storageSetPartitionNumber = make_shared<long>(boost::any_cast<long>(m["StorageSetPartitionNumber"]));
    }
    if (m.find("SystemDiskCategories") != m.end() && !m["SystemDiskCategories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SystemDiskCategories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SystemDiskCategories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      systemDiskCategories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Tenancy") != m.end() && !m["Tenancy"].empty()) {
      tenancy = make_shared<string>(boost::any_cast<string>(m["Tenancy"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateScalingConfigurationShrinkRequest() = default;
};
class CreateScalingConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> scalingConfigurationId{};

  CreateScalingConfigurationResponseBody() {}

  explicit CreateScalingConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingConfigurationId) {
      res["ScalingConfigurationId"] = boost::any(*scalingConfigurationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingConfigurationId") != m.end() && !m["ScalingConfigurationId"].empty()) {
      scalingConfigurationId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationId"]));
    }
  }


  virtual ~CreateScalingConfigurationResponseBody() = default;
};
class CreateScalingConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateScalingConfigurationResponseBody> body{};

  CreateScalingConfigurationResponse() {}

  explicit CreateScalingConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateScalingConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateScalingConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateScalingConfigurationResponse() = default;
};
class CreateScalingGroupRequestAlbServerGroups : public Darabonba::Model {
public:
  shared_ptr<string> albServerGroupId{};
  shared_ptr<long> port{};
  shared_ptr<long> weight{};

  CreateScalingGroupRequestAlbServerGroups() {}

  explicit CreateScalingGroupRequestAlbServerGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (albServerGroupId) {
      res["AlbServerGroupId"] = boost::any(*albServerGroupId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlbServerGroupId") != m.end() && !m["AlbServerGroupId"].empty()) {
      albServerGroupId = make_shared<string>(boost::any_cast<string>(m["AlbServerGroupId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~CreateScalingGroupRequestAlbServerGroups() = default;
};
class CreateScalingGroupRequestCapacityOptions : public Darabonba::Model {
public:
  shared_ptr<bool> compensateWithOnDemand{};
  shared_ptr<long> onDemandBaseCapacity{};
  shared_ptr<long> onDemandPercentageAboveBaseCapacity{};
  shared_ptr<bool> spotAutoReplaceOnDemand{};

  CreateScalingGroupRequestCapacityOptions() {}

  explicit CreateScalingGroupRequestCapacityOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compensateWithOnDemand) {
      res["CompensateWithOnDemand"] = boost::any(*compensateWithOnDemand);
    }
    if (onDemandBaseCapacity) {
      res["OnDemandBaseCapacity"] = boost::any(*onDemandBaseCapacity);
    }
    if (onDemandPercentageAboveBaseCapacity) {
      res["OnDemandPercentageAboveBaseCapacity"] = boost::any(*onDemandPercentageAboveBaseCapacity);
    }
    if (spotAutoReplaceOnDemand) {
      res["SpotAutoReplaceOnDemand"] = boost::any(*spotAutoReplaceOnDemand);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompensateWithOnDemand") != m.end() && !m["CompensateWithOnDemand"].empty()) {
      compensateWithOnDemand = make_shared<bool>(boost::any_cast<bool>(m["CompensateWithOnDemand"]));
    }
    if (m.find("OnDemandBaseCapacity") != m.end() && !m["OnDemandBaseCapacity"].empty()) {
      onDemandBaseCapacity = make_shared<long>(boost::any_cast<long>(m["OnDemandBaseCapacity"]));
    }
    if (m.find("OnDemandPercentageAboveBaseCapacity") != m.end() && !m["OnDemandPercentageAboveBaseCapacity"].empty()) {
      onDemandPercentageAboveBaseCapacity = make_shared<long>(boost::any_cast<long>(m["OnDemandPercentageAboveBaseCapacity"]));
    }
    if (m.find("SpotAutoReplaceOnDemand") != m.end() && !m["SpotAutoReplaceOnDemand"].empty()) {
      spotAutoReplaceOnDemand = make_shared<bool>(boost::any_cast<bool>(m["SpotAutoReplaceOnDemand"]));
    }
  }


  virtual ~CreateScalingGroupRequestCapacityOptions() = default;
};
class CreateScalingGroupRequestDBInstances : public Darabonba::Model {
public:
  shared_ptr<string> attachMode{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> type{};

  CreateScalingGroupRequestDBInstances() {}

  explicit CreateScalingGroupRequestDBInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachMode) {
      res["AttachMode"] = boost::any(*attachMode);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachMode") != m.end() && !m["AttachMode"].empty()) {
      attachMode = make_shared<string>(boost::any_cast<string>(m["AttachMode"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateScalingGroupRequestDBInstances() = default;
};
class CreateScalingGroupRequestLaunchTemplateOverrides : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<double> spotPriceLimit{};
  shared_ptr<long> weightedCapacity{};

  CreateScalingGroupRequestLaunchTemplateOverrides() {}

  explicit CreateScalingGroupRequestLaunchTemplateOverrides(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (spotPriceLimit) {
      res["SpotPriceLimit"] = boost::any(*spotPriceLimit);
    }
    if (weightedCapacity) {
      res["WeightedCapacity"] = boost::any(*weightedCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("SpotPriceLimit") != m.end() && !m["SpotPriceLimit"].empty()) {
      spotPriceLimit = make_shared<double>(boost::any_cast<double>(m["SpotPriceLimit"]));
    }
    if (m.find("WeightedCapacity") != m.end() && !m["WeightedCapacity"].empty()) {
      weightedCapacity = make_shared<long>(boost::any_cast<long>(m["WeightedCapacity"]));
    }
  }


  virtual ~CreateScalingGroupRequestLaunchTemplateOverrides() = default;
};
class CreateScalingGroupRequestLifecycleHooks : public Darabonba::Model {
public:
  shared_ptr<string> defaultResult{};
  shared_ptr<long> heartbeatTimeout{};
  shared_ptr<string> lifecycleHookName{};
  shared_ptr<string> lifecycleTransition{};
  shared_ptr<string> notificationArn{};
  shared_ptr<string> notificationMetadata{};

  CreateScalingGroupRequestLifecycleHooks() {}

  explicit CreateScalingGroupRequestLifecycleHooks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultResult) {
      res["DefaultResult"] = boost::any(*defaultResult);
    }
    if (heartbeatTimeout) {
      res["HeartbeatTimeout"] = boost::any(*heartbeatTimeout);
    }
    if (lifecycleHookName) {
      res["LifecycleHookName"] = boost::any(*lifecycleHookName);
    }
    if (lifecycleTransition) {
      res["LifecycleTransition"] = boost::any(*lifecycleTransition);
    }
    if (notificationArn) {
      res["NotificationArn"] = boost::any(*notificationArn);
    }
    if (notificationMetadata) {
      res["NotificationMetadata"] = boost::any(*notificationMetadata);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultResult") != m.end() && !m["DefaultResult"].empty()) {
      defaultResult = make_shared<string>(boost::any_cast<string>(m["DefaultResult"]));
    }
    if (m.find("HeartbeatTimeout") != m.end() && !m["HeartbeatTimeout"].empty()) {
      heartbeatTimeout = make_shared<long>(boost::any_cast<long>(m["HeartbeatTimeout"]));
    }
    if (m.find("LifecycleHookName") != m.end() && !m["LifecycleHookName"].empty()) {
      lifecycleHookName = make_shared<string>(boost::any_cast<string>(m["LifecycleHookName"]));
    }
    if (m.find("LifecycleTransition") != m.end() && !m["LifecycleTransition"].empty()) {
      lifecycleTransition = make_shared<string>(boost::any_cast<string>(m["LifecycleTransition"]));
    }
    if (m.find("NotificationArn") != m.end() && !m["NotificationArn"].empty()) {
      notificationArn = make_shared<string>(boost::any_cast<string>(m["NotificationArn"]));
    }
    if (m.find("NotificationMetadata") != m.end() && !m["NotificationMetadata"].empty()) {
      notificationMetadata = make_shared<string>(boost::any_cast<string>(m["NotificationMetadata"]));
    }
  }


  virtual ~CreateScalingGroupRequestLifecycleHooks() = default;
};
class CreateScalingGroupRequestLoadBalancerConfigs : public Darabonba::Model {
public:
  shared_ptr<string> loadBalancerId{};
  shared_ptr<long> weight{};

  CreateScalingGroupRequestLoadBalancerConfigs() {}

  explicit CreateScalingGroupRequestLoadBalancerConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~CreateScalingGroupRequestLoadBalancerConfigs() = default;
};
class CreateScalingGroupRequestServerGroups : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> serverGroupId{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  CreateScalingGroupRequestServerGroups() {}

  explicit CreateScalingGroupRequestServerGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (serverGroupId) {
      res["ServerGroupId"] = boost::any(*serverGroupId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("ServerGroupId") != m.end() && !m["ServerGroupId"].empty()) {
      serverGroupId = make_shared<string>(boost::any_cast<string>(m["ServerGroupId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~CreateScalingGroupRequestServerGroups() = default;
};
class CreateScalingGroupRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<bool> propagate{};
  shared_ptr<string> value{};

  CreateScalingGroupRequestTags() {}

  explicit CreateScalingGroupRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (propagate) {
      res["Propagate"] = boost::any(*propagate);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Propagate") != m.end() && !m["Propagate"].empty()) {
      propagate = make_shared<bool>(boost::any_cast<bool>(m["Propagate"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateScalingGroupRequestTags() = default;
};
class CreateScalingGroupRequestVServerGroupsVServerGroupAttributes : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> VServerGroupId{};
  shared_ptr<long> weight{};

  CreateScalingGroupRequestVServerGroupsVServerGroupAttributes() {}

  explicit CreateScalingGroupRequestVServerGroupsVServerGroupAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (VServerGroupId) {
      res["VServerGroupId"] = boost::any(*VServerGroupId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("VServerGroupId") != m.end() && !m["VServerGroupId"].empty()) {
      VServerGroupId = make_shared<string>(boost::any_cast<string>(m["VServerGroupId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~CreateScalingGroupRequestVServerGroupsVServerGroupAttributes() = default;
};
class CreateScalingGroupRequestVServerGroups : public Darabonba::Model {
public:
  shared_ptr<string> loadBalancerId{};
  shared_ptr<vector<CreateScalingGroupRequestVServerGroupsVServerGroupAttributes>> VServerGroupAttributes{};

  CreateScalingGroupRequestVServerGroups() {}

  explicit CreateScalingGroupRequestVServerGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (VServerGroupAttributes) {
      vector<boost::any> temp1;
      for(auto item1:*VServerGroupAttributes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VServerGroupAttributes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("VServerGroupAttributes") != m.end() && !m["VServerGroupAttributes"].empty()) {
      if (typeid(vector<boost::any>) == m["VServerGroupAttributes"].type()) {
        vector<CreateScalingGroupRequestVServerGroupsVServerGroupAttributes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VServerGroupAttributes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingGroupRequestVServerGroupsVServerGroupAttributes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        VServerGroupAttributes = make_shared<vector<CreateScalingGroupRequestVServerGroupsVServerGroupAttributes>>(expect1);
      }
    }
  }


  virtual ~CreateScalingGroupRequestVServerGroups() = default;
};
class CreateScalingGroupRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateScalingGroupRequestAlbServerGroups>> albServerGroups{};
  shared_ptr<string> allocationStrategy{};
  shared_ptr<bool> azBalance{};
  shared_ptr<CreateScalingGroupRequestCapacityOptions> capacityOptions{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> compensateWithOnDemand{};
  shared_ptr<string> containerGroupId{};
  shared_ptr<string> customPolicyARN{};
  shared_ptr<string> DBInstanceIds{};
  shared_ptr<vector<CreateScalingGroupRequestDBInstances>> DBInstances{};
  shared_ptr<long> defaultCooldown{};
  shared_ptr<long> desiredCapacity{};
  shared_ptr<bool> groupDeletionProtection{};
  shared_ptr<string> groupType{};
  shared_ptr<string> healthCheckType{};
  shared_ptr<vector<string>> healthCheckTypes{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> launchTemplateId{};
  shared_ptr<vector<CreateScalingGroupRequestLaunchTemplateOverrides>> launchTemplateOverrides{};
  shared_ptr<string> launchTemplateVersion{};
  shared_ptr<vector<CreateScalingGroupRequestLifecycleHooks>> lifecycleHooks{};
  shared_ptr<vector<CreateScalingGroupRequestLoadBalancerConfigs>> loadBalancerConfigs{};
  shared_ptr<string> loadBalancerIds{};
  shared_ptr<long> maxInstanceLifetime{};
  shared_ptr<long> maxSize{};
  shared_ptr<long> minSize{};
  shared_ptr<string> multiAZPolicy{};
  shared_ptr<long> onDemandBaseCapacity{};
  shared_ptr<long> onDemandPercentageAboveBaseCapacity{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> removalPolicies{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupName{};
  shared_ptr<string> scalingPolicy{};
  shared_ptr<vector<CreateScalingGroupRequestServerGroups>> serverGroups{};
  shared_ptr<string> spotAllocationStrategy{};
  shared_ptr<long> spotInstancePools{};
  shared_ptr<bool> spotInstanceRemedy{};
  shared_ptr<long> stopInstanceTimeout{};
  shared_ptr<bool> syncAlarmRuleToCms{};
  shared_ptr<vector<CreateScalingGroupRequestTags>> tags{};
  shared_ptr<vector<CreateScalingGroupRequestVServerGroups>> VServerGroups{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<vector<string>> vSwitchIds{};

  CreateScalingGroupRequest() {}

  explicit CreateScalingGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (albServerGroups) {
      vector<boost::any> temp1;
      for(auto item1:*albServerGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlbServerGroups"] = boost::any(temp1);
    }
    if (allocationStrategy) {
      res["AllocationStrategy"] = boost::any(*allocationStrategy);
    }
    if (azBalance) {
      res["AzBalance"] = boost::any(*azBalance);
    }
    if (capacityOptions) {
      res["CapacityOptions"] = capacityOptions ? boost::any(capacityOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (compensateWithOnDemand) {
      res["CompensateWithOnDemand"] = boost::any(*compensateWithOnDemand);
    }
    if (containerGroupId) {
      res["ContainerGroupId"] = boost::any(*containerGroupId);
    }
    if (customPolicyARN) {
      res["CustomPolicyARN"] = boost::any(*customPolicyARN);
    }
    if (DBInstanceIds) {
      res["DBInstanceIds"] = boost::any(*DBInstanceIds);
    }
    if (DBInstances) {
      vector<boost::any> temp1;
      for(auto item1:*DBInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DBInstances"] = boost::any(temp1);
    }
    if (defaultCooldown) {
      res["DefaultCooldown"] = boost::any(*defaultCooldown);
    }
    if (desiredCapacity) {
      res["DesiredCapacity"] = boost::any(*desiredCapacity);
    }
    if (groupDeletionProtection) {
      res["GroupDeletionProtection"] = boost::any(*groupDeletionProtection);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (healthCheckType) {
      res["HealthCheckType"] = boost::any(*healthCheckType);
    }
    if (healthCheckTypes) {
      res["HealthCheckTypes"] = boost::any(*healthCheckTypes);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (launchTemplateId) {
      res["LaunchTemplateId"] = boost::any(*launchTemplateId);
    }
    if (launchTemplateOverrides) {
      vector<boost::any> temp1;
      for(auto item1:*launchTemplateOverrides){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LaunchTemplateOverrides"] = boost::any(temp1);
    }
    if (launchTemplateVersion) {
      res["LaunchTemplateVersion"] = boost::any(*launchTemplateVersion);
    }
    if (lifecycleHooks) {
      vector<boost::any> temp1;
      for(auto item1:*lifecycleHooks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LifecycleHooks"] = boost::any(temp1);
    }
    if (loadBalancerConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*loadBalancerConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LoadBalancerConfigs"] = boost::any(temp1);
    }
    if (loadBalancerIds) {
      res["LoadBalancerIds"] = boost::any(*loadBalancerIds);
    }
    if (maxInstanceLifetime) {
      res["MaxInstanceLifetime"] = boost::any(*maxInstanceLifetime);
    }
    if (maxSize) {
      res["MaxSize"] = boost::any(*maxSize);
    }
    if (minSize) {
      res["MinSize"] = boost::any(*minSize);
    }
    if (multiAZPolicy) {
      res["MultiAZPolicy"] = boost::any(*multiAZPolicy);
    }
    if (onDemandBaseCapacity) {
      res["OnDemandBaseCapacity"] = boost::any(*onDemandBaseCapacity);
    }
    if (onDemandPercentageAboveBaseCapacity) {
      res["OnDemandPercentageAboveBaseCapacity"] = boost::any(*onDemandPercentageAboveBaseCapacity);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (removalPolicies) {
      res["RemovalPolicies"] = boost::any(*removalPolicies);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupName) {
      res["ScalingGroupName"] = boost::any(*scalingGroupName);
    }
    if (scalingPolicy) {
      res["ScalingPolicy"] = boost::any(*scalingPolicy);
    }
    if (serverGroups) {
      vector<boost::any> temp1;
      for(auto item1:*serverGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServerGroups"] = boost::any(temp1);
    }
    if (spotAllocationStrategy) {
      res["SpotAllocationStrategy"] = boost::any(*spotAllocationStrategy);
    }
    if (spotInstancePools) {
      res["SpotInstancePools"] = boost::any(*spotInstancePools);
    }
    if (spotInstanceRemedy) {
      res["SpotInstanceRemedy"] = boost::any(*spotInstanceRemedy);
    }
    if (stopInstanceTimeout) {
      res["StopInstanceTimeout"] = boost::any(*stopInstanceTimeout);
    }
    if (syncAlarmRuleToCms) {
      res["SyncAlarmRuleToCms"] = boost::any(*syncAlarmRuleToCms);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (VServerGroups) {
      vector<boost::any> temp1;
      for(auto item1:*VServerGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VServerGroups"] = boost::any(temp1);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = boost::any(*vSwitchIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlbServerGroups") != m.end() && !m["AlbServerGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["AlbServerGroups"].type()) {
        vector<CreateScalingGroupRequestAlbServerGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlbServerGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingGroupRequestAlbServerGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        albServerGroups = make_shared<vector<CreateScalingGroupRequestAlbServerGroups>>(expect1);
      }
    }
    if (m.find("AllocationStrategy") != m.end() && !m["AllocationStrategy"].empty()) {
      allocationStrategy = make_shared<string>(boost::any_cast<string>(m["AllocationStrategy"]));
    }
    if (m.find("AzBalance") != m.end() && !m["AzBalance"].empty()) {
      azBalance = make_shared<bool>(boost::any_cast<bool>(m["AzBalance"]));
    }
    if (m.find("CapacityOptions") != m.end() && !m["CapacityOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["CapacityOptions"].type()) {
        CreateScalingGroupRequestCapacityOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CapacityOptions"]));
        capacityOptions = make_shared<CreateScalingGroupRequestCapacityOptions>(model1);
      }
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CompensateWithOnDemand") != m.end() && !m["CompensateWithOnDemand"].empty()) {
      compensateWithOnDemand = make_shared<bool>(boost::any_cast<bool>(m["CompensateWithOnDemand"]));
    }
    if (m.find("ContainerGroupId") != m.end() && !m["ContainerGroupId"].empty()) {
      containerGroupId = make_shared<string>(boost::any_cast<string>(m["ContainerGroupId"]));
    }
    if (m.find("CustomPolicyARN") != m.end() && !m["CustomPolicyARN"].empty()) {
      customPolicyARN = make_shared<string>(boost::any_cast<string>(m["CustomPolicyARN"]));
    }
    if (m.find("DBInstanceIds") != m.end() && !m["DBInstanceIds"].empty()) {
      DBInstanceIds = make_shared<string>(boost::any_cast<string>(m["DBInstanceIds"]));
    }
    if (m.find("DBInstances") != m.end() && !m["DBInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["DBInstances"].type()) {
        vector<CreateScalingGroupRequestDBInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DBInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingGroupRequestDBInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DBInstances = make_shared<vector<CreateScalingGroupRequestDBInstances>>(expect1);
      }
    }
    if (m.find("DefaultCooldown") != m.end() && !m["DefaultCooldown"].empty()) {
      defaultCooldown = make_shared<long>(boost::any_cast<long>(m["DefaultCooldown"]));
    }
    if (m.find("DesiredCapacity") != m.end() && !m["DesiredCapacity"].empty()) {
      desiredCapacity = make_shared<long>(boost::any_cast<long>(m["DesiredCapacity"]));
    }
    if (m.find("GroupDeletionProtection") != m.end() && !m["GroupDeletionProtection"].empty()) {
      groupDeletionProtection = make_shared<bool>(boost::any_cast<bool>(m["GroupDeletionProtection"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("HealthCheckType") != m.end() && !m["HealthCheckType"].empty()) {
      healthCheckType = make_shared<string>(boost::any_cast<string>(m["HealthCheckType"]));
    }
    if (m.find("HealthCheckTypes") != m.end() && !m["HealthCheckTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HealthCheckTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HealthCheckTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      healthCheckTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LaunchTemplateId") != m.end() && !m["LaunchTemplateId"].empty()) {
      launchTemplateId = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateId"]));
    }
    if (m.find("LaunchTemplateOverrides") != m.end() && !m["LaunchTemplateOverrides"].empty()) {
      if (typeid(vector<boost::any>) == m["LaunchTemplateOverrides"].type()) {
        vector<CreateScalingGroupRequestLaunchTemplateOverrides> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LaunchTemplateOverrides"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingGroupRequestLaunchTemplateOverrides model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        launchTemplateOverrides = make_shared<vector<CreateScalingGroupRequestLaunchTemplateOverrides>>(expect1);
      }
    }
    if (m.find("LaunchTemplateVersion") != m.end() && !m["LaunchTemplateVersion"].empty()) {
      launchTemplateVersion = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateVersion"]));
    }
    if (m.find("LifecycleHooks") != m.end() && !m["LifecycleHooks"].empty()) {
      if (typeid(vector<boost::any>) == m["LifecycleHooks"].type()) {
        vector<CreateScalingGroupRequestLifecycleHooks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LifecycleHooks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingGroupRequestLifecycleHooks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lifecycleHooks = make_shared<vector<CreateScalingGroupRequestLifecycleHooks>>(expect1);
      }
    }
    if (m.find("LoadBalancerConfigs") != m.end() && !m["LoadBalancerConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["LoadBalancerConfigs"].type()) {
        vector<CreateScalingGroupRequestLoadBalancerConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LoadBalancerConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingGroupRequestLoadBalancerConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        loadBalancerConfigs = make_shared<vector<CreateScalingGroupRequestLoadBalancerConfigs>>(expect1);
      }
    }
    if (m.find("LoadBalancerIds") != m.end() && !m["LoadBalancerIds"].empty()) {
      loadBalancerIds = make_shared<string>(boost::any_cast<string>(m["LoadBalancerIds"]));
    }
    if (m.find("MaxInstanceLifetime") != m.end() && !m["MaxInstanceLifetime"].empty()) {
      maxInstanceLifetime = make_shared<long>(boost::any_cast<long>(m["MaxInstanceLifetime"]));
    }
    if (m.find("MaxSize") != m.end() && !m["MaxSize"].empty()) {
      maxSize = make_shared<long>(boost::any_cast<long>(m["MaxSize"]));
    }
    if (m.find("MinSize") != m.end() && !m["MinSize"].empty()) {
      minSize = make_shared<long>(boost::any_cast<long>(m["MinSize"]));
    }
    if (m.find("MultiAZPolicy") != m.end() && !m["MultiAZPolicy"].empty()) {
      multiAZPolicy = make_shared<string>(boost::any_cast<string>(m["MultiAZPolicy"]));
    }
    if (m.find("OnDemandBaseCapacity") != m.end() && !m["OnDemandBaseCapacity"].empty()) {
      onDemandBaseCapacity = make_shared<long>(boost::any_cast<long>(m["OnDemandBaseCapacity"]));
    }
    if (m.find("OnDemandPercentageAboveBaseCapacity") != m.end() && !m["OnDemandPercentageAboveBaseCapacity"].empty()) {
      onDemandPercentageAboveBaseCapacity = make_shared<long>(boost::any_cast<long>(m["OnDemandPercentageAboveBaseCapacity"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemovalPolicies") != m.end() && !m["RemovalPolicies"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RemovalPolicies"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RemovalPolicies"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      removalPolicies = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupName") != m.end() && !m["ScalingGroupName"].empty()) {
      scalingGroupName = make_shared<string>(boost::any_cast<string>(m["ScalingGroupName"]));
    }
    if (m.find("ScalingPolicy") != m.end() && !m["ScalingPolicy"].empty()) {
      scalingPolicy = make_shared<string>(boost::any_cast<string>(m["ScalingPolicy"]));
    }
    if (m.find("ServerGroups") != m.end() && !m["ServerGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["ServerGroups"].type()) {
        vector<CreateScalingGroupRequestServerGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServerGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingGroupRequestServerGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serverGroups = make_shared<vector<CreateScalingGroupRequestServerGroups>>(expect1);
      }
    }
    if (m.find("SpotAllocationStrategy") != m.end() && !m["SpotAllocationStrategy"].empty()) {
      spotAllocationStrategy = make_shared<string>(boost::any_cast<string>(m["SpotAllocationStrategy"]));
    }
    if (m.find("SpotInstancePools") != m.end() && !m["SpotInstancePools"].empty()) {
      spotInstancePools = make_shared<long>(boost::any_cast<long>(m["SpotInstancePools"]));
    }
    if (m.find("SpotInstanceRemedy") != m.end() && !m["SpotInstanceRemedy"].empty()) {
      spotInstanceRemedy = make_shared<bool>(boost::any_cast<bool>(m["SpotInstanceRemedy"]));
    }
    if (m.find("StopInstanceTimeout") != m.end() && !m["StopInstanceTimeout"].empty()) {
      stopInstanceTimeout = make_shared<long>(boost::any_cast<long>(m["StopInstanceTimeout"]));
    }
    if (m.find("SyncAlarmRuleToCms") != m.end() && !m["SyncAlarmRuleToCms"].empty()) {
      syncAlarmRuleToCms = make_shared<bool>(boost::any_cast<bool>(m["SyncAlarmRuleToCms"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<CreateScalingGroupRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingGroupRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<CreateScalingGroupRequestTags>>(expect1);
      }
    }
    if (m.find("VServerGroups") != m.end() && !m["VServerGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["VServerGroups"].type()) {
        vector<CreateScalingGroupRequestVServerGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VServerGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingGroupRequestVServerGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        VServerGroups = make_shared<vector<CreateScalingGroupRequestVServerGroups>>(expect1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateScalingGroupRequest() = default;
};
class CreateScalingGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> scalingGroupId{};

  CreateScalingGroupResponseBody() {}

  explicit CreateScalingGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~CreateScalingGroupResponseBody() = default;
};
class CreateScalingGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateScalingGroupResponseBody> body{};

  CreateScalingGroupResponse() {}

  explicit CreateScalingGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateScalingGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateScalingGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateScalingGroupResponse() = default;
};
class CreateScalingRuleRequestAlarmDimensions : public Darabonba::Model {
public:
  shared_ptr<string> dimensionKey{};
  shared_ptr<string> dimensionValue{};

  CreateScalingRuleRequestAlarmDimensions() {}

  explicit CreateScalingRuleRequestAlarmDimensions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimensionKey) {
      res["DimensionKey"] = boost::any(*dimensionKey);
    }
    if (dimensionValue) {
      res["DimensionValue"] = boost::any(*dimensionValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DimensionKey") != m.end() && !m["DimensionKey"].empty()) {
      dimensionKey = make_shared<string>(boost::any_cast<string>(m["DimensionKey"]));
    }
    if (m.find("DimensionValue") != m.end() && !m["DimensionValue"].empty()) {
      dimensionValue = make_shared<string>(boost::any_cast<string>(m["DimensionValue"]));
    }
  }


  virtual ~CreateScalingRuleRequestAlarmDimensions() = default;
};
class CreateScalingRuleRequestHybridMetricsDimensions : public Darabonba::Model {
public:
  shared_ptr<string> dimensionKey{};
  shared_ptr<string> dimensionValue{};

  CreateScalingRuleRequestHybridMetricsDimensions() {}

  explicit CreateScalingRuleRequestHybridMetricsDimensions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimensionKey) {
      res["DimensionKey"] = boost::any(*dimensionKey);
    }
    if (dimensionValue) {
      res["DimensionValue"] = boost::any(*dimensionValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DimensionKey") != m.end() && !m["DimensionKey"].empty()) {
      dimensionKey = make_shared<string>(boost::any_cast<string>(m["DimensionKey"]));
    }
    if (m.find("DimensionValue") != m.end() && !m["DimensionValue"].empty()) {
      dimensionValue = make_shared<string>(boost::any_cast<string>(m["DimensionValue"]));
    }
  }


  virtual ~CreateScalingRuleRequestHybridMetricsDimensions() = default;
};
class CreateScalingRuleRequestHybridMetrics : public Darabonba::Model {
public:
  shared_ptr<vector<CreateScalingRuleRequestHybridMetricsDimensions>> dimensions{};
  shared_ptr<string> expression{};
  shared_ptr<string> id{};
  shared_ptr<string> metricName{};
  shared_ptr<string> statistic{};

  CreateScalingRuleRequestHybridMetrics() {}

  explicit CreateScalingRuleRequestHybridMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimensions) {
      vector<boost::any> temp1;
      for(auto item1:*dimensions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dimensions"] = boost::any(temp1);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (statistic) {
      res["Statistic"] = boost::any(*statistic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      if (typeid(vector<boost::any>) == m["Dimensions"].type()) {
        vector<CreateScalingRuleRequestHybridMetricsDimensions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dimensions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingRuleRequestHybridMetricsDimensions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dimensions = make_shared<vector<CreateScalingRuleRequestHybridMetricsDimensions>>(expect1);
      }
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Statistic") != m.end() && !m["Statistic"].empty()) {
      statistic = make_shared<string>(boost::any_cast<string>(m["Statistic"]));
    }
  }


  virtual ~CreateScalingRuleRequestHybridMetrics() = default;
};
class CreateScalingRuleRequestStepAdjustments : public Darabonba::Model {
public:
  shared_ptr<double> metricIntervalLowerBound{};
  shared_ptr<double> metricIntervalUpperBound{};
  shared_ptr<long> scalingAdjustment{};

  CreateScalingRuleRequestStepAdjustments() {}

  explicit CreateScalingRuleRequestStepAdjustments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricIntervalLowerBound) {
      res["MetricIntervalLowerBound"] = boost::any(*metricIntervalLowerBound);
    }
    if (metricIntervalUpperBound) {
      res["MetricIntervalUpperBound"] = boost::any(*metricIntervalUpperBound);
    }
    if (scalingAdjustment) {
      res["ScalingAdjustment"] = boost::any(*scalingAdjustment);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricIntervalLowerBound") != m.end() && !m["MetricIntervalLowerBound"].empty()) {
      metricIntervalLowerBound = make_shared<double>(boost::any_cast<double>(m["MetricIntervalLowerBound"]));
    }
    if (m.find("MetricIntervalUpperBound") != m.end() && !m["MetricIntervalUpperBound"].empty()) {
      metricIntervalUpperBound = make_shared<double>(boost::any_cast<double>(m["MetricIntervalUpperBound"]));
    }
    if (m.find("ScalingAdjustment") != m.end() && !m["ScalingAdjustment"].empty()) {
      scalingAdjustment = make_shared<long>(boost::any_cast<long>(m["ScalingAdjustment"]));
    }
  }


  virtual ~CreateScalingRuleRequestStepAdjustments() = default;
};
class CreateScalingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> adjustmentType{};
  shared_ptr<long> adjustmentValue{};
  shared_ptr<vector<CreateScalingRuleRequestAlarmDimensions>> alarmDimensions{};
  shared_ptr<long> cooldown{};
  shared_ptr<bool> disableScaleIn{};
  shared_ptr<long> estimatedInstanceWarmup{};
  shared_ptr<vector<CreateScalingRuleRequestHybridMetrics>> hybridMetrics{};
  shared_ptr<string> hybridMonitorNamespace{};
  shared_ptr<long> initialMaxSize{};
  shared_ptr<string> metricName{};
  shared_ptr<string> metricType{};
  shared_ptr<long> minAdjustmentMagnitude{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> predictiveScalingMode{};
  shared_ptr<long> predictiveTaskBufferTime{};
  shared_ptr<string> predictiveValueBehavior{};
  shared_ptr<long> predictiveValueBuffer{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> scaleInEvaluationCount{};
  shared_ptr<long> scaleOutEvaluationCount{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> scalingRuleName{};
  shared_ptr<string> scalingRuleType{};
  shared_ptr<vector<CreateScalingRuleRequestStepAdjustments>> stepAdjustments{};
  shared_ptr<double> targetValue{};

  CreateScalingRuleRequest() {}

  explicit CreateScalingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjustmentType) {
      res["AdjustmentType"] = boost::any(*adjustmentType);
    }
    if (adjustmentValue) {
      res["AdjustmentValue"] = boost::any(*adjustmentValue);
    }
    if (alarmDimensions) {
      vector<boost::any> temp1;
      for(auto item1:*alarmDimensions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlarmDimensions"] = boost::any(temp1);
    }
    if (cooldown) {
      res["Cooldown"] = boost::any(*cooldown);
    }
    if (disableScaleIn) {
      res["DisableScaleIn"] = boost::any(*disableScaleIn);
    }
    if (estimatedInstanceWarmup) {
      res["EstimatedInstanceWarmup"] = boost::any(*estimatedInstanceWarmup);
    }
    if (hybridMetrics) {
      vector<boost::any> temp1;
      for(auto item1:*hybridMetrics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HybridMetrics"] = boost::any(temp1);
    }
    if (hybridMonitorNamespace) {
      res["HybridMonitorNamespace"] = boost::any(*hybridMonitorNamespace);
    }
    if (initialMaxSize) {
      res["InitialMaxSize"] = boost::any(*initialMaxSize);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (minAdjustmentMagnitude) {
      res["MinAdjustmentMagnitude"] = boost::any(*minAdjustmentMagnitude);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (predictiveScalingMode) {
      res["PredictiveScalingMode"] = boost::any(*predictiveScalingMode);
    }
    if (predictiveTaskBufferTime) {
      res["PredictiveTaskBufferTime"] = boost::any(*predictiveTaskBufferTime);
    }
    if (predictiveValueBehavior) {
      res["PredictiveValueBehavior"] = boost::any(*predictiveValueBehavior);
    }
    if (predictiveValueBuffer) {
      res["PredictiveValueBuffer"] = boost::any(*predictiveValueBuffer);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scaleInEvaluationCount) {
      res["ScaleInEvaluationCount"] = boost::any(*scaleInEvaluationCount);
    }
    if (scaleOutEvaluationCount) {
      res["ScaleOutEvaluationCount"] = boost::any(*scaleOutEvaluationCount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (scalingRuleName) {
      res["ScalingRuleName"] = boost::any(*scalingRuleName);
    }
    if (scalingRuleType) {
      res["ScalingRuleType"] = boost::any(*scalingRuleType);
    }
    if (stepAdjustments) {
      vector<boost::any> temp1;
      for(auto item1:*stepAdjustments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StepAdjustments"] = boost::any(temp1);
    }
    if (targetValue) {
      res["TargetValue"] = boost::any(*targetValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjustmentType") != m.end() && !m["AdjustmentType"].empty()) {
      adjustmentType = make_shared<string>(boost::any_cast<string>(m["AdjustmentType"]));
    }
    if (m.find("AdjustmentValue") != m.end() && !m["AdjustmentValue"].empty()) {
      adjustmentValue = make_shared<long>(boost::any_cast<long>(m["AdjustmentValue"]));
    }
    if (m.find("AlarmDimensions") != m.end() && !m["AlarmDimensions"].empty()) {
      if (typeid(vector<boost::any>) == m["AlarmDimensions"].type()) {
        vector<CreateScalingRuleRequestAlarmDimensions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlarmDimensions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingRuleRequestAlarmDimensions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alarmDimensions = make_shared<vector<CreateScalingRuleRequestAlarmDimensions>>(expect1);
      }
    }
    if (m.find("Cooldown") != m.end() && !m["Cooldown"].empty()) {
      cooldown = make_shared<long>(boost::any_cast<long>(m["Cooldown"]));
    }
    if (m.find("DisableScaleIn") != m.end() && !m["DisableScaleIn"].empty()) {
      disableScaleIn = make_shared<bool>(boost::any_cast<bool>(m["DisableScaleIn"]));
    }
    if (m.find("EstimatedInstanceWarmup") != m.end() && !m["EstimatedInstanceWarmup"].empty()) {
      estimatedInstanceWarmup = make_shared<long>(boost::any_cast<long>(m["EstimatedInstanceWarmup"]));
    }
    if (m.find("HybridMetrics") != m.end() && !m["HybridMetrics"].empty()) {
      if (typeid(vector<boost::any>) == m["HybridMetrics"].type()) {
        vector<CreateScalingRuleRequestHybridMetrics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HybridMetrics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingRuleRequestHybridMetrics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hybridMetrics = make_shared<vector<CreateScalingRuleRequestHybridMetrics>>(expect1);
      }
    }
    if (m.find("HybridMonitorNamespace") != m.end() && !m["HybridMonitorNamespace"].empty()) {
      hybridMonitorNamespace = make_shared<string>(boost::any_cast<string>(m["HybridMonitorNamespace"]));
    }
    if (m.find("InitialMaxSize") != m.end() && !m["InitialMaxSize"].empty()) {
      initialMaxSize = make_shared<long>(boost::any_cast<long>(m["InitialMaxSize"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("MinAdjustmentMagnitude") != m.end() && !m["MinAdjustmentMagnitude"].empty()) {
      minAdjustmentMagnitude = make_shared<long>(boost::any_cast<long>(m["MinAdjustmentMagnitude"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PredictiveScalingMode") != m.end() && !m["PredictiveScalingMode"].empty()) {
      predictiveScalingMode = make_shared<string>(boost::any_cast<string>(m["PredictiveScalingMode"]));
    }
    if (m.find("PredictiveTaskBufferTime") != m.end() && !m["PredictiveTaskBufferTime"].empty()) {
      predictiveTaskBufferTime = make_shared<long>(boost::any_cast<long>(m["PredictiveTaskBufferTime"]));
    }
    if (m.find("PredictiveValueBehavior") != m.end() && !m["PredictiveValueBehavior"].empty()) {
      predictiveValueBehavior = make_shared<string>(boost::any_cast<string>(m["PredictiveValueBehavior"]));
    }
    if (m.find("PredictiveValueBuffer") != m.end() && !m["PredictiveValueBuffer"].empty()) {
      predictiveValueBuffer = make_shared<long>(boost::any_cast<long>(m["PredictiveValueBuffer"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScaleInEvaluationCount") != m.end() && !m["ScaleInEvaluationCount"].empty()) {
      scaleInEvaluationCount = make_shared<long>(boost::any_cast<long>(m["ScaleInEvaluationCount"]));
    }
    if (m.find("ScaleOutEvaluationCount") != m.end() && !m["ScaleOutEvaluationCount"].empty()) {
      scaleOutEvaluationCount = make_shared<long>(boost::any_cast<long>(m["ScaleOutEvaluationCount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("ScalingRuleName") != m.end() && !m["ScalingRuleName"].empty()) {
      scalingRuleName = make_shared<string>(boost::any_cast<string>(m["ScalingRuleName"]));
    }
    if (m.find("ScalingRuleType") != m.end() && !m["ScalingRuleType"].empty()) {
      scalingRuleType = make_shared<string>(boost::any_cast<string>(m["ScalingRuleType"]));
    }
    if (m.find("StepAdjustments") != m.end() && !m["StepAdjustments"].empty()) {
      if (typeid(vector<boost::any>) == m["StepAdjustments"].type()) {
        vector<CreateScalingRuleRequestStepAdjustments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StepAdjustments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScalingRuleRequestStepAdjustments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stepAdjustments = make_shared<vector<CreateScalingRuleRequestStepAdjustments>>(expect1);
      }
    }
    if (m.find("TargetValue") != m.end() && !m["TargetValue"].empty()) {
      targetValue = make_shared<double>(boost::any_cast<double>(m["TargetValue"]));
    }
  }


  virtual ~CreateScalingRuleRequest() = default;
};
class CreateScalingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> scalingRuleAri{};
  shared_ptr<string> scalingRuleId{};

  CreateScalingRuleResponseBody() {}

  explicit CreateScalingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingRuleAri) {
      res["ScalingRuleAri"] = boost::any(*scalingRuleAri);
    }
    if (scalingRuleId) {
      res["ScalingRuleId"] = boost::any(*scalingRuleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingRuleAri") != m.end() && !m["ScalingRuleAri"].empty()) {
      scalingRuleAri = make_shared<string>(boost::any_cast<string>(m["ScalingRuleAri"]));
    }
    if (m.find("ScalingRuleId") != m.end() && !m["ScalingRuleId"].empty()) {
      scalingRuleId = make_shared<string>(boost::any_cast<string>(m["ScalingRuleId"]));
    }
  }


  virtual ~CreateScalingRuleResponseBody() = default;
};
class CreateScalingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateScalingRuleResponseBody> body{};

  CreateScalingRuleResponse() {}

  explicit CreateScalingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateScalingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateScalingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateScalingRuleResponse() = default;
};
class CreateScheduledTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> desiredCapacity{};
  shared_ptr<long> launchExpirationTime{};
  shared_ptr<string> launchTime{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minValue{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> recurrenceEndTime{};
  shared_ptr<string> recurrenceType{};
  shared_ptr<string> recurrenceValue{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> scheduledAction{};
  shared_ptr<string> scheduledTaskName{};
  shared_ptr<bool> taskEnabled{};

  CreateScheduledTaskRequest() {}

  explicit CreateScheduledTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (desiredCapacity) {
      res["DesiredCapacity"] = boost::any(*desiredCapacity);
    }
    if (launchExpirationTime) {
      res["LaunchExpirationTime"] = boost::any(*launchExpirationTime);
    }
    if (launchTime) {
      res["LaunchTime"] = boost::any(*launchTime);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (recurrenceEndTime) {
      res["RecurrenceEndTime"] = boost::any(*recurrenceEndTime);
    }
    if (recurrenceType) {
      res["RecurrenceType"] = boost::any(*recurrenceType);
    }
    if (recurrenceValue) {
      res["RecurrenceValue"] = boost::any(*recurrenceValue);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (scheduledAction) {
      res["ScheduledAction"] = boost::any(*scheduledAction);
    }
    if (scheduledTaskName) {
      res["ScheduledTaskName"] = boost::any(*scheduledTaskName);
    }
    if (taskEnabled) {
      res["TaskEnabled"] = boost::any(*taskEnabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DesiredCapacity") != m.end() && !m["DesiredCapacity"].empty()) {
      desiredCapacity = make_shared<long>(boost::any_cast<long>(m["DesiredCapacity"]));
    }
    if (m.find("LaunchExpirationTime") != m.end() && !m["LaunchExpirationTime"].empty()) {
      launchExpirationTime = make_shared<long>(boost::any_cast<long>(m["LaunchExpirationTime"]));
    }
    if (m.find("LaunchTime") != m.end() && !m["LaunchTime"].empty()) {
      launchTime = make_shared<string>(boost::any_cast<string>(m["LaunchTime"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RecurrenceEndTime") != m.end() && !m["RecurrenceEndTime"].empty()) {
      recurrenceEndTime = make_shared<string>(boost::any_cast<string>(m["RecurrenceEndTime"]));
    }
    if (m.find("RecurrenceType") != m.end() && !m["RecurrenceType"].empty()) {
      recurrenceType = make_shared<string>(boost::any_cast<string>(m["RecurrenceType"]));
    }
    if (m.find("RecurrenceValue") != m.end() && !m["RecurrenceValue"].empty()) {
      recurrenceValue = make_shared<string>(boost::any_cast<string>(m["RecurrenceValue"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("ScheduledAction") != m.end() && !m["ScheduledAction"].empty()) {
      scheduledAction = make_shared<string>(boost::any_cast<string>(m["ScheduledAction"]));
    }
    if (m.find("ScheduledTaskName") != m.end() && !m["ScheduledTaskName"].empty()) {
      scheduledTaskName = make_shared<string>(boost::any_cast<string>(m["ScheduledTaskName"]));
    }
    if (m.find("TaskEnabled") != m.end() && !m["TaskEnabled"].empty()) {
      taskEnabled = make_shared<bool>(boost::any_cast<bool>(m["TaskEnabled"]));
    }
  }


  virtual ~CreateScheduledTaskRequest() = default;
};
class CreateScheduledTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> scheduledTaskId{};

  CreateScheduledTaskResponseBody() {}

  explicit CreateScheduledTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduledTaskId) {
      res["ScheduledTaskId"] = boost::any(*scheduledTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScheduledTaskId") != m.end() && !m["ScheduledTaskId"].empty()) {
      scheduledTaskId = make_shared<string>(boost::any_cast<string>(m["ScheduledTaskId"]));
    }
  }


  virtual ~CreateScheduledTaskResponseBody() = default;
};
class CreateScheduledTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateScheduledTaskResponseBody> body{};

  CreateScheduledTaskResponse() {}

  explicit CreateScheduledTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateScheduledTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateScheduledTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateScheduledTaskResponse() = default;
};
class DeactivateScalingConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingConfigurationId{};

  DeactivateScalingConfigurationRequest() {}

  explicit DeactivateScalingConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingConfigurationId) {
      res["ScalingConfigurationId"] = boost::any(*scalingConfigurationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingConfigurationId") != m.end() && !m["ScalingConfigurationId"].empty()) {
      scalingConfigurationId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationId"]));
    }
  }


  virtual ~DeactivateScalingConfigurationRequest() = default;
};
class DeactivateScalingConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeactivateScalingConfigurationResponseBody() {}

  explicit DeactivateScalingConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeactivateScalingConfigurationResponseBody() = default;
};
class DeactivateScalingConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeactivateScalingConfigurationResponseBody> body{};

  DeactivateScalingConfigurationResponse() {}

  explicit DeactivateScalingConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeactivateScalingConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeactivateScalingConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~DeactivateScalingConfigurationResponse() = default;
};
class DeleteAlarmRequest : public Darabonba::Model {
public:
  shared_ptr<string> alarmTaskId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};

  DeleteAlarmRequest() {}

  explicit DeleteAlarmRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmTaskId) {
      res["AlarmTaskId"] = boost::any(*alarmTaskId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmTaskId") != m.end() && !m["AlarmTaskId"].empty()) {
      alarmTaskId = make_shared<string>(boost::any_cast<string>(m["AlarmTaskId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
  }


  virtual ~DeleteAlarmRequest() = default;
};
class DeleteAlarmResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> alarmTaskId{};
  shared_ptr<string> requestId{};

  DeleteAlarmResponseBody() {}

  explicit DeleteAlarmResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmTaskId) {
      res["AlarmTaskId"] = boost::any(*alarmTaskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmTaskId") != m.end() && !m["AlarmTaskId"].empty()) {
      alarmTaskId = make_shared<string>(boost::any_cast<string>(m["AlarmTaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAlarmResponseBody() = default;
};
class DeleteAlarmResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAlarmResponseBody> body{};

  DeleteAlarmResponse() {}

  explicit DeleteAlarmResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAlarmResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAlarmResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAlarmResponse() = default;
};
class DeleteEciScalingConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingConfigurationId{};

  DeleteEciScalingConfigurationRequest() {}

  explicit DeleteEciScalingConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingConfigurationId) {
      res["ScalingConfigurationId"] = boost::any(*scalingConfigurationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingConfigurationId") != m.end() && !m["ScalingConfigurationId"].empty()) {
      scalingConfigurationId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationId"]));
    }
  }


  virtual ~DeleteEciScalingConfigurationRequest() = default;
};
class DeleteEciScalingConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteEciScalingConfigurationResponseBody() {}

  explicit DeleteEciScalingConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEciScalingConfigurationResponseBody() = default;
};
class DeleteEciScalingConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEciScalingConfigurationResponseBody> body{};

  DeleteEciScalingConfigurationResponse() {}

  explicit DeleteEciScalingConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEciScalingConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEciScalingConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEciScalingConfigurationResponse() = default;
};
class DeleteLifecycleHookRequest : public Darabonba::Model {
public:
  shared_ptr<string> lifecycleHookId{};
  shared_ptr<string> lifecycleHookName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};

  DeleteLifecycleHookRequest() {}

  explicit DeleteLifecycleHookRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lifecycleHookId) {
      res["LifecycleHookId"] = boost::any(*lifecycleHookId);
    }
    if (lifecycleHookName) {
      res["LifecycleHookName"] = boost::any(*lifecycleHookName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LifecycleHookId") != m.end() && !m["LifecycleHookId"].empty()) {
      lifecycleHookId = make_shared<string>(boost::any_cast<string>(m["LifecycleHookId"]));
    }
    if (m.find("LifecycleHookName") != m.end() && !m["LifecycleHookName"].empty()) {
      lifecycleHookName = make_shared<string>(boost::any_cast<string>(m["LifecycleHookName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~DeleteLifecycleHookRequest() = default;
};
class DeleteLifecycleHookResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLifecycleHookResponseBody() {}

  explicit DeleteLifecycleHookResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLifecycleHookResponseBody() = default;
};
class DeleteLifecycleHookResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLifecycleHookResponseBody> body{};

  DeleteLifecycleHookResponse() {}

  explicit DeleteLifecycleHookResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLifecycleHookResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLifecycleHookResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLifecycleHookResponse() = default;
};
class DeleteNotificationConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> notificationArn{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};

  DeleteNotificationConfigurationRequest() {}

  explicit DeleteNotificationConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notificationArn) {
      res["NotificationArn"] = boost::any(*notificationArn);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotificationArn") != m.end() && !m["NotificationArn"].empty()) {
      notificationArn = make_shared<string>(boost::any_cast<string>(m["NotificationArn"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~DeleteNotificationConfigurationRequest() = default;
};
class DeleteNotificationConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteNotificationConfigurationResponseBody() {}

  explicit DeleteNotificationConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteNotificationConfigurationResponseBody() = default;
};
class DeleteNotificationConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNotificationConfigurationResponseBody> body{};

  DeleteNotificationConfigurationResponse() {}

  explicit DeleteNotificationConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNotificationConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNotificationConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNotificationConfigurationResponse() = default;
};
class DeleteScalingConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingConfigurationId{};

  DeleteScalingConfigurationRequest() {}

  explicit DeleteScalingConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingConfigurationId) {
      res["ScalingConfigurationId"] = boost::any(*scalingConfigurationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingConfigurationId") != m.end() && !m["ScalingConfigurationId"].empty()) {
      scalingConfigurationId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationId"]));
    }
  }


  virtual ~DeleteScalingConfigurationRequest() = default;
};
class DeleteScalingConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteScalingConfigurationResponseBody() {}

  explicit DeleteScalingConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteScalingConfigurationResponseBody() = default;
};
class DeleteScalingConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteScalingConfigurationResponseBody> body{};

  DeleteScalingConfigurationResponse() {}

  explicit DeleteScalingConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteScalingConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteScalingConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteScalingConfigurationResponse() = default;
};
class DeleteScalingGroupRequest : public Darabonba::Model {
public:
  shared_ptr<bool> forceDelete{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};

  DeleteScalingGroupRequest() {}

  explicit DeleteScalingGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forceDelete) {
      res["ForceDelete"] = boost::any(*forceDelete);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForceDelete") != m.end() && !m["ForceDelete"].empty()) {
      forceDelete = make_shared<bool>(boost::any_cast<bool>(m["ForceDelete"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~DeleteScalingGroupRequest() = default;
};
class DeleteScalingGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteScalingGroupResponseBody() {}

  explicit DeleteScalingGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteScalingGroupResponseBody() = default;
};
class DeleteScalingGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteScalingGroupResponseBody> body{};

  DeleteScalingGroupResponse() {}

  explicit DeleteScalingGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteScalingGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteScalingGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteScalingGroupResponse() = default;
};
class DeleteScalingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingRuleId{};

  DeleteScalingRuleRequest() {}

  explicit DeleteScalingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingRuleId) {
      res["ScalingRuleId"] = boost::any(*scalingRuleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingRuleId") != m.end() && !m["ScalingRuleId"].empty()) {
      scalingRuleId = make_shared<string>(boost::any_cast<string>(m["ScalingRuleId"]));
    }
  }


  virtual ~DeleteScalingRuleRequest() = default;
};
class DeleteScalingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteScalingRuleResponseBody() {}

  explicit DeleteScalingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteScalingRuleResponseBody() = default;
};
class DeleteScalingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteScalingRuleResponseBody> body{};

  DeleteScalingRuleResponse() {}

  explicit DeleteScalingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteScalingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteScalingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteScalingRuleResponse() = default;
};
class DeleteScheduledTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scheduledTaskId{};

  DeleteScheduledTaskRequest() {}

  explicit DeleteScheduledTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scheduledTaskId) {
      res["ScheduledTaskId"] = boost::any(*scheduledTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScheduledTaskId") != m.end() && !m["ScheduledTaskId"].empty()) {
      scheduledTaskId = make_shared<string>(boost::any_cast<string>(m["ScheduledTaskId"]));
    }
  }


  virtual ~DeleteScheduledTaskRequest() = default;
};
class DeleteScheduledTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteScheduledTaskResponseBody() {}

  explicit DeleteScheduledTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteScheduledTaskResponseBody() = default;
};
class DeleteScheduledTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteScheduledTaskResponseBody> body{};

  DeleteScheduledTaskResponse() {}

  explicit DeleteScheduledTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteScheduledTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteScheduledTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteScheduledTaskResponse() = default;
};
class DescribeAlarmsRequest : public Darabonba::Model {
public:
  shared_ptr<string> alarmTaskId{};
  shared_ptr<bool> isEnable{};
  shared_ptr<string> metricName{};
  shared_ptr<string> metricType{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> state{};

  DescribeAlarmsRequest() {}

  explicit DescribeAlarmsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmTaskId) {
      res["AlarmTaskId"] = boost::any(*alarmTaskId);
    }
    if (isEnable) {
      res["IsEnable"] = boost::any(*isEnable);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmTaskId") != m.end() && !m["AlarmTaskId"].empty()) {
      alarmTaskId = make_shared<string>(boost::any_cast<string>(m["AlarmTaskId"]));
    }
    if (m.find("IsEnable") != m.end() && !m["IsEnable"].empty()) {
      isEnable = make_shared<bool>(boost::any_cast<bool>(m["IsEnable"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~DescribeAlarmsRequest() = default;
};
class DescribeAlarmsResponseBodyAlarmListDimensions : public Darabonba::Model {
public:
  shared_ptr<string> dimensionKey{};
  shared_ptr<string> dimensionValue{};

  DescribeAlarmsResponseBodyAlarmListDimensions() {}

  explicit DescribeAlarmsResponseBodyAlarmListDimensions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimensionKey) {
      res["DimensionKey"] = boost::any(*dimensionKey);
    }
    if (dimensionValue) {
      res["DimensionValue"] = boost::any(*dimensionValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DimensionKey") != m.end() && !m["DimensionKey"].empty()) {
      dimensionKey = make_shared<string>(boost::any_cast<string>(m["DimensionKey"]));
    }
    if (m.find("DimensionValue") != m.end() && !m["DimensionValue"].empty()) {
      dimensionValue = make_shared<string>(boost::any_cast<string>(m["DimensionValue"]));
    }
  }


  virtual ~DescribeAlarmsResponseBodyAlarmListDimensions() = default;
};
class DescribeAlarmsResponseBodyAlarmListExpressions : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> metricName{};
  shared_ptr<long> period{};
  shared_ptr<string> statistics{};
  shared_ptr<double> threshold{};

  DescribeAlarmsResponseBodyAlarmListExpressions() {}

  explicit DescribeAlarmsResponseBodyAlarmListExpressions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
  }


  virtual ~DescribeAlarmsResponseBodyAlarmListExpressions() = default;
};
class DescribeAlarmsResponseBodyAlarmListHybridMetricsDimensions : public Darabonba::Model {
public:
  shared_ptr<string> dimensionKey{};
  shared_ptr<string> dimensionValue{};

  DescribeAlarmsResponseBodyAlarmListHybridMetricsDimensions() {}

  explicit DescribeAlarmsResponseBodyAlarmListHybridMetricsDimensions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimensionKey) {
      res["DimensionKey"] = boost::any(*dimensionKey);
    }
    if (dimensionValue) {
      res["DimensionValue"] = boost::any(*dimensionValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DimensionKey") != m.end() && !m["DimensionKey"].empty()) {
      dimensionKey = make_shared<string>(boost::any_cast<string>(m["DimensionKey"]));
    }
    if (m.find("DimensionValue") != m.end() && !m["DimensionValue"].empty()) {
      dimensionValue = make_shared<string>(boost::any_cast<string>(m["DimensionValue"]));
    }
  }


  virtual ~DescribeAlarmsResponseBodyAlarmListHybridMetricsDimensions() = default;
};
class DescribeAlarmsResponseBodyAlarmListHybridMetrics : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAlarmsResponseBodyAlarmListHybridMetricsDimensions>> dimensions{};
  shared_ptr<string> expression{};
  shared_ptr<string> id{};
  shared_ptr<string> metricName{};
  shared_ptr<string> statistic{};

  DescribeAlarmsResponseBodyAlarmListHybridMetrics() {}

  explicit DescribeAlarmsResponseBodyAlarmListHybridMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimensions) {
      vector<boost::any> temp1;
      for(auto item1:*dimensions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dimensions"] = boost::any(temp1);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (statistic) {
      res["Statistic"] = boost::any(*statistic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      if (typeid(vector<boost::any>) == m["Dimensions"].type()) {
        vector<DescribeAlarmsResponseBodyAlarmListHybridMetricsDimensions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dimensions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAlarmsResponseBodyAlarmListHybridMetricsDimensions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dimensions = make_shared<vector<DescribeAlarmsResponseBodyAlarmListHybridMetricsDimensions>>(expect1);
      }
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Statistic") != m.end() && !m["Statistic"].empty()) {
      statistic = make_shared<string>(boost::any_cast<string>(m["Statistic"]));
    }
  }


  virtual ~DescribeAlarmsResponseBodyAlarmListHybridMetrics() = default;
};
class DescribeAlarmsResponseBodyAlarmList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> alarmActions{};
  shared_ptr<string> alarmTaskId{};
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> description{};
  shared_ptr<vector<DescribeAlarmsResponseBodyAlarmListDimensions>> dimensions{};
  shared_ptr<string> effective{};
  shared_ptr<bool> enable{};
  shared_ptr<long> evaluationCount{};
  shared_ptr<vector<DescribeAlarmsResponseBodyAlarmListExpressions>> expressions{};
  shared_ptr<string> expressionsLogicOperator{};
  shared_ptr<vector<DescribeAlarmsResponseBodyAlarmListHybridMetrics>> hybridMetrics{};
  shared_ptr<string> hybridMonitorNamespace{};
  shared_ptr<string> metricName{};
  shared_ptr<string> metricType{};
  shared_ptr<string> name{};
  shared_ptr<long> period{};
  shared_ptr<string> promQL{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> state{};
  shared_ptr<string> statistics{};
  shared_ptr<double> threshold{};

  DescribeAlarmsResponseBodyAlarmList() {}

  explicit DescribeAlarmsResponseBodyAlarmList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmActions) {
      res["AlarmActions"] = boost::any(*alarmActions);
    }
    if (alarmTaskId) {
      res["AlarmTaskId"] = boost::any(*alarmTaskId);
    }
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dimensions) {
      vector<boost::any> temp1;
      for(auto item1:*dimensions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dimensions"] = boost::any(temp1);
    }
    if (effective) {
      res["Effective"] = boost::any(*effective);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (expressions) {
      vector<boost::any> temp1;
      for(auto item1:*expressions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Expressions"] = boost::any(temp1);
    }
    if (expressionsLogicOperator) {
      res["ExpressionsLogicOperator"] = boost::any(*expressionsLogicOperator);
    }
    if (hybridMetrics) {
      vector<boost::any> temp1;
      for(auto item1:*hybridMetrics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HybridMetrics"] = boost::any(temp1);
    }
    if (hybridMonitorNamespace) {
      res["HybridMonitorNamespace"] = boost::any(*hybridMonitorNamespace);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (promQL) {
      res["PromQL"] = boost::any(*promQL);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmActions") != m.end() && !m["AlarmActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AlarmActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AlarmActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      alarmActions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AlarmTaskId") != m.end() && !m["AlarmTaskId"].empty()) {
      alarmTaskId = make_shared<string>(boost::any_cast<string>(m["AlarmTaskId"]));
    }
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      if (typeid(vector<boost::any>) == m["Dimensions"].type()) {
        vector<DescribeAlarmsResponseBodyAlarmListDimensions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dimensions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAlarmsResponseBodyAlarmListDimensions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dimensions = make_shared<vector<DescribeAlarmsResponseBodyAlarmListDimensions>>(expect1);
      }
    }
    if (m.find("Effective") != m.end() && !m["Effective"].empty()) {
      effective = make_shared<string>(boost::any_cast<string>(m["Effective"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("Expressions") != m.end() && !m["Expressions"].empty()) {
      if (typeid(vector<boost::any>) == m["Expressions"].type()) {
        vector<DescribeAlarmsResponseBodyAlarmListExpressions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Expressions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAlarmsResponseBodyAlarmListExpressions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        expressions = make_shared<vector<DescribeAlarmsResponseBodyAlarmListExpressions>>(expect1);
      }
    }
    if (m.find("ExpressionsLogicOperator") != m.end() && !m["ExpressionsLogicOperator"].empty()) {
      expressionsLogicOperator = make_shared<string>(boost::any_cast<string>(m["ExpressionsLogicOperator"]));
    }
    if (m.find("HybridMetrics") != m.end() && !m["HybridMetrics"].empty()) {
      if (typeid(vector<boost::any>) == m["HybridMetrics"].type()) {
        vector<DescribeAlarmsResponseBodyAlarmListHybridMetrics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HybridMetrics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAlarmsResponseBodyAlarmListHybridMetrics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hybridMetrics = make_shared<vector<DescribeAlarmsResponseBodyAlarmListHybridMetrics>>(expect1);
      }
    }
    if (m.find("HybridMonitorNamespace") != m.end() && !m["HybridMonitorNamespace"].empty()) {
      hybridMonitorNamespace = make_shared<string>(boost::any_cast<string>(m["HybridMonitorNamespace"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PromQL") != m.end() && !m["PromQL"].empty()) {
      promQL = make_shared<string>(boost::any_cast<string>(m["PromQL"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
  }


  virtual ~DescribeAlarmsResponseBodyAlarmList() = default;
};
class DescribeAlarmsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAlarmsResponseBodyAlarmList>> alarmList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeAlarmsResponseBody() {}

  explicit DescribeAlarmsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmList) {
      vector<boost::any> temp1;
      for(auto item1:*alarmList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlarmList"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmList") != m.end() && !m["AlarmList"].empty()) {
      if (typeid(vector<boost::any>) == m["AlarmList"].type()) {
        vector<DescribeAlarmsResponseBodyAlarmList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlarmList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAlarmsResponseBodyAlarmList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alarmList = make_shared<vector<DescribeAlarmsResponseBodyAlarmList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAlarmsResponseBody() = default;
};
class DescribeAlarmsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAlarmsResponseBody> body{};

  DescribeAlarmsResponse() {}

  explicit DescribeAlarmsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAlarmsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAlarmsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAlarmsResponse() = default;
};
class DescribeAlertConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};

  DescribeAlertConfigurationRequest() {}

  explicit DescribeAlertConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~DescribeAlertConfigurationRequest() = default;
};
class DescribeAlertConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> scaleStatuses{};

  DescribeAlertConfigurationResponseBody() {}

  explicit DescribeAlertConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scaleStatuses) {
      res["ScaleStatuses"] = boost::any(*scaleStatuses);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScaleStatuses") != m.end() && !m["ScaleStatuses"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScaleStatuses"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScaleStatuses"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scaleStatuses = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAlertConfigurationResponseBody() = default;
};
class DescribeAlertConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAlertConfigurationResponseBody> body{};

  DescribeAlertConfigurationResponse() {}

  explicit DescribeAlertConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAlertConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAlertConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAlertConfigurationResponse() = default;
};
class DescribeDiagnoseReportsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> reportIds{};
  shared_ptr<string> scalingGroupId{};

  DescribeDiagnoseReportsRequest() {}

  explicit DescribeDiagnoseReportsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reportIds) {
      res["ReportIds"] = boost::any(*reportIds);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReportIds") != m.end() && !m["ReportIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReportIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReportIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      reportIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~DescribeDiagnoseReportsRequest() = default;
};
class DescribeDiagnoseReportsResponseBodyReportsDetails : public Darabonba::Model {
public:
  shared_ptr<string> diagnoseType{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> status{};

  DescribeDiagnoseReportsResponseBodyReportsDetails() {}

  explicit DescribeDiagnoseReportsResponseBodyReportsDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diagnoseType) {
      res["DiagnoseType"] = boost::any(*diagnoseType);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiagnoseType") != m.end() && !m["DiagnoseType"].empty()) {
      diagnoseType = make_shared<string>(boost::any_cast<string>(m["DiagnoseType"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDiagnoseReportsResponseBodyReportsDetails() = default;
};
class DescribeDiagnoseReportsResponseBodyReports : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<vector<DescribeDiagnoseReportsResponseBodyReportsDetails>> details{};
  shared_ptr<string> diagnoseStatus{};
  shared_ptr<string> processStatus{};
  shared_ptr<string> regionId{};
  shared_ptr<string> reportId{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> userId{};

  DescribeDiagnoseReportsResponseBodyReports() {}

  explicit DescribeDiagnoseReportsResponseBodyReports(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (details) {
      vector<boost::any> temp1;
      for(auto item1:*details){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Details"] = boost::any(temp1);
    }
    if (diagnoseStatus) {
      res["DiagnoseStatus"] = boost::any(*diagnoseStatus);
    }
    if (processStatus) {
      res["ProcessStatus"] = boost::any(*processStatus);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      if (typeid(vector<boost::any>) == m["Details"].type()) {
        vector<DescribeDiagnoseReportsResponseBodyReportsDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Details"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDiagnoseReportsResponseBodyReportsDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        details = make_shared<vector<DescribeDiagnoseReportsResponseBodyReportsDetails>>(expect1);
      }
    }
    if (m.find("DiagnoseStatus") != m.end() && !m["DiagnoseStatus"].empty()) {
      diagnoseStatus = make_shared<string>(boost::any_cast<string>(m["DiagnoseStatus"]));
    }
    if (m.find("ProcessStatus") != m.end() && !m["ProcessStatus"].empty()) {
      processStatus = make_shared<string>(boost::any_cast<string>(m["ProcessStatus"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~DescribeDiagnoseReportsResponseBodyReports() = default;
};
class DescribeDiagnoseReportsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeDiagnoseReportsResponseBodyReports>> reports{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDiagnoseReportsResponseBody() {}

  explicit DescribeDiagnoseReportsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (reports) {
      vector<boost::any> temp1;
      for(auto item1:*reports){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Reports"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Reports") != m.end() && !m["Reports"].empty()) {
      if (typeid(vector<boost::any>) == m["Reports"].type()) {
        vector<DescribeDiagnoseReportsResponseBodyReports> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Reports"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDiagnoseReportsResponseBodyReports model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reports = make_shared<vector<DescribeDiagnoseReportsResponseBodyReports>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDiagnoseReportsResponseBody() = default;
};
class DescribeDiagnoseReportsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDiagnoseReportsResponseBody> body{};

  DescribeDiagnoseReportsResponse() {}

  explicit DescribeDiagnoseReportsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDiagnoseReportsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDiagnoseReportsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDiagnoseReportsResponse() = default;
};
class DescribeEciScalingConfigurationDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> outputFormat{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scalingConfigurationId{};
  shared_ptr<string> scalingGroupId{};

  DescribeEciScalingConfigurationDetailRequest() {}

  explicit DescribeEciScalingConfigurationDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputFormat) {
      res["OutputFormat"] = boost::any(*outputFormat);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scalingConfigurationId) {
      res["ScalingConfigurationId"] = boost::any(*scalingConfigurationId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputFormat") != m.end() && !m["OutputFormat"].empty()) {
      outputFormat = make_shared<string>(boost::any_cast<string>(m["OutputFormat"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScalingConfigurationId") != m.end() && !m["ScalingConfigurationId"].empty()) {
      scalingConfigurationId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationDetailRequest() = default;
};
class DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationAcrRegistryInfos : public Darabonba::Model {
public:
  shared_ptr<vector<string>> domains{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> regionId{};

  DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationAcrRegistryInfos() {}

  explicit DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationAcrRegistryInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = boost::any(*domains);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Domains"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domains = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationAcrRegistryInfos() = default;
};
class DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainersEnvironmentVars : public Darabonba::Model {
public:
  shared_ptr<string> fieldRefFieldPath{};
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainersEnvironmentVars() {}

  explicit DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainersEnvironmentVars(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldRefFieldPath) {
      res["FieldRefFieldPath"] = boost::any(*fieldRefFieldPath);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldRefFieldPath") != m.end() && !m["FieldRefFieldPath"].empty()) {
      fieldRefFieldPath = make_shared<string>(boost::any_cast<string>(m["FieldRefFieldPath"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainersEnvironmentVars() = default;
};
class DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainersPorts : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> protocol{};

  DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainersPorts() {}

  explicit DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainersPorts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainersPorts() = default;
};
class DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainersVolumeMounts : public Darabonba::Model {
public:
  shared_ptr<string> mountPath{};
  shared_ptr<string> mountPropagation{};
  shared_ptr<string> name{};
  shared_ptr<bool> readOnly{};
  shared_ptr<string> subPath{};

  DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainersVolumeMounts() {}

  explicit DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainersVolumeMounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountPath) {
      res["MountPath"] = boost::any(*mountPath);
    }
    if (mountPropagation) {
      res["MountPropagation"] = boost::any(*mountPropagation);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    if (subPath) {
      res["SubPath"] = boost::any(*subPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MountPath") != m.end() && !m["MountPath"].empty()) {
      mountPath = make_shared<string>(boost::any_cast<string>(m["MountPath"]));
    }
    if (m.find("MountPropagation") != m.end() && !m["MountPropagation"].empty()) {
      mountPropagation = make_shared<string>(boost::any_cast<string>(m["MountPropagation"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
    if (m.find("SubPath") != m.end() && !m["SubPath"].empty()) {
      subPath = make_shared<string>(boost::any_cast<string>(m["SubPath"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainersVolumeMounts() = default;
};
class DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainers : public Darabonba::Model {
public:
  shared_ptr<vector<string>> args{};
  shared_ptr<vector<string>> commands{};
  shared_ptr<double> cpu{};
  shared_ptr<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainersEnvironmentVars>> environmentVars{};
  shared_ptr<long> gpu{};
  shared_ptr<string> image{};
  shared_ptr<string> imagePullPolicy{};
  shared_ptr<vector<string>> lifecyclePostStartHandlerExecs{};
  shared_ptr<string> lifecyclePostStartHandlerHttpGetHost{};
  shared_ptr<string> lifecyclePostStartHandlerHttpGetPath{};
  shared_ptr<long> lifecyclePostStartHandlerHttpGetPort{};
  shared_ptr<string> lifecyclePostStartHandlerHttpGetScheme{};
  shared_ptr<string> lifecyclePostStartHandlerTcpSocketHost{};
  shared_ptr<long> lifecyclePostStartHandlerTcpSocketPort{};
  shared_ptr<vector<string>> lifecyclePreStopHandlerExecs{};
  shared_ptr<string> lifecyclePreStopHandlerHttpGetHost{};
  shared_ptr<string> lifecyclePreStopHandlerHttpGetPath{};
  shared_ptr<long> lifecyclePreStopHandlerHttpGetPort{};
  shared_ptr<string> lifecyclePreStopHandlerHttpGetScheme{};
  shared_ptr<string> lifecyclePreStopHandlerTcpSocketHost{};
  shared_ptr<long> lifecyclePreStopHandlerTcpSocketPort{};
  shared_ptr<vector<string>> livenessProbeExecCommands{};
  shared_ptr<long> livenessProbeFailureThreshold{};
  shared_ptr<string> livenessProbeHttpGetPath{};
  shared_ptr<long> livenessProbeHttpGetPort{};
  shared_ptr<string> livenessProbeHttpGetScheme{};
  shared_ptr<long> livenessProbeInitialDelaySeconds{};
  shared_ptr<long> livenessProbePeriodSeconds{};
  shared_ptr<long> livenessProbeSuccessThreshold{};
  shared_ptr<long> livenessProbeTcpSocketPort{};
  shared_ptr<long> livenessProbeTimeoutSeconds{};
  shared_ptr<double> memory{};
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainersPorts>> ports{};
  shared_ptr<vector<string>> readinessProbeExecCommands{};
  shared_ptr<long> readinessProbeFailureThreshold{};
  shared_ptr<string> readinessProbeHttpGetPath{};
  shared_ptr<long> readinessProbeHttpGetPort{};
  shared_ptr<string> readinessProbeHttpGetScheme{};
  shared_ptr<long> readinessProbeInitialDelaySeconds{};
  shared_ptr<long> readinessProbePeriodSeconds{};
  shared_ptr<long> readinessProbeSuccessThreshold{};
  shared_ptr<long> readinessProbeTcpSocketPort{};
  shared_ptr<long> readinessProbeTimeoutSeconds{};
  shared_ptr<vector<string>> securityContextCapabilityAdds{};
  shared_ptr<bool> securityContextReadOnlyRootFilesystem{};
  shared_ptr<long> securityContextRunAsUser{};
  shared_ptr<bool> stdin{};
  shared_ptr<bool> stdinOnce{};
  shared_ptr<bool> tty{};
  shared_ptr<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainersVolumeMounts>> volumeMounts{};
  shared_ptr<string> workingDir{};

  DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainers() {}

  explicit DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (args) {
      res["Args"] = boost::any(*args);
    }
    if (commands) {
      res["Commands"] = boost::any(*commands);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (environmentVars) {
      vector<boost::any> temp1;
      for(auto item1:*environmentVars){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnvironmentVars"] = boost::any(temp1);
    }
    if (gpu) {
      res["Gpu"] = boost::any(*gpu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (imagePullPolicy) {
      res["ImagePullPolicy"] = boost::any(*imagePullPolicy);
    }
    if (lifecyclePostStartHandlerExecs) {
      res["LifecyclePostStartHandlerExecs"] = boost::any(*lifecyclePostStartHandlerExecs);
    }
    if (lifecyclePostStartHandlerHttpGetHost) {
      res["LifecyclePostStartHandlerHttpGetHost"] = boost::any(*lifecyclePostStartHandlerHttpGetHost);
    }
    if (lifecyclePostStartHandlerHttpGetPath) {
      res["LifecyclePostStartHandlerHttpGetPath"] = boost::any(*lifecyclePostStartHandlerHttpGetPath);
    }
    if (lifecyclePostStartHandlerHttpGetPort) {
      res["LifecyclePostStartHandlerHttpGetPort"] = boost::any(*lifecyclePostStartHandlerHttpGetPort);
    }
    if (lifecyclePostStartHandlerHttpGetScheme) {
      res["LifecyclePostStartHandlerHttpGetScheme"] = boost::any(*lifecyclePostStartHandlerHttpGetScheme);
    }
    if (lifecyclePostStartHandlerTcpSocketHost) {
      res["LifecyclePostStartHandlerTcpSocketHost"] = boost::any(*lifecyclePostStartHandlerTcpSocketHost);
    }
    if (lifecyclePostStartHandlerTcpSocketPort) {
      res["LifecyclePostStartHandlerTcpSocketPort"] = boost::any(*lifecyclePostStartHandlerTcpSocketPort);
    }
    if (lifecyclePreStopHandlerExecs) {
      res["LifecyclePreStopHandlerExecs"] = boost::any(*lifecyclePreStopHandlerExecs);
    }
    if (lifecyclePreStopHandlerHttpGetHost) {
      res["LifecyclePreStopHandlerHttpGetHost"] = boost::any(*lifecyclePreStopHandlerHttpGetHost);
    }
    if (lifecyclePreStopHandlerHttpGetPath) {
      res["LifecyclePreStopHandlerHttpGetPath"] = boost::any(*lifecyclePreStopHandlerHttpGetPath);
    }
    if (lifecyclePreStopHandlerHttpGetPort) {
      res["LifecyclePreStopHandlerHttpGetPort"] = boost::any(*lifecyclePreStopHandlerHttpGetPort);
    }
    if (lifecyclePreStopHandlerHttpGetScheme) {
      res["LifecyclePreStopHandlerHttpGetScheme"] = boost::any(*lifecyclePreStopHandlerHttpGetScheme);
    }
    if (lifecyclePreStopHandlerTcpSocketHost) {
      res["LifecyclePreStopHandlerTcpSocketHost"] = boost::any(*lifecyclePreStopHandlerTcpSocketHost);
    }
    if (lifecyclePreStopHandlerTcpSocketPort) {
      res["LifecyclePreStopHandlerTcpSocketPort"] = boost::any(*lifecyclePreStopHandlerTcpSocketPort);
    }
    if (livenessProbeExecCommands) {
      res["LivenessProbeExecCommands"] = boost::any(*livenessProbeExecCommands);
    }
    if (livenessProbeFailureThreshold) {
      res["LivenessProbeFailureThreshold"] = boost::any(*livenessProbeFailureThreshold);
    }
    if (livenessProbeHttpGetPath) {
      res["LivenessProbeHttpGetPath"] = boost::any(*livenessProbeHttpGetPath);
    }
    if (livenessProbeHttpGetPort) {
      res["LivenessProbeHttpGetPort"] = boost::any(*livenessProbeHttpGetPort);
    }
    if (livenessProbeHttpGetScheme) {
      res["LivenessProbeHttpGetScheme"] = boost::any(*livenessProbeHttpGetScheme);
    }
    if (livenessProbeInitialDelaySeconds) {
      res["LivenessProbeInitialDelaySeconds"] = boost::any(*livenessProbeInitialDelaySeconds);
    }
    if (livenessProbePeriodSeconds) {
      res["LivenessProbePeriodSeconds"] = boost::any(*livenessProbePeriodSeconds);
    }
    if (livenessProbeSuccessThreshold) {
      res["LivenessProbeSuccessThreshold"] = boost::any(*livenessProbeSuccessThreshold);
    }
    if (livenessProbeTcpSocketPort) {
      res["LivenessProbeTcpSocketPort"] = boost::any(*livenessProbeTcpSocketPort);
    }
    if (livenessProbeTimeoutSeconds) {
      res["LivenessProbeTimeoutSeconds"] = boost::any(*livenessProbeTimeoutSeconds);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ports) {
      vector<boost::any> temp1;
      for(auto item1:*ports){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ports"] = boost::any(temp1);
    }
    if (readinessProbeExecCommands) {
      res["ReadinessProbeExecCommands"] = boost::any(*readinessProbeExecCommands);
    }
    if (readinessProbeFailureThreshold) {
      res["ReadinessProbeFailureThreshold"] = boost::any(*readinessProbeFailureThreshold);
    }
    if (readinessProbeHttpGetPath) {
      res["ReadinessProbeHttpGetPath"] = boost::any(*readinessProbeHttpGetPath);
    }
    if (readinessProbeHttpGetPort) {
      res["ReadinessProbeHttpGetPort"] = boost::any(*readinessProbeHttpGetPort);
    }
    if (readinessProbeHttpGetScheme) {
      res["ReadinessProbeHttpGetScheme"] = boost::any(*readinessProbeHttpGetScheme);
    }
    if (readinessProbeInitialDelaySeconds) {
      res["ReadinessProbeInitialDelaySeconds"] = boost::any(*readinessProbeInitialDelaySeconds);
    }
    if (readinessProbePeriodSeconds) {
      res["ReadinessProbePeriodSeconds"] = boost::any(*readinessProbePeriodSeconds);
    }
    if (readinessProbeSuccessThreshold) {
      res["ReadinessProbeSuccessThreshold"] = boost::any(*readinessProbeSuccessThreshold);
    }
    if (readinessProbeTcpSocketPort) {
      res["ReadinessProbeTcpSocketPort"] = boost::any(*readinessProbeTcpSocketPort);
    }
    if (readinessProbeTimeoutSeconds) {
      res["ReadinessProbeTimeoutSeconds"] = boost::any(*readinessProbeTimeoutSeconds);
    }
    if (securityContextCapabilityAdds) {
      res["SecurityContextCapabilityAdds"] = boost::any(*securityContextCapabilityAdds);
    }
    if (securityContextReadOnlyRootFilesystem) {
      res["SecurityContextReadOnlyRootFilesystem"] = boost::any(*securityContextReadOnlyRootFilesystem);
    }
    if (securityContextRunAsUser) {
      res["SecurityContextRunAsUser"] = boost::any(*securityContextRunAsUser);
    }
    if (stdin) {
      res["Stdin"] = boost::any(*stdin);
    }
    if (stdinOnce) {
      res["StdinOnce"] = boost::any(*stdinOnce);
    }
    if (tty) {
      res["Tty"] = boost::any(*tty);
    }
    if (volumeMounts) {
      vector<boost::any> temp1;
      for(auto item1:*volumeMounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VolumeMounts"] = boost::any(temp1);
    }
    if (workingDir) {
      res["WorkingDir"] = boost::any(*workingDir);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Args") != m.end() && !m["Args"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Args"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Args"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      args = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Commands") != m.end() && !m["Commands"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Commands"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Commands"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      commands = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<double>(boost::any_cast<double>(m["Cpu"]));
    }
    if (m.find("EnvironmentVars") != m.end() && !m["EnvironmentVars"].empty()) {
      if (typeid(vector<boost::any>) == m["EnvironmentVars"].type()) {
        vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainersEnvironmentVars> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnvironmentVars"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainersEnvironmentVars model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        environmentVars = make_shared<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainersEnvironmentVars>>(expect1);
      }
    }
    if (m.find("Gpu") != m.end() && !m["Gpu"].empty()) {
      gpu = make_shared<long>(boost::any_cast<long>(m["Gpu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ImagePullPolicy") != m.end() && !m["ImagePullPolicy"].empty()) {
      imagePullPolicy = make_shared<string>(boost::any_cast<string>(m["ImagePullPolicy"]));
    }
    if (m.find("LifecyclePostStartHandlerExecs") != m.end() && !m["LifecyclePostStartHandlerExecs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LifecyclePostStartHandlerExecs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LifecyclePostStartHandlerExecs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      lifecyclePostStartHandlerExecs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LifecyclePostStartHandlerHttpGetHost") != m.end() && !m["LifecyclePostStartHandlerHttpGetHost"].empty()) {
      lifecyclePostStartHandlerHttpGetHost = make_shared<string>(boost::any_cast<string>(m["LifecyclePostStartHandlerHttpGetHost"]));
    }
    if (m.find("LifecyclePostStartHandlerHttpGetPath") != m.end() && !m["LifecyclePostStartHandlerHttpGetPath"].empty()) {
      lifecyclePostStartHandlerHttpGetPath = make_shared<string>(boost::any_cast<string>(m["LifecyclePostStartHandlerHttpGetPath"]));
    }
    if (m.find("LifecyclePostStartHandlerHttpGetPort") != m.end() && !m["LifecyclePostStartHandlerHttpGetPort"].empty()) {
      lifecyclePostStartHandlerHttpGetPort = make_shared<long>(boost::any_cast<long>(m["LifecyclePostStartHandlerHttpGetPort"]));
    }
    if (m.find("LifecyclePostStartHandlerHttpGetScheme") != m.end() && !m["LifecyclePostStartHandlerHttpGetScheme"].empty()) {
      lifecyclePostStartHandlerHttpGetScheme = make_shared<string>(boost::any_cast<string>(m["LifecyclePostStartHandlerHttpGetScheme"]));
    }
    if (m.find("LifecyclePostStartHandlerTcpSocketHost") != m.end() && !m["LifecyclePostStartHandlerTcpSocketHost"].empty()) {
      lifecyclePostStartHandlerTcpSocketHost = make_shared<string>(boost::any_cast<string>(m["LifecyclePostStartHandlerTcpSocketHost"]));
    }
    if (m.find("LifecyclePostStartHandlerTcpSocketPort") != m.end() && !m["LifecyclePostStartHandlerTcpSocketPort"].empty()) {
      lifecyclePostStartHandlerTcpSocketPort = make_shared<long>(boost::any_cast<long>(m["LifecyclePostStartHandlerTcpSocketPort"]));
    }
    if (m.find("LifecyclePreStopHandlerExecs") != m.end() && !m["LifecyclePreStopHandlerExecs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LifecyclePreStopHandlerExecs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LifecyclePreStopHandlerExecs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      lifecyclePreStopHandlerExecs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LifecyclePreStopHandlerHttpGetHost") != m.end() && !m["LifecyclePreStopHandlerHttpGetHost"].empty()) {
      lifecyclePreStopHandlerHttpGetHost = make_shared<string>(boost::any_cast<string>(m["LifecyclePreStopHandlerHttpGetHost"]));
    }
    if (m.find("LifecyclePreStopHandlerHttpGetPath") != m.end() && !m["LifecyclePreStopHandlerHttpGetPath"].empty()) {
      lifecyclePreStopHandlerHttpGetPath = make_shared<string>(boost::any_cast<string>(m["LifecyclePreStopHandlerHttpGetPath"]));
    }
    if (m.find("LifecyclePreStopHandlerHttpGetPort") != m.end() && !m["LifecyclePreStopHandlerHttpGetPort"].empty()) {
      lifecyclePreStopHandlerHttpGetPort = make_shared<long>(boost::any_cast<long>(m["LifecyclePreStopHandlerHttpGetPort"]));
    }
    if (m.find("LifecyclePreStopHandlerHttpGetScheme") != m.end() && !m["LifecyclePreStopHandlerHttpGetScheme"].empty()) {
      lifecyclePreStopHandlerHttpGetScheme = make_shared<string>(boost::any_cast<string>(m["LifecyclePreStopHandlerHttpGetScheme"]));
    }
    if (m.find("LifecyclePreStopHandlerTcpSocketHost") != m.end() && !m["LifecyclePreStopHandlerTcpSocketHost"].empty()) {
      lifecyclePreStopHandlerTcpSocketHost = make_shared<string>(boost::any_cast<string>(m["LifecyclePreStopHandlerTcpSocketHost"]));
    }
    if (m.find("LifecyclePreStopHandlerTcpSocketPort") != m.end() && !m["LifecyclePreStopHandlerTcpSocketPort"].empty()) {
      lifecyclePreStopHandlerTcpSocketPort = make_shared<long>(boost::any_cast<long>(m["LifecyclePreStopHandlerTcpSocketPort"]));
    }
    if (m.find("LivenessProbeExecCommands") != m.end() && !m["LivenessProbeExecCommands"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LivenessProbeExecCommands"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LivenessProbeExecCommands"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      livenessProbeExecCommands = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LivenessProbeFailureThreshold") != m.end() && !m["LivenessProbeFailureThreshold"].empty()) {
      livenessProbeFailureThreshold = make_shared<long>(boost::any_cast<long>(m["LivenessProbeFailureThreshold"]));
    }
    if (m.find("LivenessProbeHttpGetPath") != m.end() && !m["LivenessProbeHttpGetPath"].empty()) {
      livenessProbeHttpGetPath = make_shared<string>(boost::any_cast<string>(m["LivenessProbeHttpGetPath"]));
    }
    if (m.find("LivenessProbeHttpGetPort") != m.end() && !m["LivenessProbeHttpGetPort"].empty()) {
      livenessProbeHttpGetPort = make_shared<long>(boost::any_cast<long>(m["LivenessProbeHttpGetPort"]));
    }
    if (m.find("LivenessProbeHttpGetScheme") != m.end() && !m["LivenessProbeHttpGetScheme"].empty()) {
      livenessProbeHttpGetScheme = make_shared<string>(boost::any_cast<string>(m["LivenessProbeHttpGetScheme"]));
    }
    if (m.find("LivenessProbeInitialDelaySeconds") != m.end() && !m["LivenessProbeInitialDelaySeconds"].empty()) {
      livenessProbeInitialDelaySeconds = make_shared<long>(boost::any_cast<long>(m["LivenessProbeInitialDelaySeconds"]));
    }
    if (m.find("LivenessProbePeriodSeconds") != m.end() && !m["LivenessProbePeriodSeconds"].empty()) {
      livenessProbePeriodSeconds = make_shared<long>(boost::any_cast<long>(m["LivenessProbePeriodSeconds"]));
    }
    if (m.find("LivenessProbeSuccessThreshold") != m.end() && !m["LivenessProbeSuccessThreshold"].empty()) {
      livenessProbeSuccessThreshold = make_shared<long>(boost::any_cast<long>(m["LivenessProbeSuccessThreshold"]));
    }
    if (m.find("LivenessProbeTcpSocketPort") != m.end() && !m["LivenessProbeTcpSocketPort"].empty()) {
      livenessProbeTcpSocketPort = make_shared<long>(boost::any_cast<long>(m["LivenessProbeTcpSocketPort"]));
    }
    if (m.find("LivenessProbeTimeoutSeconds") != m.end() && !m["LivenessProbeTimeoutSeconds"].empty()) {
      livenessProbeTimeoutSeconds = make_shared<long>(boost::any_cast<long>(m["LivenessProbeTimeoutSeconds"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Ports") != m.end() && !m["Ports"].empty()) {
      if (typeid(vector<boost::any>) == m["Ports"].type()) {
        vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainersPorts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ports"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainersPorts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ports = make_shared<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainersPorts>>(expect1);
      }
    }
    if (m.find("ReadinessProbeExecCommands") != m.end() && !m["ReadinessProbeExecCommands"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReadinessProbeExecCommands"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReadinessProbeExecCommands"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      readinessProbeExecCommands = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ReadinessProbeFailureThreshold") != m.end() && !m["ReadinessProbeFailureThreshold"].empty()) {
      readinessProbeFailureThreshold = make_shared<long>(boost::any_cast<long>(m["ReadinessProbeFailureThreshold"]));
    }
    if (m.find("ReadinessProbeHttpGetPath") != m.end() && !m["ReadinessProbeHttpGetPath"].empty()) {
      readinessProbeHttpGetPath = make_shared<string>(boost::any_cast<string>(m["ReadinessProbeHttpGetPath"]));
    }
    if (m.find("ReadinessProbeHttpGetPort") != m.end() && !m["ReadinessProbeHttpGetPort"].empty()) {
      readinessProbeHttpGetPort = make_shared<long>(boost::any_cast<long>(m["ReadinessProbeHttpGetPort"]));
    }
    if (m.find("ReadinessProbeHttpGetScheme") != m.end() && !m["ReadinessProbeHttpGetScheme"].empty()) {
      readinessProbeHttpGetScheme = make_shared<string>(boost::any_cast<string>(m["ReadinessProbeHttpGetScheme"]));
    }
    if (m.find("ReadinessProbeInitialDelaySeconds") != m.end() && !m["ReadinessProbeInitialDelaySeconds"].empty()) {
      readinessProbeInitialDelaySeconds = make_shared<long>(boost::any_cast<long>(m["ReadinessProbeInitialDelaySeconds"]));
    }
    if (m.find("ReadinessProbePeriodSeconds") != m.end() && !m["ReadinessProbePeriodSeconds"].empty()) {
      readinessProbePeriodSeconds = make_shared<long>(boost::any_cast<long>(m["ReadinessProbePeriodSeconds"]));
    }
    if (m.find("ReadinessProbeSuccessThreshold") != m.end() && !m["ReadinessProbeSuccessThreshold"].empty()) {
      readinessProbeSuccessThreshold = make_shared<long>(boost::any_cast<long>(m["ReadinessProbeSuccessThreshold"]));
    }
    if (m.find("ReadinessProbeTcpSocketPort") != m.end() && !m["ReadinessProbeTcpSocketPort"].empty()) {
      readinessProbeTcpSocketPort = make_shared<long>(boost::any_cast<long>(m["ReadinessProbeTcpSocketPort"]));
    }
    if (m.find("ReadinessProbeTimeoutSeconds") != m.end() && !m["ReadinessProbeTimeoutSeconds"].empty()) {
      readinessProbeTimeoutSeconds = make_shared<long>(boost::any_cast<long>(m["ReadinessProbeTimeoutSeconds"]));
    }
    if (m.find("SecurityContextCapabilityAdds") != m.end() && !m["SecurityContextCapabilityAdds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityContextCapabilityAdds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityContextCapabilityAdds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityContextCapabilityAdds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SecurityContextReadOnlyRootFilesystem") != m.end() && !m["SecurityContextReadOnlyRootFilesystem"].empty()) {
      securityContextReadOnlyRootFilesystem = make_shared<bool>(boost::any_cast<bool>(m["SecurityContextReadOnlyRootFilesystem"]));
    }
    if (m.find("SecurityContextRunAsUser") != m.end() && !m["SecurityContextRunAsUser"].empty()) {
      securityContextRunAsUser = make_shared<long>(boost::any_cast<long>(m["SecurityContextRunAsUser"]));
    }
    if (m.find("Stdin") != m.end() && !m["Stdin"].empty()) {
      stdin = make_shared<bool>(boost::any_cast<bool>(m["Stdin"]));
    }
    if (m.find("StdinOnce") != m.end() && !m["StdinOnce"].empty()) {
      stdinOnce = make_shared<bool>(boost::any_cast<bool>(m["StdinOnce"]));
    }
    if (m.find("Tty") != m.end() && !m["Tty"].empty()) {
      tty = make_shared<bool>(boost::any_cast<bool>(m["Tty"]));
    }
    if (m.find("VolumeMounts") != m.end() && !m["VolumeMounts"].empty()) {
      if (typeid(vector<boost::any>) == m["VolumeMounts"].type()) {
        vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainersVolumeMounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VolumeMounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainersVolumeMounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        volumeMounts = make_shared<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainersVolumeMounts>>(expect1);
      }
    }
    if (m.find("WorkingDir") != m.end() && !m["WorkingDir"].empty()) {
      workingDir = make_shared<string>(boost::any_cast<string>(m["WorkingDir"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainers() = default;
};
class DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationDnsConfigOptions : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationDnsConfigOptions() {}

  explicit DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationDnsConfigOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationDnsConfigOptions() = default;
};
class DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationHostAliases : public Darabonba::Model {
public:
  shared_ptr<vector<string>> hostnames{};
  shared_ptr<string> ip{};

  DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationHostAliases() {}

  explicit DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationHostAliases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostnames) {
      res["Hostnames"] = boost::any(*hostnames);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Hostnames") != m.end() && !m["Hostnames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Hostnames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Hostnames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostnames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationHostAliases() = default;
};
class DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationImageRegistryCredentials : public Darabonba::Model {
public:
  shared_ptr<string> password{};
  shared_ptr<string> server{};
  shared_ptr<string> userName{};

  DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationImageRegistryCredentials() {}

  explicit DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationImageRegistryCredentials(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (server) {
      res["Server"] = boost::any(*server);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Server") != m.end() && !m["Server"].empty()) {
      server = make_shared<string>(boost::any_cast<string>(m["Server"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationImageRegistryCredentials() = default;
};
class DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainersInitContainerEnvironmentVars : public Darabonba::Model {
public:
  shared_ptr<string> fieldRefFieldPath{};
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainersInitContainerEnvironmentVars() {}

  explicit DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainersInitContainerEnvironmentVars(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldRefFieldPath) {
      res["FieldRefFieldPath"] = boost::any(*fieldRefFieldPath);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldRefFieldPath") != m.end() && !m["FieldRefFieldPath"].empty()) {
      fieldRefFieldPath = make_shared<string>(boost::any_cast<string>(m["FieldRefFieldPath"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainersInitContainerEnvironmentVars() = default;
};
class DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainersInitContainerPorts : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> protocol{};

  DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainersInitContainerPorts() {}

  explicit DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainersInitContainerPorts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainersInitContainerPorts() = default;
};
class DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainersInitContainerVolumeMounts : public Darabonba::Model {
public:
  shared_ptr<string> mountPath{};
  shared_ptr<string> mountPropagation{};
  shared_ptr<string> name{};
  shared_ptr<bool> readOnly{};
  shared_ptr<string> subPath{};

  DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainersInitContainerVolumeMounts() {}

  explicit DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainersInitContainerVolumeMounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountPath) {
      res["MountPath"] = boost::any(*mountPath);
    }
    if (mountPropagation) {
      res["MountPropagation"] = boost::any(*mountPropagation);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    if (subPath) {
      res["SubPath"] = boost::any(*subPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MountPath") != m.end() && !m["MountPath"].empty()) {
      mountPath = make_shared<string>(boost::any_cast<string>(m["MountPath"]));
    }
    if (m.find("MountPropagation") != m.end() && !m["MountPropagation"].empty()) {
      mountPropagation = make_shared<string>(boost::any_cast<string>(m["MountPropagation"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
    if (m.find("SubPath") != m.end() && !m["SubPath"].empty()) {
      subPath = make_shared<string>(boost::any_cast<string>(m["SubPath"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainersInitContainerVolumeMounts() = default;
};
class DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainers : public Darabonba::Model {
public:
  shared_ptr<double> cpu{};
  shared_ptr<long> gpu{};
  shared_ptr<string> image{};
  shared_ptr<string> imagePullPolicy{};
  shared_ptr<vector<string>> initContainerArgs{};
  shared_ptr<vector<string>> initContainerCommands{};
  shared_ptr<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainersInitContainerEnvironmentVars>> initContainerEnvironmentVars{};
  shared_ptr<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainersInitContainerPorts>> initContainerPorts{};
  shared_ptr<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainersInitContainerVolumeMounts>> initContainerVolumeMounts{};
  shared_ptr<double> memory{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> securityContextCapabilityAdds{};
  shared_ptr<bool> securityContextReadOnlyRootFilesystem{};
  shared_ptr<string> securityContextRunAsUser{};
  shared_ptr<string> workingDir{};

  DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainers() {}

  explicit DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (gpu) {
      res["Gpu"] = boost::any(*gpu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (imagePullPolicy) {
      res["ImagePullPolicy"] = boost::any(*imagePullPolicy);
    }
    if (initContainerArgs) {
      res["InitContainerArgs"] = boost::any(*initContainerArgs);
    }
    if (initContainerCommands) {
      res["InitContainerCommands"] = boost::any(*initContainerCommands);
    }
    if (initContainerEnvironmentVars) {
      vector<boost::any> temp1;
      for(auto item1:*initContainerEnvironmentVars){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InitContainerEnvironmentVars"] = boost::any(temp1);
    }
    if (initContainerPorts) {
      vector<boost::any> temp1;
      for(auto item1:*initContainerPorts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InitContainerPorts"] = boost::any(temp1);
    }
    if (initContainerVolumeMounts) {
      vector<boost::any> temp1;
      for(auto item1:*initContainerVolumeMounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InitContainerVolumeMounts"] = boost::any(temp1);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (securityContextCapabilityAdds) {
      res["SecurityContextCapabilityAdds"] = boost::any(*securityContextCapabilityAdds);
    }
    if (securityContextReadOnlyRootFilesystem) {
      res["SecurityContextReadOnlyRootFilesystem"] = boost::any(*securityContextReadOnlyRootFilesystem);
    }
    if (securityContextRunAsUser) {
      res["SecurityContextRunAsUser"] = boost::any(*securityContextRunAsUser);
    }
    if (workingDir) {
      res["WorkingDir"] = boost::any(*workingDir);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<double>(boost::any_cast<double>(m["Cpu"]));
    }
    if (m.find("Gpu") != m.end() && !m["Gpu"].empty()) {
      gpu = make_shared<long>(boost::any_cast<long>(m["Gpu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ImagePullPolicy") != m.end() && !m["ImagePullPolicy"].empty()) {
      imagePullPolicy = make_shared<string>(boost::any_cast<string>(m["ImagePullPolicy"]));
    }
    if (m.find("InitContainerArgs") != m.end() && !m["InitContainerArgs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InitContainerArgs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InitContainerArgs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      initContainerArgs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InitContainerCommands") != m.end() && !m["InitContainerCommands"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InitContainerCommands"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InitContainerCommands"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      initContainerCommands = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InitContainerEnvironmentVars") != m.end() && !m["InitContainerEnvironmentVars"].empty()) {
      if (typeid(vector<boost::any>) == m["InitContainerEnvironmentVars"].type()) {
        vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainersInitContainerEnvironmentVars> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InitContainerEnvironmentVars"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainersInitContainerEnvironmentVars model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        initContainerEnvironmentVars = make_shared<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainersInitContainerEnvironmentVars>>(expect1);
      }
    }
    if (m.find("InitContainerPorts") != m.end() && !m["InitContainerPorts"].empty()) {
      if (typeid(vector<boost::any>) == m["InitContainerPorts"].type()) {
        vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainersInitContainerPorts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InitContainerPorts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainersInitContainerPorts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        initContainerPorts = make_shared<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainersInitContainerPorts>>(expect1);
      }
    }
    if (m.find("InitContainerVolumeMounts") != m.end() && !m["InitContainerVolumeMounts"].empty()) {
      if (typeid(vector<boost::any>) == m["InitContainerVolumeMounts"].type()) {
        vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainersInitContainerVolumeMounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InitContainerVolumeMounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainersInitContainerVolumeMounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        initContainerVolumeMounts = make_shared<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainersInitContainerVolumeMounts>>(expect1);
      }
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SecurityContextCapabilityAdds") != m.end() && !m["SecurityContextCapabilityAdds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityContextCapabilityAdds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityContextCapabilityAdds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityContextCapabilityAdds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SecurityContextReadOnlyRootFilesystem") != m.end() && !m["SecurityContextReadOnlyRootFilesystem"].empty()) {
      securityContextReadOnlyRootFilesystem = make_shared<bool>(boost::any_cast<bool>(m["SecurityContextReadOnlyRootFilesystem"]));
    }
    if (m.find("SecurityContextRunAsUser") != m.end() && !m["SecurityContextRunAsUser"].empty()) {
      securityContextRunAsUser = make_shared<string>(boost::any_cast<string>(m["SecurityContextRunAsUser"]));
    }
    if (m.find("WorkingDir") != m.end() && !m["WorkingDir"].empty()) {
      workingDir = make_shared<string>(boost::any_cast<string>(m["WorkingDir"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainers() = default;
};
class DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationSecurityContextSysCtls : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationSecurityContextSysCtls() {}

  explicit DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationSecurityContextSysCtls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationSecurityContextSysCtls() = default;
};
class DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationTags() {}

  explicit DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationTags() = default;
};
class DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationVolumesConfigFileVolumeConfigFileToPaths : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> mode{};
  shared_ptr<string> path{};

  DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationVolumesConfigFileVolumeConfigFileToPaths() {}

  explicit DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationVolumesConfigFileVolumeConfigFileToPaths(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<long>(boost::any_cast<long>(m["Mode"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationVolumesConfigFileVolumeConfigFileToPaths() = default;
};
class DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationVolumes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationVolumesConfigFileVolumeConfigFileToPaths>> configFileVolumeConfigFileToPaths{};
  shared_ptr<long> configFileVolumeDefaultMode{};
  shared_ptr<string> diskVolumeDiskId{};
  shared_ptr<long> diskVolumeDiskSize{};
  shared_ptr<string> diskVolumeFsType{};
  shared_ptr<string> emptyDirVolumeMedium{};
  shared_ptr<string> emptyDirVolumeSizeLimit{};
  shared_ptr<string> flexVolumeDriver{};
  shared_ptr<string> flexVolumeFsType{};
  shared_ptr<string> flexVolumeOptions{};
  shared_ptr<string> hostPathVolumePath{};
  shared_ptr<string> hostPathVolumeType{};
  shared_ptr<string> NFSVolumePath{};
  shared_ptr<bool> NFSVolumeReadOnly{};
  shared_ptr<string> NFSVolumeServer{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationVolumes() {}

  explicit DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationVolumes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configFileVolumeConfigFileToPaths) {
      vector<boost::any> temp1;
      for(auto item1:*configFileVolumeConfigFileToPaths){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigFileVolumeConfigFileToPaths"] = boost::any(temp1);
    }
    if (configFileVolumeDefaultMode) {
      res["ConfigFileVolumeDefaultMode"] = boost::any(*configFileVolumeDefaultMode);
    }
    if (diskVolumeDiskId) {
      res["DiskVolumeDiskId"] = boost::any(*diskVolumeDiskId);
    }
    if (diskVolumeDiskSize) {
      res["DiskVolumeDiskSize"] = boost::any(*diskVolumeDiskSize);
    }
    if (diskVolumeFsType) {
      res["DiskVolumeFsType"] = boost::any(*diskVolumeFsType);
    }
    if (emptyDirVolumeMedium) {
      res["EmptyDirVolumeMedium"] = boost::any(*emptyDirVolumeMedium);
    }
    if (emptyDirVolumeSizeLimit) {
      res["EmptyDirVolumeSizeLimit"] = boost::any(*emptyDirVolumeSizeLimit);
    }
    if (flexVolumeDriver) {
      res["FlexVolumeDriver"] = boost::any(*flexVolumeDriver);
    }
    if (flexVolumeFsType) {
      res["FlexVolumeFsType"] = boost::any(*flexVolumeFsType);
    }
    if (flexVolumeOptions) {
      res["FlexVolumeOptions"] = boost::any(*flexVolumeOptions);
    }
    if (hostPathVolumePath) {
      res["HostPathVolumePath"] = boost::any(*hostPathVolumePath);
    }
    if (hostPathVolumeType) {
      res["HostPathVolumeType"] = boost::any(*hostPathVolumeType);
    }
    if (NFSVolumePath) {
      res["NFSVolumePath"] = boost::any(*NFSVolumePath);
    }
    if (NFSVolumeReadOnly) {
      res["NFSVolumeReadOnly"] = boost::any(*NFSVolumeReadOnly);
    }
    if (NFSVolumeServer) {
      res["NFSVolumeServer"] = boost::any(*NFSVolumeServer);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigFileVolumeConfigFileToPaths") != m.end() && !m["ConfigFileVolumeConfigFileToPaths"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigFileVolumeConfigFileToPaths"].type()) {
        vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationVolumesConfigFileVolumeConfigFileToPaths> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigFileVolumeConfigFileToPaths"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationVolumesConfigFileVolumeConfigFileToPaths model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configFileVolumeConfigFileToPaths = make_shared<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationVolumesConfigFileVolumeConfigFileToPaths>>(expect1);
      }
    }
    if (m.find("ConfigFileVolumeDefaultMode") != m.end() && !m["ConfigFileVolumeDefaultMode"].empty()) {
      configFileVolumeDefaultMode = make_shared<long>(boost::any_cast<long>(m["ConfigFileVolumeDefaultMode"]));
    }
    if (m.find("DiskVolumeDiskId") != m.end() && !m["DiskVolumeDiskId"].empty()) {
      diskVolumeDiskId = make_shared<string>(boost::any_cast<string>(m["DiskVolumeDiskId"]));
    }
    if (m.find("DiskVolumeDiskSize") != m.end() && !m["DiskVolumeDiskSize"].empty()) {
      diskVolumeDiskSize = make_shared<long>(boost::any_cast<long>(m["DiskVolumeDiskSize"]));
    }
    if (m.find("DiskVolumeFsType") != m.end() && !m["DiskVolumeFsType"].empty()) {
      diskVolumeFsType = make_shared<string>(boost::any_cast<string>(m["DiskVolumeFsType"]));
    }
    if (m.find("EmptyDirVolumeMedium") != m.end() && !m["EmptyDirVolumeMedium"].empty()) {
      emptyDirVolumeMedium = make_shared<string>(boost::any_cast<string>(m["EmptyDirVolumeMedium"]));
    }
    if (m.find("EmptyDirVolumeSizeLimit") != m.end() && !m["EmptyDirVolumeSizeLimit"].empty()) {
      emptyDirVolumeSizeLimit = make_shared<string>(boost::any_cast<string>(m["EmptyDirVolumeSizeLimit"]));
    }
    if (m.find("FlexVolumeDriver") != m.end() && !m["FlexVolumeDriver"].empty()) {
      flexVolumeDriver = make_shared<string>(boost::any_cast<string>(m["FlexVolumeDriver"]));
    }
    if (m.find("FlexVolumeFsType") != m.end() && !m["FlexVolumeFsType"].empty()) {
      flexVolumeFsType = make_shared<string>(boost::any_cast<string>(m["FlexVolumeFsType"]));
    }
    if (m.find("FlexVolumeOptions") != m.end() && !m["FlexVolumeOptions"].empty()) {
      flexVolumeOptions = make_shared<string>(boost::any_cast<string>(m["FlexVolumeOptions"]));
    }
    if (m.find("HostPathVolumePath") != m.end() && !m["HostPathVolumePath"].empty()) {
      hostPathVolumePath = make_shared<string>(boost::any_cast<string>(m["HostPathVolumePath"]));
    }
    if (m.find("HostPathVolumeType") != m.end() && !m["HostPathVolumeType"].empty()) {
      hostPathVolumeType = make_shared<string>(boost::any_cast<string>(m["HostPathVolumeType"]));
    }
    if (m.find("NFSVolumePath") != m.end() && !m["NFSVolumePath"].empty()) {
      NFSVolumePath = make_shared<string>(boost::any_cast<string>(m["NFSVolumePath"]));
    }
    if (m.find("NFSVolumeReadOnly") != m.end() && !m["NFSVolumeReadOnly"].empty()) {
      NFSVolumeReadOnly = make_shared<bool>(boost::any_cast<bool>(m["NFSVolumeReadOnly"]));
    }
    if (m.find("NFSVolumeServer") != m.end() && !m["NFSVolumeServer"].empty()) {
      NFSVolumeServer = make_shared<string>(boost::any_cast<string>(m["NFSVolumeServer"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationVolumes() = default;
};
class DescribeEciScalingConfigurationDetailResponseBodyScalingConfiguration : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationAcrRegistryInfos>> acrRegistryInfos{};
  shared_ptr<long> activeDeadlineSeconds{};
  shared_ptr<bool> autoCreateEip{};
  shared_ptr<bool> autoMatchImageCache{};
  shared_ptr<vector<string>> computeCategory{};
  shared_ptr<string> containerGroupName{};
  shared_ptr<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainers>> containers{};
  shared_ptr<bool> costOptimization{};
  shared_ptr<double> cpu{};
  shared_ptr<long> cpuOptionsCore{};
  shared_ptr<long> cpuOptionsThreadsPerCore{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> dataCacheBucket{};
  shared_ptr<bool> dataCacheBurstingEnabled{};
  shared_ptr<string> dataCachePL{};
  shared_ptr<long> dataCacheProvisionedIops{};
  shared_ptr<string> description{};
  shared_ptr<vector<string>> dnsConfigNameServers{};
  shared_ptr<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationDnsConfigOptions>> dnsConfigOptions{};
  shared_ptr<vector<string>> dnsConfigSearches{};
  shared_ptr<string> dnsPolicy{};
  shared_ptr<long> egressBandwidth{};
  shared_ptr<long> eipBandwidth{};
  shared_ptr<string> eipCommonBandwidthPackage{};
  shared_ptr<string> eipISP{};
  shared_ptr<string> eipPublicIpAddressPoolId{};
  shared_ptr<long> ephemeralStorage{};
  shared_ptr<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationHostAliases>> hostAliases{};
  shared_ptr<string> hostName{};
  shared_ptr<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationImageRegistryCredentials>> imageRegistryCredentials{};
  shared_ptr<string> imageSnapshotId{};
  shared_ptr<long> ingressBandwidth{};
  shared_ptr<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainers>> initContainers{};
  shared_ptr<string> instanceFamilyLevel{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<long> ipv6AddressCount{};
  shared_ptr<string> lifecycleState{};
  shared_ptr<long> loadBalancerWeight{};
  shared_ptr<double> memory{};
  shared_ptr<vector<string>> ntpServers{};
  shared_ptr<string> ramRoleName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> restartPolicy{};
  shared_ptr<string> scalingConfigurationId{};
  shared_ptr<string> scalingConfigurationName{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationSecurityContextSysCtls>> securityContextSysCtls{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<bool> slsEnable{};
  shared_ptr<double> spotPriceLimit{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationTags>> tags{};
  shared_ptr<long> terminationGracePeriodSeconds{};
  shared_ptr<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationVolumes>> volumes{};

  DescribeEciScalingConfigurationDetailResponseBodyScalingConfiguration() {}

  explicit DescribeEciScalingConfigurationDetailResponseBodyScalingConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acrRegistryInfos) {
      vector<boost::any> temp1;
      for(auto item1:*acrRegistryInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AcrRegistryInfos"] = boost::any(temp1);
    }
    if (activeDeadlineSeconds) {
      res["ActiveDeadlineSeconds"] = boost::any(*activeDeadlineSeconds);
    }
    if (autoCreateEip) {
      res["AutoCreateEip"] = boost::any(*autoCreateEip);
    }
    if (autoMatchImageCache) {
      res["AutoMatchImageCache"] = boost::any(*autoMatchImageCache);
    }
    if (computeCategory) {
      res["ComputeCategory"] = boost::any(*computeCategory);
    }
    if (containerGroupName) {
      res["ContainerGroupName"] = boost::any(*containerGroupName);
    }
    if (containers) {
      vector<boost::any> temp1;
      for(auto item1:*containers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Containers"] = boost::any(temp1);
    }
    if (costOptimization) {
      res["CostOptimization"] = boost::any(*costOptimization);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (cpuOptionsCore) {
      res["CpuOptionsCore"] = boost::any(*cpuOptionsCore);
    }
    if (cpuOptionsThreadsPerCore) {
      res["CpuOptionsThreadsPerCore"] = boost::any(*cpuOptionsThreadsPerCore);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (dataCacheBucket) {
      res["DataCacheBucket"] = boost::any(*dataCacheBucket);
    }
    if (dataCacheBurstingEnabled) {
      res["DataCacheBurstingEnabled"] = boost::any(*dataCacheBurstingEnabled);
    }
    if (dataCachePL) {
      res["DataCachePL"] = boost::any(*dataCachePL);
    }
    if (dataCacheProvisionedIops) {
      res["DataCacheProvisionedIops"] = boost::any(*dataCacheProvisionedIops);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dnsConfigNameServers) {
      res["DnsConfigNameServers"] = boost::any(*dnsConfigNameServers);
    }
    if (dnsConfigOptions) {
      vector<boost::any> temp1;
      for(auto item1:*dnsConfigOptions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DnsConfigOptions"] = boost::any(temp1);
    }
    if (dnsConfigSearches) {
      res["DnsConfigSearches"] = boost::any(*dnsConfigSearches);
    }
    if (dnsPolicy) {
      res["DnsPolicy"] = boost::any(*dnsPolicy);
    }
    if (egressBandwidth) {
      res["EgressBandwidth"] = boost::any(*egressBandwidth);
    }
    if (eipBandwidth) {
      res["EipBandwidth"] = boost::any(*eipBandwidth);
    }
    if (eipCommonBandwidthPackage) {
      res["EipCommonBandwidthPackage"] = boost::any(*eipCommonBandwidthPackage);
    }
    if (eipISP) {
      res["EipISP"] = boost::any(*eipISP);
    }
    if (eipPublicIpAddressPoolId) {
      res["EipPublicIpAddressPoolId"] = boost::any(*eipPublicIpAddressPoolId);
    }
    if (ephemeralStorage) {
      res["EphemeralStorage"] = boost::any(*ephemeralStorage);
    }
    if (hostAliases) {
      vector<boost::any> temp1;
      for(auto item1:*hostAliases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostAliases"] = boost::any(temp1);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (imageRegistryCredentials) {
      vector<boost::any> temp1;
      for(auto item1:*imageRegistryCredentials){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageRegistryCredentials"] = boost::any(temp1);
    }
    if (imageSnapshotId) {
      res["ImageSnapshotId"] = boost::any(*imageSnapshotId);
    }
    if (ingressBandwidth) {
      res["IngressBandwidth"] = boost::any(*ingressBandwidth);
    }
    if (initContainers) {
      vector<boost::any> temp1;
      for(auto item1:*initContainers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InitContainers"] = boost::any(temp1);
    }
    if (instanceFamilyLevel) {
      res["InstanceFamilyLevel"] = boost::any(*instanceFamilyLevel);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = boost::any(*instanceTypes);
    }
    if (ipv6AddressCount) {
      res["Ipv6AddressCount"] = boost::any(*ipv6AddressCount);
    }
    if (lifecycleState) {
      res["LifecycleState"] = boost::any(*lifecycleState);
    }
    if (loadBalancerWeight) {
      res["LoadBalancerWeight"] = boost::any(*loadBalancerWeight);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (ntpServers) {
      res["NtpServers"] = boost::any(*ntpServers);
    }
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (restartPolicy) {
      res["RestartPolicy"] = boost::any(*restartPolicy);
    }
    if (scalingConfigurationId) {
      res["ScalingConfigurationId"] = boost::any(*scalingConfigurationId);
    }
    if (scalingConfigurationName) {
      res["ScalingConfigurationName"] = boost::any(*scalingConfigurationName);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (securityContextSysCtls) {
      vector<boost::any> temp1;
      for(auto item1:*securityContextSysCtls){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityContextSysCtls"] = boost::any(temp1);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (slsEnable) {
      res["SlsEnable"] = boost::any(*slsEnable);
    }
    if (spotPriceLimit) {
      res["SpotPriceLimit"] = boost::any(*spotPriceLimit);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (terminationGracePeriodSeconds) {
      res["TerminationGracePeriodSeconds"] = boost::any(*terminationGracePeriodSeconds);
    }
    if (volumes) {
      vector<boost::any> temp1;
      for(auto item1:*volumes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Volumes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcrRegistryInfos") != m.end() && !m["AcrRegistryInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["AcrRegistryInfos"].type()) {
        vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationAcrRegistryInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AcrRegistryInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationAcrRegistryInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        acrRegistryInfos = make_shared<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationAcrRegistryInfos>>(expect1);
      }
    }
    if (m.find("ActiveDeadlineSeconds") != m.end() && !m["ActiveDeadlineSeconds"].empty()) {
      activeDeadlineSeconds = make_shared<long>(boost::any_cast<long>(m["ActiveDeadlineSeconds"]));
    }
    if (m.find("AutoCreateEip") != m.end() && !m["AutoCreateEip"].empty()) {
      autoCreateEip = make_shared<bool>(boost::any_cast<bool>(m["AutoCreateEip"]));
    }
    if (m.find("AutoMatchImageCache") != m.end() && !m["AutoMatchImageCache"].empty()) {
      autoMatchImageCache = make_shared<bool>(boost::any_cast<bool>(m["AutoMatchImageCache"]));
    }
    if (m.find("ComputeCategory") != m.end() && !m["ComputeCategory"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComputeCategory"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComputeCategory"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      computeCategory = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ContainerGroupName") != m.end() && !m["ContainerGroupName"].empty()) {
      containerGroupName = make_shared<string>(boost::any_cast<string>(m["ContainerGroupName"]));
    }
    if (m.find("Containers") != m.end() && !m["Containers"].empty()) {
      if (typeid(vector<boost::any>) == m["Containers"].type()) {
        vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Containers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        containers = make_shared<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationContainers>>(expect1);
      }
    }
    if (m.find("CostOptimization") != m.end() && !m["CostOptimization"].empty()) {
      costOptimization = make_shared<bool>(boost::any_cast<bool>(m["CostOptimization"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<double>(boost::any_cast<double>(m["Cpu"]));
    }
    if (m.find("CpuOptionsCore") != m.end() && !m["CpuOptionsCore"].empty()) {
      cpuOptionsCore = make_shared<long>(boost::any_cast<long>(m["CpuOptionsCore"]));
    }
    if (m.find("CpuOptionsThreadsPerCore") != m.end() && !m["CpuOptionsThreadsPerCore"].empty()) {
      cpuOptionsThreadsPerCore = make_shared<long>(boost::any_cast<long>(m["CpuOptionsThreadsPerCore"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DataCacheBucket") != m.end() && !m["DataCacheBucket"].empty()) {
      dataCacheBucket = make_shared<string>(boost::any_cast<string>(m["DataCacheBucket"]));
    }
    if (m.find("DataCacheBurstingEnabled") != m.end() && !m["DataCacheBurstingEnabled"].empty()) {
      dataCacheBurstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["DataCacheBurstingEnabled"]));
    }
    if (m.find("DataCachePL") != m.end() && !m["DataCachePL"].empty()) {
      dataCachePL = make_shared<string>(boost::any_cast<string>(m["DataCachePL"]));
    }
    if (m.find("DataCacheProvisionedIops") != m.end() && !m["DataCacheProvisionedIops"].empty()) {
      dataCacheProvisionedIops = make_shared<long>(boost::any_cast<long>(m["DataCacheProvisionedIops"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DnsConfigNameServers") != m.end() && !m["DnsConfigNameServers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DnsConfigNameServers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DnsConfigNameServers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dnsConfigNameServers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DnsConfigOptions") != m.end() && !m["DnsConfigOptions"].empty()) {
      if (typeid(vector<boost::any>) == m["DnsConfigOptions"].type()) {
        vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationDnsConfigOptions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DnsConfigOptions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationDnsConfigOptions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dnsConfigOptions = make_shared<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationDnsConfigOptions>>(expect1);
      }
    }
    if (m.find("DnsConfigSearches") != m.end() && !m["DnsConfigSearches"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DnsConfigSearches"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DnsConfigSearches"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dnsConfigSearches = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DnsPolicy") != m.end() && !m["DnsPolicy"].empty()) {
      dnsPolicy = make_shared<string>(boost::any_cast<string>(m["DnsPolicy"]));
    }
    if (m.find("EgressBandwidth") != m.end() && !m["EgressBandwidth"].empty()) {
      egressBandwidth = make_shared<long>(boost::any_cast<long>(m["EgressBandwidth"]));
    }
    if (m.find("EipBandwidth") != m.end() && !m["EipBandwidth"].empty()) {
      eipBandwidth = make_shared<long>(boost::any_cast<long>(m["EipBandwidth"]));
    }
    if (m.find("EipCommonBandwidthPackage") != m.end() && !m["EipCommonBandwidthPackage"].empty()) {
      eipCommonBandwidthPackage = make_shared<string>(boost::any_cast<string>(m["EipCommonBandwidthPackage"]));
    }
    if (m.find("EipISP") != m.end() && !m["EipISP"].empty()) {
      eipISP = make_shared<string>(boost::any_cast<string>(m["EipISP"]));
    }
    if (m.find("EipPublicIpAddressPoolId") != m.end() && !m["EipPublicIpAddressPoolId"].empty()) {
      eipPublicIpAddressPoolId = make_shared<string>(boost::any_cast<string>(m["EipPublicIpAddressPoolId"]));
    }
    if (m.find("EphemeralStorage") != m.end() && !m["EphemeralStorage"].empty()) {
      ephemeralStorage = make_shared<long>(boost::any_cast<long>(m["EphemeralStorage"]));
    }
    if (m.find("HostAliases") != m.end() && !m["HostAliases"].empty()) {
      if (typeid(vector<boost::any>) == m["HostAliases"].type()) {
        vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationHostAliases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostAliases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationHostAliases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostAliases = make_shared<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationHostAliases>>(expect1);
      }
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ImageRegistryCredentials") != m.end() && !m["ImageRegistryCredentials"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageRegistryCredentials"].type()) {
        vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationImageRegistryCredentials> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageRegistryCredentials"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationImageRegistryCredentials model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageRegistryCredentials = make_shared<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationImageRegistryCredentials>>(expect1);
      }
    }
    if (m.find("ImageSnapshotId") != m.end() && !m["ImageSnapshotId"].empty()) {
      imageSnapshotId = make_shared<string>(boost::any_cast<string>(m["ImageSnapshotId"]));
    }
    if (m.find("IngressBandwidth") != m.end() && !m["IngressBandwidth"].empty()) {
      ingressBandwidth = make_shared<long>(boost::any_cast<long>(m["IngressBandwidth"]));
    }
    if (m.find("InitContainers") != m.end() && !m["InitContainers"].empty()) {
      if (typeid(vector<boost::any>) == m["InitContainers"].type()) {
        vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InitContainers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        initContainers = make_shared<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationInitContainers>>(expect1);
      }
    }
    if (m.find("InstanceFamilyLevel") != m.end() && !m["InstanceFamilyLevel"].empty()) {
      instanceFamilyLevel = make_shared<string>(boost::any_cast<string>(m["InstanceFamilyLevel"]));
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Ipv6AddressCount") != m.end() && !m["Ipv6AddressCount"].empty()) {
      ipv6AddressCount = make_shared<long>(boost::any_cast<long>(m["Ipv6AddressCount"]));
    }
    if (m.find("LifecycleState") != m.end() && !m["LifecycleState"].empty()) {
      lifecycleState = make_shared<string>(boost::any_cast<string>(m["LifecycleState"]));
    }
    if (m.find("LoadBalancerWeight") != m.end() && !m["LoadBalancerWeight"].empty()) {
      loadBalancerWeight = make_shared<long>(boost::any_cast<long>(m["LoadBalancerWeight"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("NtpServers") != m.end() && !m["NtpServers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NtpServers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NtpServers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ntpServers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RestartPolicy") != m.end() && !m["RestartPolicy"].empty()) {
      restartPolicy = make_shared<string>(boost::any_cast<string>(m["RestartPolicy"]));
    }
    if (m.find("ScalingConfigurationId") != m.end() && !m["ScalingConfigurationId"].empty()) {
      scalingConfigurationId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationId"]));
    }
    if (m.find("ScalingConfigurationName") != m.end() && !m["ScalingConfigurationName"].empty()) {
      scalingConfigurationName = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationName"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("SecurityContextSysCtls") != m.end() && !m["SecurityContextSysCtls"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityContextSysCtls"].type()) {
        vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationSecurityContextSysCtls> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityContextSysCtls"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationSecurityContextSysCtls model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityContextSysCtls = make_shared<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationSecurityContextSysCtls>>(expect1);
      }
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SlsEnable") != m.end() && !m["SlsEnable"].empty()) {
      slsEnable = make_shared<bool>(boost::any_cast<bool>(m["SlsEnable"]));
    }
    if (m.find("SpotPriceLimit") != m.end() && !m["SpotPriceLimit"].empty()) {
      spotPriceLimit = make_shared<double>(boost::any_cast<double>(m["SpotPriceLimit"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationTags>>(expect1);
      }
    }
    if (m.find("TerminationGracePeriodSeconds") != m.end() && !m["TerminationGracePeriodSeconds"].empty()) {
      terminationGracePeriodSeconds = make_shared<long>(boost::any_cast<long>(m["TerminationGracePeriodSeconds"]));
    }
    if (m.find("Volumes") != m.end() && !m["Volumes"].empty()) {
      if (typeid(vector<boost::any>) == m["Volumes"].type()) {
        vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationVolumes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Volumes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationVolumes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        volumes = make_shared<vector<DescribeEciScalingConfigurationDetailResponseBodyScalingConfigurationVolumes>>(expect1);
      }
    }
  }


  virtual ~DescribeEciScalingConfigurationDetailResponseBodyScalingConfiguration() = default;
};
class DescribeEciScalingConfigurationDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> output{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeEciScalingConfigurationDetailResponseBodyScalingConfiguration> scalingConfiguration{};

  DescribeEciScalingConfigurationDetailResponseBody() {}

  explicit DescribeEciScalingConfigurationDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingConfiguration) {
      res["ScalingConfiguration"] = scalingConfiguration ? boost::any(scalingConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingConfiguration") != m.end() && !m["ScalingConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScalingConfiguration"].type()) {
        DescribeEciScalingConfigurationDetailResponseBodyScalingConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScalingConfiguration"]));
        scalingConfiguration = make_shared<DescribeEciScalingConfigurationDetailResponseBodyScalingConfiguration>(model1);
      }
    }
  }


  virtual ~DescribeEciScalingConfigurationDetailResponseBody() = default;
};
class DescribeEciScalingConfigurationDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEciScalingConfigurationDetailResponseBody> body{};

  DescribeEciScalingConfigurationDetailResponse() {}

  explicit DescribeEciScalingConfigurationDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEciScalingConfigurationDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEciScalingConfigurationDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEciScalingConfigurationDetailResponse() = default;
};
class DescribeEciScalingConfigurationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<string>> scalingConfigurationIds{};
  shared_ptr<vector<string>> scalingConfigurationNames{};
  shared_ptr<string> scalingGroupId{};

  DescribeEciScalingConfigurationsRequest() {}

  explicit DescribeEciScalingConfigurationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingConfigurationIds) {
      res["ScalingConfigurationIds"] = boost::any(*scalingConfigurationIds);
    }
    if (scalingConfigurationNames) {
      res["ScalingConfigurationNames"] = boost::any(*scalingConfigurationNames);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingConfigurationIds") != m.end() && !m["ScalingConfigurationIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScalingConfigurationIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScalingConfigurationIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scalingConfigurationIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScalingConfigurationNames") != m.end() && !m["ScalingConfigurationNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScalingConfigurationNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScalingConfigurationNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scalingConfigurationNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationsRequest() = default;
};
class DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos : public Darabonba::Model {
public:
  shared_ptr<vector<string>> domains{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> regionId{};

  DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos() {}

  explicit DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = boost::any(*domains);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Domains"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domains = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos() = default;
};
class DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars : public Darabonba::Model {
public:
  shared_ptr<string> fieldRefFieldPath{};
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars() {}

  explicit DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldRefFieldPath) {
      res["FieldRefFieldPath"] = boost::any(*fieldRefFieldPath);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldRefFieldPath") != m.end() && !m["FieldRefFieldPath"].empty()) {
      fieldRefFieldPath = make_shared<string>(boost::any_cast<string>(m["FieldRefFieldPath"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars() = default;
};
class DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> protocol{};

  DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts() {}

  explicit DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts() = default;
};
class DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts : public Darabonba::Model {
public:
  shared_ptr<string> mountPath{};
  shared_ptr<string> mountPropagation{};
  shared_ptr<string> name{};
  shared_ptr<bool> readOnly{};
  shared_ptr<string> subPath{};

  DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts() {}

  explicit DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountPath) {
      res["MountPath"] = boost::any(*mountPath);
    }
    if (mountPropagation) {
      res["MountPropagation"] = boost::any(*mountPropagation);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    if (subPath) {
      res["SubPath"] = boost::any(*subPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MountPath") != m.end() && !m["MountPath"].empty()) {
      mountPath = make_shared<string>(boost::any_cast<string>(m["MountPath"]));
    }
    if (m.find("MountPropagation") != m.end() && !m["MountPropagation"].empty()) {
      mountPropagation = make_shared<string>(boost::any_cast<string>(m["MountPropagation"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
    if (m.find("SubPath") != m.end() && !m["SubPath"].empty()) {
      subPath = make_shared<string>(boost::any_cast<string>(m["SubPath"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts() = default;
};
class DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers : public Darabonba::Model {
public:
  shared_ptr<vector<string>> args{};
  shared_ptr<vector<string>> commands{};
  shared_ptr<double> cpu{};
  shared_ptr<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars>> environmentVars{};
  shared_ptr<long> gpu{};
  shared_ptr<string> image{};
  shared_ptr<string> imagePullPolicy{};
  shared_ptr<vector<string>> lifecyclePostStartHandlerExecs{};
  shared_ptr<string> lifecyclePostStartHandlerHttpGetHost{};
  shared_ptr<string> lifecyclePostStartHandlerHttpGetPath{};
  shared_ptr<long> lifecyclePostStartHandlerHttpGetPort{};
  shared_ptr<string> lifecyclePostStartHandlerHttpGetScheme{};
  shared_ptr<string> lifecyclePostStartHandlerTcpSocketHost{};
  shared_ptr<long> lifecyclePostStartHandlerTcpSocketPort{};
  shared_ptr<vector<string>> lifecyclePreStopHandlerExecs{};
  shared_ptr<string> lifecyclePreStopHandlerHttpGetHost{};
  shared_ptr<string> lifecyclePreStopHandlerHttpGetPath{};
  shared_ptr<long> lifecyclePreStopHandlerHttpGetPort{};
  shared_ptr<string> lifecyclePreStopHandlerHttpGetScheme{};
  shared_ptr<string> lifecyclePreStopHandlerTcpSocketHost{};
  shared_ptr<long> lifecyclePreStopHandlerTcpSocketPort{};
  shared_ptr<vector<string>> livenessProbeExecCommands{};
  shared_ptr<long> livenessProbeFailureThreshold{};
  shared_ptr<string> livenessProbeHttpGetPath{};
  shared_ptr<long> livenessProbeHttpGetPort{};
  shared_ptr<string> livenessProbeHttpGetScheme{};
  shared_ptr<long> livenessProbeInitialDelaySeconds{};
  shared_ptr<long> livenessProbePeriodSeconds{};
  shared_ptr<long> livenessProbeSuccessThreshold{};
  shared_ptr<long> livenessProbeTcpSocketPort{};
  shared_ptr<long> livenessProbeTimeoutSeconds{};
  shared_ptr<double> memory{};
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts>> ports{};
  shared_ptr<vector<string>> readinessProbeExecCommands{};
  shared_ptr<long> readinessProbeFailureThreshold{};
  shared_ptr<string> readinessProbeHttpGetPath{};
  shared_ptr<long> readinessProbeHttpGetPort{};
  shared_ptr<string> readinessProbeHttpGetScheme{};
  shared_ptr<long> readinessProbeInitialDelaySeconds{};
  shared_ptr<long> readinessProbePeriodSeconds{};
  shared_ptr<long> readinessProbeSuccessThreshold{};
  shared_ptr<long> readinessProbeTcpSocketPort{};
  shared_ptr<long> readinessProbeTimeoutSeconds{};
  shared_ptr<vector<string>> securityContextCapabilityAdds{};
  shared_ptr<bool> securityContextReadOnlyRootFilesystem{};
  shared_ptr<long> securityContextRunAsUser{};
  shared_ptr<bool> stdin{};
  shared_ptr<bool> stdinOnce{};
  shared_ptr<bool> tty{};
  shared_ptr<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts>> volumeMounts{};
  shared_ptr<string> workingDir{};

  DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers() {}

  explicit DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (args) {
      res["Args"] = boost::any(*args);
    }
    if (commands) {
      res["Commands"] = boost::any(*commands);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (environmentVars) {
      vector<boost::any> temp1;
      for(auto item1:*environmentVars){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnvironmentVars"] = boost::any(temp1);
    }
    if (gpu) {
      res["Gpu"] = boost::any(*gpu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (imagePullPolicy) {
      res["ImagePullPolicy"] = boost::any(*imagePullPolicy);
    }
    if (lifecyclePostStartHandlerExecs) {
      res["LifecyclePostStartHandlerExecs"] = boost::any(*lifecyclePostStartHandlerExecs);
    }
    if (lifecyclePostStartHandlerHttpGetHost) {
      res["LifecyclePostStartHandlerHttpGetHost"] = boost::any(*lifecyclePostStartHandlerHttpGetHost);
    }
    if (lifecyclePostStartHandlerHttpGetPath) {
      res["LifecyclePostStartHandlerHttpGetPath"] = boost::any(*lifecyclePostStartHandlerHttpGetPath);
    }
    if (lifecyclePostStartHandlerHttpGetPort) {
      res["LifecyclePostStartHandlerHttpGetPort"] = boost::any(*lifecyclePostStartHandlerHttpGetPort);
    }
    if (lifecyclePostStartHandlerHttpGetScheme) {
      res["LifecyclePostStartHandlerHttpGetScheme"] = boost::any(*lifecyclePostStartHandlerHttpGetScheme);
    }
    if (lifecyclePostStartHandlerTcpSocketHost) {
      res["LifecyclePostStartHandlerTcpSocketHost"] = boost::any(*lifecyclePostStartHandlerTcpSocketHost);
    }
    if (lifecyclePostStartHandlerTcpSocketPort) {
      res["LifecyclePostStartHandlerTcpSocketPort"] = boost::any(*lifecyclePostStartHandlerTcpSocketPort);
    }
    if (lifecyclePreStopHandlerExecs) {
      res["LifecyclePreStopHandlerExecs"] = boost::any(*lifecyclePreStopHandlerExecs);
    }
    if (lifecyclePreStopHandlerHttpGetHost) {
      res["LifecyclePreStopHandlerHttpGetHost"] = boost::any(*lifecyclePreStopHandlerHttpGetHost);
    }
    if (lifecyclePreStopHandlerHttpGetPath) {
      res["LifecyclePreStopHandlerHttpGetPath"] = boost::any(*lifecyclePreStopHandlerHttpGetPath);
    }
    if (lifecyclePreStopHandlerHttpGetPort) {
      res["LifecyclePreStopHandlerHttpGetPort"] = boost::any(*lifecyclePreStopHandlerHttpGetPort);
    }
    if (lifecyclePreStopHandlerHttpGetScheme) {
      res["LifecyclePreStopHandlerHttpGetScheme"] = boost::any(*lifecyclePreStopHandlerHttpGetScheme);
    }
    if (lifecyclePreStopHandlerTcpSocketHost) {
      res["LifecyclePreStopHandlerTcpSocketHost"] = boost::any(*lifecyclePreStopHandlerTcpSocketHost);
    }
    if (lifecyclePreStopHandlerTcpSocketPort) {
      res["LifecyclePreStopHandlerTcpSocketPort"] = boost::any(*lifecyclePreStopHandlerTcpSocketPort);
    }
    if (livenessProbeExecCommands) {
      res["LivenessProbeExecCommands"] = boost::any(*livenessProbeExecCommands);
    }
    if (livenessProbeFailureThreshold) {
      res["LivenessProbeFailureThreshold"] = boost::any(*livenessProbeFailureThreshold);
    }
    if (livenessProbeHttpGetPath) {
      res["LivenessProbeHttpGetPath"] = boost::any(*livenessProbeHttpGetPath);
    }
    if (livenessProbeHttpGetPort) {
      res["LivenessProbeHttpGetPort"] = boost::any(*livenessProbeHttpGetPort);
    }
    if (livenessProbeHttpGetScheme) {
      res["LivenessProbeHttpGetScheme"] = boost::any(*livenessProbeHttpGetScheme);
    }
    if (livenessProbeInitialDelaySeconds) {
      res["LivenessProbeInitialDelaySeconds"] = boost::any(*livenessProbeInitialDelaySeconds);
    }
    if (livenessProbePeriodSeconds) {
      res["LivenessProbePeriodSeconds"] = boost::any(*livenessProbePeriodSeconds);
    }
    if (livenessProbeSuccessThreshold) {
      res["LivenessProbeSuccessThreshold"] = boost::any(*livenessProbeSuccessThreshold);
    }
    if (livenessProbeTcpSocketPort) {
      res["LivenessProbeTcpSocketPort"] = boost::any(*livenessProbeTcpSocketPort);
    }
    if (livenessProbeTimeoutSeconds) {
      res["LivenessProbeTimeoutSeconds"] = boost::any(*livenessProbeTimeoutSeconds);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ports) {
      vector<boost::any> temp1;
      for(auto item1:*ports){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ports"] = boost::any(temp1);
    }
    if (readinessProbeExecCommands) {
      res["ReadinessProbeExecCommands"] = boost::any(*readinessProbeExecCommands);
    }
    if (readinessProbeFailureThreshold) {
      res["ReadinessProbeFailureThreshold"] = boost::any(*readinessProbeFailureThreshold);
    }
    if (readinessProbeHttpGetPath) {
      res["ReadinessProbeHttpGetPath"] = boost::any(*readinessProbeHttpGetPath);
    }
    if (readinessProbeHttpGetPort) {
      res["ReadinessProbeHttpGetPort"] = boost::any(*readinessProbeHttpGetPort);
    }
    if (readinessProbeHttpGetScheme) {
      res["ReadinessProbeHttpGetScheme"] = boost::any(*readinessProbeHttpGetScheme);
    }
    if (readinessProbeInitialDelaySeconds) {
      res["ReadinessProbeInitialDelaySeconds"] = boost::any(*readinessProbeInitialDelaySeconds);
    }
    if (readinessProbePeriodSeconds) {
      res["ReadinessProbePeriodSeconds"] = boost::any(*readinessProbePeriodSeconds);
    }
    if (readinessProbeSuccessThreshold) {
      res["ReadinessProbeSuccessThreshold"] = boost::any(*readinessProbeSuccessThreshold);
    }
    if (readinessProbeTcpSocketPort) {
      res["ReadinessProbeTcpSocketPort"] = boost::any(*readinessProbeTcpSocketPort);
    }
    if (readinessProbeTimeoutSeconds) {
      res["ReadinessProbeTimeoutSeconds"] = boost::any(*readinessProbeTimeoutSeconds);
    }
    if (securityContextCapabilityAdds) {
      res["SecurityContextCapabilityAdds"] = boost::any(*securityContextCapabilityAdds);
    }
    if (securityContextReadOnlyRootFilesystem) {
      res["SecurityContextReadOnlyRootFilesystem"] = boost::any(*securityContextReadOnlyRootFilesystem);
    }
    if (securityContextRunAsUser) {
      res["SecurityContextRunAsUser"] = boost::any(*securityContextRunAsUser);
    }
    if (stdin) {
      res["Stdin"] = boost::any(*stdin);
    }
    if (stdinOnce) {
      res["StdinOnce"] = boost::any(*stdinOnce);
    }
    if (tty) {
      res["Tty"] = boost::any(*tty);
    }
    if (volumeMounts) {
      vector<boost::any> temp1;
      for(auto item1:*volumeMounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VolumeMounts"] = boost::any(temp1);
    }
    if (workingDir) {
      res["WorkingDir"] = boost::any(*workingDir);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Args") != m.end() && !m["Args"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Args"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Args"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      args = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Commands") != m.end() && !m["Commands"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Commands"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Commands"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      commands = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<double>(boost::any_cast<double>(m["Cpu"]));
    }
    if (m.find("EnvironmentVars") != m.end() && !m["EnvironmentVars"].empty()) {
      if (typeid(vector<boost::any>) == m["EnvironmentVars"].type()) {
        vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnvironmentVars"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        environmentVars = make_shared<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars>>(expect1);
      }
    }
    if (m.find("Gpu") != m.end() && !m["Gpu"].empty()) {
      gpu = make_shared<long>(boost::any_cast<long>(m["Gpu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ImagePullPolicy") != m.end() && !m["ImagePullPolicy"].empty()) {
      imagePullPolicy = make_shared<string>(boost::any_cast<string>(m["ImagePullPolicy"]));
    }
    if (m.find("LifecyclePostStartHandlerExecs") != m.end() && !m["LifecyclePostStartHandlerExecs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LifecyclePostStartHandlerExecs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LifecyclePostStartHandlerExecs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      lifecyclePostStartHandlerExecs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LifecyclePostStartHandlerHttpGetHost") != m.end() && !m["LifecyclePostStartHandlerHttpGetHost"].empty()) {
      lifecyclePostStartHandlerHttpGetHost = make_shared<string>(boost::any_cast<string>(m["LifecyclePostStartHandlerHttpGetHost"]));
    }
    if (m.find("LifecyclePostStartHandlerHttpGetPath") != m.end() && !m["LifecyclePostStartHandlerHttpGetPath"].empty()) {
      lifecyclePostStartHandlerHttpGetPath = make_shared<string>(boost::any_cast<string>(m["LifecyclePostStartHandlerHttpGetPath"]));
    }
    if (m.find("LifecyclePostStartHandlerHttpGetPort") != m.end() && !m["LifecyclePostStartHandlerHttpGetPort"].empty()) {
      lifecyclePostStartHandlerHttpGetPort = make_shared<long>(boost::any_cast<long>(m["LifecyclePostStartHandlerHttpGetPort"]));
    }
    if (m.find("LifecyclePostStartHandlerHttpGetScheme") != m.end() && !m["LifecyclePostStartHandlerHttpGetScheme"].empty()) {
      lifecyclePostStartHandlerHttpGetScheme = make_shared<string>(boost::any_cast<string>(m["LifecyclePostStartHandlerHttpGetScheme"]));
    }
    if (m.find("LifecyclePostStartHandlerTcpSocketHost") != m.end() && !m["LifecyclePostStartHandlerTcpSocketHost"].empty()) {
      lifecyclePostStartHandlerTcpSocketHost = make_shared<string>(boost::any_cast<string>(m["LifecyclePostStartHandlerTcpSocketHost"]));
    }
    if (m.find("LifecyclePostStartHandlerTcpSocketPort") != m.end() && !m["LifecyclePostStartHandlerTcpSocketPort"].empty()) {
      lifecyclePostStartHandlerTcpSocketPort = make_shared<long>(boost::any_cast<long>(m["LifecyclePostStartHandlerTcpSocketPort"]));
    }
    if (m.find("LifecyclePreStopHandlerExecs") != m.end() && !m["LifecyclePreStopHandlerExecs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LifecyclePreStopHandlerExecs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LifecyclePreStopHandlerExecs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      lifecyclePreStopHandlerExecs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LifecyclePreStopHandlerHttpGetHost") != m.end() && !m["LifecyclePreStopHandlerHttpGetHost"].empty()) {
      lifecyclePreStopHandlerHttpGetHost = make_shared<string>(boost::any_cast<string>(m["LifecyclePreStopHandlerHttpGetHost"]));
    }
    if (m.find("LifecyclePreStopHandlerHttpGetPath") != m.end() && !m["LifecyclePreStopHandlerHttpGetPath"].empty()) {
      lifecyclePreStopHandlerHttpGetPath = make_shared<string>(boost::any_cast<string>(m["LifecyclePreStopHandlerHttpGetPath"]));
    }
    if (m.find("LifecyclePreStopHandlerHttpGetPort") != m.end() && !m["LifecyclePreStopHandlerHttpGetPort"].empty()) {
      lifecyclePreStopHandlerHttpGetPort = make_shared<long>(boost::any_cast<long>(m["LifecyclePreStopHandlerHttpGetPort"]));
    }
    if (m.find("LifecyclePreStopHandlerHttpGetScheme") != m.end() && !m["LifecyclePreStopHandlerHttpGetScheme"].empty()) {
      lifecyclePreStopHandlerHttpGetScheme = make_shared<string>(boost::any_cast<string>(m["LifecyclePreStopHandlerHttpGetScheme"]));
    }
    if (m.find("LifecyclePreStopHandlerTcpSocketHost") != m.end() && !m["LifecyclePreStopHandlerTcpSocketHost"].empty()) {
      lifecyclePreStopHandlerTcpSocketHost = make_shared<string>(boost::any_cast<string>(m["LifecyclePreStopHandlerTcpSocketHost"]));
    }
    if (m.find("LifecyclePreStopHandlerTcpSocketPort") != m.end() && !m["LifecyclePreStopHandlerTcpSocketPort"].empty()) {
      lifecyclePreStopHandlerTcpSocketPort = make_shared<long>(boost::any_cast<long>(m["LifecyclePreStopHandlerTcpSocketPort"]));
    }
    if (m.find("LivenessProbeExecCommands") != m.end() && !m["LivenessProbeExecCommands"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LivenessProbeExecCommands"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LivenessProbeExecCommands"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      livenessProbeExecCommands = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LivenessProbeFailureThreshold") != m.end() && !m["LivenessProbeFailureThreshold"].empty()) {
      livenessProbeFailureThreshold = make_shared<long>(boost::any_cast<long>(m["LivenessProbeFailureThreshold"]));
    }
    if (m.find("LivenessProbeHttpGetPath") != m.end() && !m["LivenessProbeHttpGetPath"].empty()) {
      livenessProbeHttpGetPath = make_shared<string>(boost::any_cast<string>(m["LivenessProbeHttpGetPath"]));
    }
    if (m.find("LivenessProbeHttpGetPort") != m.end() && !m["LivenessProbeHttpGetPort"].empty()) {
      livenessProbeHttpGetPort = make_shared<long>(boost::any_cast<long>(m["LivenessProbeHttpGetPort"]));
    }
    if (m.find("LivenessProbeHttpGetScheme") != m.end() && !m["LivenessProbeHttpGetScheme"].empty()) {
      livenessProbeHttpGetScheme = make_shared<string>(boost::any_cast<string>(m["LivenessProbeHttpGetScheme"]));
    }
    if (m.find("LivenessProbeInitialDelaySeconds") != m.end() && !m["LivenessProbeInitialDelaySeconds"].empty()) {
      livenessProbeInitialDelaySeconds = make_shared<long>(boost::any_cast<long>(m["LivenessProbeInitialDelaySeconds"]));
    }
    if (m.find("LivenessProbePeriodSeconds") != m.end() && !m["LivenessProbePeriodSeconds"].empty()) {
      livenessProbePeriodSeconds = make_shared<long>(boost::any_cast<long>(m["LivenessProbePeriodSeconds"]));
    }
    if (m.find("LivenessProbeSuccessThreshold") != m.end() && !m["LivenessProbeSuccessThreshold"].empty()) {
      livenessProbeSuccessThreshold = make_shared<long>(boost::any_cast<long>(m["LivenessProbeSuccessThreshold"]));
    }
    if (m.find("LivenessProbeTcpSocketPort") != m.end() && !m["LivenessProbeTcpSocketPort"].empty()) {
      livenessProbeTcpSocketPort = make_shared<long>(boost::any_cast<long>(m["LivenessProbeTcpSocketPort"]));
    }
    if (m.find("LivenessProbeTimeoutSeconds") != m.end() && !m["LivenessProbeTimeoutSeconds"].empty()) {
      livenessProbeTimeoutSeconds = make_shared<long>(boost::any_cast<long>(m["LivenessProbeTimeoutSeconds"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Ports") != m.end() && !m["Ports"].empty()) {
      if (typeid(vector<boost::any>) == m["Ports"].type()) {
        vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ports"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ports = make_shared<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts>>(expect1);
      }
    }
    if (m.find("ReadinessProbeExecCommands") != m.end() && !m["ReadinessProbeExecCommands"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReadinessProbeExecCommands"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReadinessProbeExecCommands"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      readinessProbeExecCommands = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ReadinessProbeFailureThreshold") != m.end() && !m["ReadinessProbeFailureThreshold"].empty()) {
      readinessProbeFailureThreshold = make_shared<long>(boost::any_cast<long>(m["ReadinessProbeFailureThreshold"]));
    }
    if (m.find("ReadinessProbeHttpGetPath") != m.end() && !m["ReadinessProbeHttpGetPath"].empty()) {
      readinessProbeHttpGetPath = make_shared<string>(boost::any_cast<string>(m["ReadinessProbeHttpGetPath"]));
    }
    if (m.find("ReadinessProbeHttpGetPort") != m.end() && !m["ReadinessProbeHttpGetPort"].empty()) {
      readinessProbeHttpGetPort = make_shared<long>(boost::any_cast<long>(m["ReadinessProbeHttpGetPort"]));
    }
    if (m.find("ReadinessProbeHttpGetScheme") != m.end() && !m["ReadinessProbeHttpGetScheme"].empty()) {
      readinessProbeHttpGetScheme = make_shared<string>(boost::any_cast<string>(m["ReadinessProbeHttpGetScheme"]));
    }
    if (m.find("ReadinessProbeInitialDelaySeconds") != m.end() && !m["ReadinessProbeInitialDelaySeconds"].empty()) {
      readinessProbeInitialDelaySeconds = make_shared<long>(boost::any_cast<long>(m["ReadinessProbeInitialDelaySeconds"]));
    }
    if (m.find("ReadinessProbePeriodSeconds") != m.end() && !m["ReadinessProbePeriodSeconds"].empty()) {
      readinessProbePeriodSeconds = make_shared<long>(boost::any_cast<long>(m["ReadinessProbePeriodSeconds"]));
    }
    if (m.find("ReadinessProbeSuccessThreshold") != m.end() && !m["ReadinessProbeSuccessThreshold"].empty()) {
      readinessProbeSuccessThreshold = make_shared<long>(boost::any_cast<long>(m["ReadinessProbeSuccessThreshold"]));
    }
    if (m.find("ReadinessProbeTcpSocketPort") != m.end() && !m["ReadinessProbeTcpSocketPort"].empty()) {
      readinessProbeTcpSocketPort = make_shared<long>(boost::any_cast<long>(m["ReadinessProbeTcpSocketPort"]));
    }
    if (m.find("ReadinessProbeTimeoutSeconds") != m.end() && !m["ReadinessProbeTimeoutSeconds"].empty()) {
      readinessProbeTimeoutSeconds = make_shared<long>(boost::any_cast<long>(m["ReadinessProbeTimeoutSeconds"]));
    }
    if (m.find("SecurityContextCapabilityAdds") != m.end() && !m["SecurityContextCapabilityAdds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityContextCapabilityAdds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityContextCapabilityAdds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityContextCapabilityAdds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SecurityContextReadOnlyRootFilesystem") != m.end() && !m["SecurityContextReadOnlyRootFilesystem"].empty()) {
      securityContextReadOnlyRootFilesystem = make_shared<bool>(boost::any_cast<bool>(m["SecurityContextReadOnlyRootFilesystem"]));
    }
    if (m.find("SecurityContextRunAsUser") != m.end() && !m["SecurityContextRunAsUser"].empty()) {
      securityContextRunAsUser = make_shared<long>(boost::any_cast<long>(m["SecurityContextRunAsUser"]));
    }
    if (m.find("Stdin") != m.end() && !m["Stdin"].empty()) {
      stdin = make_shared<bool>(boost::any_cast<bool>(m["Stdin"]));
    }
    if (m.find("StdinOnce") != m.end() && !m["StdinOnce"].empty()) {
      stdinOnce = make_shared<bool>(boost::any_cast<bool>(m["StdinOnce"]));
    }
    if (m.find("Tty") != m.end() && !m["Tty"].empty()) {
      tty = make_shared<bool>(boost::any_cast<bool>(m["Tty"]));
    }
    if (m.find("VolumeMounts") != m.end() && !m["VolumeMounts"].empty()) {
      if (typeid(vector<boost::any>) == m["VolumeMounts"].type()) {
        vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VolumeMounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        volumeMounts = make_shared<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts>>(expect1);
      }
    }
    if (m.find("WorkingDir") != m.end() && !m["WorkingDir"].empty()) {
      workingDir = make_shared<string>(boost::any_cast<string>(m["WorkingDir"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers() = default;
};
class DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions() {}

  explicit DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions() = default;
};
class DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases : public Darabonba::Model {
public:
  shared_ptr<vector<string>> hostnames{};
  shared_ptr<string> ip{};

  DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases() {}

  explicit DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostnames) {
      res["Hostnames"] = boost::any(*hostnames);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Hostnames") != m.end() && !m["Hostnames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Hostnames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Hostnames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostnames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases() = default;
};
class DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials : public Darabonba::Model {
public:
  shared_ptr<string> password{};
  shared_ptr<string> server{};
  shared_ptr<string> userName{};

  DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials() {}

  explicit DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (server) {
      res["Server"] = boost::any(*server);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Server") != m.end() && !m["Server"].empty()) {
      server = make_shared<string>(boost::any_cast<string>(m["Server"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials() = default;
};
class DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars : public Darabonba::Model {
public:
  shared_ptr<string> fieldRefFieldPath{};
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars() {}

  explicit DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldRefFieldPath) {
      res["FieldRefFieldPath"] = boost::any(*fieldRefFieldPath);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldRefFieldPath") != m.end() && !m["FieldRefFieldPath"].empty()) {
      fieldRefFieldPath = make_shared<string>(boost::any_cast<string>(m["FieldRefFieldPath"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars() = default;
};
class DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> protocol{};

  DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts() {}

  explicit DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts() = default;
};
class DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts : public Darabonba::Model {
public:
  shared_ptr<string> mountPath{};
  shared_ptr<string> mountPropagation{};
  shared_ptr<string> name{};
  shared_ptr<bool> readOnly{};
  shared_ptr<string> subPath{};

  DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts() {}

  explicit DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountPath) {
      res["MountPath"] = boost::any(*mountPath);
    }
    if (mountPropagation) {
      res["MountPropagation"] = boost::any(*mountPropagation);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    if (subPath) {
      res["SubPath"] = boost::any(*subPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MountPath") != m.end() && !m["MountPath"].empty()) {
      mountPath = make_shared<string>(boost::any_cast<string>(m["MountPath"]));
    }
    if (m.find("MountPropagation") != m.end() && !m["MountPropagation"].empty()) {
      mountPropagation = make_shared<string>(boost::any_cast<string>(m["MountPropagation"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
    if (m.find("SubPath") != m.end() && !m["SubPath"].empty()) {
      subPath = make_shared<string>(boost::any_cast<string>(m["SubPath"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts() = default;
};
class DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers : public Darabonba::Model {
public:
  shared_ptr<double> cpu{};
  shared_ptr<long> gpu{};
  shared_ptr<string> image{};
  shared_ptr<string> imagePullPolicy{};
  shared_ptr<vector<string>> initContainerArgs{};
  shared_ptr<vector<string>> initContainerCommands{};
  shared_ptr<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars>> initContainerEnvironmentVars{};
  shared_ptr<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts>> initContainerPorts{};
  shared_ptr<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts>> initContainerVolumeMounts{};
  shared_ptr<double> memory{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> securityContextCapabilityAdds{};
  shared_ptr<bool> securityContextReadOnlyRootFilesystem{};
  shared_ptr<string> securityContextRunAsUser{};
  shared_ptr<string> workingDir{};

  DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers() {}

  explicit DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (gpu) {
      res["Gpu"] = boost::any(*gpu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (imagePullPolicy) {
      res["ImagePullPolicy"] = boost::any(*imagePullPolicy);
    }
    if (initContainerArgs) {
      res["InitContainerArgs"] = boost::any(*initContainerArgs);
    }
    if (initContainerCommands) {
      res["InitContainerCommands"] = boost::any(*initContainerCommands);
    }
    if (initContainerEnvironmentVars) {
      vector<boost::any> temp1;
      for(auto item1:*initContainerEnvironmentVars){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InitContainerEnvironmentVars"] = boost::any(temp1);
    }
    if (initContainerPorts) {
      vector<boost::any> temp1;
      for(auto item1:*initContainerPorts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InitContainerPorts"] = boost::any(temp1);
    }
    if (initContainerVolumeMounts) {
      vector<boost::any> temp1;
      for(auto item1:*initContainerVolumeMounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InitContainerVolumeMounts"] = boost::any(temp1);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (securityContextCapabilityAdds) {
      res["SecurityContextCapabilityAdds"] = boost::any(*securityContextCapabilityAdds);
    }
    if (securityContextReadOnlyRootFilesystem) {
      res["SecurityContextReadOnlyRootFilesystem"] = boost::any(*securityContextReadOnlyRootFilesystem);
    }
    if (securityContextRunAsUser) {
      res["SecurityContextRunAsUser"] = boost::any(*securityContextRunAsUser);
    }
    if (workingDir) {
      res["WorkingDir"] = boost::any(*workingDir);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<double>(boost::any_cast<double>(m["Cpu"]));
    }
    if (m.find("Gpu") != m.end() && !m["Gpu"].empty()) {
      gpu = make_shared<long>(boost::any_cast<long>(m["Gpu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ImagePullPolicy") != m.end() && !m["ImagePullPolicy"].empty()) {
      imagePullPolicy = make_shared<string>(boost::any_cast<string>(m["ImagePullPolicy"]));
    }
    if (m.find("InitContainerArgs") != m.end() && !m["InitContainerArgs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InitContainerArgs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InitContainerArgs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      initContainerArgs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InitContainerCommands") != m.end() && !m["InitContainerCommands"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InitContainerCommands"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InitContainerCommands"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      initContainerCommands = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InitContainerEnvironmentVars") != m.end() && !m["InitContainerEnvironmentVars"].empty()) {
      if (typeid(vector<boost::any>) == m["InitContainerEnvironmentVars"].type()) {
        vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InitContainerEnvironmentVars"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        initContainerEnvironmentVars = make_shared<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars>>(expect1);
      }
    }
    if (m.find("InitContainerPorts") != m.end() && !m["InitContainerPorts"].empty()) {
      if (typeid(vector<boost::any>) == m["InitContainerPorts"].type()) {
        vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InitContainerPorts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        initContainerPorts = make_shared<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts>>(expect1);
      }
    }
    if (m.find("InitContainerVolumeMounts") != m.end() && !m["InitContainerVolumeMounts"].empty()) {
      if (typeid(vector<boost::any>) == m["InitContainerVolumeMounts"].type()) {
        vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InitContainerVolumeMounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        initContainerVolumeMounts = make_shared<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts>>(expect1);
      }
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SecurityContextCapabilityAdds") != m.end() && !m["SecurityContextCapabilityAdds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityContextCapabilityAdds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityContextCapabilityAdds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityContextCapabilityAdds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SecurityContextReadOnlyRootFilesystem") != m.end() && !m["SecurityContextReadOnlyRootFilesystem"].empty()) {
      securityContextReadOnlyRootFilesystem = make_shared<bool>(boost::any_cast<bool>(m["SecurityContextReadOnlyRootFilesystem"]));
    }
    if (m.find("SecurityContextRunAsUser") != m.end() && !m["SecurityContextRunAsUser"].empty()) {
      securityContextRunAsUser = make_shared<string>(boost::any_cast<string>(m["SecurityContextRunAsUser"]));
    }
    if (m.find("WorkingDir") != m.end() && !m["WorkingDir"].empty()) {
      workingDir = make_shared<string>(boost::any_cast<string>(m["WorkingDir"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers() = default;
};
class DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls() {}

  explicit DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls() = default;
};
class DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags() {}

  explicit DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags() = default;
};
class DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> mode{};
  shared_ptr<string> path{};

  DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths() {}

  explicit DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<long>(boost::any_cast<long>(m["Mode"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths() = default;
};
class DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths>> configFileVolumeConfigFileToPaths{};
  shared_ptr<long> configFileVolumeDefaultMode{};
  shared_ptr<string> diskVolumeDiskId{};
  shared_ptr<long> diskVolumeDiskSize{};
  shared_ptr<string> diskVolumeFsType{};
  shared_ptr<string> emptyDirVolumeMedium{};
  shared_ptr<string> emptyDirVolumeSizeLimit{};
  shared_ptr<string> flexVolumeDriver{};
  shared_ptr<string> flexVolumeFsType{};
  shared_ptr<string> flexVolumeOptions{};
  shared_ptr<string> hostPathVolumePath{};
  shared_ptr<string> hostPathVolumeType{};
  shared_ptr<string> NFSVolumePath{};
  shared_ptr<bool> NFSVolumeReadOnly{};
  shared_ptr<string> NFSVolumeServer{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes() {}

  explicit DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configFileVolumeConfigFileToPaths) {
      vector<boost::any> temp1;
      for(auto item1:*configFileVolumeConfigFileToPaths){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigFileVolumeConfigFileToPaths"] = boost::any(temp1);
    }
    if (configFileVolumeDefaultMode) {
      res["ConfigFileVolumeDefaultMode"] = boost::any(*configFileVolumeDefaultMode);
    }
    if (diskVolumeDiskId) {
      res["DiskVolumeDiskId"] = boost::any(*diskVolumeDiskId);
    }
    if (diskVolumeDiskSize) {
      res["DiskVolumeDiskSize"] = boost::any(*diskVolumeDiskSize);
    }
    if (diskVolumeFsType) {
      res["DiskVolumeFsType"] = boost::any(*diskVolumeFsType);
    }
    if (emptyDirVolumeMedium) {
      res["EmptyDirVolumeMedium"] = boost::any(*emptyDirVolumeMedium);
    }
    if (emptyDirVolumeSizeLimit) {
      res["EmptyDirVolumeSizeLimit"] = boost::any(*emptyDirVolumeSizeLimit);
    }
    if (flexVolumeDriver) {
      res["FlexVolumeDriver"] = boost::any(*flexVolumeDriver);
    }
    if (flexVolumeFsType) {
      res["FlexVolumeFsType"] = boost::any(*flexVolumeFsType);
    }
    if (flexVolumeOptions) {
      res["FlexVolumeOptions"] = boost::any(*flexVolumeOptions);
    }
    if (hostPathVolumePath) {
      res["HostPathVolumePath"] = boost::any(*hostPathVolumePath);
    }
    if (hostPathVolumeType) {
      res["HostPathVolumeType"] = boost::any(*hostPathVolumeType);
    }
    if (NFSVolumePath) {
      res["NFSVolumePath"] = boost::any(*NFSVolumePath);
    }
    if (NFSVolumeReadOnly) {
      res["NFSVolumeReadOnly"] = boost::any(*NFSVolumeReadOnly);
    }
    if (NFSVolumeServer) {
      res["NFSVolumeServer"] = boost::any(*NFSVolumeServer);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigFileVolumeConfigFileToPaths") != m.end() && !m["ConfigFileVolumeConfigFileToPaths"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigFileVolumeConfigFileToPaths"].type()) {
        vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigFileVolumeConfigFileToPaths"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configFileVolumeConfigFileToPaths = make_shared<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths>>(expect1);
      }
    }
    if (m.find("ConfigFileVolumeDefaultMode") != m.end() && !m["ConfigFileVolumeDefaultMode"].empty()) {
      configFileVolumeDefaultMode = make_shared<long>(boost::any_cast<long>(m["ConfigFileVolumeDefaultMode"]));
    }
    if (m.find("DiskVolumeDiskId") != m.end() && !m["DiskVolumeDiskId"].empty()) {
      diskVolumeDiskId = make_shared<string>(boost::any_cast<string>(m["DiskVolumeDiskId"]));
    }
    if (m.find("DiskVolumeDiskSize") != m.end() && !m["DiskVolumeDiskSize"].empty()) {
      diskVolumeDiskSize = make_shared<long>(boost::any_cast<long>(m["DiskVolumeDiskSize"]));
    }
    if (m.find("DiskVolumeFsType") != m.end() && !m["DiskVolumeFsType"].empty()) {
      diskVolumeFsType = make_shared<string>(boost::any_cast<string>(m["DiskVolumeFsType"]));
    }
    if (m.find("EmptyDirVolumeMedium") != m.end() && !m["EmptyDirVolumeMedium"].empty()) {
      emptyDirVolumeMedium = make_shared<string>(boost::any_cast<string>(m["EmptyDirVolumeMedium"]));
    }
    if (m.find("EmptyDirVolumeSizeLimit") != m.end() && !m["EmptyDirVolumeSizeLimit"].empty()) {
      emptyDirVolumeSizeLimit = make_shared<string>(boost::any_cast<string>(m["EmptyDirVolumeSizeLimit"]));
    }
    if (m.find("FlexVolumeDriver") != m.end() && !m["FlexVolumeDriver"].empty()) {
      flexVolumeDriver = make_shared<string>(boost::any_cast<string>(m["FlexVolumeDriver"]));
    }
    if (m.find("FlexVolumeFsType") != m.end() && !m["FlexVolumeFsType"].empty()) {
      flexVolumeFsType = make_shared<string>(boost::any_cast<string>(m["FlexVolumeFsType"]));
    }
    if (m.find("FlexVolumeOptions") != m.end() && !m["FlexVolumeOptions"].empty()) {
      flexVolumeOptions = make_shared<string>(boost::any_cast<string>(m["FlexVolumeOptions"]));
    }
    if (m.find("HostPathVolumePath") != m.end() && !m["HostPathVolumePath"].empty()) {
      hostPathVolumePath = make_shared<string>(boost::any_cast<string>(m["HostPathVolumePath"]));
    }
    if (m.find("HostPathVolumeType") != m.end() && !m["HostPathVolumeType"].empty()) {
      hostPathVolumeType = make_shared<string>(boost::any_cast<string>(m["HostPathVolumeType"]));
    }
    if (m.find("NFSVolumePath") != m.end() && !m["NFSVolumePath"].empty()) {
      NFSVolumePath = make_shared<string>(boost::any_cast<string>(m["NFSVolumePath"]));
    }
    if (m.find("NFSVolumeReadOnly") != m.end() && !m["NFSVolumeReadOnly"].empty()) {
      NFSVolumeReadOnly = make_shared<bool>(boost::any_cast<bool>(m["NFSVolumeReadOnly"]));
    }
    if (m.find("NFSVolumeServer") != m.end() && !m["NFSVolumeServer"].empty()) {
      NFSVolumeServer = make_shared<string>(boost::any_cast<string>(m["NFSVolumeServer"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes() = default;
};
class DescribeEciScalingConfigurationsResponseBodyScalingConfigurations : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos>> acrRegistryInfos{};
  shared_ptr<long> activeDeadlineSeconds{};
  shared_ptr<bool> autoCreateEip{};
  shared_ptr<bool> autoMatchImageCache{};
  shared_ptr<string> containerGroupName{};
  shared_ptr<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers>> containers{};
  shared_ptr<bool> costOptimization{};
  shared_ptr<double> cpu{};
  shared_ptr<long> cpuOptionsCore{};
  shared_ptr<long> cpuOptionsThreadsPerCore{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> dataCacheBucket{};
  shared_ptr<bool> dataCacheBurstingEnabled{};
  shared_ptr<string> dataCachePL{};
  shared_ptr<long> dataCacheProvisionedIops{};
  shared_ptr<string> description{};
  shared_ptr<vector<string>> dnsConfigNameServers{};
  shared_ptr<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions>> dnsConfigOptions{};
  shared_ptr<vector<string>> dnsConfigSearches{};
  shared_ptr<string> dnsPolicy{};
  shared_ptr<long> egressBandwidth{};
  shared_ptr<long> eipBandwidth{};
  shared_ptr<long> ephemeralStorage{};
  shared_ptr<string> gpuDriverVersion{};
  shared_ptr<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases>> hostAliases{};
  shared_ptr<string> hostName{};
  shared_ptr<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials>> imageRegistryCredentials{};
  shared_ptr<string> imageSnapshotId{};
  shared_ptr<long> ingressBandwidth{};
  shared_ptr<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers>> initContainers{};
  shared_ptr<string> instanceFamilyLevel{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<long> ipv6AddressCount{};
  shared_ptr<string> lifecycleState{};
  shared_ptr<long> loadBalancerWeight{};
  shared_ptr<double> memory{};
  shared_ptr<vector<string>> ntpServers{};
  shared_ptr<string> ramRoleName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> restartPolicy{};
  shared_ptr<string> scalingConfigurationId{};
  shared_ptr<string> scalingConfigurationName{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls>> securityContextSysCtls{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<bool> slsEnable{};
  shared_ptr<double> spotPriceLimit{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags>> tags{};
  shared_ptr<long> terminationGracePeriodSeconds{};
  shared_ptr<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes>> volumes{};

  DescribeEciScalingConfigurationsResponseBodyScalingConfigurations() {}

  explicit DescribeEciScalingConfigurationsResponseBodyScalingConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acrRegistryInfos) {
      vector<boost::any> temp1;
      for(auto item1:*acrRegistryInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AcrRegistryInfos"] = boost::any(temp1);
    }
    if (activeDeadlineSeconds) {
      res["ActiveDeadlineSeconds"] = boost::any(*activeDeadlineSeconds);
    }
    if (autoCreateEip) {
      res["AutoCreateEip"] = boost::any(*autoCreateEip);
    }
    if (autoMatchImageCache) {
      res["AutoMatchImageCache"] = boost::any(*autoMatchImageCache);
    }
    if (containerGroupName) {
      res["ContainerGroupName"] = boost::any(*containerGroupName);
    }
    if (containers) {
      vector<boost::any> temp1;
      for(auto item1:*containers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Containers"] = boost::any(temp1);
    }
    if (costOptimization) {
      res["CostOptimization"] = boost::any(*costOptimization);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (cpuOptionsCore) {
      res["CpuOptionsCore"] = boost::any(*cpuOptionsCore);
    }
    if (cpuOptionsThreadsPerCore) {
      res["CpuOptionsThreadsPerCore"] = boost::any(*cpuOptionsThreadsPerCore);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (dataCacheBucket) {
      res["DataCacheBucket"] = boost::any(*dataCacheBucket);
    }
    if (dataCacheBurstingEnabled) {
      res["DataCacheBurstingEnabled"] = boost::any(*dataCacheBurstingEnabled);
    }
    if (dataCachePL) {
      res["DataCachePL"] = boost::any(*dataCachePL);
    }
    if (dataCacheProvisionedIops) {
      res["DataCacheProvisionedIops"] = boost::any(*dataCacheProvisionedIops);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dnsConfigNameServers) {
      res["DnsConfigNameServers"] = boost::any(*dnsConfigNameServers);
    }
    if (dnsConfigOptions) {
      vector<boost::any> temp1;
      for(auto item1:*dnsConfigOptions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DnsConfigOptions"] = boost::any(temp1);
    }
    if (dnsConfigSearches) {
      res["DnsConfigSearches"] = boost::any(*dnsConfigSearches);
    }
    if (dnsPolicy) {
      res["DnsPolicy"] = boost::any(*dnsPolicy);
    }
    if (egressBandwidth) {
      res["EgressBandwidth"] = boost::any(*egressBandwidth);
    }
    if (eipBandwidth) {
      res["EipBandwidth"] = boost::any(*eipBandwidth);
    }
    if (ephemeralStorage) {
      res["EphemeralStorage"] = boost::any(*ephemeralStorage);
    }
    if (gpuDriverVersion) {
      res["GpuDriverVersion"] = boost::any(*gpuDriverVersion);
    }
    if (hostAliases) {
      vector<boost::any> temp1;
      for(auto item1:*hostAliases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostAliases"] = boost::any(temp1);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (imageRegistryCredentials) {
      vector<boost::any> temp1;
      for(auto item1:*imageRegistryCredentials){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageRegistryCredentials"] = boost::any(temp1);
    }
    if (imageSnapshotId) {
      res["ImageSnapshotId"] = boost::any(*imageSnapshotId);
    }
    if (ingressBandwidth) {
      res["IngressBandwidth"] = boost::any(*ingressBandwidth);
    }
    if (initContainers) {
      vector<boost::any> temp1;
      for(auto item1:*initContainers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InitContainers"] = boost::any(temp1);
    }
    if (instanceFamilyLevel) {
      res["InstanceFamilyLevel"] = boost::any(*instanceFamilyLevel);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = boost::any(*instanceTypes);
    }
    if (ipv6AddressCount) {
      res["Ipv6AddressCount"] = boost::any(*ipv6AddressCount);
    }
    if (lifecycleState) {
      res["LifecycleState"] = boost::any(*lifecycleState);
    }
    if (loadBalancerWeight) {
      res["LoadBalancerWeight"] = boost::any(*loadBalancerWeight);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (ntpServers) {
      res["NtpServers"] = boost::any(*ntpServers);
    }
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (restartPolicy) {
      res["RestartPolicy"] = boost::any(*restartPolicy);
    }
    if (scalingConfigurationId) {
      res["ScalingConfigurationId"] = boost::any(*scalingConfigurationId);
    }
    if (scalingConfigurationName) {
      res["ScalingConfigurationName"] = boost::any(*scalingConfigurationName);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (securityContextSysCtls) {
      vector<boost::any> temp1;
      for(auto item1:*securityContextSysCtls){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityContextSysCtls"] = boost::any(temp1);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (slsEnable) {
      res["SlsEnable"] = boost::any(*slsEnable);
    }
    if (spotPriceLimit) {
      res["SpotPriceLimit"] = boost::any(*spotPriceLimit);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (terminationGracePeriodSeconds) {
      res["TerminationGracePeriodSeconds"] = boost::any(*terminationGracePeriodSeconds);
    }
    if (volumes) {
      vector<boost::any> temp1;
      for(auto item1:*volumes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Volumes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcrRegistryInfos") != m.end() && !m["AcrRegistryInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["AcrRegistryInfos"].type()) {
        vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AcrRegistryInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        acrRegistryInfos = make_shared<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos>>(expect1);
      }
    }
    if (m.find("ActiveDeadlineSeconds") != m.end() && !m["ActiveDeadlineSeconds"].empty()) {
      activeDeadlineSeconds = make_shared<long>(boost::any_cast<long>(m["ActiveDeadlineSeconds"]));
    }
    if (m.find("AutoCreateEip") != m.end() && !m["AutoCreateEip"].empty()) {
      autoCreateEip = make_shared<bool>(boost::any_cast<bool>(m["AutoCreateEip"]));
    }
    if (m.find("AutoMatchImageCache") != m.end() && !m["AutoMatchImageCache"].empty()) {
      autoMatchImageCache = make_shared<bool>(boost::any_cast<bool>(m["AutoMatchImageCache"]));
    }
    if (m.find("ContainerGroupName") != m.end() && !m["ContainerGroupName"].empty()) {
      containerGroupName = make_shared<string>(boost::any_cast<string>(m["ContainerGroupName"]));
    }
    if (m.find("Containers") != m.end() && !m["Containers"].empty()) {
      if (typeid(vector<boost::any>) == m["Containers"].type()) {
        vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Containers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        containers = make_shared<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers>>(expect1);
      }
    }
    if (m.find("CostOptimization") != m.end() && !m["CostOptimization"].empty()) {
      costOptimization = make_shared<bool>(boost::any_cast<bool>(m["CostOptimization"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<double>(boost::any_cast<double>(m["Cpu"]));
    }
    if (m.find("CpuOptionsCore") != m.end() && !m["CpuOptionsCore"].empty()) {
      cpuOptionsCore = make_shared<long>(boost::any_cast<long>(m["CpuOptionsCore"]));
    }
    if (m.find("CpuOptionsThreadsPerCore") != m.end() && !m["CpuOptionsThreadsPerCore"].empty()) {
      cpuOptionsThreadsPerCore = make_shared<long>(boost::any_cast<long>(m["CpuOptionsThreadsPerCore"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DataCacheBucket") != m.end() && !m["DataCacheBucket"].empty()) {
      dataCacheBucket = make_shared<string>(boost::any_cast<string>(m["DataCacheBucket"]));
    }
    if (m.find("DataCacheBurstingEnabled") != m.end() && !m["DataCacheBurstingEnabled"].empty()) {
      dataCacheBurstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["DataCacheBurstingEnabled"]));
    }
    if (m.find("DataCachePL") != m.end() && !m["DataCachePL"].empty()) {
      dataCachePL = make_shared<string>(boost::any_cast<string>(m["DataCachePL"]));
    }
    if (m.find("DataCacheProvisionedIops") != m.end() && !m["DataCacheProvisionedIops"].empty()) {
      dataCacheProvisionedIops = make_shared<long>(boost::any_cast<long>(m["DataCacheProvisionedIops"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DnsConfigNameServers") != m.end() && !m["DnsConfigNameServers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DnsConfigNameServers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DnsConfigNameServers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dnsConfigNameServers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DnsConfigOptions") != m.end() && !m["DnsConfigOptions"].empty()) {
      if (typeid(vector<boost::any>) == m["DnsConfigOptions"].type()) {
        vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DnsConfigOptions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dnsConfigOptions = make_shared<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions>>(expect1);
      }
    }
    if (m.find("DnsConfigSearches") != m.end() && !m["DnsConfigSearches"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DnsConfigSearches"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DnsConfigSearches"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dnsConfigSearches = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DnsPolicy") != m.end() && !m["DnsPolicy"].empty()) {
      dnsPolicy = make_shared<string>(boost::any_cast<string>(m["DnsPolicy"]));
    }
    if (m.find("EgressBandwidth") != m.end() && !m["EgressBandwidth"].empty()) {
      egressBandwidth = make_shared<long>(boost::any_cast<long>(m["EgressBandwidth"]));
    }
    if (m.find("EipBandwidth") != m.end() && !m["EipBandwidth"].empty()) {
      eipBandwidth = make_shared<long>(boost::any_cast<long>(m["EipBandwidth"]));
    }
    if (m.find("EphemeralStorage") != m.end() && !m["EphemeralStorage"].empty()) {
      ephemeralStorage = make_shared<long>(boost::any_cast<long>(m["EphemeralStorage"]));
    }
    if (m.find("GpuDriverVersion") != m.end() && !m["GpuDriverVersion"].empty()) {
      gpuDriverVersion = make_shared<string>(boost::any_cast<string>(m["GpuDriverVersion"]));
    }
    if (m.find("HostAliases") != m.end() && !m["HostAliases"].empty()) {
      if (typeid(vector<boost::any>) == m["HostAliases"].type()) {
        vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostAliases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostAliases = make_shared<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases>>(expect1);
      }
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ImageRegistryCredentials") != m.end() && !m["ImageRegistryCredentials"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageRegistryCredentials"].type()) {
        vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageRegistryCredentials"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageRegistryCredentials = make_shared<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials>>(expect1);
      }
    }
    if (m.find("ImageSnapshotId") != m.end() && !m["ImageSnapshotId"].empty()) {
      imageSnapshotId = make_shared<string>(boost::any_cast<string>(m["ImageSnapshotId"]));
    }
    if (m.find("IngressBandwidth") != m.end() && !m["IngressBandwidth"].empty()) {
      ingressBandwidth = make_shared<long>(boost::any_cast<long>(m["IngressBandwidth"]));
    }
    if (m.find("InitContainers") != m.end() && !m["InitContainers"].empty()) {
      if (typeid(vector<boost::any>) == m["InitContainers"].type()) {
        vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InitContainers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        initContainers = make_shared<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers>>(expect1);
      }
    }
    if (m.find("InstanceFamilyLevel") != m.end() && !m["InstanceFamilyLevel"].empty()) {
      instanceFamilyLevel = make_shared<string>(boost::any_cast<string>(m["InstanceFamilyLevel"]));
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Ipv6AddressCount") != m.end() && !m["Ipv6AddressCount"].empty()) {
      ipv6AddressCount = make_shared<long>(boost::any_cast<long>(m["Ipv6AddressCount"]));
    }
    if (m.find("LifecycleState") != m.end() && !m["LifecycleState"].empty()) {
      lifecycleState = make_shared<string>(boost::any_cast<string>(m["LifecycleState"]));
    }
    if (m.find("LoadBalancerWeight") != m.end() && !m["LoadBalancerWeight"].empty()) {
      loadBalancerWeight = make_shared<long>(boost::any_cast<long>(m["LoadBalancerWeight"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("NtpServers") != m.end() && !m["NtpServers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NtpServers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NtpServers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ntpServers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RestartPolicy") != m.end() && !m["RestartPolicy"].empty()) {
      restartPolicy = make_shared<string>(boost::any_cast<string>(m["RestartPolicy"]));
    }
    if (m.find("ScalingConfigurationId") != m.end() && !m["ScalingConfigurationId"].empty()) {
      scalingConfigurationId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationId"]));
    }
    if (m.find("ScalingConfigurationName") != m.end() && !m["ScalingConfigurationName"].empty()) {
      scalingConfigurationName = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationName"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("SecurityContextSysCtls") != m.end() && !m["SecurityContextSysCtls"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityContextSysCtls"].type()) {
        vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityContextSysCtls"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityContextSysCtls = make_shared<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls>>(expect1);
      }
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SlsEnable") != m.end() && !m["SlsEnable"].empty()) {
      slsEnable = make_shared<bool>(boost::any_cast<bool>(m["SlsEnable"]));
    }
    if (m.find("SpotPriceLimit") != m.end() && !m["SpotPriceLimit"].empty()) {
      spotPriceLimit = make_shared<double>(boost::any_cast<double>(m["SpotPriceLimit"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags>>(expect1);
      }
    }
    if (m.find("TerminationGracePeriodSeconds") != m.end() && !m["TerminationGracePeriodSeconds"].empty()) {
      terminationGracePeriodSeconds = make_shared<long>(boost::any_cast<long>(m["TerminationGracePeriodSeconds"]));
    }
    if (m.find("Volumes") != m.end() && !m["Volumes"].empty()) {
      if (typeid(vector<boost::any>) == m["Volumes"].type()) {
        vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Volumes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        volumes = make_shared<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes>>(expect1);
      }
    }
  }


  virtual ~DescribeEciScalingConfigurationsResponseBodyScalingConfigurations() = default;
};
class DescribeEciScalingConfigurationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurations>> scalingConfigurations{};
  shared_ptr<long> totalCount{};

  DescribeEciScalingConfigurationsResponseBody() {}

  explicit DescribeEciScalingConfigurationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*scalingConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScalingConfigurations"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingConfigurations") != m.end() && !m["ScalingConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["ScalingConfigurations"].type()) {
        vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScalingConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEciScalingConfigurationsResponseBodyScalingConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scalingConfigurations = make_shared<vector<DescribeEciScalingConfigurationsResponseBodyScalingConfigurations>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeEciScalingConfigurationsResponseBody() = default;
};
class DescribeEciScalingConfigurationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEciScalingConfigurationsResponseBody> body{};

  DescribeEciScalingConfigurationsResponse() {}

  explicit DescribeEciScalingConfigurationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEciScalingConfigurationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEciScalingConfigurationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEciScalingConfigurationsResponse() = default;
};
class DescribeElasticStrengthRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dataDiskCategories{};
  shared_ptr<string> imageFamily{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<long> ipv6AddressCount{};
  shared_ptr<string> priorityStrategy{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<vector<string>> scalingGroupIds{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<vector<string>> systemDiskCategories{};
  shared_ptr<vector<string>> vSwitchIds{};

  DescribeElasticStrengthRequest() {}

  explicit DescribeElasticStrengthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDiskCategories) {
      res["DataDiskCategories"] = boost::any(*dataDiskCategories);
    }
    if (imageFamily) {
      res["ImageFamily"] = boost::any(*imageFamily);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = boost::any(*instanceTypes);
    }
    if (ipv6AddressCount) {
      res["Ipv6AddressCount"] = boost::any(*ipv6AddressCount);
    }
    if (priorityStrategy) {
      res["PriorityStrategy"] = boost::any(*priorityStrategy);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (scalingGroupIds) {
      res["ScalingGroupIds"] = boost::any(*scalingGroupIds);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (systemDiskCategories) {
      res["SystemDiskCategories"] = boost::any(*systemDiskCategories);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = boost::any(*vSwitchIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDiskCategories") != m.end() && !m["DataDiskCategories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DataDiskCategories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DataDiskCategories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dataDiskCategories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ImageFamily") != m.end() && !m["ImageFamily"].empty()) {
      imageFamily = make_shared<string>(boost::any_cast<string>(m["ImageFamily"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Ipv6AddressCount") != m.end() && !m["Ipv6AddressCount"].empty()) {
      ipv6AddressCount = make_shared<long>(boost::any_cast<long>(m["Ipv6AddressCount"]));
    }
    if (m.find("PriorityStrategy") != m.end() && !m["PriorityStrategy"].empty()) {
      priorityStrategy = make_shared<string>(boost::any_cast<string>(m["PriorityStrategy"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("ScalingGroupIds") != m.end() && !m["ScalingGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScalingGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScalingGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scalingGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("SystemDiskCategories") != m.end() && !m["SystemDiskCategories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SystemDiskCategories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SystemDiskCategories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      systemDiskCategories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeElasticStrengthRequest() = default;
};
class DescribeElasticStrengthResponseBodyElasticStrengthModelsResourcePoolsInventoryHealth : public Darabonba::Model {
public:
  shared_ptr<long> adequacyScore{};
  shared_ptr<long> healthScore{};
  shared_ptr<long> hotScore{};
  shared_ptr<long> supplyScore{};

  DescribeElasticStrengthResponseBodyElasticStrengthModelsResourcePoolsInventoryHealth() {}

  explicit DescribeElasticStrengthResponseBodyElasticStrengthModelsResourcePoolsInventoryHealth(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adequacyScore) {
      res["AdequacyScore"] = boost::any(*adequacyScore);
    }
    if (healthScore) {
      res["HealthScore"] = boost::any(*healthScore);
    }
    if (hotScore) {
      res["HotScore"] = boost::any(*hotScore);
    }
    if (supplyScore) {
      res["SupplyScore"] = boost::any(*supplyScore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdequacyScore") != m.end() && !m["AdequacyScore"].empty()) {
      adequacyScore = make_shared<long>(boost::any_cast<long>(m["AdequacyScore"]));
    }
    if (m.find("HealthScore") != m.end() && !m["HealthScore"].empty()) {
      healthScore = make_shared<long>(boost::any_cast<long>(m["HealthScore"]));
    }
    if (m.find("HotScore") != m.end() && !m["HotScore"].empty()) {
      hotScore = make_shared<long>(boost::any_cast<long>(m["HotScore"]));
    }
    if (m.find("SupplyScore") != m.end() && !m["SupplyScore"].empty()) {
      supplyScore = make_shared<long>(boost::any_cast<long>(m["SupplyScore"]));
    }
  }


  virtual ~DescribeElasticStrengthResponseBodyElasticStrengthModelsResourcePoolsInventoryHealth() = default;
};
class DescribeElasticStrengthResponseBodyElasticStrengthModelsResourcePools : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> instanceType{};
  shared_ptr<DescribeElasticStrengthResponseBodyElasticStrengthModelsResourcePoolsInventoryHealth> inventoryHealth{};
  shared_ptr<string> msg{};
  shared_ptr<string> status{};
  shared_ptr<double> strength{};
  shared_ptr<vector<string>> vSwitchIds{};
  shared_ptr<string> zoneId{};

  DescribeElasticStrengthResponseBodyElasticStrengthModelsResourcePools() {}

  explicit DescribeElasticStrengthResponseBodyElasticStrengthModelsResourcePools(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (inventoryHealth) {
      res["InventoryHealth"] = inventoryHealth ? boost::any(inventoryHealth->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (strength) {
      res["Strength"] = boost::any(*strength);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = boost::any(*vSwitchIds);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InventoryHealth") != m.end() && !m["InventoryHealth"].empty()) {
      if (typeid(map<string, boost::any>) == m["InventoryHealth"].type()) {
        DescribeElasticStrengthResponseBodyElasticStrengthModelsResourcePoolsInventoryHealth model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InventoryHealth"]));
        inventoryHealth = make_shared<DescribeElasticStrengthResponseBodyElasticStrengthModelsResourcePoolsInventoryHealth>(model1);
      }
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Strength") != m.end() && !m["Strength"].empty()) {
      strength = make_shared<double>(boost::any_cast<double>(m["Strength"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeElasticStrengthResponseBodyElasticStrengthModelsResourcePools() = default;
};
class DescribeElasticStrengthResponseBodyElasticStrengthModels : public Darabonba::Model {
public:
  shared_ptr<string> elasticStrength{};
  shared_ptr<vector<DescribeElasticStrengthResponseBodyElasticStrengthModelsResourcePools>> resourcePools{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<double> totalStrength{};

  DescribeElasticStrengthResponseBodyElasticStrengthModels() {}

  explicit DescribeElasticStrengthResponseBodyElasticStrengthModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (elasticStrength) {
      res["ElasticStrength"] = boost::any(*elasticStrength);
    }
    if (resourcePools) {
      vector<boost::any> temp1;
      for(auto item1:*resourcePools){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourcePools"] = boost::any(temp1);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (totalStrength) {
      res["TotalStrength"] = boost::any(*totalStrength);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ElasticStrength") != m.end() && !m["ElasticStrength"].empty()) {
      elasticStrength = make_shared<string>(boost::any_cast<string>(m["ElasticStrength"]));
    }
    if (m.find("ResourcePools") != m.end() && !m["ResourcePools"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourcePools"].type()) {
        vector<DescribeElasticStrengthResponseBodyElasticStrengthModelsResourcePools> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourcePools"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeElasticStrengthResponseBodyElasticStrengthModelsResourcePools model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourcePools = make_shared<vector<DescribeElasticStrengthResponseBodyElasticStrengthModelsResourcePools>>(expect1);
      }
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("TotalStrength") != m.end() && !m["TotalStrength"].empty()) {
      totalStrength = make_shared<double>(boost::any_cast<double>(m["TotalStrength"]));
    }
  }


  virtual ~DescribeElasticStrengthResponseBodyElasticStrengthModels() = default;
};
class DescribeElasticStrengthResponseBodyResourcePools : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> msg{};
  shared_ptr<double> strength{};
  shared_ptr<vector<string>> vSwitchIds{};
  shared_ptr<string> zoneId{};

  DescribeElasticStrengthResponseBodyResourcePools() {}

  explicit DescribeElasticStrengthResponseBodyResourcePools(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (strength) {
      res["Strength"] = boost::any(*strength);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = boost::any(*vSwitchIds);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("Strength") != m.end() && !m["Strength"].empty()) {
      strength = make_shared<double>(boost::any_cast<double>(m["Strength"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeElasticStrengthResponseBodyResourcePools() = default;
};
class DescribeElasticStrengthResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeElasticStrengthResponseBodyElasticStrengthModels>> elasticStrengthModels{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeElasticStrengthResponseBodyResourcePools>> resourcePools{};
  shared_ptr<double> totalStrength{};

  DescribeElasticStrengthResponseBody() {}

  explicit DescribeElasticStrengthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (elasticStrengthModels) {
      vector<boost::any> temp1;
      for(auto item1:*elasticStrengthModels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ElasticStrengthModels"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourcePools) {
      vector<boost::any> temp1;
      for(auto item1:*resourcePools){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourcePools"] = boost::any(temp1);
    }
    if (totalStrength) {
      res["TotalStrength"] = boost::any(*totalStrength);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ElasticStrengthModels") != m.end() && !m["ElasticStrengthModels"].empty()) {
      if (typeid(vector<boost::any>) == m["ElasticStrengthModels"].type()) {
        vector<DescribeElasticStrengthResponseBodyElasticStrengthModels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ElasticStrengthModels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeElasticStrengthResponseBodyElasticStrengthModels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        elasticStrengthModels = make_shared<vector<DescribeElasticStrengthResponseBodyElasticStrengthModels>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourcePools") != m.end() && !m["ResourcePools"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourcePools"].type()) {
        vector<DescribeElasticStrengthResponseBodyResourcePools> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourcePools"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeElasticStrengthResponseBodyResourcePools model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourcePools = make_shared<vector<DescribeElasticStrengthResponseBodyResourcePools>>(expect1);
      }
    }
    if (m.find("TotalStrength") != m.end() && !m["TotalStrength"].empty()) {
      totalStrength = make_shared<double>(boost::any_cast<double>(m["TotalStrength"]));
    }
  }


  virtual ~DescribeElasticStrengthResponseBody() = default;
};
class DescribeElasticStrengthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeElasticStrengthResponseBody> body{};

  DescribeElasticStrengthResponse() {}

  explicit DescribeElasticStrengthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeElasticStrengthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeElasticStrengthResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeElasticStrengthResponse() = default;
};
class DescribeInstanceRefreshesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceRefreshTaskIds{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scalingGroupId{};

  DescribeInstanceRefreshesRequest() {}

  explicit DescribeInstanceRefreshesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceRefreshTaskIds) {
      res["InstanceRefreshTaskIds"] = boost::any(*instanceRefreshTaskIds);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceRefreshTaskIds") != m.end() && !m["InstanceRefreshTaskIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceRefreshTaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceRefreshTaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceRefreshTaskIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~DescribeInstanceRefreshesRequest() = default;
};
class DescribeInstanceRefreshesResponseBodyInstanceRefreshTasksDesiredConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> scalingConfigurationId{};

  DescribeInstanceRefreshesResponseBodyInstanceRefreshTasksDesiredConfiguration() {}

  explicit DescribeInstanceRefreshesResponseBodyInstanceRefreshTasksDesiredConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (scalingConfigurationId) {
      res["ScalingConfigurationId"] = boost::any(*scalingConfigurationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ScalingConfigurationId") != m.end() && !m["ScalingConfigurationId"].empty()) {
      scalingConfigurationId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationId"]));
    }
  }


  virtual ~DescribeInstanceRefreshesResponseBodyInstanceRefreshTasksDesiredConfiguration() = default;
};
class DescribeInstanceRefreshesResponseBodyInstanceRefreshTasks : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceRefreshesResponseBodyInstanceRefreshTasksDesiredConfiguration> desiredConfiguration{};
  shared_ptr<string> detail{};
  shared_ptr<string> endTime{};
  shared_ptr<long> finishedUpdateCapacity{};
  shared_ptr<string> instanceRefreshTaskId{};
  shared_ptr<long> maxHealthyPercentage{};
  shared_ptr<long> minHealthyPercentage{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<bool> skipMatching{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<long> totalNeedUpdateCapacity{};

  DescribeInstanceRefreshesResponseBodyInstanceRefreshTasks() {}

  explicit DescribeInstanceRefreshesResponseBodyInstanceRefreshTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desiredConfiguration) {
      res["DesiredConfiguration"] = desiredConfiguration ? boost::any(desiredConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (finishedUpdateCapacity) {
      res["FinishedUpdateCapacity"] = boost::any(*finishedUpdateCapacity);
    }
    if (instanceRefreshTaskId) {
      res["InstanceRefreshTaskId"] = boost::any(*instanceRefreshTaskId);
    }
    if (maxHealthyPercentage) {
      res["MaxHealthyPercentage"] = boost::any(*maxHealthyPercentage);
    }
    if (minHealthyPercentage) {
      res["MinHealthyPercentage"] = boost::any(*minHealthyPercentage);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (skipMatching) {
      res["SkipMatching"] = boost::any(*skipMatching);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalNeedUpdateCapacity) {
      res["TotalNeedUpdateCapacity"] = boost::any(*totalNeedUpdateCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesiredConfiguration") != m.end() && !m["DesiredConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["DesiredConfiguration"].type()) {
        DescribeInstanceRefreshesResponseBodyInstanceRefreshTasksDesiredConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DesiredConfiguration"]));
        desiredConfiguration = make_shared<DescribeInstanceRefreshesResponseBodyInstanceRefreshTasksDesiredConfiguration>(model1);
      }
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FinishedUpdateCapacity") != m.end() && !m["FinishedUpdateCapacity"].empty()) {
      finishedUpdateCapacity = make_shared<long>(boost::any_cast<long>(m["FinishedUpdateCapacity"]));
    }
    if (m.find("InstanceRefreshTaskId") != m.end() && !m["InstanceRefreshTaskId"].empty()) {
      instanceRefreshTaskId = make_shared<string>(boost::any_cast<string>(m["InstanceRefreshTaskId"]));
    }
    if (m.find("MaxHealthyPercentage") != m.end() && !m["MaxHealthyPercentage"].empty()) {
      maxHealthyPercentage = make_shared<long>(boost::any_cast<long>(m["MaxHealthyPercentage"]));
    }
    if (m.find("MinHealthyPercentage") != m.end() && !m["MinHealthyPercentage"].empty()) {
      minHealthyPercentage = make_shared<long>(boost::any_cast<long>(m["MinHealthyPercentage"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("SkipMatching") != m.end() && !m["SkipMatching"].empty()) {
      skipMatching = make_shared<bool>(boost::any_cast<bool>(m["SkipMatching"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TotalNeedUpdateCapacity") != m.end() && !m["TotalNeedUpdateCapacity"].empty()) {
      totalNeedUpdateCapacity = make_shared<long>(boost::any_cast<long>(m["TotalNeedUpdateCapacity"]));
    }
  }


  virtual ~DescribeInstanceRefreshesResponseBodyInstanceRefreshTasks() = default;
};
class DescribeInstanceRefreshesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceRefreshesResponseBodyInstanceRefreshTasks>> instanceRefreshTasks{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeInstanceRefreshesResponseBody() {}

  explicit DescribeInstanceRefreshesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceRefreshTasks) {
      vector<boost::any> temp1;
      for(auto item1:*instanceRefreshTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceRefreshTasks"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceRefreshTasks") != m.end() && !m["InstanceRefreshTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceRefreshTasks"].type()) {
        vector<DescribeInstanceRefreshesResponseBodyInstanceRefreshTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceRefreshTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceRefreshesResponseBodyInstanceRefreshTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceRefreshTasks = make_shared<vector<DescribeInstanceRefreshesResponseBodyInstanceRefreshTasks>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeInstanceRefreshesResponseBody() = default;
};
class DescribeInstanceRefreshesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceRefreshesResponseBody> body{};

  DescribeInstanceRefreshesResponse() {}

  explicit DescribeInstanceRefreshesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceRefreshesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceRefreshesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceRefreshesResponse() = default;
};
class DescribeLifecycleActionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> lifecycleActionStatus{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingActivityId{};

  DescribeLifecycleActionsRequest() {}

  explicit DescribeLifecycleActionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lifecycleActionStatus) {
      res["LifecycleActionStatus"] = boost::any(*lifecycleActionStatus);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingActivityId) {
      res["ScalingActivityId"] = boost::any(*scalingActivityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LifecycleActionStatus") != m.end() && !m["LifecycleActionStatus"].empty()) {
      lifecycleActionStatus = make_shared<string>(boost::any_cast<string>(m["LifecycleActionStatus"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingActivityId") != m.end() && !m["ScalingActivityId"].empty()) {
      scalingActivityId = make_shared<string>(boost::any_cast<string>(m["ScalingActivityId"]));
    }
  }


  virtual ~DescribeLifecycleActionsRequest() = default;
};
class DescribeLifecycleActionsResponseBodyLifecycleActions : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> lifecycleActionResult{};
  shared_ptr<string> lifecycleActionStatus{};
  shared_ptr<string> lifecycleActionToken{};
  shared_ptr<string> lifecycleHookId{};

  DescribeLifecycleActionsResponseBodyLifecycleActions() {}

  explicit DescribeLifecycleActionsResponseBodyLifecycleActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (lifecycleActionResult) {
      res["LifecycleActionResult"] = boost::any(*lifecycleActionResult);
    }
    if (lifecycleActionStatus) {
      res["LifecycleActionStatus"] = boost::any(*lifecycleActionStatus);
    }
    if (lifecycleActionToken) {
      res["LifecycleActionToken"] = boost::any(*lifecycleActionToken);
    }
    if (lifecycleHookId) {
      res["LifecycleHookId"] = boost::any(*lifecycleHookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LifecycleActionResult") != m.end() && !m["LifecycleActionResult"].empty()) {
      lifecycleActionResult = make_shared<string>(boost::any_cast<string>(m["LifecycleActionResult"]));
    }
    if (m.find("LifecycleActionStatus") != m.end() && !m["LifecycleActionStatus"].empty()) {
      lifecycleActionStatus = make_shared<string>(boost::any_cast<string>(m["LifecycleActionStatus"]));
    }
    if (m.find("LifecycleActionToken") != m.end() && !m["LifecycleActionToken"].empty()) {
      lifecycleActionToken = make_shared<string>(boost::any_cast<string>(m["LifecycleActionToken"]));
    }
    if (m.find("LifecycleHookId") != m.end() && !m["LifecycleHookId"].empty()) {
      lifecycleHookId = make_shared<string>(boost::any_cast<string>(m["LifecycleHookId"]));
    }
  }


  virtual ~DescribeLifecycleActionsResponseBodyLifecycleActions() = default;
};
class DescribeLifecycleActionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLifecycleActionsResponseBodyLifecycleActions>> lifecycleActions{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeLifecycleActionsResponseBody() {}

  explicit DescribeLifecycleActionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lifecycleActions) {
      vector<boost::any> temp1;
      for(auto item1:*lifecycleActions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LifecycleActions"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LifecycleActions") != m.end() && !m["LifecycleActions"].empty()) {
      if (typeid(vector<boost::any>) == m["LifecycleActions"].type()) {
        vector<DescribeLifecycleActionsResponseBodyLifecycleActions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LifecycleActions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLifecycleActionsResponseBodyLifecycleActions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lifecycleActions = make_shared<vector<DescribeLifecycleActionsResponseBodyLifecycleActions>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeLifecycleActionsResponseBody() = default;
};
class DescribeLifecycleActionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLifecycleActionsResponseBody> body{};

  DescribeLifecycleActionsResponse() {}

  explicit DescribeLifecycleActionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLifecycleActionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLifecycleActionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLifecycleActionsResponse() = default;
};
class DescribeLifecycleHooksRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> lifecycleHookIds{};
  shared_ptr<string> lifecycleHookName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};

  DescribeLifecycleHooksRequest() {}

  explicit DescribeLifecycleHooksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lifecycleHookIds) {
      res["LifecycleHookIds"] = boost::any(*lifecycleHookIds);
    }
    if (lifecycleHookName) {
      res["LifecycleHookName"] = boost::any(*lifecycleHookName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LifecycleHookIds") != m.end() && !m["LifecycleHookIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LifecycleHookIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LifecycleHookIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      lifecycleHookIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LifecycleHookName") != m.end() && !m["LifecycleHookName"].empty()) {
      lifecycleHookName = make_shared<string>(boost::any_cast<string>(m["LifecycleHookName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~DescribeLifecycleHooksRequest() = default;
};
class DescribeLifecycleHooksResponseBodyLifecycleHooks : public Darabonba::Model {
public:
  shared_ptr<string> defaultResult{};
  shared_ptr<long> heartbeatTimeout{};
  shared_ptr<string> lifecycleHookId{};
  shared_ptr<string> lifecycleHookName{};
  shared_ptr<string> lifecycleHookStatus{};
  shared_ptr<string> lifecycleTransition{};
  shared_ptr<string> notificationArn{};
  shared_ptr<string> notificationMetadata{};
  shared_ptr<string> scalingGroupId{};

  DescribeLifecycleHooksResponseBodyLifecycleHooks() {}

  explicit DescribeLifecycleHooksResponseBodyLifecycleHooks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultResult) {
      res["DefaultResult"] = boost::any(*defaultResult);
    }
    if (heartbeatTimeout) {
      res["HeartbeatTimeout"] = boost::any(*heartbeatTimeout);
    }
    if (lifecycleHookId) {
      res["LifecycleHookId"] = boost::any(*lifecycleHookId);
    }
    if (lifecycleHookName) {
      res["LifecycleHookName"] = boost::any(*lifecycleHookName);
    }
    if (lifecycleHookStatus) {
      res["LifecycleHookStatus"] = boost::any(*lifecycleHookStatus);
    }
    if (lifecycleTransition) {
      res["LifecycleTransition"] = boost::any(*lifecycleTransition);
    }
    if (notificationArn) {
      res["NotificationArn"] = boost::any(*notificationArn);
    }
    if (notificationMetadata) {
      res["NotificationMetadata"] = boost::any(*notificationMetadata);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultResult") != m.end() && !m["DefaultResult"].empty()) {
      defaultResult = make_shared<string>(boost::any_cast<string>(m["DefaultResult"]));
    }
    if (m.find("HeartbeatTimeout") != m.end() && !m["HeartbeatTimeout"].empty()) {
      heartbeatTimeout = make_shared<long>(boost::any_cast<long>(m["HeartbeatTimeout"]));
    }
    if (m.find("LifecycleHookId") != m.end() && !m["LifecycleHookId"].empty()) {
      lifecycleHookId = make_shared<string>(boost::any_cast<string>(m["LifecycleHookId"]));
    }
    if (m.find("LifecycleHookName") != m.end() && !m["LifecycleHookName"].empty()) {
      lifecycleHookName = make_shared<string>(boost::any_cast<string>(m["LifecycleHookName"]));
    }
    if (m.find("LifecycleHookStatus") != m.end() && !m["LifecycleHookStatus"].empty()) {
      lifecycleHookStatus = make_shared<string>(boost::any_cast<string>(m["LifecycleHookStatus"]));
    }
    if (m.find("LifecycleTransition") != m.end() && !m["LifecycleTransition"].empty()) {
      lifecycleTransition = make_shared<string>(boost::any_cast<string>(m["LifecycleTransition"]));
    }
    if (m.find("NotificationArn") != m.end() && !m["NotificationArn"].empty()) {
      notificationArn = make_shared<string>(boost::any_cast<string>(m["NotificationArn"]));
    }
    if (m.find("NotificationMetadata") != m.end() && !m["NotificationMetadata"].empty()) {
      notificationMetadata = make_shared<string>(boost::any_cast<string>(m["NotificationMetadata"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~DescribeLifecycleHooksResponseBodyLifecycleHooks() = default;
};
class DescribeLifecycleHooksResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLifecycleHooksResponseBodyLifecycleHooks>> lifecycleHooks{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeLifecycleHooksResponseBody() {}

  explicit DescribeLifecycleHooksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lifecycleHooks) {
      vector<boost::any> temp1;
      for(auto item1:*lifecycleHooks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LifecycleHooks"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LifecycleHooks") != m.end() && !m["LifecycleHooks"].empty()) {
      if (typeid(vector<boost::any>) == m["LifecycleHooks"].type()) {
        vector<DescribeLifecycleHooksResponseBodyLifecycleHooks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LifecycleHooks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLifecycleHooksResponseBodyLifecycleHooks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lifecycleHooks = make_shared<vector<DescribeLifecycleHooksResponseBodyLifecycleHooks>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeLifecycleHooksResponseBody() = default;
};
class DescribeLifecycleHooksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLifecycleHooksResponseBody> body{};

  DescribeLifecycleHooksResponse() {}

  explicit DescribeLifecycleHooksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLifecycleHooksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLifecycleHooksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLifecycleHooksResponse() = default;
};
class DescribeLimitationRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};

  DescribeLimitationRequest() {}

  explicit DescribeLimitationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
  }


  virtual ~DescribeLimitationRequest() = default;
};
class DescribeLimitationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxNumberOfAlbServerGroup{};
  shared_ptr<long> maxNumberOfDBInstances{};
  shared_ptr<long> maxNumberOfLifecycleHooks{};
  shared_ptr<long> maxNumberOfLoadBalancers{};
  shared_ptr<long> maxNumberOfMaxSize{};
  shared_ptr<long> maxNumberOfMinSize{};
  shared_ptr<long> maxNumberOfNlbServerGroup{};
  shared_ptr<long> maxNumberOfNotificationConfigurations{};
  shared_ptr<long> maxNumberOfScalingConfigurations{};
  shared_ptr<long> maxNumberOfScalingGroups{};
  shared_ptr<long> maxNumberOfScalingInstances{};
  shared_ptr<long> maxNumberOfScalingRules{};
  shared_ptr<long> maxNumberOfScheduledTasks{};
  shared_ptr<long> maxNumberOfVServerGroups{};
  shared_ptr<string> requestId{};

  DescribeLimitationResponseBody() {}

  explicit DescribeLimitationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxNumberOfAlbServerGroup) {
      res["MaxNumberOfAlbServerGroup"] = boost::any(*maxNumberOfAlbServerGroup);
    }
    if (maxNumberOfDBInstances) {
      res["MaxNumberOfDBInstances"] = boost::any(*maxNumberOfDBInstances);
    }
    if (maxNumberOfLifecycleHooks) {
      res["MaxNumberOfLifecycleHooks"] = boost::any(*maxNumberOfLifecycleHooks);
    }
    if (maxNumberOfLoadBalancers) {
      res["MaxNumberOfLoadBalancers"] = boost::any(*maxNumberOfLoadBalancers);
    }
    if (maxNumberOfMaxSize) {
      res["MaxNumberOfMaxSize"] = boost::any(*maxNumberOfMaxSize);
    }
    if (maxNumberOfMinSize) {
      res["MaxNumberOfMinSize"] = boost::any(*maxNumberOfMinSize);
    }
    if (maxNumberOfNlbServerGroup) {
      res["MaxNumberOfNlbServerGroup"] = boost::any(*maxNumberOfNlbServerGroup);
    }
    if (maxNumberOfNotificationConfigurations) {
      res["MaxNumberOfNotificationConfigurations"] = boost::any(*maxNumberOfNotificationConfigurations);
    }
    if (maxNumberOfScalingConfigurations) {
      res["MaxNumberOfScalingConfigurations"] = boost::any(*maxNumberOfScalingConfigurations);
    }
    if (maxNumberOfScalingGroups) {
      res["MaxNumberOfScalingGroups"] = boost::any(*maxNumberOfScalingGroups);
    }
    if (maxNumberOfScalingInstances) {
      res["MaxNumberOfScalingInstances"] = boost::any(*maxNumberOfScalingInstances);
    }
    if (maxNumberOfScalingRules) {
      res["MaxNumberOfScalingRules"] = boost::any(*maxNumberOfScalingRules);
    }
    if (maxNumberOfScheduledTasks) {
      res["MaxNumberOfScheduledTasks"] = boost::any(*maxNumberOfScheduledTasks);
    }
    if (maxNumberOfVServerGroups) {
      res["MaxNumberOfVServerGroups"] = boost::any(*maxNumberOfVServerGroups);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxNumberOfAlbServerGroup") != m.end() && !m["MaxNumberOfAlbServerGroup"].empty()) {
      maxNumberOfAlbServerGroup = make_shared<long>(boost::any_cast<long>(m["MaxNumberOfAlbServerGroup"]));
    }
    if (m.find("MaxNumberOfDBInstances") != m.end() && !m["MaxNumberOfDBInstances"].empty()) {
      maxNumberOfDBInstances = make_shared<long>(boost::any_cast<long>(m["MaxNumberOfDBInstances"]));
    }
    if (m.find("MaxNumberOfLifecycleHooks") != m.end() && !m["MaxNumberOfLifecycleHooks"].empty()) {
      maxNumberOfLifecycleHooks = make_shared<long>(boost::any_cast<long>(m["MaxNumberOfLifecycleHooks"]));
    }
    if (m.find("MaxNumberOfLoadBalancers") != m.end() && !m["MaxNumberOfLoadBalancers"].empty()) {
      maxNumberOfLoadBalancers = make_shared<long>(boost::any_cast<long>(m["MaxNumberOfLoadBalancers"]));
    }
    if (m.find("MaxNumberOfMaxSize") != m.end() && !m["MaxNumberOfMaxSize"].empty()) {
      maxNumberOfMaxSize = make_shared<long>(boost::any_cast<long>(m["MaxNumberOfMaxSize"]));
    }
    if (m.find("MaxNumberOfMinSize") != m.end() && !m["MaxNumberOfMinSize"].empty()) {
      maxNumberOfMinSize = make_shared<long>(boost::any_cast<long>(m["MaxNumberOfMinSize"]));
    }
    if (m.find("MaxNumberOfNlbServerGroup") != m.end() && !m["MaxNumberOfNlbServerGroup"].empty()) {
      maxNumberOfNlbServerGroup = make_shared<long>(boost::any_cast<long>(m["MaxNumberOfNlbServerGroup"]));
    }
    if (m.find("MaxNumberOfNotificationConfigurations") != m.end() && !m["MaxNumberOfNotificationConfigurations"].empty()) {
      maxNumberOfNotificationConfigurations = make_shared<long>(boost::any_cast<long>(m["MaxNumberOfNotificationConfigurations"]));
    }
    if (m.find("MaxNumberOfScalingConfigurations") != m.end() && !m["MaxNumberOfScalingConfigurations"].empty()) {
      maxNumberOfScalingConfigurations = make_shared<long>(boost::any_cast<long>(m["MaxNumberOfScalingConfigurations"]));
    }
    if (m.find("MaxNumberOfScalingGroups") != m.end() && !m["MaxNumberOfScalingGroups"].empty()) {
      maxNumberOfScalingGroups = make_shared<long>(boost::any_cast<long>(m["MaxNumberOfScalingGroups"]));
    }
    if (m.find("MaxNumberOfScalingInstances") != m.end() && !m["MaxNumberOfScalingInstances"].empty()) {
      maxNumberOfScalingInstances = make_shared<long>(boost::any_cast<long>(m["MaxNumberOfScalingInstances"]));
    }
    if (m.find("MaxNumberOfScalingRules") != m.end() && !m["MaxNumberOfScalingRules"].empty()) {
      maxNumberOfScalingRules = make_shared<long>(boost::any_cast<long>(m["MaxNumberOfScalingRules"]));
    }
    if (m.find("MaxNumberOfScheduledTasks") != m.end() && !m["MaxNumberOfScheduledTasks"].empty()) {
      maxNumberOfScheduledTasks = make_shared<long>(boost::any_cast<long>(m["MaxNumberOfScheduledTasks"]));
    }
    if (m.find("MaxNumberOfVServerGroups") != m.end() && !m["MaxNumberOfVServerGroups"].empty()) {
      maxNumberOfVServerGroups = make_shared<long>(boost::any_cast<long>(m["MaxNumberOfVServerGroups"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLimitationResponseBody() = default;
};
class DescribeLimitationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLimitationResponseBody> body{};

  DescribeLimitationResponse() {}

  explicit DescribeLimitationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLimitationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLimitationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLimitationResponse() = default;
};
class DescribeNotificationConfigurationsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};

  DescribeNotificationConfigurationsRequest() {}

  explicit DescribeNotificationConfigurationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~DescribeNotificationConfigurationsRequest() = default;
};
class DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels : public Darabonba::Model {
public:
  shared_ptr<string> notificationArn{};
  shared_ptr<vector<string>> notificationTypes{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> timeZone{};

  DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels() {}

  explicit DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notificationArn) {
      res["NotificationArn"] = boost::any(*notificationArn);
    }
    if (notificationTypes) {
      res["NotificationTypes"] = boost::any(*notificationTypes);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotificationArn") != m.end() && !m["NotificationArn"].empty()) {
      notificationArn = make_shared<string>(boost::any_cast<string>(m["NotificationArn"]));
    }
    if (m.find("NotificationTypes") != m.end() && !m["NotificationTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NotificationTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NotificationTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      notificationTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels() = default;
};
class DescribeNotificationConfigurationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels>> notificationConfigurationModels{};
  shared_ptr<string> requestId{};

  DescribeNotificationConfigurationsResponseBody() {}

  explicit DescribeNotificationConfigurationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notificationConfigurationModels) {
      vector<boost::any> temp1;
      for(auto item1:*notificationConfigurationModels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationConfigurationModels"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotificationConfigurationModels") != m.end() && !m["NotificationConfigurationModels"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationConfigurationModels"].type()) {
        vector<DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationConfigurationModels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationConfigurationModels = make_shared<vector<DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeNotificationConfigurationsResponseBody() = default;
};
class DescribeNotificationConfigurationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNotificationConfigurationsResponseBody> body{};

  DescribeNotificationConfigurationsResponse() {}

  explicit DescribeNotificationConfigurationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNotificationConfigurationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNotificationConfigurationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNotificationConfigurationsResponse() = default;
};
class DescribeNotificationTypesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};

  DescribeNotificationTypesRequest() {}

  explicit DescribeNotificationTypesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
  }


  virtual ~DescribeNotificationTypesRequest() = default;
};
class DescribeNotificationTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> notificationTypes{};
  shared_ptr<string> requestId{};

  DescribeNotificationTypesResponseBody() {}

  explicit DescribeNotificationTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notificationTypes) {
      res["NotificationTypes"] = boost::any(*notificationTypes);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotificationTypes") != m.end() && !m["NotificationTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NotificationTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NotificationTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      notificationTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeNotificationTypesResponseBody() = default;
};
class DescribeNotificationTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNotificationTypesResponseBody> body{};

  DescribeNotificationTypesResponse() {}

  explicit DescribeNotificationTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNotificationTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNotificationTypesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNotificationTypesResponse() = default;
};
class DescribePatternTypesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> architecture{};
  shared_ptr<string> burstablePerformance{};
  shared_ptr<long> channelId{};
  shared_ptr<long> cores{};
  shared_ptr<vector<long>> coresList{};
  shared_ptr<vector<string>> cpuArchitectures{};
  shared_ptr<vector<string>> excludedInstanceType{};
  shared_ptr<vector<string>> gpuSpecs{};
  shared_ptr<vector<string>> instanceCategories{};
  shared_ptr<string> instanceFamilyLevel{};
  shared_ptr<vector<string>> instanceTypeFamilies{};
  shared_ptr<double> maxPrice{};
  shared_ptr<long> maximumCpuCoreCount{};
  shared_ptr<long> maximumGpuAmount{};
  shared_ptr<double> maximumMemorySize{};
  shared_ptr<double> memory{};
  shared_ptr<vector<double>> memoryList{};
  shared_ptr<long> minimumBaselineCredit{};
  shared_ptr<long> minimumCpuCoreCount{};
  shared_ptr<long> minimumEniIpv6AddressQuantity{};
  shared_ptr<long> minimumEniPrivateIpAddressQuantity{};
  shared_ptr<long> minimumEniQuantity{};
  shared_ptr<long> minimumGpuAmount{};
  shared_ptr<long> minimumInitialCredit{};
  shared_ptr<double> minimumMemorySize{};
  shared_ptr<vector<string>> physicalProcessorModels{};
  shared_ptr<string> regionId{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<vector<string>> vSwitchId{};
  shared_ptr<vector<string>> zoneId{};

  DescribePatternTypesRequest() {}

  explicit DescribePatternTypesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architecture) {
      res["Architecture"] = boost::any(*architecture);
    }
    if (burstablePerformance) {
      res["BurstablePerformance"] = boost::any(*burstablePerformance);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (coresList) {
      res["CoresList"] = boost::any(*coresList);
    }
    if (cpuArchitectures) {
      res["CpuArchitectures"] = boost::any(*cpuArchitectures);
    }
    if (excludedInstanceType) {
      res["ExcludedInstanceType"] = boost::any(*excludedInstanceType);
    }
    if (gpuSpecs) {
      res["GpuSpecs"] = boost::any(*gpuSpecs);
    }
    if (instanceCategories) {
      res["InstanceCategories"] = boost::any(*instanceCategories);
    }
    if (instanceFamilyLevel) {
      res["InstanceFamilyLevel"] = boost::any(*instanceFamilyLevel);
    }
    if (instanceTypeFamilies) {
      res["InstanceTypeFamilies"] = boost::any(*instanceTypeFamilies);
    }
    if (maxPrice) {
      res["MaxPrice"] = boost::any(*maxPrice);
    }
    if (maximumCpuCoreCount) {
      res["MaximumCpuCoreCount"] = boost::any(*maximumCpuCoreCount);
    }
    if (maximumGpuAmount) {
      res["MaximumGpuAmount"] = boost::any(*maximumGpuAmount);
    }
    if (maximumMemorySize) {
      res["MaximumMemorySize"] = boost::any(*maximumMemorySize);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (memoryList) {
      res["MemoryList"] = boost::any(*memoryList);
    }
    if (minimumBaselineCredit) {
      res["MinimumBaselineCredit"] = boost::any(*minimumBaselineCredit);
    }
    if (minimumCpuCoreCount) {
      res["MinimumCpuCoreCount"] = boost::any(*minimumCpuCoreCount);
    }
    if (minimumEniIpv6AddressQuantity) {
      res["MinimumEniIpv6AddressQuantity"] = boost::any(*minimumEniIpv6AddressQuantity);
    }
    if (minimumEniPrivateIpAddressQuantity) {
      res["MinimumEniPrivateIpAddressQuantity"] = boost::any(*minimumEniPrivateIpAddressQuantity);
    }
    if (minimumEniQuantity) {
      res["MinimumEniQuantity"] = boost::any(*minimumEniQuantity);
    }
    if (minimumGpuAmount) {
      res["MinimumGpuAmount"] = boost::any(*minimumGpuAmount);
    }
    if (minimumInitialCredit) {
      res["MinimumInitialCredit"] = boost::any(*minimumInitialCredit);
    }
    if (minimumMemorySize) {
      res["MinimumMemorySize"] = boost::any(*minimumMemorySize);
    }
    if (physicalProcessorModels) {
      res["PhysicalProcessorModels"] = boost::any(*physicalProcessorModels);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Architecture") != m.end() && !m["Architecture"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Architecture"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Architecture"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      architecture = make_shared<vector<string>>(toVec1);
    }
    if (m.find("BurstablePerformance") != m.end() && !m["BurstablePerformance"].empty()) {
      burstablePerformance = make_shared<string>(boost::any_cast<string>(m["BurstablePerformance"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<long>(boost::any_cast<long>(m["ChannelId"]));
    }
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("CoresList") != m.end() && !m["CoresList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["CoresList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CoresList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      coresList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("CpuArchitectures") != m.end() && !m["CpuArchitectures"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CpuArchitectures"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CpuArchitectures"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cpuArchitectures = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExcludedInstanceType") != m.end() && !m["ExcludedInstanceType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludedInstanceType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludedInstanceType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludedInstanceType = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GpuSpecs") != m.end() && !m["GpuSpecs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GpuSpecs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GpuSpecs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      gpuSpecs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceCategories") != m.end() && !m["InstanceCategories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceCategories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceCategories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceCategories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceFamilyLevel") != m.end() && !m["InstanceFamilyLevel"].empty()) {
      instanceFamilyLevel = make_shared<string>(boost::any_cast<string>(m["InstanceFamilyLevel"]));
    }
    if (m.find("InstanceTypeFamilies") != m.end() && !m["InstanceTypeFamilies"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypeFamilies"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypeFamilies"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypeFamilies = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxPrice") != m.end() && !m["MaxPrice"].empty()) {
      maxPrice = make_shared<double>(boost::any_cast<double>(m["MaxPrice"]));
    }
    if (m.find("MaximumCpuCoreCount") != m.end() && !m["MaximumCpuCoreCount"].empty()) {
      maximumCpuCoreCount = make_shared<long>(boost::any_cast<long>(m["MaximumCpuCoreCount"]));
    }
    if (m.find("MaximumGpuAmount") != m.end() && !m["MaximumGpuAmount"].empty()) {
      maximumGpuAmount = make_shared<long>(boost::any_cast<long>(m["MaximumGpuAmount"]));
    }
    if (m.find("MaximumMemorySize") != m.end() && !m["MaximumMemorySize"].empty()) {
      maximumMemorySize = make_shared<double>(boost::any_cast<double>(m["MaximumMemorySize"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("MemoryList") != m.end() && !m["MemoryList"].empty()) {
      vector<double> toVec1;
      if (typeid(vector<boost::any>) == m["MemoryList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MemoryList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<double>(item));
        }
      }
      memoryList = make_shared<vector<double>>(toVec1);
    }
    if (m.find("MinimumBaselineCredit") != m.end() && !m["MinimumBaselineCredit"].empty()) {
      minimumBaselineCredit = make_shared<long>(boost::any_cast<long>(m["MinimumBaselineCredit"]));
    }
    if (m.find("MinimumCpuCoreCount") != m.end() && !m["MinimumCpuCoreCount"].empty()) {
      minimumCpuCoreCount = make_shared<long>(boost::any_cast<long>(m["MinimumCpuCoreCount"]));
    }
    if (m.find("MinimumEniIpv6AddressQuantity") != m.end() && !m["MinimumEniIpv6AddressQuantity"].empty()) {
      minimumEniIpv6AddressQuantity = make_shared<long>(boost::any_cast<long>(m["MinimumEniIpv6AddressQuantity"]));
    }
    if (m.find("MinimumEniPrivateIpAddressQuantity") != m.end() && !m["MinimumEniPrivateIpAddressQuantity"].empty()) {
      minimumEniPrivateIpAddressQuantity = make_shared<long>(boost::any_cast<long>(m["MinimumEniPrivateIpAddressQuantity"]));
    }
    if (m.find("MinimumEniQuantity") != m.end() && !m["MinimumEniQuantity"].empty()) {
      minimumEniQuantity = make_shared<long>(boost::any_cast<long>(m["MinimumEniQuantity"]));
    }
    if (m.find("MinimumGpuAmount") != m.end() && !m["MinimumGpuAmount"].empty()) {
      minimumGpuAmount = make_shared<long>(boost::any_cast<long>(m["MinimumGpuAmount"]));
    }
    if (m.find("MinimumInitialCredit") != m.end() && !m["MinimumInitialCredit"].empty()) {
      minimumInitialCredit = make_shared<long>(boost::any_cast<long>(m["MinimumInitialCredit"]));
    }
    if (m.find("MinimumMemorySize") != m.end() && !m["MinimumMemorySize"].empty()) {
      minimumMemorySize = make_shared<double>(boost::any_cast<double>(m["MinimumMemorySize"]));
    }
    if (m.find("PhysicalProcessorModels") != m.end() && !m["PhysicalProcessorModels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PhysicalProcessorModels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PhysicalProcessorModels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      physicalProcessorModels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ZoneId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ZoneId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      zoneId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribePatternTypesRequest() = default;
};
class DescribePatternTypesResponseBodyPatternTypes : public Darabonba::Model {
public:
  shared_ptr<long> cores{};
  shared_ptr<string> instanceFamilyLevel{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> instanceTypeFamily{};
  shared_ptr<double> memory{};

  DescribePatternTypesResponseBodyPatternTypes() {}

  explicit DescribePatternTypesResponseBodyPatternTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (instanceFamilyLevel) {
      res["InstanceFamilyLevel"] = boost::any(*instanceFamilyLevel);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("InstanceFamilyLevel") != m.end() && !m["InstanceFamilyLevel"].empty()) {
      instanceFamilyLevel = make_shared<string>(boost::any_cast<string>(m["InstanceFamilyLevel"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      instanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamily"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
  }


  virtual ~DescribePatternTypesResponseBodyPatternTypes() = default;
};
class DescribePatternTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePatternTypesResponseBodyPatternTypes>> patternTypes{};
  shared_ptr<string> requestId{};

  DescribePatternTypesResponseBody() {}

  explicit DescribePatternTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (patternTypes) {
      vector<boost::any> temp1;
      for(auto item1:*patternTypes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PatternTypes"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PatternTypes") != m.end() && !m["PatternTypes"].empty()) {
      if (typeid(vector<boost::any>) == m["PatternTypes"].type()) {
        vector<DescribePatternTypesResponseBodyPatternTypes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PatternTypes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePatternTypesResponseBodyPatternTypes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        patternTypes = make_shared<vector<DescribePatternTypesResponseBodyPatternTypes>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePatternTypesResponseBody() = default;
};
class DescribePatternTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePatternTypesResponseBody> body{};

  DescribePatternTypesResponse() {}

  explicit DescribePatternTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePatternTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePatternTypesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePatternTypesResponse() = default;
};
class DescribeRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeRegionsRequest() {}

  explicit DescribeRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeRegionsRequest() = default;
};
class DescribeRegionsResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<bool> classicUnavailable{};
  shared_ptr<string> localName{};
  shared_ptr<string> regionEndpoint{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> vpcUnavailable{};

  DescribeRegionsResponseBodyRegions() {}

  explicit DescribeRegionsResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classicUnavailable) {
      res["ClassicUnavailable"] = boost::any(*classicUnavailable);
    }
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionEndpoint) {
      res["RegionEndpoint"] = boost::any(*regionEndpoint);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vpcUnavailable) {
      res["VpcUnavailable"] = boost::any(*vpcUnavailable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassicUnavailable") != m.end() && !m["ClassicUnavailable"].empty()) {
      classicUnavailable = make_shared<bool>(boost::any_cast<bool>(m["ClassicUnavailable"]));
    }
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionEndpoint") != m.end() && !m["RegionEndpoint"].empty()) {
      regionEndpoint = make_shared<string>(boost::any_cast<string>(m["RegionEndpoint"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VpcUnavailable") != m.end() && !m["VpcUnavailable"].empty()) {
      vpcUnavailable = make_shared<bool>(boost::any_cast<bool>(m["VpcUnavailable"]));
    }
  }


  virtual ~DescribeRegionsResponseBodyRegions() = default;
};
class DescribeRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRegionsResponseBodyRegions>> regions{};
  shared_ptr<string> requestId{};

  DescribeRegionsResponseBody() {}

  explicit DescribeRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regions) {
      vector<boost::any> temp1;
      for(auto item1:*regions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Regions"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(vector<boost::any>) == m["Regions"].type()) {
        vector<DescribeRegionsResponseBodyRegions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Regions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRegionsResponseBodyRegions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regions = make_shared<vector<DescribeRegionsResponseBodyRegions>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRegionsResponseBody() = default;
};
class DescribeRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRegionsResponseBody> body{};

  DescribeRegionsResponse() {}

  explicit DescribeRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRegionsResponse() = default;
};
class DescribeScalingActivitiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceRefreshTaskId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<string>> scalingActivityIds{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> statusCode{};

  DescribeScalingActivitiesRequest() {}

  explicit DescribeScalingActivitiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceRefreshTaskId) {
      res["InstanceRefreshTaskId"] = boost::any(*instanceRefreshTaskId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingActivityIds) {
      res["ScalingActivityIds"] = boost::any(*scalingActivityIds);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceRefreshTaskId") != m.end() && !m["InstanceRefreshTaskId"].empty()) {
      instanceRefreshTaskId = make_shared<string>(boost::any_cast<string>(m["InstanceRefreshTaskId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingActivityIds") != m.end() && !m["ScalingActivityIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScalingActivityIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScalingActivityIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scalingActivityIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<string>(boost::any_cast<string>(m["StatusCode"]));
    }
  }


  virtual ~DescribeScalingActivitiesRequest() = default;
};
class DescribeScalingActivitiesResponseBodyScalingActivitiesLifecycleHookContext : public Darabonba::Model {
public:
  shared_ptr<bool> disableLifecycleHook{};
  shared_ptr<vector<string>> ignoredLifecycleHookIds{};

  DescribeScalingActivitiesResponseBodyScalingActivitiesLifecycleHookContext() {}

  explicit DescribeScalingActivitiesResponseBodyScalingActivitiesLifecycleHookContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disableLifecycleHook) {
      res["DisableLifecycleHook"] = boost::any(*disableLifecycleHook);
    }
    if (ignoredLifecycleHookIds) {
      res["IgnoredLifecycleHookIds"] = boost::any(*ignoredLifecycleHookIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisableLifecycleHook") != m.end() && !m["DisableLifecycleHook"].empty()) {
      disableLifecycleHook = make_shared<bool>(boost::any_cast<bool>(m["DisableLifecycleHook"]));
    }
    if (m.find("IgnoredLifecycleHookIds") != m.end() && !m["IgnoredLifecycleHookIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IgnoredLifecycleHookIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IgnoredLifecycleHookIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ignoredLifecycleHookIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeScalingActivitiesResponseBodyScalingActivitiesLifecycleHookContext() = default;
};
class DescribeScalingActivitiesResponseBodyScalingActivities : public Darabonba::Model {
public:
  shared_ptr<string> activityMetadata{};
  shared_ptr<string> attachedCapacity{};
  shared_ptr<string> autoCreatedCapacity{};
  shared_ptr<string> cause{};
  shared_ptr<long> createdCapacity{};
  shared_ptr<vector<string>> createdInstances{};
  shared_ptr<string> description{};
  shared_ptr<long> destroyedCapacity{};
  shared_ptr<vector<string>> destroyedInstances{};
  shared_ptr<string> detail{};
  shared_ptr<string> endTime{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> instanceRefreshTaskId{};
  shared_ptr<DescribeScalingActivitiesResponseBodyScalingActivitiesLifecycleHookContext> lifecycleHookContext{};
  shared_ptr<long> progress{};
  shared_ptr<string> scalingActivityId{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<long> scalingInstanceNumber{};
  shared_ptr<string> startTime{};
  shared_ptr<long> startedCapacity{};
  shared_ptr<vector<string>> startedInstances{};
  shared_ptr<string> statusCode{};
  shared_ptr<string> statusMessage{};
  shared_ptr<long> stoppedCapacity{};
  shared_ptr<vector<string>> stoppedInstances{};
  shared_ptr<string> totalCapacity{};
  shared_ptr<string> triggerSourceId{};
  shared_ptr<string> triggerSourceType{};

  DescribeScalingActivitiesResponseBodyScalingActivities() {}

  explicit DescribeScalingActivitiesResponseBodyScalingActivities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityMetadata) {
      res["ActivityMetadata"] = boost::any(*activityMetadata);
    }
    if (attachedCapacity) {
      res["AttachedCapacity"] = boost::any(*attachedCapacity);
    }
    if (autoCreatedCapacity) {
      res["AutoCreatedCapacity"] = boost::any(*autoCreatedCapacity);
    }
    if (cause) {
      res["Cause"] = boost::any(*cause);
    }
    if (createdCapacity) {
      res["CreatedCapacity"] = boost::any(*createdCapacity);
    }
    if (createdInstances) {
      res["CreatedInstances"] = boost::any(*createdInstances);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destroyedCapacity) {
      res["DestroyedCapacity"] = boost::any(*destroyedCapacity);
    }
    if (destroyedInstances) {
      res["DestroyedInstances"] = boost::any(*destroyedInstances);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (instanceRefreshTaskId) {
      res["InstanceRefreshTaskId"] = boost::any(*instanceRefreshTaskId);
    }
    if (lifecycleHookContext) {
      res["LifecycleHookContext"] = lifecycleHookContext ? boost::any(lifecycleHookContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (scalingActivityId) {
      res["ScalingActivityId"] = boost::any(*scalingActivityId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (scalingInstanceNumber) {
      res["ScalingInstanceNumber"] = boost::any(*scalingInstanceNumber);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (startedCapacity) {
      res["StartedCapacity"] = boost::any(*startedCapacity);
    }
    if (startedInstances) {
      res["StartedInstances"] = boost::any(*startedInstances);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    if (statusMessage) {
      res["StatusMessage"] = boost::any(*statusMessage);
    }
    if (stoppedCapacity) {
      res["StoppedCapacity"] = boost::any(*stoppedCapacity);
    }
    if (stoppedInstances) {
      res["StoppedInstances"] = boost::any(*stoppedInstances);
    }
    if (totalCapacity) {
      res["TotalCapacity"] = boost::any(*totalCapacity);
    }
    if (triggerSourceId) {
      res["TriggerSourceId"] = boost::any(*triggerSourceId);
    }
    if (triggerSourceType) {
      res["TriggerSourceType"] = boost::any(*triggerSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityMetadata") != m.end() && !m["ActivityMetadata"].empty()) {
      activityMetadata = make_shared<string>(boost::any_cast<string>(m["ActivityMetadata"]));
    }
    if (m.find("AttachedCapacity") != m.end() && !m["AttachedCapacity"].empty()) {
      attachedCapacity = make_shared<string>(boost::any_cast<string>(m["AttachedCapacity"]));
    }
    if (m.find("AutoCreatedCapacity") != m.end() && !m["AutoCreatedCapacity"].empty()) {
      autoCreatedCapacity = make_shared<string>(boost::any_cast<string>(m["AutoCreatedCapacity"]));
    }
    if (m.find("Cause") != m.end() && !m["Cause"].empty()) {
      cause = make_shared<string>(boost::any_cast<string>(m["Cause"]));
    }
    if (m.find("CreatedCapacity") != m.end() && !m["CreatedCapacity"].empty()) {
      createdCapacity = make_shared<long>(boost::any_cast<long>(m["CreatedCapacity"]));
    }
    if (m.find("CreatedInstances") != m.end() && !m["CreatedInstances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CreatedInstances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CreatedInstances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      createdInstances = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestroyedCapacity") != m.end() && !m["DestroyedCapacity"].empty()) {
      destroyedCapacity = make_shared<long>(boost::any_cast<long>(m["DestroyedCapacity"]));
    }
    if (m.find("DestroyedInstances") != m.end() && !m["DestroyedInstances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DestroyedInstances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DestroyedInstances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      destroyedInstances = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("InstanceRefreshTaskId") != m.end() && !m["InstanceRefreshTaskId"].empty()) {
      instanceRefreshTaskId = make_shared<string>(boost::any_cast<string>(m["InstanceRefreshTaskId"]));
    }
    if (m.find("LifecycleHookContext") != m.end() && !m["LifecycleHookContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["LifecycleHookContext"].type()) {
        DescribeScalingActivitiesResponseBodyScalingActivitiesLifecycleHookContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LifecycleHookContext"]));
        lifecycleHookContext = make_shared<DescribeScalingActivitiesResponseBodyScalingActivitiesLifecycleHookContext>(model1);
      }
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("ScalingActivityId") != m.end() && !m["ScalingActivityId"].empty()) {
      scalingActivityId = make_shared<string>(boost::any_cast<string>(m["ScalingActivityId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("ScalingInstanceNumber") != m.end() && !m["ScalingInstanceNumber"].empty()) {
      scalingInstanceNumber = make_shared<long>(boost::any_cast<long>(m["ScalingInstanceNumber"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StartedCapacity") != m.end() && !m["StartedCapacity"].empty()) {
      startedCapacity = make_shared<long>(boost::any_cast<long>(m["StartedCapacity"]));
    }
    if (m.find("StartedInstances") != m.end() && !m["StartedInstances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StartedInstances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StartedInstances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      startedInstances = make_shared<vector<string>>(toVec1);
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<string>(boost::any_cast<string>(m["StatusCode"]));
    }
    if (m.find("StatusMessage") != m.end() && !m["StatusMessage"].empty()) {
      statusMessage = make_shared<string>(boost::any_cast<string>(m["StatusMessage"]));
    }
    if (m.find("StoppedCapacity") != m.end() && !m["StoppedCapacity"].empty()) {
      stoppedCapacity = make_shared<long>(boost::any_cast<long>(m["StoppedCapacity"]));
    }
    if (m.find("StoppedInstances") != m.end() && !m["StoppedInstances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StoppedInstances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StoppedInstances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      stoppedInstances = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TotalCapacity") != m.end() && !m["TotalCapacity"].empty()) {
      totalCapacity = make_shared<string>(boost::any_cast<string>(m["TotalCapacity"]));
    }
    if (m.find("TriggerSourceId") != m.end() && !m["TriggerSourceId"].empty()) {
      triggerSourceId = make_shared<string>(boost::any_cast<string>(m["TriggerSourceId"]));
    }
    if (m.find("TriggerSourceType") != m.end() && !m["TriggerSourceType"].empty()) {
      triggerSourceType = make_shared<string>(boost::any_cast<string>(m["TriggerSourceType"]));
    }
  }


  virtual ~DescribeScalingActivitiesResponseBodyScalingActivities() = default;
};
class DescribeScalingActivitiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeScalingActivitiesResponseBodyScalingActivities>> scalingActivities{};
  shared_ptr<long> totalCount{};

  DescribeScalingActivitiesResponseBody() {}

  explicit DescribeScalingActivitiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingActivities) {
      vector<boost::any> temp1;
      for(auto item1:*scalingActivities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScalingActivities"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingActivities") != m.end() && !m["ScalingActivities"].empty()) {
      if (typeid(vector<boost::any>) == m["ScalingActivities"].type()) {
        vector<DescribeScalingActivitiesResponseBodyScalingActivities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScalingActivities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingActivitiesResponseBodyScalingActivities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scalingActivities = make_shared<vector<DescribeScalingActivitiesResponseBodyScalingActivities>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeScalingActivitiesResponseBody() = default;
};
class DescribeScalingActivitiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeScalingActivitiesResponseBody> body{};

  DescribeScalingActivitiesResponse() {}

  explicit DescribeScalingActivitiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScalingActivitiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScalingActivitiesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScalingActivitiesResponse() = default;
};
class DescribeScalingActivityDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scalingActivityId{};

  DescribeScalingActivityDetailRequest() {}

  explicit DescribeScalingActivityDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingActivityId) {
      res["ScalingActivityId"] = boost::any(*scalingActivityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingActivityId") != m.end() && !m["ScalingActivityId"].empty()) {
      scalingActivityId = make_shared<string>(boost::any_cast<string>(m["ScalingActivityId"]));
    }
  }


  virtual ~DescribeScalingActivityDetailRequest() = default;
};
class DescribeScalingActivityDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> detail{};
  shared_ptr<string> requestId{};
  shared_ptr<string> scalingActivityId{};

  DescribeScalingActivityDetailResponseBody() {}

  explicit DescribeScalingActivityDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingActivityId) {
      res["ScalingActivityId"] = boost::any(*scalingActivityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingActivityId") != m.end() && !m["ScalingActivityId"].empty()) {
      scalingActivityId = make_shared<string>(boost::any_cast<string>(m["ScalingActivityId"]));
    }
  }


  virtual ~DescribeScalingActivityDetailResponseBody() = default;
};
class DescribeScalingActivityDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeScalingActivityDetailResponseBody> body{};

  DescribeScalingActivityDetailResponse() {}

  explicit DescribeScalingActivityDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScalingActivityDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScalingActivityDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScalingActivityDetailResponse() = default;
};
class DescribeScalingConfigurationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<string>> scalingConfigurationIds{};
  shared_ptr<vector<string>> scalingConfigurationNames{};
  shared_ptr<string> scalingGroupId{};

  DescribeScalingConfigurationsRequest() {}

  explicit DescribeScalingConfigurationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingConfigurationIds) {
      res["ScalingConfigurationIds"] = boost::any(*scalingConfigurationIds);
    }
    if (scalingConfigurationNames) {
      res["ScalingConfigurationNames"] = boost::any(*scalingConfigurationNames);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingConfigurationIds") != m.end() && !m["ScalingConfigurationIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScalingConfigurationIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScalingConfigurationIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scalingConfigurationIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScalingConfigurationNames") != m.end() && !m["ScalingConfigurationNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScalingConfigurationNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScalingConfigurationNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scalingConfigurationNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~DescribeScalingConfigurationsRequest() = default;
};
class DescribeScalingConfigurationsResponseBodyScalingConfigurationsCustomPriorities : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<string> vswitchId{};

  DescribeScalingConfigurationsResponseBodyScalingConfigurationsCustomPriorities() {}

  explicit DescribeScalingConfigurationsResponseBodyScalingConfigurationsCustomPriorities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~DescribeScalingConfigurationsResponseBodyScalingConfigurationsCustomPriorities() = default;
};
class DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks : public Darabonba::Model {
public:
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<bool> burstingEnabled{};
  shared_ptr<vector<string>> categories{};
  shared_ptr<string> category{};
  shared_ptr<bool> deleteWithInstance{};
  shared_ptr<string> description{};
  shared_ptr<string> device{};
  shared_ptr<string> diskName{};
  shared_ptr<string> encrypted{};
  shared_ptr<string> KMSKeyId{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<long> provisionedIops{};
  shared_ptr<long> size{};
  shared_ptr<string> snapshotId{};

  DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks() {}

  explicit DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoSnapshotPolicyId) {
      res["AutoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    if (burstingEnabled) {
      res["BurstingEnabled"] = boost::any(*burstingEnabled);
    }
    if (categories) {
      res["Categories"] = boost::any(*categories);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (provisionedIops) {
      res["ProvisionedIops"] = boost::any(*provisionedIops);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoSnapshotPolicyId") != m.end() && !m["AutoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["AutoSnapshotPolicyId"]));
    }
    if (m.find("BurstingEnabled") != m.end() && !m["BurstingEnabled"].empty()) {
      burstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["BurstingEnabled"]));
    }
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Categories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      categories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<bool>(boost::any_cast<bool>(m["DeleteWithInstance"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<string>(boost::any_cast<string>(m["Encrypted"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("ProvisionedIops") != m.end() && !m["ProvisionedIops"].empty()) {
      provisionedIops = make_shared<long>(boost::any_cast<long>(m["ProvisionedIops"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
  }


  virtual ~DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks() = default;
};
class DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos : public Darabonba::Model {
public:
  shared_ptr<vector<string>> architectures{};
  shared_ptr<string> burstablePerformance{};
  shared_ptr<long> cores{};
  shared_ptr<vector<string>> cpuArchitectures{};
  shared_ptr<vector<string>> excludedInstanceTypes{};
  shared_ptr<vector<string>> gpuSpecs{};
  shared_ptr<vector<string>> instanceCategories{};
  shared_ptr<string> instanceFamilyLevel{};
  shared_ptr<vector<string>> instanceTypeFamilies{};
  shared_ptr<double> maxPrice{};
  shared_ptr<long> maximumCpuCoreCount{};
  shared_ptr<long> maximumGpuAmount{};
  shared_ptr<double> maximumMemorySize{};
  shared_ptr<double> memory{};
  shared_ptr<long> minimumBaselineCredit{};
  shared_ptr<long> minimumCpuCoreCount{};
  shared_ptr<long> minimumEniIpv6AddressQuantity{};
  shared_ptr<long> minimumEniPrivateIpAddressQuantity{};
  shared_ptr<long> minimumEniQuantity{};
  shared_ptr<long> minimumGpuAmount{};
  shared_ptr<long> minimumInitialCredit{};
  shared_ptr<double> minimumMemorySize{};
  shared_ptr<vector<string>> physicalProcessorModels{};

  DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos() {}

  explicit DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architectures) {
      res["Architectures"] = boost::any(*architectures);
    }
    if (burstablePerformance) {
      res["BurstablePerformance"] = boost::any(*burstablePerformance);
    }
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (cpuArchitectures) {
      res["CpuArchitectures"] = boost::any(*cpuArchitectures);
    }
    if (excludedInstanceTypes) {
      res["ExcludedInstanceTypes"] = boost::any(*excludedInstanceTypes);
    }
    if (gpuSpecs) {
      res["GpuSpecs"] = boost::any(*gpuSpecs);
    }
    if (instanceCategories) {
      res["InstanceCategories"] = boost::any(*instanceCategories);
    }
    if (instanceFamilyLevel) {
      res["InstanceFamilyLevel"] = boost::any(*instanceFamilyLevel);
    }
    if (instanceTypeFamilies) {
      res["InstanceTypeFamilies"] = boost::any(*instanceTypeFamilies);
    }
    if (maxPrice) {
      res["MaxPrice"] = boost::any(*maxPrice);
    }
    if (maximumCpuCoreCount) {
      res["MaximumCpuCoreCount"] = boost::any(*maximumCpuCoreCount);
    }
    if (maximumGpuAmount) {
      res["MaximumGpuAmount"] = boost::any(*maximumGpuAmount);
    }
    if (maximumMemorySize) {
      res["MaximumMemorySize"] = boost::any(*maximumMemorySize);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (minimumBaselineCredit) {
      res["MinimumBaselineCredit"] = boost::any(*minimumBaselineCredit);
    }
    if (minimumCpuCoreCount) {
      res["MinimumCpuCoreCount"] = boost::any(*minimumCpuCoreCount);
    }
    if (minimumEniIpv6AddressQuantity) {
      res["MinimumEniIpv6AddressQuantity"] = boost::any(*minimumEniIpv6AddressQuantity);
    }
    if (minimumEniPrivateIpAddressQuantity) {
      res["MinimumEniPrivateIpAddressQuantity"] = boost::any(*minimumEniPrivateIpAddressQuantity);
    }
    if (minimumEniQuantity) {
      res["MinimumEniQuantity"] = boost::any(*minimumEniQuantity);
    }
    if (minimumGpuAmount) {
      res["MinimumGpuAmount"] = boost::any(*minimumGpuAmount);
    }
    if (minimumInitialCredit) {
      res["MinimumInitialCredit"] = boost::any(*minimumInitialCredit);
    }
    if (minimumMemorySize) {
      res["MinimumMemorySize"] = boost::any(*minimumMemorySize);
    }
    if (physicalProcessorModels) {
      res["PhysicalProcessorModels"] = boost::any(*physicalProcessorModels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Architectures") != m.end() && !m["Architectures"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Architectures"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Architectures"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      architectures = make_shared<vector<string>>(toVec1);
    }
    if (m.find("BurstablePerformance") != m.end() && !m["BurstablePerformance"].empty()) {
      burstablePerformance = make_shared<string>(boost::any_cast<string>(m["BurstablePerformance"]));
    }
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("CpuArchitectures") != m.end() && !m["CpuArchitectures"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CpuArchitectures"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CpuArchitectures"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cpuArchitectures = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExcludedInstanceTypes") != m.end() && !m["ExcludedInstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludedInstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludedInstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludedInstanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GpuSpecs") != m.end() && !m["GpuSpecs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GpuSpecs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GpuSpecs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      gpuSpecs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceCategories") != m.end() && !m["InstanceCategories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceCategories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceCategories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceCategories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceFamilyLevel") != m.end() && !m["InstanceFamilyLevel"].empty()) {
      instanceFamilyLevel = make_shared<string>(boost::any_cast<string>(m["InstanceFamilyLevel"]));
    }
    if (m.find("InstanceTypeFamilies") != m.end() && !m["InstanceTypeFamilies"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypeFamilies"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypeFamilies"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypeFamilies = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxPrice") != m.end() && !m["MaxPrice"].empty()) {
      maxPrice = make_shared<double>(boost::any_cast<double>(m["MaxPrice"]));
    }
    if (m.find("MaximumCpuCoreCount") != m.end() && !m["MaximumCpuCoreCount"].empty()) {
      maximumCpuCoreCount = make_shared<long>(boost::any_cast<long>(m["MaximumCpuCoreCount"]));
    }
    if (m.find("MaximumGpuAmount") != m.end() && !m["MaximumGpuAmount"].empty()) {
      maximumGpuAmount = make_shared<long>(boost::any_cast<long>(m["MaximumGpuAmount"]));
    }
    if (m.find("MaximumMemorySize") != m.end() && !m["MaximumMemorySize"].empty()) {
      maximumMemorySize = make_shared<double>(boost::any_cast<double>(m["MaximumMemorySize"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("MinimumBaselineCredit") != m.end() && !m["MinimumBaselineCredit"].empty()) {
      minimumBaselineCredit = make_shared<long>(boost::any_cast<long>(m["MinimumBaselineCredit"]));
    }
    if (m.find("MinimumCpuCoreCount") != m.end() && !m["MinimumCpuCoreCount"].empty()) {
      minimumCpuCoreCount = make_shared<long>(boost::any_cast<long>(m["MinimumCpuCoreCount"]));
    }
    if (m.find("MinimumEniIpv6AddressQuantity") != m.end() && !m["MinimumEniIpv6AddressQuantity"].empty()) {
      minimumEniIpv6AddressQuantity = make_shared<long>(boost::any_cast<long>(m["MinimumEniIpv6AddressQuantity"]));
    }
    if (m.find("MinimumEniPrivateIpAddressQuantity") != m.end() && !m["MinimumEniPrivateIpAddressQuantity"].empty()) {
      minimumEniPrivateIpAddressQuantity = make_shared<long>(boost::any_cast<long>(m["MinimumEniPrivateIpAddressQuantity"]));
    }
    if (m.find("MinimumEniQuantity") != m.end() && !m["MinimumEniQuantity"].empty()) {
      minimumEniQuantity = make_shared<long>(boost::any_cast<long>(m["MinimumEniQuantity"]));
    }
    if (m.find("MinimumGpuAmount") != m.end() && !m["MinimumGpuAmount"].empty()) {
      minimumGpuAmount = make_shared<long>(boost::any_cast<long>(m["MinimumGpuAmount"]));
    }
    if (m.find("MinimumInitialCredit") != m.end() && !m["MinimumInitialCredit"].empty()) {
      minimumInitialCredit = make_shared<long>(boost::any_cast<long>(m["MinimumInitialCredit"]));
    }
    if (m.find("MinimumMemorySize") != m.end() && !m["MinimumMemorySize"].empty()) {
      minimumMemorySize = make_shared<double>(boost::any_cast<double>(m["MinimumMemorySize"]));
    }
    if (m.find("PhysicalProcessorModels") != m.end() && !m["PhysicalProcessorModels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PhysicalProcessorModels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PhysicalProcessorModels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      physicalProcessorModels = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos() = default;
};
class DescribeScalingConfigurationsResponseBodyScalingConfigurationsNetworkInterfaces : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<long> ipv6AddressCount{};
  shared_ptr<string> networkInterfaceTrafficMode{};
  shared_ptr<vector<string>> securityGroupIds{};

  DescribeScalingConfigurationsResponseBodyScalingConfigurationsNetworkInterfaces() {}

  explicit DescribeScalingConfigurationsResponseBodyScalingConfigurationsNetworkInterfaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ipv6AddressCount) {
      res["Ipv6AddressCount"] = boost::any(*ipv6AddressCount);
    }
    if (networkInterfaceTrafficMode) {
      res["NetworkInterfaceTrafficMode"] = boost::any(*networkInterfaceTrafficMode);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ipv6AddressCount") != m.end() && !m["Ipv6AddressCount"].empty()) {
      ipv6AddressCount = make_shared<long>(boost::any_cast<long>(m["Ipv6AddressCount"]));
    }
    if (m.find("NetworkInterfaceTrafficMode") != m.end() && !m["NetworkInterfaceTrafficMode"].empty()) {
      networkInterfaceTrafficMode = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceTrafficMode"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeScalingConfigurationsResponseBodyScalingConfigurationsNetworkInterfaces() = default;
};
class DescribeScalingConfigurationsResponseBodyScalingConfigurationsSchedulerOptions : public Darabonba::Model {
public:
  shared_ptr<string> managedPrivateSpaceId{};

  DescribeScalingConfigurationsResponseBodyScalingConfigurationsSchedulerOptions() {}

  explicit DescribeScalingConfigurationsResponseBodyScalingConfigurationsSchedulerOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (managedPrivateSpaceId) {
      res["ManagedPrivateSpaceId"] = boost::any(*managedPrivateSpaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ManagedPrivateSpaceId") != m.end() && !m["ManagedPrivateSpaceId"].empty()) {
      managedPrivateSpaceId = make_shared<string>(boost::any_cast<string>(m["ManagedPrivateSpaceId"]));
    }
  }


  virtual ~DescribeScalingConfigurationsResponseBodyScalingConfigurationsSchedulerOptions() = default;
};
class DescribeScalingConfigurationsResponseBodyScalingConfigurationsSecurityOptions : public Darabonba::Model {
public:
  shared_ptr<string> confidentialComputingMode{};

  DescribeScalingConfigurationsResponseBodyScalingConfigurationsSecurityOptions() {}

  explicit DescribeScalingConfigurationsResponseBodyScalingConfigurationsSecurityOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (confidentialComputingMode) {
      res["ConfidentialComputingMode"] = boost::any(*confidentialComputingMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfidentialComputingMode") != m.end() && !m["ConfidentialComputingMode"].empty()) {
      confidentialComputingMode = make_shared<string>(boost::any_cast<string>(m["ConfidentialComputingMode"]));
    }
  }


  virtual ~DescribeScalingConfigurationsResponseBodyScalingConfigurationsSecurityOptions() = default;
};
class DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<double> priceLimit{};

  DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits() {}

  explicit DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (priceLimit) {
      res["PriceLimit"] = boost::any(*priceLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("PriceLimit") != m.end() && !m["PriceLimit"].empty()) {
      priceLimit = make_shared<double>(boost::any_cast<double>(m["PriceLimit"]));
    }
  }


  virtual ~DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits() = default;
};
class DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags() {}

  explicit DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags() = default;
};
class DescribeScalingConfigurationsResponseBodyScalingConfigurations : public Darabonba::Model {
public:
  shared_ptr<string> affinity{};
  shared_ptr<long> cpu{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> creditSpecification{};
  shared_ptr<vector<DescribeScalingConfigurationsResponseBodyScalingConfigurationsCustomPriorities>> customPriorities{};
  shared_ptr<vector<DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks>> dataDisks{};
  shared_ptr<string> dedicatedHostClusterId{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<bool> deletionProtection{};
  shared_ptr<string> deploymentSetId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> hpcClusterId{};
  shared_ptr<string> httpEndpoint{};
  shared_ptr<string> httpTokens{};
  shared_ptr<string> imageFamily{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<bool> imageOptionsLoginAsNonRoot{};
  shared_ptr<string> imageOwnerAlias{};
  shared_ptr<string> instanceDescription{};
  shared_ptr<string> instanceGeneration{};
  shared_ptr<string> instanceName{};
  shared_ptr<vector<DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos>> instancePatternInfos{};
  shared_ptr<string> instanceType{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidthIn{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> ioOptimized{};
  shared_ptr<long> ipv6AddressCount{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> lifecycleState{};
  shared_ptr<long> loadBalancerWeight{};
  shared_ptr<long> memory{};
  shared_ptr<vector<DescribeScalingConfigurationsResponseBodyScalingConfigurationsNetworkInterfaces>> networkInterfaces{};
  shared_ptr<bool> passwordInherit{};
  shared_ptr<bool> passwordSetted{};
  shared_ptr<string> privatePoolOptions_id{};
  shared_ptr<string> privatePoolOptions_matchCriteria{};
  shared_ptr<string> ramRoleName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> scalingConfigurationId{};
  shared_ptr<string> scalingConfigurationName{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<DescribeScalingConfigurationsResponseBodyScalingConfigurationsSchedulerOptions> schedulerOptions{};
  shared_ptr<string> securityEnhancementStrategy{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<DescribeScalingConfigurationsResponseBodyScalingConfigurationsSecurityOptions> securityOptions{};
  shared_ptr<long> spotDuration{};
  shared_ptr<string> spotInterruptionBehavior{};
  shared_ptr<vector<DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits>> spotPriceLimits{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<string> storageSetId{};
  shared_ptr<long> storageSetPartitionNumber{};
  shared_ptr<string> systemDiskAutoSnapshotPolicyId{};
  shared_ptr<bool> systemDiskBurstingEnabled{};
  shared_ptr<vector<string>> systemDiskCategories{};
  shared_ptr<string> systemDiskCategory{};
  shared_ptr<string> systemDiskDescription{};
  shared_ptr<string> systemDiskEncryptAlgorithm{};
  shared_ptr<bool> systemDiskEncrypted{};
  shared_ptr<string> systemDiskKMSKeyId{};
  shared_ptr<string> systemDiskName{};
  shared_ptr<string> systemDiskPerformanceLevel{};
  shared_ptr<long> systemDiskProvisionedIops{};
  shared_ptr<long> systemDiskSize{};
  shared_ptr<vector<DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags>> tags{};
  shared_ptr<string> tenancy{};
  shared_ptr<string> userData{};
  shared_ptr<vector<long>> weightedCapacities{};
  shared_ptr<string> zoneId{};

  DescribeScalingConfigurationsResponseBodyScalingConfigurations() {}

  explicit DescribeScalingConfigurationsResponseBodyScalingConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affinity) {
      res["Affinity"] = boost::any(*affinity);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (creditSpecification) {
      res["CreditSpecification"] = boost::any(*creditSpecification);
    }
    if (customPriorities) {
      vector<boost::any> temp1;
      for(auto item1:*customPriorities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomPriorities"] = boost::any(temp1);
    }
    if (dataDisks) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisks"] = boost::any(temp1);
    }
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (deletionProtection) {
      res["DeletionProtection"] = boost::any(*deletionProtection);
    }
    if (deploymentSetId) {
      res["DeploymentSetId"] = boost::any(*deploymentSetId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (hpcClusterId) {
      res["HpcClusterId"] = boost::any(*hpcClusterId);
    }
    if (httpEndpoint) {
      res["HttpEndpoint"] = boost::any(*httpEndpoint);
    }
    if (httpTokens) {
      res["HttpTokens"] = boost::any(*httpTokens);
    }
    if (imageFamily) {
      res["ImageFamily"] = boost::any(*imageFamily);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (imageOptionsLoginAsNonRoot) {
      res["ImageOptionsLoginAsNonRoot"] = boost::any(*imageOptionsLoginAsNonRoot);
    }
    if (imageOwnerAlias) {
      res["ImageOwnerAlias"] = boost::any(*imageOwnerAlias);
    }
    if (instanceDescription) {
      res["InstanceDescription"] = boost::any(*instanceDescription);
    }
    if (instanceGeneration) {
      res["InstanceGeneration"] = boost::any(*instanceGeneration);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instancePatternInfos) {
      vector<boost::any> temp1;
      for(auto item1:*instancePatternInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstancePatternInfos"] = boost::any(temp1);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = boost::any(*instanceTypes);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidthIn) {
      res["InternetMaxBandwidthIn"] = boost::any(*internetMaxBandwidthIn);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (ipv6AddressCount) {
      res["Ipv6AddressCount"] = boost::any(*ipv6AddressCount);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (lifecycleState) {
      res["LifecycleState"] = boost::any(*lifecycleState);
    }
    if (loadBalancerWeight) {
      res["LoadBalancerWeight"] = boost::any(*loadBalancerWeight);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (networkInterfaces) {
      vector<boost::any> temp1;
      for(auto item1:*networkInterfaces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkInterfaces"] = boost::any(temp1);
    }
    if (passwordInherit) {
      res["PasswordInherit"] = boost::any(*passwordInherit);
    }
    if (passwordSetted) {
      res["PasswordSetted"] = boost::any(*passwordSetted);
    }
    if (privatePoolOptions_id) {
      res["PrivatePoolOptions.Id"] = boost::any(*privatePoolOptions_id);
    }
    if (privatePoolOptions_matchCriteria) {
      res["PrivatePoolOptions.MatchCriteria"] = boost::any(*privatePoolOptions_matchCriteria);
    }
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (scalingConfigurationId) {
      res["ScalingConfigurationId"] = boost::any(*scalingConfigurationId);
    }
    if (scalingConfigurationName) {
      res["ScalingConfigurationName"] = boost::any(*scalingConfigurationName);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (schedulerOptions) {
      res["SchedulerOptions"] = schedulerOptions ? boost::any(schedulerOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (securityEnhancementStrategy) {
      res["SecurityEnhancementStrategy"] = boost::any(*securityEnhancementStrategy);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    if (securityOptions) {
      res["SecurityOptions"] = securityOptions ? boost::any(securityOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spotDuration) {
      res["SpotDuration"] = boost::any(*spotDuration);
    }
    if (spotInterruptionBehavior) {
      res["SpotInterruptionBehavior"] = boost::any(*spotInterruptionBehavior);
    }
    if (spotPriceLimits) {
      vector<boost::any> temp1;
      for(auto item1:*spotPriceLimits){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpotPriceLimits"] = boost::any(temp1);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    if (storageSetPartitionNumber) {
      res["StorageSetPartitionNumber"] = boost::any(*storageSetPartitionNumber);
    }
    if (systemDiskAutoSnapshotPolicyId) {
      res["SystemDiskAutoSnapshotPolicyId"] = boost::any(*systemDiskAutoSnapshotPolicyId);
    }
    if (systemDiskBurstingEnabled) {
      res["SystemDiskBurstingEnabled"] = boost::any(*systemDiskBurstingEnabled);
    }
    if (systemDiskCategories) {
      res["SystemDiskCategories"] = boost::any(*systemDiskCategories);
    }
    if (systemDiskCategory) {
      res["SystemDiskCategory"] = boost::any(*systemDiskCategory);
    }
    if (systemDiskDescription) {
      res["SystemDiskDescription"] = boost::any(*systemDiskDescription);
    }
    if (systemDiskEncryptAlgorithm) {
      res["SystemDiskEncryptAlgorithm"] = boost::any(*systemDiskEncryptAlgorithm);
    }
    if (systemDiskEncrypted) {
      res["SystemDiskEncrypted"] = boost::any(*systemDiskEncrypted);
    }
    if (systemDiskKMSKeyId) {
      res["SystemDiskKMSKeyId"] = boost::any(*systemDiskKMSKeyId);
    }
    if (systemDiskName) {
      res["SystemDiskName"] = boost::any(*systemDiskName);
    }
    if (systemDiskPerformanceLevel) {
      res["SystemDiskPerformanceLevel"] = boost::any(*systemDiskPerformanceLevel);
    }
    if (systemDiskProvisionedIops) {
      res["SystemDiskProvisionedIops"] = boost::any(*systemDiskProvisionedIops);
    }
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (tenancy) {
      res["Tenancy"] = boost::any(*tenancy);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (weightedCapacities) {
      res["WeightedCapacities"] = boost::any(*weightedCapacities);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Affinity") != m.end() && !m["Affinity"].empty()) {
      affinity = make_shared<string>(boost::any_cast<string>(m["Affinity"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("CreditSpecification") != m.end() && !m["CreditSpecification"].empty()) {
      creditSpecification = make_shared<string>(boost::any_cast<string>(m["CreditSpecification"]));
    }
    if (m.find("CustomPriorities") != m.end() && !m["CustomPriorities"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomPriorities"].type()) {
        vector<DescribeScalingConfigurationsResponseBodyScalingConfigurationsCustomPriorities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomPriorities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingConfigurationsResponseBodyScalingConfigurationsCustomPriorities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customPriorities = make_shared<vector<DescribeScalingConfigurationsResponseBodyScalingConfigurationsCustomPriorities>>(expect1);
      }
    }
    if (m.find("DataDisks") != m.end() && !m["DataDisks"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisks"].type()) {
        vector<DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisks = make_shared<vector<DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks>>(expect1);
      }
    }
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("DeletionProtection") != m.end() && !m["DeletionProtection"].empty()) {
      deletionProtection = make_shared<bool>(boost::any_cast<bool>(m["DeletionProtection"]));
    }
    if (m.find("DeploymentSetId") != m.end() && !m["DeploymentSetId"].empty()) {
      deploymentSetId = make_shared<string>(boost::any_cast<string>(m["DeploymentSetId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("HpcClusterId") != m.end() && !m["HpcClusterId"].empty()) {
      hpcClusterId = make_shared<string>(boost::any_cast<string>(m["HpcClusterId"]));
    }
    if (m.find("HttpEndpoint") != m.end() && !m["HttpEndpoint"].empty()) {
      httpEndpoint = make_shared<string>(boost::any_cast<string>(m["HttpEndpoint"]));
    }
    if (m.find("HttpTokens") != m.end() && !m["HttpTokens"].empty()) {
      httpTokens = make_shared<string>(boost::any_cast<string>(m["HttpTokens"]));
    }
    if (m.find("ImageFamily") != m.end() && !m["ImageFamily"].empty()) {
      imageFamily = make_shared<string>(boost::any_cast<string>(m["ImageFamily"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("ImageOptionsLoginAsNonRoot") != m.end() && !m["ImageOptionsLoginAsNonRoot"].empty()) {
      imageOptionsLoginAsNonRoot = make_shared<bool>(boost::any_cast<bool>(m["ImageOptionsLoginAsNonRoot"]));
    }
    if (m.find("ImageOwnerAlias") != m.end() && !m["ImageOwnerAlias"].empty()) {
      imageOwnerAlias = make_shared<string>(boost::any_cast<string>(m["ImageOwnerAlias"]));
    }
    if (m.find("InstanceDescription") != m.end() && !m["InstanceDescription"].empty()) {
      instanceDescription = make_shared<string>(boost::any_cast<string>(m["InstanceDescription"]));
    }
    if (m.find("InstanceGeneration") != m.end() && !m["InstanceGeneration"].empty()) {
      instanceGeneration = make_shared<string>(boost::any_cast<string>(m["InstanceGeneration"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstancePatternInfos") != m.end() && !m["InstancePatternInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["InstancePatternInfos"].type()) {
        vector<DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstancePatternInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instancePatternInfos = make_shared<vector<DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos>>(expect1);
      }
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("InternetMaxBandwidthIn") != m.end() && !m["InternetMaxBandwidthIn"].empty()) {
      internetMaxBandwidthIn = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthIn"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("Ipv6AddressCount") != m.end() && !m["Ipv6AddressCount"].empty()) {
      ipv6AddressCount = make_shared<long>(boost::any_cast<long>(m["Ipv6AddressCount"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("LifecycleState") != m.end() && !m["LifecycleState"].empty()) {
      lifecycleState = make_shared<string>(boost::any_cast<string>(m["LifecycleState"]));
    }
    if (m.find("LoadBalancerWeight") != m.end() && !m["LoadBalancerWeight"].empty()) {
      loadBalancerWeight = make_shared<long>(boost::any_cast<long>(m["LoadBalancerWeight"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("NetworkInterfaces") != m.end() && !m["NetworkInterfaces"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkInterfaces"].type()) {
        vector<DescribeScalingConfigurationsResponseBodyScalingConfigurationsNetworkInterfaces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkInterfaces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingConfigurationsResponseBodyScalingConfigurationsNetworkInterfaces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkInterfaces = make_shared<vector<DescribeScalingConfigurationsResponseBodyScalingConfigurationsNetworkInterfaces>>(expect1);
      }
    }
    if (m.find("PasswordInherit") != m.end() && !m["PasswordInherit"].empty()) {
      passwordInherit = make_shared<bool>(boost::any_cast<bool>(m["PasswordInherit"]));
    }
    if (m.find("PasswordSetted") != m.end() && !m["PasswordSetted"].empty()) {
      passwordSetted = make_shared<bool>(boost::any_cast<bool>(m["PasswordSetted"]));
    }
    if (m.find("PrivatePoolOptions.Id") != m.end() && !m["PrivatePoolOptions.Id"].empty()) {
      privatePoolOptions_id = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptions.Id"]));
    }
    if (m.find("PrivatePoolOptions.MatchCriteria") != m.end() && !m["PrivatePoolOptions.MatchCriteria"].empty()) {
      privatePoolOptions_matchCriteria = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptions.MatchCriteria"]));
    }
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ScalingConfigurationId") != m.end() && !m["ScalingConfigurationId"].empty()) {
      scalingConfigurationId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationId"]));
    }
    if (m.find("ScalingConfigurationName") != m.end() && !m["ScalingConfigurationName"].empty()) {
      scalingConfigurationName = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationName"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("SchedulerOptions") != m.end() && !m["SchedulerOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["SchedulerOptions"].type()) {
        DescribeScalingConfigurationsResponseBodyScalingConfigurationsSchedulerOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SchedulerOptions"]));
        schedulerOptions = make_shared<DescribeScalingConfigurationsResponseBodyScalingConfigurationsSchedulerOptions>(model1);
      }
    }
    if (m.find("SecurityEnhancementStrategy") != m.end() && !m["SecurityEnhancementStrategy"].empty()) {
      securityEnhancementStrategy = make_shared<string>(boost::any_cast<string>(m["SecurityEnhancementStrategy"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SecurityOptions") != m.end() && !m["SecurityOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityOptions"].type()) {
        DescribeScalingConfigurationsResponseBodyScalingConfigurationsSecurityOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityOptions"]));
        securityOptions = make_shared<DescribeScalingConfigurationsResponseBodyScalingConfigurationsSecurityOptions>(model1);
      }
    }
    if (m.find("SpotDuration") != m.end() && !m["SpotDuration"].empty()) {
      spotDuration = make_shared<long>(boost::any_cast<long>(m["SpotDuration"]));
    }
    if (m.find("SpotInterruptionBehavior") != m.end() && !m["SpotInterruptionBehavior"].empty()) {
      spotInterruptionBehavior = make_shared<string>(boost::any_cast<string>(m["SpotInterruptionBehavior"]));
    }
    if (m.find("SpotPriceLimits") != m.end() && !m["SpotPriceLimits"].empty()) {
      if (typeid(vector<boost::any>) == m["SpotPriceLimits"].type()) {
        vector<DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpotPriceLimits"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spotPriceLimits = make_shared<vector<DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits>>(expect1);
      }
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
    if (m.find("StorageSetPartitionNumber") != m.end() && !m["StorageSetPartitionNumber"].empty()) {
      storageSetPartitionNumber = make_shared<long>(boost::any_cast<long>(m["StorageSetPartitionNumber"]));
    }
    if (m.find("SystemDiskAutoSnapshotPolicyId") != m.end() && !m["SystemDiskAutoSnapshotPolicyId"].empty()) {
      systemDiskAutoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["SystemDiskAutoSnapshotPolicyId"]));
    }
    if (m.find("SystemDiskBurstingEnabled") != m.end() && !m["SystemDiskBurstingEnabled"].empty()) {
      systemDiskBurstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["SystemDiskBurstingEnabled"]));
    }
    if (m.find("SystemDiskCategories") != m.end() && !m["SystemDiskCategories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SystemDiskCategories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SystemDiskCategories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      systemDiskCategories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SystemDiskCategory") != m.end() && !m["SystemDiskCategory"].empty()) {
      systemDiskCategory = make_shared<string>(boost::any_cast<string>(m["SystemDiskCategory"]));
    }
    if (m.find("SystemDiskDescription") != m.end() && !m["SystemDiskDescription"].empty()) {
      systemDiskDescription = make_shared<string>(boost::any_cast<string>(m["SystemDiskDescription"]));
    }
    if (m.find("SystemDiskEncryptAlgorithm") != m.end() && !m["SystemDiskEncryptAlgorithm"].empty()) {
      systemDiskEncryptAlgorithm = make_shared<string>(boost::any_cast<string>(m["SystemDiskEncryptAlgorithm"]));
    }
    if (m.find("SystemDiskEncrypted") != m.end() && !m["SystemDiskEncrypted"].empty()) {
      systemDiskEncrypted = make_shared<bool>(boost::any_cast<bool>(m["SystemDiskEncrypted"]));
    }
    if (m.find("SystemDiskKMSKeyId") != m.end() && !m["SystemDiskKMSKeyId"].empty()) {
      systemDiskKMSKeyId = make_shared<string>(boost::any_cast<string>(m["SystemDiskKMSKeyId"]));
    }
    if (m.find("SystemDiskName") != m.end() && !m["SystemDiskName"].empty()) {
      systemDiskName = make_shared<string>(boost::any_cast<string>(m["SystemDiskName"]));
    }
    if (m.find("SystemDiskPerformanceLevel") != m.end() && !m["SystemDiskPerformanceLevel"].empty()) {
      systemDiskPerformanceLevel = make_shared<string>(boost::any_cast<string>(m["SystemDiskPerformanceLevel"]));
    }
    if (m.find("SystemDiskProvisionedIops") != m.end() && !m["SystemDiskProvisionedIops"].empty()) {
      systemDiskProvisionedIops = make_shared<long>(boost::any_cast<long>(m["SystemDiskProvisionedIops"]));
    }
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskSize"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags>>(expect1);
      }
    }
    if (m.find("Tenancy") != m.end() && !m["Tenancy"].empty()) {
      tenancy = make_shared<string>(boost::any_cast<string>(m["Tenancy"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("WeightedCapacities") != m.end() && !m["WeightedCapacities"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["WeightedCapacities"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WeightedCapacities"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      weightedCapacities = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeScalingConfigurationsResponseBodyScalingConfigurations() = default;
};
class DescribeScalingConfigurationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeScalingConfigurationsResponseBodyScalingConfigurations>> scalingConfigurations{};
  shared_ptr<long> totalCount{};

  DescribeScalingConfigurationsResponseBody() {}

  explicit DescribeScalingConfigurationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*scalingConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScalingConfigurations"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingConfigurations") != m.end() && !m["ScalingConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["ScalingConfigurations"].type()) {
        vector<DescribeScalingConfigurationsResponseBodyScalingConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScalingConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingConfigurationsResponseBodyScalingConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scalingConfigurations = make_shared<vector<DescribeScalingConfigurationsResponseBodyScalingConfigurations>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeScalingConfigurationsResponseBody() = default;
};
class DescribeScalingConfigurationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeScalingConfigurationsResponseBody> body{};

  DescribeScalingConfigurationsResponse() {}

  explicit DescribeScalingConfigurationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScalingConfigurationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScalingConfigurationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScalingConfigurationsResponse() = default;
};
class DescribeScalingGroupDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> outputFormat{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scalingGroupId{};

  DescribeScalingGroupDetailRequest() {}

  explicit DescribeScalingGroupDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputFormat) {
      res["OutputFormat"] = boost::any(*outputFormat);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputFormat") != m.end() && !m["OutputFormat"].empty()) {
      outputFormat = make_shared<string>(boost::any_cast<string>(m["OutputFormat"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~DescribeScalingGroupDetailRequest() = default;
};
class DescribeScalingGroupDetailResponseBodyScalingGroupAlbServerGroups : public Darabonba::Model {
public:
  shared_ptr<string> albServerGroupId{};
  shared_ptr<long> port{};
  shared_ptr<long> weight{};

  DescribeScalingGroupDetailResponseBodyScalingGroupAlbServerGroups() {}

  explicit DescribeScalingGroupDetailResponseBodyScalingGroupAlbServerGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (albServerGroupId) {
      res["AlbServerGroupId"] = boost::any(*albServerGroupId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlbServerGroupId") != m.end() && !m["AlbServerGroupId"].empty()) {
      albServerGroupId = make_shared<string>(boost::any_cast<string>(m["AlbServerGroupId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~DescribeScalingGroupDetailResponseBodyScalingGroupAlbServerGroups() = default;
};
class DescribeScalingGroupDetailResponseBodyScalingGroupLaunchTemplateOverrides : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<double> spotPriceLimit{};
  shared_ptr<long> weightedCapacity{};

  DescribeScalingGroupDetailResponseBodyScalingGroupLaunchTemplateOverrides() {}

  explicit DescribeScalingGroupDetailResponseBodyScalingGroupLaunchTemplateOverrides(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (spotPriceLimit) {
      res["SpotPriceLimit"] = boost::any(*spotPriceLimit);
    }
    if (weightedCapacity) {
      res["WeightedCapacity"] = boost::any(*weightedCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("SpotPriceLimit") != m.end() && !m["SpotPriceLimit"].empty()) {
      spotPriceLimit = make_shared<double>(boost::any_cast<double>(m["SpotPriceLimit"]));
    }
    if (m.find("WeightedCapacity") != m.end() && !m["WeightedCapacity"].empty()) {
      weightedCapacity = make_shared<long>(boost::any_cast<long>(m["WeightedCapacity"]));
    }
  }


  virtual ~DescribeScalingGroupDetailResponseBodyScalingGroupLaunchTemplateOverrides() = default;
};
class DescribeScalingGroupDetailResponseBodyScalingGroupLoadBalancerConfigs : public Darabonba::Model {
public:
  shared_ptr<string> loadBalancerId{};
  shared_ptr<long> weight{};

  DescribeScalingGroupDetailResponseBodyScalingGroupLoadBalancerConfigs() {}

  explicit DescribeScalingGroupDetailResponseBodyScalingGroupLoadBalancerConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~DescribeScalingGroupDetailResponseBodyScalingGroupLoadBalancerConfigs() = default;
};
class DescribeScalingGroupDetailResponseBodyScalingGroupServerGroups : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> serverGroupId{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  DescribeScalingGroupDetailResponseBodyScalingGroupServerGroups() {}

  explicit DescribeScalingGroupDetailResponseBodyScalingGroupServerGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (serverGroupId) {
      res["ServerGroupId"] = boost::any(*serverGroupId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("ServerGroupId") != m.end() && !m["ServerGroupId"].empty()) {
      serverGroupId = make_shared<string>(boost::any_cast<string>(m["ServerGroupId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~DescribeScalingGroupDetailResponseBodyScalingGroupServerGroups() = default;
};
class DescribeScalingGroupDetailResponseBodyScalingGroupTags : public Darabonba::Model {
public:
  shared_ptr<bool> propagate{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  DescribeScalingGroupDetailResponseBodyScalingGroupTags() {}

  explicit DescribeScalingGroupDetailResponseBodyScalingGroupTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propagate) {
      res["Propagate"] = boost::any(*propagate);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Propagate") != m.end() && !m["Propagate"].empty()) {
      propagate = make_shared<bool>(boost::any_cast<bool>(m["Propagate"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribeScalingGroupDetailResponseBodyScalingGroupTags() = default;
};
class DescribeScalingGroupDetailResponseBodyScalingGroupVServerGroupsVServerGroupAttributes : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> VServerGroupId{};
  shared_ptr<long> weight{};

  DescribeScalingGroupDetailResponseBodyScalingGroupVServerGroupsVServerGroupAttributes() {}

  explicit DescribeScalingGroupDetailResponseBodyScalingGroupVServerGroupsVServerGroupAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (VServerGroupId) {
      res["VServerGroupId"] = boost::any(*VServerGroupId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("VServerGroupId") != m.end() && !m["VServerGroupId"].empty()) {
      VServerGroupId = make_shared<string>(boost::any_cast<string>(m["VServerGroupId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~DescribeScalingGroupDetailResponseBodyScalingGroupVServerGroupsVServerGroupAttributes() = default;
};
class DescribeScalingGroupDetailResponseBodyScalingGroupVServerGroups : public Darabonba::Model {
public:
  shared_ptr<string> loadBalancerId{};
  shared_ptr<vector<DescribeScalingGroupDetailResponseBodyScalingGroupVServerGroupsVServerGroupAttributes>> VServerGroupAttributes{};

  DescribeScalingGroupDetailResponseBodyScalingGroupVServerGroups() {}

  explicit DescribeScalingGroupDetailResponseBodyScalingGroupVServerGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (VServerGroupAttributes) {
      vector<boost::any> temp1;
      for(auto item1:*VServerGroupAttributes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VServerGroupAttributes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("VServerGroupAttributes") != m.end() && !m["VServerGroupAttributes"].empty()) {
      if (typeid(vector<boost::any>) == m["VServerGroupAttributes"].type()) {
        vector<DescribeScalingGroupDetailResponseBodyScalingGroupVServerGroupsVServerGroupAttributes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VServerGroupAttributes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingGroupDetailResponseBodyScalingGroupVServerGroupsVServerGroupAttributes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        VServerGroupAttributes = make_shared<vector<DescribeScalingGroupDetailResponseBodyScalingGroupVServerGroupsVServerGroupAttributes>>(expect1);
      }
    }
  }


  virtual ~DescribeScalingGroupDetailResponseBodyScalingGroupVServerGroups() = default;
};
class DescribeScalingGroupDetailResponseBodyScalingGroup : public Darabonba::Model {
public:
  shared_ptr<long> activeCapacity{};
  shared_ptr<string> activeScalingConfigurationId{};
  shared_ptr<vector<DescribeScalingGroupDetailResponseBodyScalingGroupAlbServerGroups>> albServerGroups{};
  shared_ptr<string> allocationStrategy{};
  shared_ptr<bool> azBalance{};
  shared_ptr<bool> compensateWithOnDemand{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> currentHostName{};
  shared_ptr<string> customPolicyARN{};
  shared_ptr<vector<string>> DBInstanceIds{};
  shared_ptr<long> defaultCooldown{};
  shared_ptr<long> desiredCapacity{};
  shared_ptr<bool> enableDesiredCapacity{};
  shared_ptr<bool> groupDeletionProtection{};
  shared_ptr<string> groupType{};
  shared_ptr<string> healthCheckType{};
  shared_ptr<vector<string>> healthCheckTypes{};
  shared_ptr<long> initCapacity{};
  shared_ptr<bool> isElasticStrengthInAlarm{};
  shared_ptr<string> launchTemplateId{};
  shared_ptr<vector<DescribeScalingGroupDetailResponseBodyScalingGroupLaunchTemplateOverrides>> launchTemplateOverrides{};
  shared_ptr<string> launchTemplateVersion{};
  shared_ptr<string> lifecycleState{};
  shared_ptr<vector<DescribeScalingGroupDetailResponseBodyScalingGroupLoadBalancerConfigs>> loadBalancerConfigs{};
  shared_ptr<vector<string>> loadBalancerIds{};
  shared_ptr<long> maxInstanceLifetime{};
  shared_ptr<long> maxSize{};
  shared_ptr<long> minSize{};
  shared_ptr<string> modificationTime{};
  shared_ptr<string> monitorGroupId{};
  shared_ptr<string> multiAZPolicy{};
  shared_ptr<long> onDemandBaseCapacity{};
  shared_ptr<long> onDemandPercentageAboveBaseCapacity{};
  shared_ptr<long> pendingCapacity{};
  shared_ptr<long> pendingWaitCapacity{};
  shared_ptr<long> protectedCapacity{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> removalPolicies{};
  shared_ptr<long> removingCapacity{};
  shared_ptr<long> removingWaitCapacity{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> scalingGroupName{};
  shared_ptr<string> scalingPolicy{};
  shared_ptr<vector<DescribeScalingGroupDetailResponseBodyScalingGroupServerGroups>> serverGroups{};
  shared_ptr<string> spotAllocationStrategy{};
  shared_ptr<long> spotInstancePools{};
  shared_ptr<bool> spotInstanceRemedy{};
  shared_ptr<long> standbyCapacity{};
  shared_ptr<long> stoppedCapacity{};
  shared_ptr<vector<string>> suspendedProcesses{};
  shared_ptr<bool> systemSuspended{};
  shared_ptr<vector<DescribeScalingGroupDetailResponseBodyScalingGroupTags>> tags{};
  shared_ptr<long> totalCapacity{};
  shared_ptr<long> totalInstanceCount{};
  shared_ptr<vector<DescribeScalingGroupDetailResponseBodyScalingGroupVServerGroups>> VServerGroups{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<vector<string>> vSwitchIds{};
  shared_ptr<string> vpcId{};

  DescribeScalingGroupDetailResponseBodyScalingGroup() {}

  explicit DescribeScalingGroupDetailResponseBodyScalingGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeCapacity) {
      res["ActiveCapacity"] = boost::any(*activeCapacity);
    }
    if (activeScalingConfigurationId) {
      res["ActiveScalingConfigurationId"] = boost::any(*activeScalingConfigurationId);
    }
    if (albServerGroups) {
      vector<boost::any> temp1;
      for(auto item1:*albServerGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlbServerGroups"] = boost::any(temp1);
    }
    if (allocationStrategy) {
      res["AllocationStrategy"] = boost::any(*allocationStrategy);
    }
    if (azBalance) {
      res["AzBalance"] = boost::any(*azBalance);
    }
    if (compensateWithOnDemand) {
      res["CompensateWithOnDemand"] = boost::any(*compensateWithOnDemand);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (currentHostName) {
      res["CurrentHostName"] = boost::any(*currentHostName);
    }
    if (customPolicyARN) {
      res["CustomPolicyARN"] = boost::any(*customPolicyARN);
    }
    if (DBInstanceIds) {
      res["DBInstanceIds"] = boost::any(*DBInstanceIds);
    }
    if (defaultCooldown) {
      res["DefaultCooldown"] = boost::any(*defaultCooldown);
    }
    if (desiredCapacity) {
      res["DesiredCapacity"] = boost::any(*desiredCapacity);
    }
    if (enableDesiredCapacity) {
      res["EnableDesiredCapacity"] = boost::any(*enableDesiredCapacity);
    }
    if (groupDeletionProtection) {
      res["GroupDeletionProtection"] = boost::any(*groupDeletionProtection);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (healthCheckType) {
      res["HealthCheckType"] = boost::any(*healthCheckType);
    }
    if (healthCheckTypes) {
      res["HealthCheckTypes"] = boost::any(*healthCheckTypes);
    }
    if (initCapacity) {
      res["InitCapacity"] = boost::any(*initCapacity);
    }
    if (isElasticStrengthInAlarm) {
      res["IsElasticStrengthInAlarm"] = boost::any(*isElasticStrengthInAlarm);
    }
    if (launchTemplateId) {
      res["LaunchTemplateId"] = boost::any(*launchTemplateId);
    }
    if (launchTemplateOverrides) {
      vector<boost::any> temp1;
      for(auto item1:*launchTemplateOverrides){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LaunchTemplateOverrides"] = boost::any(temp1);
    }
    if (launchTemplateVersion) {
      res["LaunchTemplateVersion"] = boost::any(*launchTemplateVersion);
    }
    if (lifecycleState) {
      res["LifecycleState"] = boost::any(*lifecycleState);
    }
    if (loadBalancerConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*loadBalancerConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LoadBalancerConfigs"] = boost::any(temp1);
    }
    if (loadBalancerIds) {
      res["LoadBalancerIds"] = boost::any(*loadBalancerIds);
    }
    if (maxInstanceLifetime) {
      res["MaxInstanceLifetime"] = boost::any(*maxInstanceLifetime);
    }
    if (maxSize) {
      res["MaxSize"] = boost::any(*maxSize);
    }
    if (minSize) {
      res["MinSize"] = boost::any(*minSize);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (monitorGroupId) {
      res["MonitorGroupId"] = boost::any(*monitorGroupId);
    }
    if (multiAZPolicy) {
      res["MultiAZPolicy"] = boost::any(*multiAZPolicy);
    }
    if (onDemandBaseCapacity) {
      res["OnDemandBaseCapacity"] = boost::any(*onDemandBaseCapacity);
    }
    if (onDemandPercentageAboveBaseCapacity) {
      res["OnDemandPercentageAboveBaseCapacity"] = boost::any(*onDemandPercentageAboveBaseCapacity);
    }
    if (pendingCapacity) {
      res["PendingCapacity"] = boost::any(*pendingCapacity);
    }
    if (pendingWaitCapacity) {
      res["PendingWaitCapacity"] = boost::any(*pendingWaitCapacity);
    }
    if (protectedCapacity) {
      res["ProtectedCapacity"] = boost::any(*protectedCapacity);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (removalPolicies) {
      res["RemovalPolicies"] = boost::any(*removalPolicies);
    }
    if (removingCapacity) {
      res["RemovingCapacity"] = boost::any(*removingCapacity);
    }
    if (removingWaitCapacity) {
      res["RemovingWaitCapacity"] = boost::any(*removingWaitCapacity);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (scalingGroupName) {
      res["ScalingGroupName"] = boost::any(*scalingGroupName);
    }
    if (scalingPolicy) {
      res["ScalingPolicy"] = boost::any(*scalingPolicy);
    }
    if (serverGroups) {
      vector<boost::any> temp1;
      for(auto item1:*serverGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServerGroups"] = boost::any(temp1);
    }
    if (spotAllocationStrategy) {
      res["SpotAllocationStrategy"] = boost::any(*spotAllocationStrategy);
    }
    if (spotInstancePools) {
      res["SpotInstancePools"] = boost::any(*spotInstancePools);
    }
    if (spotInstanceRemedy) {
      res["SpotInstanceRemedy"] = boost::any(*spotInstanceRemedy);
    }
    if (standbyCapacity) {
      res["StandbyCapacity"] = boost::any(*standbyCapacity);
    }
    if (stoppedCapacity) {
      res["StoppedCapacity"] = boost::any(*stoppedCapacity);
    }
    if (suspendedProcesses) {
      res["SuspendedProcesses"] = boost::any(*suspendedProcesses);
    }
    if (systemSuspended) {
      res["SystemSuspended"] = boost::any(*systemSuspended);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (totalCapacity) {
      res["TotalCapacity"] = boost::any(*totalCapacity);
    }
    if (totalInstanceCount) {
      res["TotalInstanceCount"] = boost::any(*totalInstanceCount);
    }
    if (VServerGroups) {
      vector<boost::any> temp1;
      for(auto item1:*VServerGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VServerGroups"] = boost::any(temp1);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = boost::any(*vSwitchIds);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveCapacity") != m.end() && !m["ActiveCapacity"].empty()) {
      activeCapacity = make_shared<long>(boost::any_cast<long>(m["ActiveCapacity"]));
    }
    if (m.find("ActiveScalingConfigurationId") != m.end() && !m["ActiveScalingConfigurationId"].empty()) {
      activeScalingConfigurationId = make_shared<string>(boost::any_cast<string>(m["ActiveScalingConfigurationId"]));
    }
    if (m.find("AlbServerGroups") != m.end() && !m["AlbServerGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["AlbServerGroups"].type()) {
        vector<DescribeScalingGroupDetailResponseBodyScalingGroupAlbServerGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlbServerGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingGroupDetailResponseBodyScalingGroupAlbServerGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        albServerGroups = make_shared<vector<DescribeScalingGroupDetailResponseBodyScalingGroupAlbServerGroups>>(expect1);
      }
    }
    if (m.find("AllocationStrategy") != m.end() && !m["AllocationStrategy"].empty()) {
      allocationStrategy = make_shared<string>(boost::any_cast<string>(m["AllocationStrategy"]));
    }
    if (m.find("AzBalance") != m.end() && !m["AzBalance"].empty()) {
      azBalance = make_shared<bool>(boost::any_cast<bool>(m["AzBalance"]));
    }
    if (m.find("CompensateWithOnDemand") != m.end() && !m["CompensateWithOnDemand"].empty()) {
      compensateWithOnDemand = make_shared<bool>(boost::any_cast<bool>(m["CompensateWithOnDemand"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("CurrentHostName") != m.end() && !m["CurrentHostName"].empty()) {
      currentHostName = make_shared<string>(boost::any_cast<string>(m["CurrentHostName"]));
    }
    if (m.find("CustomPolicyARN") != m.end() && !m["CustomPolicyARN"].empty()) {
      customPolicyARN = make_shared<string>(boost::any_cast<string>(m["CustomPolicyARN"]));
    }
    if (m.find("DBInstanceIds") != m.end() && !m["DBInstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DBInstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DBInstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      DBInstanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DefaultCooldown") != m.end() && !m["DefaultCooldown"].empty()) {
      defaultCooldown = make_shared<long>(boost::any_cast<long>(m["DefaultCooldown"]));
    }
    if (m.find("DesiredCapacity") != m.end() && !m["DesiredCapacity"].empty()) {
      desiredCapacity = make_shared<long>(boost::any_cast<long>(m["DesiredCapacity"]));
    }
    if (m.find("EnableDesiredCapacity") != m.end() && !m["EnableDesiredCapacity"].empty()) {
      enableDesiredCapacity = make_shared<bool>(boost::any_cast<bool>(m["EnableDesiredCapacity"]));
    }
    if (m.find("GroupDeletionProtection") != m.end() && !m["GroupDeletionProtection"].empty()) {
      groupDeletionProtection = make_shared<bool>(boost::any_cast<bool>(m["GroupDeletionProtection"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("HealthCheckType") != m.end() && !m["HealthCheckType"].empty()) {
      healthCheckType = make_shared<string>(boost::any_cast<string>(m["HealthCheckType"]));
    }
    if (m.find("HealthCheckTypes") != m.end() && !m["HealthCheckTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HealthCheckTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HealthCheckTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      healthCheckTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InitCapacity") != m.end() && !m["InitCapacity"].empty()) {
      initCapacity = make_shared<long>(boost::any_cast<long>(m["InitCapacity"]));
    }
    if (m.find("IsElasticStrengthInAlarm") != m.end() && !m["IsElasticStrengthInAlarm"].empty()) {
      isElasticStrengthInAlarm = make_shared<bool>(boost::any_cast<bool>(m["IsElasticStrengthInAlarm"]));
    }
    if (m.find("LaunchTemplateId") != m.end() && !m["LaunchTemplateId"].empty()) {
      launchTemplateId = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateId"]));
    }
    if (m.find("LaunchTemplateOverrides") != m.end() && !m["LaunchTemplateOverrides"].empty()) {
      if (typeid(vector<boost::any>) == m["LaunchTemplateOverrides"].type()) {
        vector<DescribeScalingGroupDetailResponseBodyScalingGroupLaunchTemplateOverrides> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LaunchTemplateOverrides"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingGroupDetailResponseBodyScalingGroupLaunchTemplateOverrides model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        launchTemplateOverrides = make_shared<vector<DescribeScalingGroupDetailResponseBodyScalingGroupLaunchTemplateOverrides>>(expect1);
      }
    }
    if (m.find("LaunchTemplateVersion") != m.end() && !m["LaunchTemplateVersion"].empty()) {
      launchTemplateVersion = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateVersion"]));
    }
    if (m.find("LifecycleState") != m.end() && !m["LifecycleState"].empty()) {
      lifecycleState = make_shared<string>(boost::any_cast<string>(m["LifecycleState"]));
    }
    if (m.find("LoadBalancerConfigs") != m.end() && !m["LoadBalancerConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["LoadBalancerConfigs"].type()) {
        vector<DescribeScalingGroupDetailResponseBodyScalingGroupLoadBalancerConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LoadBalancerConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingGroupDetailResponseBodyScalingGroupLoadBalancerConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        loadBalancerConfigs = make_shared<vector<DescribeScalingGroupDetailResponseBodyScalingGroupLoadBalancerConfigs>>(expect1);
      }
    }
    if (m.find("LoadBalancerIds") != m.end() && !m["LoadBalancerIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LoadBalancerIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LoadBalancerIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      loadBalancerIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxInstanceLifetime") != m.end() && !m["MaxInstanceLifetime"].empty()) {
      maxInstanceLifetime = make_shared<long>(boost::any_cast<long>(m["MaxInstanceLifetime"]));
    }
    if (m.find("MaxSize") != m.end() && !m["MaxSize"].empty()) {
      maxSize = make_shared<long>(boost::any_cast<long>(m["MaxSize"]));
    }
    if (m.find("MinSize") != m.end() && !m["MinSize"].empty()) {
      minSize = make_shared<long>(boost::any_cast<long>(m["MinSize"]));
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("MonitorGroupId") != m.end() && !m["MonitorGroupId"].empty()) {
      monitorGroupId = make_shared<string>(boost::any_cast<string>(m["MonitorGroupId"]));
    }
    if (m.find("MultiAZPolicy") != m.end() && !m["MultiAZPolicy"].empty()) {
      multiAZPolicy = make_shared<string>(boost::any_cast<string>(m["MultiAZPolicy"]));
    }
    if (m.find("OnDemandBaseCapacity") != m.end() && !m["OnDemandBaseCapacity"].empty()) {
      onDemandBaseCapacity = make_shared<long>(boost::any_cast<long>(m["OnDemandBaseCapacity"]));
    }
    if (m.find("OnDemandPercentageAboveBaseCapacity") != m.end() && !m["OnDemandPercentageAboveBaseCapacity"].empty()) {
      onDemandPercentageAboveBaseCapacity = make_shared<long>(boost::any_cast<long>(m["OnDemandPercentageAboveBaseCapacity"]));
    }
    if (m.find("PendingCapacity") != m.end() && !m["PendingCapacity"].empty()) {
      pendingCapacity = make_shared<long>(boost::any_cast<long>(m["PendingCapacity"]));
    }
    if (m.find("PendingWaitCapacity") != m.end() && !m["PendingWaitCapacity"].empty()) {
      pendingWaitCapacity = make_shared<long>(boost::any_cast<long>(m["PendingWaitCapacity"]));
    }
    if (m.find("ProtectedCapacity") != m.end() && !m["ProtectedCapacity"].empty()) {
      protectedCapacity = make_shared<long>(boost::any_cast<long>(m["ProtectedCapacity"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemovalPolicies") != m.end() && !m["RemovalPolicies"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RemovalPolicies"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RemovalPolicies"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      removalPolicies = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RemovingCapacity") != m.end() && !m["RemovingCapacity"].empty()) {
      removingCapacity = make_shared<long>(boost::any_cast<long>(m["RemovingCapacity"]));
    }
    if (m.find("RemovingWaitCapacity") != m.end() && !m["RemovingWaitCapacity"].empty()) {
      removingWaitCapacity = make_shared<long>(boost::any_cast<long>(m["RemovingWaitCapacity"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("ScalingGroupName") != m.end() && !m["ScalingGroupName"].empty()) {
      scalingGroupName = make_shared<string>(boost::any_cast<string>(m["ScalingGroupName"]));
    }
    if (m.find("ScalingPolicy") != m.end() && !m["ScalingPolicy"].empty()) {
      scalingPolicy = make_shared<string>(boost::any_cast<string>(m["ScalingPolicy"]));
    }
    if (m.find("ServerGroups") != m.end() && !m["ServerGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["ServerGroups"].type()) {
        vector<DescribeScalingGroupDetailResponseBodyScalingGroupServerGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServerGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingGroupDetailResponseBodyScalingGroupServerGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serverGroups = make_shared<vector<DescribeScalingGroupDetailResponseBodyScalingGroupServerGroups>>(expect1);
      }
    }
    if (m.find("SpotAllocationStrategy") != m.end() && !m["SpotAllocationStrategy"].empty()) {
      spotAllocationStrategy = make_shared<string>(boost::any_cast<string>(m["SpotAllocationStrategy"]));
    }
    if (m.find("SpotInstancePools") != m.end() && !m["SpotInstancePools"].empty()) {
      spotInstancePools = make_shared<long>(boost::any_cast<long>(m["SpotInstancePools"]));
    }
    if (m.find("SpotInstanceRemedy") != m.end() && !m["SpotInstanceRemedy"].empty()) {
      spotInstanceRemedy = make_shared<bool>(boost::any_cast<bool>(m["SpotInstanceRemedy"]));
    }
    if (m.find("StandbyCapacity") != m.end() && !m["StandbyCapacity"].empty()) {
      standbyCapacity = make_shared<long>(boost::any_cast<long>(m["StandbyCapacity"]));
    }
    if (m.find("StoppedCapacity") != m.end() && !m["StoppedCapacity"].empty()) {
      stoppedCapacity = make_shared<long>(boost::any_cast<long>(m["StoppedCapacity"]));
    }
    if (m.find("SuspendedProcesses") != m.end() && !m["SuspendedProcesses"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SuspendedProcesses"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SuspendedProcesses"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      suspendedProcesses = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SystemSuspended") != m.end() && !m["SystemSuspended"].empty()) {
      systemSuspended = make_shared<bool>(boost::any_cast<bool>(m["SystemSuspended"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeScalingGroupDetailResponseBodyScalingGroupTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingGroupDetailResponseBodyScalingGroupTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeScalingGroupDetailResponseBodyScalingGroupTags>>(expect1);
      }
    }
    if (m.find("TotalCapacity") != m.end() && !m["TotalCapacity"].empty()) {
      totalCapacity = make_shared<long>(boost::any_cast<long>(m["TotalCapacity"]));
    }
    if (m.find("TotalInstanceCount") != m.end() && !m["TotalInstanceCount"].empty()) {
      totalInstanceCount = make_shared<long>(boost::any_cast<long>(m["TotalInstanceCount"]));
    }
    if (m.find("VServerGroups") != m.end() && !m["VServerGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["VServerGroups"].type()) {
        vector<DescribeScalingGroupDetailResponseBodyScalingGroupVServerGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VServerGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingGroupDetailResponseBodyScalingGroupVServerGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        VServerGroups = make_shared<vector<DescribeScalingGroupDetailResponseBodyScalingGroupVServerGroups>>(expect1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeScalingGroupDetailResponseBodyScalingGroup() = default;
};
class DescribeScalingGroupDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> output{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeScalingGroupDetailResponseBodyScalingGroup> scalingGroup{};

  DescribeScalingGroupDetailResponseBody() {}

  explicit DescribeScalingGroupDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingGroup) {
      res["ScalingGroup"] = scalingGroup ? boost::any(scalingGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingGroup") != m.end() && !m["ScalingGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScalingGroup"].type()) {
        DescribeScalingGroupDetailResponseBodyScalingGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScalingGroup"]));
        scalingGroup = make_shared<DescribeScalingGroupDetailResponseBodyScalingGroup>(model1);
      }
    }
  }


  virtual ~DescribeScalingGroupDetailResponseBody() = default;
};
class DescribeScalingGroupDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeScalingGroupDetailResponseBody> body{};

  DescribeScalingGroupDetailResponse() {}

  explicit DescribeScalingGroupDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScalingGroupDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScalingGroupDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScalingGroupDetailResponse() = default;
};
class DescribeScalingGroupDiagnoseDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> scalingGroupId{};

  DescribeScalingGroupDiagnoseDetailsRequest() {}

  explicit DescribeScalingGroupDiagnoseDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~DescribeScalingGroupDiagnoseDetailsRequest() = default;
};
class DescribeScalingGroupDiagnoseDetailsResponseBodyDetails : public Darabonba::Model {
public:
  shared_ptr<string> diagnoseType{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> status{};

  DescribeScalingGroupDiagnoseDetailsResponseBodyDetails() {}

  explicit DescribeScalingGroupDiagnoseDetailsResponseBodyDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diagnoseType) {
      res["DiagnoseType"] = boost::any(*diagnoseType);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiagnoseType") != m.end() && !m["DiagnoseType"].empty()) {
      diagnoseType = make_shared<string>(boost::any_cast<string>(m["DiagnoseType"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeScalingGroupDiagnoseDetailsResponseBodyDetails() = default;
};
class DescribeScalingGroupDiagnoseDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeScalingGroupDiagnoseDetailsResponseBodyDetails>> details{};
  shared_ptr<string> requestId{};

  DescribeScalingGroupDiagnoseDetailsResponseBody() {}

  explicit DescribeScalingGroupDiagnoseDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (details) {
      vector<boost::any> temp1;
      for(auto item1:*details){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Details"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      if (typeid(vector<boost::any>) == m["Details"].type()) {
        vector<DescribeScalingGroupDiagnoseDetailsResponseBodyDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Details"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingGroupDiagnoseDetailsResponseBodyDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        details = make_shared<vector<DescribeScalingGroupDiagnoseDetailsResponseBodyDetails>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeScalingGroupDiagnoseDetailsResponseBody() = default;
};
class DescribeScalingGroupDiagnoseDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeScalingGroupDiagnoseDetailsResponseBody> body{};

  DescribeScalingGroupDiagnoseDetailsResponse() {}

  explicit DescribeScalingGroupDiagnoseDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScalingGroupDiagnoseDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScalingGroupDiagnoseDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScalingGroupDiagnoseDetailsResponse() = default;
};
class DescribeScalingGroupsRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeScalingGroupsRequestTags() {}

  explicit DescribeScalingGroupsRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeScalingGroupsRequestTags() = default;
};
class DescribeScalingGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<string>> scalingGroupIds{};
  shared_ptr<string> scalingGroupName{};
  shared_ptr<vector<string>> scalingGroupNames{};
  shared_ptr<vector<DescribeScalingGroupsRequestTags>> tags{};

  DescribeScalingGroupsRequest() {}

  explicit DescribeScalingGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingGroupIds) {
      res["ScalingGroupIds"] = boost::any(*scalingGroupIds);
    }
    if (scalingGroupName) {
      res["ScalingGroupName"] = boost::any(*scalingGroupName);
    }
    if (scalingGroupNames) {
      res["ScalingGroupNames"] = boost::any(*scalingGroupNames);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingGroupIds") != m.end() && !m["ScalingGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScalingGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScalingGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scalingGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScalingGroupName") != m.end() && !m["ScalingGroupName"].empty()) {
      scalingGroupName = make_shared<string>(boost::any_cast<string>(m["ScalingGroupName"]));
    }
    if (m.find("ScalingGroupNames") != m.end() && !m["ScalingGroupNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScalingGroupNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScalingGroupNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scalingGroupNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeScalingGroupsRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingGroupsRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeScalingGroupsRequestTags>>(expect1);
      }
    }
  }


  virtual ~DescribeScalingGroupsRequest() = default;
};
class DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups : public Darabonba::Model {
public:
  shared_ptr<string> albServerGroupId{};
  shared_ptr<long> port{};
  shared_ptr<long> weight{};

  DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups() {}

  explicit DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (albServerGroupId) {
      res["AlbServerGroupId"] = boost::any(*albServerGroupId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlbServerGroupId") != m.end() && !m["AlbServerGroupId"].empty()) {
      albServerGroupId = make_shared<string>(boost::any_cast<string>(m["AlbServerGroupId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups() = default;
};
class DescribeScalingGroupsResponseBodyScalingGroupsCapacityOptions : public Darabonba::Model {
public:
  shared_ptr<bool> compensateWithOnDemand{};
  shared_ptr<long> onDemandBaseCapacity{};
  shared_ptr<long> onDemandPercentageAboveBaseCapacity{};
  shared_ptr<bool> spotAutoReplaceOnDemand{};

  DescribeScalingGroupsResponseBodyScalingGroupsCapacityOptions() {}

  explicit DescribeScalingGroupsResponseBodyScalingGroupsCapacityOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compensateWithOnDemand) {
      res["CompensateWithOnDemand"] = boost::any(*compensateWithOnDemand);
    }
    if (onDemandBaseCapacity) {
      res["OnDemandBaseCapacity"] = boost::any(*onDemandBaseCapacity);
    }
    if (onDemandPercentageAboveBaseCapacity) {
      res["OnDemandPercentageAboveBaseCapacity"] = boost::any(*onDemandPercentageAboveBaseCapacity);
    }
    if (spotAutoReplaceOnDemand) {
      res["SpotAutoReplaceOnDemand"] = boost::any(*spotAutoReplaceOnDemand);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompensateWithOnDemand") != m.end() && !m["CompensateWithOnDemand"].empty()) {
      compensateWithOnDemand = make_shared<bool>(boost::any_cast<bool>(m["CompensateWithOnDemand"]));
    }
    if (m.find("OnDemandBaseCapacity") != m.end() && !m["OnDemandBaseCapacity"].empty()) {
      onDemandBaseCapacity = make_shared<long>(boost::any_cast<long>(m["OnDemandBaseCapacity"]));
    }
    if (m.find("OnDemandPercentageAboveBaseCapacity") != m.end() && !m["OnDemandPercentageAboveBaseCapacity"].empty()) {
      onDemandPercentageAboveBaseCapacity = make_shared<long>(boost::any_cast<long>(m["OnDemandPercentageAboveBaseCapacity"]));
    }
    if (m.find("SpotAutoReplaceOnDemand") != m.end() && !m["SpotAutoReplaceOnDemand"].empty()) {
      spotAutoReplaceOnDemand = make_shared<bool>(boost::any_cast<bool>(m["SpotAutoReplaceOnDemand"]));
    }
  }


  virtual ~DescribeScalingGroupsResponseBodyScalingGroupsCapacityOptions() = default;
};
class DescribeScalingGroupsResponseBodyScalingGroupsDBInstances : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<string> type{};

  DescribeScalingGroupsResponseBodyScalingGroupsDBInstances() {}

  explicit DescribeScalingGroupsResponseBodyScalingGroupsDBInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeScalingGroupsResponseBodyScalingGroupsDBInstances() = default;
};
class DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<double> spotPriceLimit{};
  shared_ptr<long> weightedCapacity{};

  DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides() {}

  explicit DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (spotPriceLimit) {
      res["SpotPriceLimit"] = boost::any(*spotPriceLimit);
    }
    if (weightedCapacity) {
      res["WeightedCapacity"] = boost::any(*weightedCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("SpotPriceLimit") != m.end() && !m["SpotPriceLimit"].empty()) {
      spotPriceLimit = make_shared<double>(boost::any_cast<double>(m["SpotPriceLimit"]));
    }
    if (m.find("WeightedCapacity") != m.end() && !m["WeightedCapacity"].empty()) {
      weightedCapacity = make_shared<long>(boost::any_cast<long>(m["WeightedCapacity"]));
    }
  }


  virtual ~DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides() = default;
};
class DescribeScalingGroupsResponseBodyScalingGroupsLoadBalancerConfigs : public Darabonba::Model {
public:
  shared_ptr<string> loadBalancerId{};
  shared_ptr<long> weight{};

  DescribeScalingGroupsResponseBodyScalingGroupsLoadBalancerConfigs() {}

  explicit DescribeScalingGroupsResponseBodyScalingGroupsLoadBalancerConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~DescribeScalingGroupsResponseBodyScalingGroupsLoadBalancerConfigs() = default;
};
class DescribeScalingGroupsResponseBodyScalingGroupsServerGroups : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> serverGroupId{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  DescribeScalingGroupsResponseBodyScalingGroupsServerGroups() {}

  explicit DescribeScalingGroupsResponseBodyScalingGroupsServerGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (serverGroupId) {
      res["ServerGroupId"] = boost::any(*serverGroupId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("ServerGroupId") != m.end() && !m["ServerGroupId"].empty()) {
      serverGroupId = make_shared<string>(boost::any_cast<string>(m["ServerGroupId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~DescribeScalingGroupsResponseBodyScalingGroupsServerGroups() = default;
};
class DescribeScalingGroupsResponseBodyScalingGroupsTags : public Darabonba::Model {
public:
  shared_ptr<bool> propagate{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  DescribeScalingGroupsResponseBodyScalingGroupsTags() {}

  explicit DescribeScalingGroupsResponseBodyScalingGroupsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propagate) {
      res["Propagate"] = boost::any(*propagate);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Propagate") != m.end() && !m["Propagate"].empty()) {
      propagate = make_shared<bool>(boost::any_cast<bool>(m["Propagate"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribeScalingGroupsResponseBodyScalingGroupsTags() = default;
};
class DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> VServerGroupId{};
  shared_ptr<long> weight{};

  DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes() {}

  explicit DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (VServerGroupId) {
      res["VServerGroupId"] = boost::any(*VServerGroupId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("VServerGroupId") != m.end() && !m["VServerGroupId"].empty()) {
      VServerGroupId = make_shared<string>(boost::any_cast<string>(m["VServerGroupId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes() = default;
};
class DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups : public Darabonba::Model {
public:
  shared_ptr<string> loadBalancerId{};
  shared_ptr<vector<DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes>> VServerGroupAttributes{};

  DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups() {}

  explicit DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (VServerGroupAttributes) {
      vector<boost::any> temp1;
      for(auto item1:*VServerGroupAttributes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VServerGroupAttributes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("VServerGroupAttributes") != m.end() && !m["VServerGroupAttributes"].empty()) {
      if (typeid(vector<boost::any>) == m["VServerGroupAttributes"].type()) {
        vector<DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VServerGroupAttributes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        VServerGroupAttributes = make_shared<vector<DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes>>(expect1);
      }
    }
  }


  virtual ~DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups() = default;
};
class DescribeScalingGroupsResponseBodyScalingGroups : public Darabonba::Model {
public:
  shared_ptr<long> activeCapacity{};
  shared_ptr<string> activeScalingConfigurationId{};
  shared_ptr<vector<DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups>> albServerGroups{};
  shared_ptr<string> allocationStrategy{};
  shared_ptr<bool> azBalance{};
  shared_ptr<DescribeScalingGroupsResponseBodyScalingGroupsCapacityOptions> capacityOptions{};
  shared_ptr<bool> compensateWithOnDemand{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> currentHostName{};
  shared_ptr<string> customPolicyARN{};
  shared_ptr<vector<string>> DBInstanceIds{};
  shared_ptr<vector<DescribeScalingGroupsResponseBodyScalingGroupsDBInstances>> DBInstances{};
  shared_ptr<long> defaultCooldown{};
  shared_ptr<long> desiredCapacity{};
  shared_ptr<bool> enableDesiredCapacity{};
  shared_ptr<bool> groupDeletionProtection{};
  shared_ptr<string> groupType{};
  shared_ptr<string> healthCheckType{};
  shared_ptr<vector<string>> healthCheckTypes{};
  shared_ptr<long> initCapacity{};
  shared_ptr<bool> isElasticStrengthInAlarm{};
  shared_ptr<string> launchTemplateId{};
  shared_ptr<vector<DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides>> launchTemplateOverrides{};
  shared_ptr<string> launchTemplateVersion{};
  shared_ptr<string> lifecycleState{};
  shared_ptr<vector<DescribeScalingGroupsResponseBodyScalingGroupsLoadBalancerConfigs>> loadBalancerConfigs{};
  shared_ptr<vector<string>> loadBalancerIds{};
  shared_ptr<long> maxInstanceLifetime{};
  shared_ptr<long> maxSize{};
  shared_ptr<long> minSize{};
  shared_ptr<string> modificationTime{};
  shared_ptr<string> monitorGroupId{};
  shared_ptr<string> multiAZPolicy{};
  shared_ptr<long> onDemandBaseCapacity{};
  shared_ptr<long> onDemandPercentageAboveBaseCapacity{};
  shared_ptr<long> pendingCapacity{};
  shared_ptr<long> pendingWaitCapacity{};
  shared_ptr<long> protectedCapacity{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> removalPolicies{};
  shared_ptr<long> removingCapacity{};
  shared_ptr<long> removingWaitCapacity{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> scalingGroupName{};
  shared_ptr<string> scalingPolicy{};
  shared_ptr<vector<DescribeScalingGroupsResponseBodyScalingGroupsServerGroups>> serverGroups{};
  shared_ptr<string> spotAllocationStrategy{};
  shared_ptr<long> spotCapacity{};
  shared_ptr<long> spotInstancePools{};
  shared_ptr<bool> spotInstanceRemedy{};
  shared_ptr<long> standbyCapacity{};
  shared_ptr<long> stopInstanceTimeout{};
  shared_ptr<long> stoppedCapacity{};
  shared_ptr<vector<string>> suspendedProcesses{};
  shared_ptr<bool> systemSuspended{};
  shared_ptr<vector<DescribeScalingGroupsResponseBodyScalingGroupsTags>> tags{};
  shared_ptr<long> totalCapacity{};
  shared_ptr<long> totalInstanceCount{};
  shared_ptr<vector<DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups>> VServerGroups{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<vector<string>> vSwitchIds{};
  shared_ptr<string> vpcId{};

  DescribeScalingGroupsResponseBodyScalingGroups() {}

  explicit DescribeScalingGroupsResponseBodyScalingGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeCapacity) {
      res["ActiveCapacity"] = boost::any(*activeCapacity);
    }
    if (activeScalingConfigurationId) {
      res["ActiveScalingConfigurationId"] = boost::any(*activeScalingConfigurationId);
    }
    if (albServerGroups) {
      vector<boost::any> temp1;
      for(auto item1:*albServerGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlbServerGroups"] = boost::any(temp1);
    }
    if (allocationStrategy) {
      res["AllocationStrategy"] = boost::any(*allocationStrategy);
    }
    if (azBalance) {
      res["AzBalance"] = boost::any(*azBalance);
    }
    if (capacityOptions) {
      res["CapacityOptions"] = capacityOptions ? boost::any(capacityOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (compensateWithOnDemand) {
      res["CompensateWithOnDemand"] = boost::any(*compensateWithOnDemand);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (currentHostName) {
      res["CurrentHostName"] = boost::any(*currentHostName);
    }
    if (customPolicyARN) {
      res["CustomPolicyARN"] = boost::any(*customPolicyARN);
    }
    if (DBInstanceIds) {
      res["DBInstanceIds"] = boost::any(*DBInstanceIds);
    }
    if (DBInstances) {
      vector<boost::any> temp1;
      for(auto item1:*DBInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DBInstances"] = boost::any(temp1);
    }
    if (defaultCooldown) {
      res["DefaultCooldown"] = boost::any(*defaultCooldown);
    }
    if (desiredCapacity) {
      res["DesiredCapacity"] = boost::any(*desiredCapacity);
    }
    if (enableDesiredCapacity) {
      res["EnableDesiredCapacity"] = boost::any(*enableDesiredCapacity);
    }
    if (groupDeletionProtection) {
      res["GroupDeletionProtection"] = boost::any(*groupDeletionProtection);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (healthCheckType) {
      res["HealthCheckType"] = boost::any(*healthCheckType);
    }
    if (healthCheckTypes) {
      res["HealthCheckTypes"] = boost::any(*healthCheckTypes);
    }
    if (initCapacity) {
      res["InitCapacity"] = boost::any(*initCapacity);
    }
    if (isElasticStrengthInAlarm) {
      res["IsElasticStrengthInAlarm"] = boost::any(*isElasticStrengthInAlarm);
    }
    if (launchTemplateId) {
      res["LaunchTemplateId"] = boost::any(*launchTemplateId);
    }
    if (launchTemplateOverrides) {
      vector<boost::any> temp1;
      for(auto item1:*launchTemplateOverrides){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LaunchTemplateOverrides"] = boost::any(temp1);
    }
    if (launchTemplateVersion) {
      res["LaunchTemplateVersion"] = boost::any(*launchTemplateVersion);
    }
    if (lifecycleState) {
      res["LifecycleState"] = boost::any(*lifecycleState);
    }
    if (loadBalancerConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*loadBalancerConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LoadBalancerConfigs"] = boost::any(temp1);
    }
    if (loadBalancerIds) {
      res["LoadBalancerIds"] = boost::any(*loadBalancerIds);
    }
    if (maxInstanceLifetime) {
      res["MaxInstanceLifetime"] = boost::any(*maxInstanceLifetime);
    }
    if (maxSize) {
      res["MaxSize"] = boost::any(*maxSize);
    }
    if (minSize) {
      res["MinSize"] = boost::any(*minSize);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (monitorGroupId) {
      res["MonitorGroupId"] = boost::any(*monitorGroupId);
    }
    if (multiAZPolicy) {
      res["MultiAZPolicy"] = boost::any(*multiAZPolicy);
    }
    if (onDemandBaseCapacity) {
      res["OnDemandBaseCapacity"] = boost::any(*onDemandBaseCapacity);
    }
    if (onDemandPercentageAboveBaseCapacity) {
      res["OnDemandPercentageAboveBaseCapacity"] = boost::any(*onDemandPercentageAboveBaseCapacity);
    }
    if (pendingCapacity) {
      res["PendingCapacity"] = boost::any(*pendingCapacity);
    }
    if (pendingWaitCapacity) {
      res["PendingWaitCapacity"] = boost::any(*pendingWaitCapacity);
    }
    if (protectedCapacity) {
      res["ProtectedCapacity"] = boost::any(*protectedCapacity);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (removalPolicies) {
      res["RemovalPolicies"] = boost::any(*removalPolicies);
    }
    if (removingCapacity) {
      res["RemovingCapacity"] = boost::any(*removingCapacity);
    }
    if (removingWaitCapacity) {
      res["RemovingWaitCapacity"] = boost::any(*removingWaitCapacity);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (scalingGroupName) {
      res["ScalingGroupName"] = boost::any(*scalingGroupName);
    }
    if (scalingPolicy) {
      res["ScalingPolicy"] = boost::any(*scalingPolicy);
    }
    if (serverGroups) {
      vector<boost::any> temp1;
      for(auto item1:*serverGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServerGroups"] = boost::any(temp1);
    }
    if (spotAllocationStrategy) {
      res["SpotAllocationStrategy"] = boost::any(*spotAllocationStrategy);
    }
    if (spotCapacity) {
      res["SpotCapacity"] = boost::any(*spotCapacity);
    }
    if (spotInstancePools) {
      res["SpotInstancePools"] = boost::any(*spotInstancePools);
    }
    if (spotInstanceRemedy) {
      res["SpotInstanceRemedy"] = boost::any(*spotInstanceRemedy);
    }
    if (standbyCapacity) {
      res["StandbyCapacity"] = boost::any(*standbyCapacity);
    }
    if (stopInstanceTimeout) {
      res["StopInstanceTimeout"] = boost::any(*stopInstanceTimeout);
    }
    if (stoppedCapacity) {
      res["StoppedCapacity"] = boost::any(*stoppedCapacity);
    }
    if (suspendedProcesses) {
      res["SuspendedProcesses"] = boost::any(*suspendedProcesses);
    }
    if (systemSuspended) {
      res["SystemSuspended"] = boost::any(*systemSuspended);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (totalCapacity) {
      res["TotalCapacity"] = boost::any(*totalCapacity);
    }
    if (totalInstanceCount) {
      res["TotalInstanceCount"] = boost::any(*totalInstanceCount);
    }
    if (VServerGroups) {
      vector<boost::any> temp1;
      for(auto item1:*VServerGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VServerGroups"] = boost::any(temp1);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = boost::any(*vSwitchIds);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveCapacity") != m.end() && !m["ActiveCapacity"].empty()) {
      activeCapacity = make_shared<long>(boost::any_cast<long>(m["ActiveCapacity"]));
    }
    if (m.find("ActiveScalingConfigurationId") != m.end() && !m["ActiveScalingConfigurationId"].empty()) {
      activeScalingConfigurationId = make_shared<string>(boost::any_cast<string>(m["ActiveScalingConfigurationId"]));
    }
    if (m.find("AlbServerGroups") != m.end() && !m["AlbServerGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["AlbServerGroups"].type()) {
        vector<DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlbServerGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        albServerGroups = make_shared<vector<DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups>>(expect1);
      }
    }
    if (m.find("AllocationStrategy") != m.end() && !m["AllocationStrategy"].empty()) {
      allocationStrategy = make_shared<string>(boost::any_cast<string>(m["AllocationStrategy"]));
    }
    if (m.find("AzBalance") != m.end() && !m["AzBalance"].empty()) {
      azBalance = make_shared<bool>(boost::any_cast<bool>(m["AzBalance"]));
    }
    if (m.find("CapacityOptions") != m.end() && !m["CapacityOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["CapacityOptions"].type()) {
        DescribeScalingGroupsResponseBodyScalingGroupsCapacityOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CapacityOptions"]));
        capacityOptions = make_shared<DescribeScalingGroupsResponseBodyScalingGroupsCapacityOptions>(model1);
      }
    }
    if (m.find("CompensateWithOnDemand") != m.end() && !m["CompensateWithOnDemand"].empty()) {
      compensateWithOnDemand = make_shared<bool>(boost::any_cast<bool>(m["CompensateWithOnDemand"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("CurrentHostName") != m.end() && !m["CurrentHostName"].empty()) {
      currentHostName = make_shared<string>(boost::any_cast<string>(m["CurrentHostName"]));
    }
    if (m.find("CustomPolicyARN") != m.end() && !m["CustomPolicyARN"].empty()) {
      customPolicyARN = make_shared<string>(boost::any_cast<string>(m["CustomPolicyARN"]));
    }
    if (m.find("DBInstanceIds") != m.end() && !m["DBInstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DBInstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DBInstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      DBInstanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DBInstances") != m.end() && !m["DBInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["DBInstances"].type()) {
        vector<DescribeScalingGroupsResponseBodyScalingGroupsDBInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DBInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingGroupsResponseBodyScalingGroupsDBInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DBInstances = make_shared<vector<DescribeScalingGroupsResponseBodyScalingGroupsDBInstances>>(expect1);
      }
    }
    if (m.find("DefaultCooldown") != m.end() && !m["DefaultCooldown"].empty()) {
      defaultCooldown = make_shared<long>(boost::any_cast<long>(m["DefaultCooldown"]));
    }
    if (m.find("DesiredCapacity") != m.end() && !m["DesiredCapacity"].empty()) {
      desiredCapacity = make_shared<long>(boost::any_cast<long>(m["DesiredCapacity"]));
    }
    if (m.find("EnableDesiredCapacity") != m.end() && !m["EnableDesiredCapacity"].empty()) {
      enableDesiredCapacity = make_shared<bool>(boost::any_cast<bool>(m["EnableDesiredCapacity"]));
    }
    if (m.find("GroupDeletionProtection") != m.end() && !m["GroupDeletionProtection"].empty()) {
      groupDeletionProtection = make_shared<bool>(boost::any_cast<bool>(m["GroupDeletionProtection"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("HealthCheckType") != m.end() && !m["HealthCheckType"].empty()) {
      healthCheckType = make_shared<string>(boost::any_cast<string>(m["HealthCheckType"]));
    }
    if (m.find("HealthCheckTypes") != m.end() && !m["HealthCheckTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HealthCheckTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HealthCheckTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      healthCheckTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InitCapacity") != m.end() && !m["InitCapacity"].empty()) {
      initCapacity = make_shared<long>(boost::any_cast<long>(m["InitCapacity"]));
    }
    if (m.find("IsElasticStrengthInAlarm") != m.end() && !m["IsElasticStrengthInAlarm"].empty()) {
      isElasticStrengthInAlarm = make_shared<bool>(boost::any_cast<bool>(m["IsElasticStrengthInAlarm"]));
    }
    if (m.find("LaunchTemplateId") != m.end() && !m["LaunchTemplateId"].empty()) {
      launchTemplateId = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateId"]));
    }
    if (m.find("LaunchTemplateOverrides") != m.end() && !m["LaunchTemplateOverrides"].empty()) {
      if (typeid(vector<boost::any>) == m["LaunchTemplateOverrides"].type()) {
        vector<DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LaunchTemplateOverrides"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        launchTemplateOverrides = make_shared<vector<DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides>>(expect1);
      }
    }
    if (m.find("LaunchTemplateVersion") != m.end() && !m["LaunchTemplateVersion"].empty()) {
      launchTemplateVersion = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateVersion"]));
    }
    if (m.find("LifecycleState") != m.end() && !m["LifecycleState"].empty()) {
      lifecycleState = make_shared<string>(boost::any_cast<string>(m["LifecycleState"]));
    }
    if (m.find("LoadBalancerConfigs") != m.end() && !m["LoadBalancerConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["LoadBalancerConfigs"].type()) {
        vector<DescribeScalingGroupsResponseBodyScalingGroupsLoadBalancerConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LoadBalancerConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingGroupsResponseBodyScalingGroupsLoadBalancerConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        loadBalancerConfigs = make_shared<vector<DescribeScalingGroupsResponseBodyScalingGroupsLoadBalancerConfigs>>(expect1);
      }
    }
    if (m.find("LoadBalancerIds") != m.end() && !m["LoadBalancerIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LoadBalancerIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LoadBalancerIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      loadBalancerIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxInstanceLifetime") != m.end() && !m["MaxInstanceLifetime"].empty()) {
      maxInstanceLifetime = make_shared<long>(boost::any_cast<long>(m["MaxInstanceLifetime"]));
    }
    if (m.find("MaxSize") != m.end() && !m["MaxSize"].empty()) {
      maxSize = make_shared<long>(boost::any_cast<long>(m["MaxSize"]));
    }
    if (m.find("MinSize") != m.end() && !m["MinSize"].empty()) {
      minSize = make_shared<long>(boost::any_cast<long>(m["MinSize"]));
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("MonitorGroupId") != m.end() && !m["MonitorGroupId"].empty()) {
      monitorGroupId = make_shared<string>(boost::any_cast<string>(m["MonitorGroupId"]));
    }
    if (m.find("MultiAZPolicy") != m.end() && !m["MultiAZPolicy"].empty()) {
      multiAZPolicy = make_shared<string>(boost::any_cast<string>(m["MultiAZPolicy"]));
    }
    if (m.find("OnDemandBaseCapacity") != m.end() && !m["OnDemandBaseCapacity"].empty()) {
      onDemandBaseCapacity = make_shared<long>(boost::any_cast<long>(m["OnDemandBaseCapacity"]));
    }
    if (m.find("OnDemandPercentageAboveBaseCapacity") != m.end() && !m["OnDemandPercentageAboveBaseCapacity"].empty()) {
      onDemandPercentageAboveBaseCapacity = make_shared<long>(boost::any_cast<long>(m["OnDemandPercentageAboveBaseCapacity"]));
    }
    if (m.find("PendingCapacity") != m.end() && !m["PendingCapacity"].empty()) {
      pendingCapacity = make_shared<long>(boost::any_cast<long>(m["PendingCapacity"]));
    }
    if (m.find("PendingWaitCapacity") != m.end() && !m["PendingWaitCapacity"].empty()) {
      pendingWaitCapacity = make_shared<long>(boost::any_cast<long>(m["PendingWaitCapacity"]));
    }
    if (m.find("ProtectedCapacity") != m.end() && !m["ProtectedCapacity"].empty()) {
      protectedCapacity = make_shared<long>(boost::any_cast<long>(m["ProtectedCapacity"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemovalPolicies") != m.end() && !m["RemovalPolicies"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RemovalPolicies"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RemovalPolicies"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      removalPolicies = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RemovingCapacity") != m.end() && !m["RemovingCapacity"].empty()) {
      removingCapacity = make_shared<long>(boost::any_cast<long>(m["RemovingCapacity"]));
    }
    if (m.find("RemovingWaitCapacity") != m.end() && !m["RemovingWaitCapacity"].empty()) {
      removingWaitCapacity = make_shared<long>(boost::any_cast<long>(m["RemovingWaitCapacity"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("ScalingGroupName") != m.end() && !m["ScalingGroupName"].empty()) {
      scalingGroupName = make_shared<string>(boost::any_cast<string>(m["ScalingGroupName"]));
    }
    if (m.find("ScalingPolicy") != m.end() && !m["ScalingPolicy"].empty()) {
      scalingPolicy = make_shared<string>(boost::any_cast<string>(m["ScalingPolicy"]));
    }
    if (m.find("ServerGroups") != m.end() && !m["ServerGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["ServerGroups"].type()) {
        vector<DescribeScalingGroupsResponseBodyScalingGroupsServerGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServerGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingGroupsResponseBodyScalingGroupsServerGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serverGroups = make_shared<vector<DescribeScalingGroupsResponseBodyScalingGroupsServerGroups>>(expect1);
      }
    }
    if (m.find("SpotAllocationStrategy") != m.end() && !m["SpotAllocationStrategy"].empty()) {
      spotAllocationStrategy = make_shared<string>(boost::any_cast<string>(m["SpotAllocationStrategy"]));
    }
    if (m.find("SpotCapacity") != m.end() && !m["SpotCapacity"].empty()) {
      spotCapacity = make_shared<long>(boost::any_cast<long>(m["SpotCapacity"]));
    }
    if (m.find("SpotInstancePools") != m.end() && !m["SpotInstancePools"].empty()) {
      spotInstancePools = make_shared<long>(boost::any_cast<long>(m["SpotInstancePools"]));
    }
    if (m.find("SpotInstanceRemedy") != m.end() && !m["SpotInstanceRemedy"].empty()) {
      spotInstanceRemedy = make_shared<bool>(boost::any_cast<bool>(m["SpotInstanceRemedy"]));
    }
    if (m.find("StandbyCapacity") != m.end() && !m["StandbyCapacity"].empty()) {
      standbyCapacity = make_shared<long>(boost::any_cast<long>(m["StandbyCapacity"]));
    }
    if (m.find("StopInstanceTimeout") != m.end() && !m["StopInstanceTimeout"].empty()) {
      stopInstanceTimeout = make_shared<long>(boost::any_cast<long>(m["StopInstanceTimeout"]));
    }
    if (m.find("StoppedCapacity") != m.end() && !m["StoppedCapacity"].empty()) {
      stoppedCapacity = make_shared<long>(boost::any_cast<long>(m["StoppedCapacity"]));
    }
    if (m.find("SuspendedProcesses") != m.end() && !m["SuspendedProcesses"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SuspendedProcesses"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SuspendedProcesses"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      suspendedProcesses = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SystemSuspended") != m.end() && !m["SystemSuspended"].empty()) {
      systemSuspended = make_shared<bool>(boost::any_cast<bool>(m["SystemSuspended"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeScalingGroupsResponseBodyScalingGroupsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingGroupsResponseBodyScalingGroupsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeScalingGroupsResponseBodyScalingGroupsTags>>(expect1);
      }
    }
    if (m.find("TotalCapacity") != m.end() && !m["TotalCapacity"].empty()) {
      totalCapacity = make_shared<long>(boost::any_cast<long>(m["TotalCapacity"]));
    }
    if (m.find("TotalInstanceCount") != m.end() && !m["TotalInstanceCount"].empty()) {
      totalInstanceCount = make_shared<long>(boost::any_cast<long>(m["TotalInstanceCount"]));
    }
    if (m.find("VServerGroups") != m.end() && !m["VServerGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["VServerGroups"].type()) {
        vector<DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VServerGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        VServerGroups = make_shared<vector<DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups>>(expect1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeScalingGroupsResponseBodyScalingGroups() = default;
};
class DescribeScalingGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeScalingGroupsResponseBodyScalingGroups>> scalingGroups{};
  shared_ptr<long> totalCount{};

  DescribeScalingGroupsResponseBody() {}

  explicit DescribeScalingGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingGroups) {
      vector<boost::any> temp1;
      for(auto item1:*scalingGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScalingGroups"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingGroups") != m.end() && !m["ScalingGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["ScalingGroups"].type()) {
        vector<DescribeScalingGroupsResponseBodyScalingGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScalingGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingGroupsResponseBodyScalingGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scalingGroups = make_shared<vector<DescribeScalingGroupsResponseBodyScalingGroups>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeScalingGroupsResponseBody() = default;
};
class DescribeScalingGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeScalingGroupsResponseBody> body{};

  DescribeScalingGroupsResponse() {}

  explicit DescribeScalingGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScalingGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScalingGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScalingGroupsResponse() = default;
};
class DescribeScalingInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> creationType{};
  shared_ptr<vector<string>> creationTypes{};
  shared_ptr<string> healthStatus{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> lifecycleState{};
  shared_ptr<vector<string>> lifecycleStates{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scalingActivityId{};
  shared_ptr<string> scalingConfigurationId{};
  shared_ptr<string> scalingGroupId{};

  DescribeScalingInstancesRequest() {}

  explicit DescribeScalingInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationType) {
      res["CreationType"] = boost::any(*creationType);
    }
    if (creationTypes) {
      res["CreationTypes"] = boost::any(*creationTypes);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (lifecycleState) {
      res["LifecycleState"] = boost::any(*lifecycleState);
    }
    if (lifecycleStates) {
      res["LifecycleStates"] = boost::any(*lifecycleStates);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingActivityId) {
      res["ScalingActivityId"] = boost::any(*scalingActivityId);
    }
    if (scalingConfigurationId) {
      res["ScalingConfigurationId"] = boost::any(*scalingConfigurationId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationType") != m.end() && !m["CreationType"].empty()) {
      creationType = make_shared<string>(boost::any_cast<string>(m["CreationType"]));
    }
    if (m.find("CreationTypes") != m.end() && !m["CreationTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CreationTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CreationTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      creationTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LifecycleState") != m.end() && !m["LifecycleState"].empty()) {
      lifecycleState = make_shared<string>(boost::any_cast<string>(m["LifecycleState"]));
    }
    if (m.find("LifecycleStates") != m.end() && !m["LifecycleStates"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LifecycleStates"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LifecycleStates"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      lifecycleStates = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingActivityId") != m.end() && !m["ScalingActivityId"].empty()) {
      scalingActivityId = make_shared<string>(boost::any_cast<string>(m["ScalingActivityId"]));
    }
    if (m.find("ScalingConfigurationId") != m.end() && !m["ScalingConfigurationId"].empty()) {
      scalingConfigurationId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~DescribeScalingInstancesRequest() = default;
};
class DescribeScalingInstancesResponseBodyScalingInstances : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> creationType{};
  shared_ptr<bool> entrusted{};
  shared_ptr<string> healthStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> launchTemplateId{};
  shared_ptr<string> launchTemplateVersion{};
  shared_ptr<string> lifecycleState{};
  shared_ptr<long> loadBalancerWeight{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> scalingActivityId{};
  shared_ptr<string> scalingConfigurationId{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> scalingInstanceId{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<string> warmupState{};
  shared_ptr<long> weightedCapacity{};
  shared_ptr<string> zoneId{};

  DescribeScalingInstancesResponseBodyScalingInstances() {}

  explicit DescribeScalingInstancesResponseBodyScalingInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (creationType) {
      res["CreationType"] = boost::any(*creationType);
    }
    if (entrusted) {
      res["Entrusted"] = boost::any(*entrusted);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (launchTemplateId) {
      res["LaunchTemplateId"] = boost::any(*launchTemplateId);
    }
    if (launchTemplateVersion) {
      res["LaunchTemplateVersion"] = boost::any(*launchTemplateVersion);
    }
    if (lifecycleState) {
      res["LifecycleState"] = boost::any(*lifecycleState);
    }
    if (loadBalancerWeight) {
      res["LoadBalancerWeight"] = boost::any(*loadBalancerWeight);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (scalingActivityId) {
      res["ScalingActivityId"] = boost::any(*scalingActivityId);
    }
    if (scalingConfigurationId) {
      res["ScalingConfigurationId"] = boost::any(*scalingConfigurationId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (scalingInstanceId) {
      res["ScalingInstanceId"] = boost::any(*scalingInstanceId);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (warmupState) {
      res["WarmupState"] = boost::any(*warmupState);
    }
    if (weightedCapacity) {
      res["WeightedCapacity"] = boost::any(*weightedCapacity);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("CreationType") != m.end() && !m["CreationType"].empty()) {
      creationType = make_shared<string>(boost::any_cast<string>(m["CreationType"]));
    }
    if (m.find("Entrusted") != m.end() && !m["Entrusted"].empty()) {
      entrusted = make_shared<bool>(boost::any_cast<bool>(m["Entrusted"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LaunchTemplateId") != m.end() && !m["LaunchTemplateId"].empty()) {
      launchTemplateId = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateId"]));
    }
    if (m.find("LaunchTemplateVersion") != m.end() && !m["LaunchTemplateVersion"].empty()) {
      launchTemplateVersion = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateVersion"]));
    }
    if (m.find("LifecycleState") != m.end() && !m["LifecycleState"].empty()) {
      lifecycleState = make_shared<string>(boost::any_cast<string>(m["LifecycleState"]));
    }
    if (m.find("LoadBalancerWeight") != m.end() && !m["LoadBalancerWeight"].empty()) {
      loadBalancerWeight = make_shared<long>(boost::any_cast<long>(m["LoadBalancerWeight"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("ScalingActivityId") != m.end() && !m["ScalingActivityId"].empty()) {
      scalingActivityId = make_shared<string>(boost::any_cast<string>(m["ScalingActivityId"]));
    }
    if (m.find("ScalingConfigurationId") != m.end() && !m["ScalingConfigurationId"].empty()) {
      scalingConfigurationId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("ScalingInstanceId") != m.end() && !m["ScalingInstanceId"].empty()) {
      scalingInstanceId = make_shared<string>(boost::any_cast<string>(m["ScalingInstanceId"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("WarmupState") != m.end() && !m["WarmupState"].empty()) {
      warmupState = make_shared<string>(boost::any_cast<string>(m["WarmupState"]));
    }
    if (m.find("WeightedCapacity") != m.end() && !m["WeightedCapacity"].empty()) {
      weightedCapacity = make_shared<long>(boost::any_cast<long>(m["WeightedCapacity"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeScalingInstancesResponseBodyScalingInstances() = default;
};
class DescribeScalingInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeScalingInstancesResponseBodyScalingInstances>> scalingInstances{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> totalSpotCount{};

  DescribeScalingInstancesResponseBody() {}

  explicit DescribeScalingInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingInstances) {
      vector<boost::any> temp1;
      for(auto item1:*scalingInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScalingInstances"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (totalSpotCount) {
      res["TotalSpotCount"] = boost::any(*totalSpotCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingInstances") != m.end() && !m["ScalingInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["ScalingInstances"].type()) {
        vector<DescribeScalingInstancesResponseBodyScalingInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScalingInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingInstancesResponseBodyScalingInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scalingInstances = make_shared<vector<DescribeScalingInstancesResponseBodyScalingInstances>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TotalSpotCount") != m.end() && !m["TotalSpotCount"].empty()) {
      totalSpotCount = make_shared<long>(boost::any_cast<long>(m["TotalSpotCount"]));
    }
  }


  virtual ~DescribeScalingInstancesResponseBody() = default;
};
class DescribeScalingInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeScalingInstancesResponseBody> body{};

  DescribeScalingInstancesResponse() {}

  explicit DescribeScalingInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScalingInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScalingInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScalingInstancesResponse() = default;
};
class DescribeScalingRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<vector<string>> scalingRuleAris{};
  shared_ptr<vector<string>> scalingRuleIds{};
  shared_ptr<vector<string>> scalingRuleNames{};
  shared_ptr<string> scalingRuleType{};
  shared_ptr<bool> showAlarmRules{};

  DescribeScalingRulesRequest() {}

  explicit DescribeScalingRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (scalingRuleAris) {
      res["ScalingRuleAris"] = boost::any(*scalingRuleAris);
    }
    if (scalingRuleIds) {
      res["ScalingRuleIds"] = boost::any(*scalingRuleIds);
    }
    if (scalingRuleNames) {
      res["ScalingRuleNames"] = boost::any(*scalingRuleNames);
    }
    if (scalingRuleType) {
      res["ScalingRuleType"] = boost::any(*scalingRuleType);
    }
    if (showAlarmRules) {
      res["ShowAlarmRules"] = boost::any(*showAlarmRules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("ScalingRuleAris") != m.end() && !m["ScalingRuleAris"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScalingRuleAris"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScalingRuleAris"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scalingRuleAris = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScalingRuleIds") != m.end() && !m["ScalingRuleIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScalingRuleIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScalingRuleIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scalingRuleIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScalingRuleNames") != m.end() && !m["ScalingRuleNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScalingRuleNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScalingRuleNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scalingRuleNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScalingRuleType") != m.end() && !m["ScalingRuleType"].empty()) {
      scalingRuleType = make_shared<string>(boost::any_cast<string>(m["ScalingRuleType"]));
    }
    if (m.find("ShowAlarmRules") != m.end() && !m["ShowAlarmRules"].empty()) {
      showAlarmRules = make_shared<bool>(boost::any_cast<bool>(m["ShowAlarmRules"]));
    }
  }


  virtual ~DescribeScalingRulesRequest() = default;
};
class DescribeScalingRulesResponseBodyScalingRulesAlarmDimensions : public Darabonba::Model {
public:
  shared_ptr<string> dimensionKey{};
  shared_ptr<string> dimensionValue{};

  DescribeScalingRulesResponseBodyScalingRulesAlarmDimensions() {}

  explicit DescribeScalingRulesResponseBodyScalingRulesAlarmDimensions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimensionKey) {
      res["DimensionKey"] = boost::any(*dimensionKey);
    }
    if (dimensionValue) {
      res["DimensionValue"] = boost::any(*dimensionValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DimensionKey") != m.end() && !m["DimensionKey"].empty()) {
      dimensionKey = make_shared<string>(boost::any_cast<string>(m["DimensionKey"]));
    }
    if (m.find("DimensionValue") != m.end() && !m["DimensionValue"].empty()) {
      dimensionValue = make_shared<string>(boost::any_cast<string>(m["DimensionValue"]));
    }
  }


  virtual ~DescribeScalingRulesResponseBodyScalingRulesAlarmDimensions() = default;
};
class DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions : public Darabonba::Model {
public:
  shared_ptr<string> dimensionKey{};
  shared_ptr<string> dimensionValue{};

  DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions() {}

  explicit DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimensionKey) {
      res["DimensionKey"] = boost::any(*dimensionKey);
    }
    if (dimensionValue) {
      res["DimensionValue"] = boost::any(*dimensionValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DimensionKey") != m.end() && !m["DimensionKey"].empty()) {
      dimensionKey = make_shared<string>(boost::any_cast<string>(m["DimensionKey"]));
    }
    if (m.find("DimensionValue") != m.end() && !m["DimensionValue"].empty()) {
      dimensionValue = make_shared<string>(boost::any_cast<string>(m["DimensionValue"]));
    }
  }


  virtual ~DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions() = default;
};
class DescribeScalingRulesResponseBodyScalingRulesAlarms : public Darabonba::Model {
public:
  shared_ptr<string> alarmTaskId{};
  shared_ptr<string> alarmTaskName{};
  shared_ptr<string> comparisonOperator{};
  shared_ptr<vector<DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions>> dimensions{};
  shared_ptr<long> evaluationCount{};
  shared_ptr<string> metricName{};
  shared_ptr<string> metricType{};
  shared_ptr<string> statistics{};
  shared_ptr<double> threshold{};

  DescribeScalingRulesResponseBodyScalingRulesAlarms() {}

  explicit DescribeScalingRulesResponseBodyScalingRulesAlarms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmTaskId) {
      res["AlarmTaskId"] = boost::any(*alarmTaskId);
    }
    if (alarmTaskName) {
      res["AlarmTaskName"] = boost::any(*alarmTaskName);
    }
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (dimensions) {
      vector<boost::any> temp1;
      for(auto item1:*dimensions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dimensions"] = boost::any(temp1);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmTaskId") != m.end() && !m["AlarmTaskId"].empty()) {
      alarmTaskId = make_shared<string>(boost::any_cast<string>(m["AlarmTaskId"]));
    }
    if (m.find("AlarmTaskName") != m.end() && !m["AlarmTaskName"].empty()) {
      alarmTaskName = make_shared<string>(boost::any_cast<string>(m["AlarmTaskName"]));
    }
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      if (typeid(vector<boost::any>) == m["Dimensions"].type()) {
        vector<DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dimensions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dimensions = make_shared<vector<DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions>>(expect1);
      }
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
  }


  virtual ~DescribeScalingRulesResponseBodyScalingRulesAlarms() = default;
};
class DescribeScalingRulesResponseBodyScalingRulesHybridMetricsDimensions : public Darabonba::Model {
public:
  shared_ptr<string> dimensionKey{};
  shared_ptr<string> dimensionValue{};

  DescribeScalingRulesResponseBodyScalingRulesHybridMetricsDimensions() {}

  explicit DescribeScalingRulesResponseBodyScalingRulesHybridMetricsDimensions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimensionKey) {
      res["DimensionKey"] = boost::any(*dimensionKey);
    }
    if (dimensionValue) {
      res["DimensionValue"] = boost::any(*dimensionValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DimensionKey") != m.end() && !m["DimensionKey"].empty()) {
      dimensionKey = make_shared<string>(boost::any_cast<string>(m["DimensionKey"]));
    }
    if (m.find("DimensionValue") != m.end() && !m["DimensionValue"].empty()) {
      dimensionValue = make_shared<string>(boost::any_cast<string>(m["DimensionValue"]));
    }
  }


  virtual ~DescribeScalingRulesResponseBodyScalingRulesHybridMetricsDimensions() = default;
};
class DescribeScalingRulesResponseBodyScalingRulesHybridMetrics : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeScalingRulesResponseBodyScalingRulesHybridMetricsDimensions>> dimensions{};
  shared_ptr<string> expression{};
  shared_ptr<string> id{};
  shared_ptr<string> metricName{};
  shared_ptr<string> statistic{};

  DescribeScalingRulesResponseBodyScalingRulesHybridMetrics() {}

  explicit DescribeScalingRulesResponseBodyScalingRulesHybridMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimensions) {
      vector<boost::any> temp1;
      for(auto item1:*dimensions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dimensions"] = boost::any(temp1);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (statistic) {
      res["Statistic"] = boost::any(*statistic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      if (typeid(vector<boost::any>) == m["Dimensions"].type()) {
        vector<DescribeScalingRulesResponseBodyScalingRulesHybridMetricsDimensions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dimensions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingRulesResponseBodyScalingRulesHybridMetricsDimensions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dimensions = make_shared<vector<DescribeScalingRulesResponseBodyScalingRulesHybridMetricsDimensions>>(expect1);
      }
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Statistic") != m.end() && !m["Statistic"].empty()) {
      statistic = make_shared<string>(boost::any_cast<string>(m["Statistic"]));
    }
  }


  virtual ~DescribeScalingRulesResponseBodyScalingRulesHybridMetrics() = default;
};
class DescribeScalingRulesResponseBodyScalingRulesStepAdjustments : public Darabonba::Model {
public:
  shared_ptr<double> metricIntervalLowerBound{};
  shared_ptr<double> metricIntervalUpperBound{};
  shared_ptr<long> scalingAdjustment{};

  DescribeScalingRulesResponseBodyScalingRulesStepAdjustments() {}

  explicit DescribeScalingRulesResponseBodyScalingRulesStepAdjustments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricIntervalLowerBound) {
      res["MetricIntervalLowerBound"] = boost::any(*metricIntervalLowerBound);
    }
    if (metricIntervalUpperBound) {
      res["MetricIntervalUpperBound"] = boost::any(*metricIntervalUpperBound);
    }
    if (scalingAdjustment) {
      res["ScalingAdjustment"] = boost::any(*scalingAdjustment);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricIntervalLowerBound") != m.end() && !m["MetricIntervalLowerBound"].empty()) {
      metricIntervalLowerBound = make_shared<double>(boost::any_cast<double>(m["MetricIntervalLowerBound"]));
    }
    if (m.find("MetricIntervalUpperBound") != m.end() && !m["MetricIntervalUpperBound"].empty()) {
      metricIntervalUpperBound = make_shared<double>(boost::any_cast<double>(m["MetricIntervalUpperBound"]));
    }
    if (m.find("ScalingAdjustment") != m.end() && !m["ScalingAdjustment"].empty()) {
      scalingAdjustment = make_shared<long>(boost::any_cast<long>(m["ScalingAdjustment"]));
    }
  }


  virtual ~DescribeScalingRulesResponseBodyScalingRulesStepAdjustments() = default;
};
class DescribeScalingRulesResponseBodyScalingRules : public Darabonba::Model {
public:
  shared_ptr<string> adjustmentType{};
  shared_ptr<long> adjustmentValue{};
  shared_ptr<vector<DescribeScalingRulesResponseBodyScalingRulesAlarmDimensions>> alarmDimensions{};
  shared_ptr<vector<DescribeScalingRulesResponseBodyScalingRulesAlarms>> alarms{};
  shared_ptr<long> cooldown{};
  shared_ptr<bool> disableScaleIn{};
  shared_ptr<long> estimatedInstanceWarmup{};
  shared_ptr<vector<DescribeScalingRulesResponseBodyScalingRulesHybridMetrics>> hybridMetrics{};
  shared_ptr<string> hybridMonitorNamespace{};
  shared_ptr<long> initialMaxSize{};
  shared_ptr<long> maxSize{};
  shared_ptr<string> metricName{};
  shared_ptr<string> metricType{};
  shared_ptr<long> minAdjustmentMagnitude{};
  shared_ptr<long> minSize{};
  shared_ptr<string> predictiveScalingMode{};
  shared_ptr<long> predictiveTaskBufferTime{};
  shared_ptr<string> predictiveValueBehavior{};
  shared_ptr<long> predictiveValueBuffer{};
  shared_ptr<long> scaleInEvaluationCount{};
  shared_ptr<long> scaleOutEvaluationCount{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> scalingRuleAri{};
  shared_ptr<string> scalingRuleId{};
  shared_ptr<string> scalingRuleName{};
  shared_ptr<string> scalingRuleType{};
  shared_ptr<vector<DescribeScalingRulesResponseBodyScalingRulesStepAdjustments>> stepAdjustments{};
  shared_ptr<double> targetValue{};

  DescribeScalingRulesResponseBodyScalingRules() {}

  explicit DescribeScalingRulesResponseBodyScalingRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjustmentType) {
      res["AdjustmentType"] = boost::any(*adjustmentType);
    }
    if (adjustmentValue) {
      res["AdjustmentValue"] = boost::any(*adjustmentValue);
    }
    if (alarmDimensions) {
      vector<boost::any> temp1;
      for(auto item1:*alarmDimensions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlarmDimensions"] = boost::any(temp1);
    }
    if (alarms) {
      vector<boost::any> temp1;
      for(auto item1:*alarms){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Alarms"] = boost::any(temp1);
    }
    if (cooldown) {
      res["Cooldown"] = boost::any(*cooldown);
    }
    if (disableScaleIn) {
      res["DisableScaleIn"] = boost::any(*disableScaleIn);
    }
    if (estimatedInstanceWarmup) {
      res["EstimatedInstanceWarmup"] = boost::any(*estimatedInstanceWarmup);
    }
    if (hybridMetrics) {
      vector<boost::any> temp1;
      for(auto item1:*hybridMetrics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HybridMetrics"] = boost::any(temp1);
    }
    if (hybridMonitorNamespace) {
      res["HybridMonitorNamespace"] = boost::any(*hybridMonitorNamespace);
    }
    if (initialMaxSize) {
      res["InitialMaxSize"] = boost::any(*initialMaxSize);
    }
    if (maxSize) {
      res["MaxSize"] = boost::any(*maxSize);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (minAdjustmentMagnitude) {
      res["MinAdjustmentMagnitude"] = boost::any(*minAdjustmentMagnitude);
    }
    if (minSize) {
      res["MinSize"] = boost::any(*minSize);
    }
    if (predictiveScalingMode) {
      res["PredictiveScalingMode"] = boost::any(*predictiveScalingMode);
    }
    if (predictiveTaskBufferTime) {
      res["PredictiveTaskBufferTime"] = boost::any(*predictiveTaskBufferTime);
    }
    if (predictiveValueBehavior) {
      res["PredictiveValueBehavior"] = boost::any(*predictiveValueBehavior);
    }
    if (predictiveValueBuffer) {
      res["PredictiveValueBuffer"] = boost::any(*predictiveValueBuffer);
    }
    if (scaleInEvaluationCount) {
      res["ScaleInEvaluationCount"] = boost::any(*scaleInEvaluationCount);
    }
    if (scaleOutEvaluationCount) {
      res["ScaleOutEvaluationCount"] = boost::any(*scaleOutEvaluationCount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (scalingRuleAri) {
      res["ScalingRuleAri"] = boost::any(*scalingRuleAri);
    }
    if (scalingRuleId) {
      res["ScalingRuleId"] = boost::any(*scalingRuleId);
    }
    if (scalingRuleName) {
      res["ScalingRuleName"] = boost::any(*scalingRuleName);
    }
    if (scalingRuleType) {
      res["ScalingRuleType"] = boost::any(*scalingRuleType);
    }
    if (stepAdjustments) {
      vector<boost::any> temp1;
      for(auto item1:*stepAdjustments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StepAdjustments"] = boost::any(temp1);
    }
    if (targetValue) {
      res["TargetValue"] = boost::any(*targetValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjustmentType") != m.end() && !m["AdjustmentType"].empty()) {
      adjustmentType = make_shared<string>(boost::any_cast<string>(m["AdjustmentType"]));
    }
    if (m.find("AdjustmentValue") != m.end() && !m["AdjustmentValue"].empty()) {
      adjustmentValue = make_shared<long>(boost::any_cast<long>(m["AdjustmentValue"]));
    }
    if (m.find("AlarmDimensions") != m.end() && !m["AlarmDimensions"].empty()) {
      if (typeid(vector<boost::any>) == m["AlarmDimensions"].type()) {
        vector<DescribeScalingRulesResponseBodyScalingRulesAlarmDimensions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlarmDimensions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingRulesResponseBodyScalingRulesAlarmDimensions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alarmDimensions = make_shared<vector<DescribeScalingRulesResponseBodyScalingRulesAlarmDimensions>>(expect1);
      }
    }
    if (m.find("Alarms") != m.end() && !m["Alarms"].empty()) {
      if (typeid(vector<boost::any>) == m["Alarms"].type()) {
        vector<DescribeScalingRulesResponseBodyScalingRulesAlarms> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Alarms"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingRulesResponseBodyScalingRulesAlarms model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alarms = make_shared<vector<DescribeScalingRulesResponseBodyScalingRulesAlarms>>(expect1);
      }
    }
    if (m.find("Cooldown") != m.end() && !m["Cooldown"].empty()) {
      cooldown = make_shared<long>(boost::any_cast<long>(m["Cooldown"]));
    }
    if (m.find("DisableScaleIn") != m.end() && !m["DisableScaleIn"].empty()) {
      disableScaleIn = make_shared<bool>(boost::any_cast<bool>(m["DisableScaleIn"]));
    }
    if (m.find("EstimatedInstanceWarmup") != m.end() && !m["EstimatedInstanceWarmup"].empty()) {
      estimatedInstanceWarmup = make_shared<long>(boost::any_cast<long>(m["EstimatedInstanceWarmup"]));
    }
    if (m.find("HybridMetrics") != m.end() && !m["HybridMetrics"].empty()) {
      if (typeid(vector<boost::any>) == m["HybridMetrics"].type()) {
        vector<DescribeScalingRulesResponseBodyScalingRulesHybridMetrics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HybridMetrics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingRulesResponseBodyScalingRulesHybridMetrics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hybridMetrics = make_shared<vector<DescribeScalingRulesResponseBodyScalingRulesHybridMetrics>>(expect1);
      }
    }
    if (m.find("HybridMonitorNamespace") != m.end() && !m["HybridMonitorNamespace"].empty()) {
      hybridMonitorNamespace = make_shared<string>(boost::any_cast<string>(m["HybridMonitorNamespace"]));
    }
    if (m.find("InitialMaxSize") != m.end() && !m["InitialMaxSize"].empty()) {
      initialMaxSize = make_shared<long>(boost::any_cast<long>(m["InitialMaxSize"]));
    }
    if (m.find("MaxSize") != m.end() && !m["MaxSize"].empty()) {
      maxSize = make_shared<long>(boost::any_cast<long>(m["MaxSize"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("MinAdjustmentMagnitude") != m.end() && !m["MinAdjustmentMagnitude"].empty()) {
      minAdjustmentMagnitude = make_shared<long>(boost::any_cast<long>(m["MinAdjustmentMagnitude"]));
    }
    if (m.find("MinSize") != m.end() && !m["MinSize"].empty()) {
      minSize = make_shared<long>(boost::any_cast<long>(m["MinSize"]));
    }
    if (m.find("PredictiveScalingMode") != m.end() && !m["PredictiveScalingMode"].empty()) {
      predictiveScalingMode = make_shared<string>(boost::any_cast<string>(m["PredictiveScalingMode"]));
    }
    if (m.find("PredictiveTaskBufferTime") != m.end() && !m["PredictiveTaskBufferTime"].empty()) {
      predictiveTaskBufferTime = make_shared<long>(boost::any_cast<long>(m["PredictiveTaskBufferTime"]));
    }
    if (m.find("PredictiveValueBehavior") != m.end() && !m["PredictiveValueBehavior"].empty()) {
      predictiveValueBehavior = make_shared<string>(boost::any_cast<string>(m["PredictiveValueBehavior"]));
    }
    if (m.find("PredictiveValueBuffer") != m.end() && !m["PredictiveValueBuffer"].empty()) {
      predictiveValueBuffer = make_shared<long>(boost::any_cast<long>(m["PredictiveValueBuffer"]));
    }
    if (m.find("ScaleInEvaluationCount") != m.end() && !m["ScaleInEvaluationCount"].empty()) {
      scaleInEvaluationCount = make_shared<long>(boost::any_cast<long>(m["ScaleInEvaluationCount"]));
    }
    if (m.find("ScaleOutEvaluationCount") != m.end() && !m["ScaleOutEvaluationCount"].empty()) {
      scaleOutEvaluationCount = make_shared<long>(boost::any_cast<long>(m["ScaleOutEvaluationCount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("ScalingRuleAri") != m.end() && !m["ScalingRuleAri"].empty()) {
      scalingRuleAri = make_shared<string>(boost::any_cast<string>(m["ScalingRuleAri"]));
    }
    if (m.find("ScalingRuleId") != m.end() && !m["ScalingRuleId"].empty()) {
      scalingRuleId = make_shared<string>(boost::any_cast<string>(m["ScalingRuleId"]));
    }
    if (m.find("ScalingRuleName") != m.end() && !m["ScalingRuleName"].empty()) {
      scalingRuleName = make_shared<string>(boost::any_cast<string>(m["ScalingRuleName"]));
    }
    if (m.find("ScalingRuleType") != m.end() && !m["ScalingRuleType"].empty()) {
      scalingRuleType = make_shared<string>(boost::any_cast<string>(m["ScalingRuleType"]));
    }
    if (m.find("StepAdjustments") != m.end() && !m["StepAdjustments"].empty()) {
      if (typeid(vector<boost::any>) == m["StepAdjustments"].type()) {
        vector<DescribeScalingRulesResponseBodyScalingRulesStepAdjustments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StepAdjustments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingRulesResponseBodyScalingRulesStepAdjustments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stepAdjustments = make_shared<vector<DescribeScalingRulesResponseBodyScalingRulesStepAdjustments>>(expect1);
      }
    }
    if (m.find("TargetValue") != m.end() && !m["TargetValue"].empty()) {
      targetValue = make_shared<double>(boost::any_cast<double>(m["TargetValue"]));
    }
  }


  virtual ~DescribeScalingRulesResponseBodyScalingRules() = default;
};
class DescribeScalingRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeScalingRulesResponseBodyScalingRules>> scalingRules{};
  shared_ptr<long> totalCount{};

  DescribeScalingRulesResponseBody() {}

  explicit DescribeScalingRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingRules) {
      vector<boost::any> temp1;
      for(auto item1:*scalingRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScalingRules"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingRules") != m.end() && !m["ScalingRules"].empty()) {
      if (typeid(vector<boost::any>) == m["ScalingRules"].type()) {
        vector<DescribeScalingRulesResponseBodyScalingRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScalingRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingRulesResponseBodyScalingRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scalingRules = make_shared<vector<DescribeScalingRulesResponseBodyScalingRules>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeScalingRulesResponseBody() = default;
};
class DescribeScalingRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeScalingRulesResponseBody> body{};

  DescribeScalingRulesResponse() {}

  explicit DescribeScalingRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScalingRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScalingRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScalingRulesResponse() = default;
};
class DescribeScheduledTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> recurrenceType{};
  shared_ptr<string> recurrenceValue{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<vector<string>> scheduledActions{};
  shared_ptr<vector<string>> scheduledTaskIds{};
  shared_ptr<vector<string>> scheduledTaskNames{};
  shared_ptr<bool> taskEnabled{};
  shared_ptr<string> taskName{};

  DescribeScheduledTasksRequest() {}

  explicit DescribeScheduledTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (recurrenceType) {
      res["RecurrenceType"] = boost::any(*recurrenceType);
    }
    if (recurrenceValue) {
      res["RecurrenceValue"] = boost::any(*recurrenceValue);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (scheduledActions) {
      res["ScheduledActions"] = boost::any(*scheduledActions);
    }
    if (scheduledTaskIds) {
      res["ScheduledTaskIds"] = boost::any(*scheduledTaskIds);
    }
    if (scheduledTaskNames) {
      res["ScheduledTaskNames"] = boost::any(*scheduledTaskNames);
    }
    if (taskEnabled) {
      res["TaskEnabled"] = boost::any(*taskEnabled);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RecurrenceType") != m.end() && !m["RecurrenceType"].empty()) {
      recurrenceType = make_shared<string>(boost::any_cast<string>(m["RecurrenceType"]));
    }
    if (m.find("RecurrenceValue") != m.end() && !m["RecurrenceValue"].empty()) {
      recurrenceValue = make_shared<string>(boost::any_cast<string>(m["RecurrenceValue"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("ScheduledActions") != m.end() && !m["ScheduledActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScheduledActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScheduledActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scheduledActions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScheduledTaskIds") != m.end() && !m["ScheduledTaskIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScheduledTaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScheduledTaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scheduledTaskIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScheduledTaskNames") != m.end() && !m["ScheduledTaskNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScheduledTaskNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScheduledTaskNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scheduledTaskNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TaskEnabled") != m.end() && !m["TaskEnabled"].empty()) {
      taskEnabled = make_shared<bool>(boost::any_cast<bool>(m["TaskEnabled"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~DescribeScheduledTasksRequest() = default;
};
class DescribeScheduledTasksResponseBodyScheduledTasks : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> desiredCapacity{};
  shared_ptr<long> launchExpirationTime{};
  shared_ptr<string> launchTime{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minValue{};
  shared_ptr<string> recurrenceEndTime{};
  shared_ptr<string> recurrenceType{};
  shared_ptr<string> recurrenceValue{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> scheduledAction{};
  shared_ptr<string> scheduledTaskId{};
  shared_ptr<string> scheduledTaskName{};
  shared_ptr<bool> taskEnabled{};

  DescribeScheduledTasksResponseBodyScheduledTasks() {}

  explicit DescribeScheduledTasksResponseBodyScheduledTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (desiredCapacity) {
      res["DesiredCapacity"] = boost::any(*desiredCapacity);
    }
    if (launchExpirationTime) {
      res["LaunchExpirationTime"] = boost::any(*launchExpirationTime);
    }
    if (launchTime) {
      res["LaunchTime"] = boost::any(*launchTime);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (recurrenceEndTime) {
      res["RecurrenceEndTime"] = boost::any(*recurrenceEndTime);
    }
    if (recurrenceType) {
      res["RecurrenceType"] = boost::any(*recurrenceType);
    }
    if (recurrenceValue) {
      res["RecurrenceValue"] = boost::any(*recurrenceValue);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (scheduledAction) {
      res["ScheduledAction"] = boost::any(*scheduledAction);
    }
    if (scheduledTaskId) {
      res["ScheduledTaskId"] = boost::any(*scheduledTaskId);
    }
    if (scheduledTaskName) {
      res["ScheduledTaskName"] = boost::any(*scheduledTaskName);
    }
    if (taskEnabled) {
      res["TaskEnabled"] = boost::any(*taskEnabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DesiredCapacity") != m.end() && !m["DesiredCapacity"].empty()) {
      desiredCapacity = make_shared<long>(boost::any_cast<long>(m["DesiredCapacity"]));
    }
    if (m.find("LaunchExpirationTime") != m.end() && !m["LaunchExpirationTime"].empty()) {
      launchExpirationTime = make_shared<long>(boost::any_cast<long>(m["LaunchExpirationTime"]));
    }
    if (m.find("LaunchTime") != m.end() && !m["LaunchTime"].empty()) {
      launchTime = make_shared<string>(boost::any_cast<string>(m["LaunchTime"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("RecurrenceEndTime") != m.end() && !m["RecurrenceEndTime"].empty()) {
      recurrenceEndTime = make_shared<string>(boost::any_cast<string>(m["RecurrenceEndTime"]));
    }
    if (m.find("RecurrenceType") != m.end() && !m["RecurrenceType"].empty()) {
      recurrenceType = make_shared<string>(boost::any_cast<string>(m["RecurrenceType"]));
    }
    if (m.find("RecurrenceValue") != m.end() && !m["RecurrenceValue"].empty()) {
      recurrenceValue = make_shared<string>(boost::any_cast<string>(m["RecurrenceValue"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("ScheduledAction") != m.end() && !m["ScheduledAction"].empty()) {
      scheduledAction = make_shared<string>(boost::any_cast<string>(m["ScheduledAction"]));
    }
    if (m.find("ScheduledTaskId") != m.end() && !m["ScheduledTaskId"].empty()) {
      scheduledTaskId = make_shared<string>(boost::any_cast<string>(m["ScheduledTaskId"]));
    }
    if (m.find("ScheduledTaskName") != m.end() && !m["ScheduledTaskName"].empty()) {
      scheduledTaskName = make_shared<string>(boost::any_cast<string>(m["ScheduledTaskName"]));
    }
    if (m.find("TaskEnabled") != m.end() && !m["TaskEnabled"].empty()) {
      taskEnabled = make_shared<bool>(boost::any_cast<bool>(m["TaskEnabled"]));
    }
  }


  virtual ~DescribeScheduledTasksResponseBodyScheduledTasks() = default;
};
class DescribeScheduledTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeScheduledTasksResponseBodyScheduledTasks>> scheduledTasks{};
  shared_ptr<long> totalCount{};

  DescribeScheduledTasksResponseBody() {}

  explicit DescribeScheduledTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduledTasks) {
      vector<boost::any> temp1;
      for(auto item1:*scheduledTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScheduledTasks"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScheduledTasks") != m.end() && !m["ScheduledTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["ScheduledTasks"].type()) {
        vector<DescribeScheduledTasksResponseBodyScheduledTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScheduledTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScheduledTasksResponseBodyScheduledTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scheduledTasks = make_shared<vector<DescribeScheduledTasksResponseBodyScheduledTasks>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeScheduledTasksResponseBody() = default;
};
class DescribeScheduledTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeScheduledTasksResponseBody> body{};

  DescribeScheduledTasksResponse() {}

  explicit DescribeScheduledTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScheduledTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScheduledTasksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScheduledTasksResponse() = default;
};
class DetachAlbServerGroupsRequestAlbServerGroups : public Darabonba::Model {
public:
  shared_ptr<string> albServerGroupId{};
  shared_ptr<long> port{};

  DetachAlbServerGroupsRequestAlbServerGroups() {}

  explicit DetachAlbServerGroupsRequestAlbServerGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (albServerGroupId) {
      res["AlbServerGroupId"] = boost::any(*albServerGroupId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlbServerGroupId") != m.end() && !m["AlbServerGroupId"].empty()) {
      albServerGroupId = make_shared<string>(boost::any_cast<string>(m["AlbServerGroupId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
  }


  virtual ~DetachAlbServerGroupsRequestAlbServerGroups() = default;
};
class DetachAlbServerGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DetachAlbServerGroupsRequestAlbServerGroups>> albServerGroups{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> forceDetach{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};

  DetachAlbServerGroupsRequest() {}

  explicit DetachAlbServerGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (albServerGroups) {
      vector<boost::any> temp1;
      for(auto item1:*albServerGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlbServerGroups"] = boost::any(temp1);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (forceDetach) {
      res["ForceDetach"] = boost::any(*forceDetach);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlbServerGroups") != m.end() && !m["AlbServerGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["AlbServerGroups"].type()) {
        vector<DetachAlbServerGroupsRequestAlbServerGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlbServerGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachAlbServerGroupsRequestAlbServerGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        albServerGroups = make_shared<vector<DetachAlbServerGroupsRequestAlbServerGroups>>(expect1);
      }
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ForceDetach") != m.end() && !m["ForceDetach"].empty()) {
      forceDetach = make_shared<bool>(boost::any_cast<bool>(m["ForceDetach"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~DetachAlbServerGroupsRequest() = default;
};
class DetachAlbServerGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> scalingActivityId{};

  DetachAlbServerGroupsResponseBody() {}

  explicit DetachAlbServerGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingActivityId) {
      res["ScalingActivityId"] = boost::any(*scalingActivityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingActivityId") != m.end() && !m["ScalingActivityId"].empty()) {
      scalingActivityId = make_shared<string>(boost::any_cast<string>(m["ScalingActivityId"]));
    }
  }


  virtual ~DetachAlbServerGroupsResponseBody() = default;
};
class DetachAlbServerGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachAlbServerGroupsResponseBody> body{};

  DetachAlbServerGroupsResponse() {}

  explicit DetachAlbServerGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachAlbServerGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachAlbServerGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DetachAlbServerGroupsResponse() = default;
};
class DetachDBInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<vector<string>> DBInstances{};
  shared_ptr<bool> forceDetach{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> removeSecurityGroup{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};

  DetachDBInstancesRequest() {}

  explicit DetachDBInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstances) {
      res["DBInstances"] = boost::any(*DBInstances);
    }
    if (forceDetach) {
      res["ForceDetach"] = boost::any(*forceDetach);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (removeSecurityGroup) {
      res["RemoveSecurityGroup"] = boost::any(*removeSecurityGroup);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstances") != m.end() && !m["DBInstances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DBInstances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DBInstances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      DBInstances = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ForceDetach") != m.end() && !m["ForceDetach"].empty()) {
      forceDetach = make_shared<bool>(boost::any_cast<bool>(m["ForceDetach"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemoveSecurityGroup") != m.end() && !m["RemoveSecurityGroup"].empty()) {
      removeSecurityGroup = make_shared<bool>(boost::any_cast<bool>(m["RemoveSecurityGroup"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~DetachDBInstancesRequest() = default;
};
class DetachDBInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DetachDBInstancesResponseBody() {}

  explicit DetachDBInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetachDBInstancesResponseBody() = default;
};
class DetachDBInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachDBInstancesResponseBody> body{};

  DetachDBInstancesResponse() {}

  explicit DetachDBInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachDBInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachDBInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DetachDBInstancesResponse() = default;
};
class DetachInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> decreaseDesiredCapacity{};
  shared_ptr<string> detachOption{};
  shared_ptr<bool> ignoreInvalidInstance{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<bool> lifecycleHook{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scalingGroupId{};

  DetachInstancesRequest() {}

  explicit DetachInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (decreaseDesiredCapacity) {
      res["DecreaseDesiredCapacity"] = boost::any(*decreaseDesiredCapacity);
    }
    if (detachOption) {
      res["DetachOption"] = boost::any(*detachOption);
    }
    if (ignoreInvalidInstance) {
      res["IgnoreInvalidInstance"] = boost::any(*ignoreInvalidInstance);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (lifecycleHook) {
      res["LifecycleHook"] = boost::any(*lifecycleHook);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DecreaseDesiredCapacity") != m.end() && !m["DecreaseDesiredCapacity"].empty()) {
      decreaseDesiredCapacity = make_shared<bool>(boost::any_cast<bool>(m["DecreaseDesiredCapacity"]));
    }
    if (m.find("DetachOption") != m.end() && !m["DetachOption"].empty()) {
      detachOption = make_shared<string>(boost::any_cast<string>(m["DetachOption"]));
    }
    if (m.find("IgnoreInvalidInstance") != m.end() && !m["IgnoreInvalidInstance"].empty()) {
      ignoreInvalidInstance = make_shared<bool>(boost::any_cast<bool>(m["IgnoreInvalidInstance"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LifecycleHook") != m.end() && !m["LifecycleHook"].empty()) {
      lifecycleHook = make_shared<bool>(boost::any_cast<bool>(m["LifecycleHook"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~DetachInstancesRequest() = default;
};
class DetachInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> scalingActivityId{};

  DetachInstancesResponseBody() {}

  explicit DetachInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingActivityId) {
      res["ScalingActivityId"] = boost::any(*scalingActivityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingActivityId") != m.end() && !m["ScalingActivityId"].empty()) {
      scalingActivityId = make_shared<string>(boost::any_cast<string>(m["ScalingActivityId"]));
    }
  }


  virtual ~DetachInstancesResponseBody() = default;
};
class DetachInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachInstancesResponseBody> body{};

  DetachInstancesResponse() {}

  explicit DetachInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DetachInstancesResponse() = default;
};
class DetachLoadBalancersRequest : public Darabonba::Model {
public:
  shared_ptr<bool> async{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> forceDetach{};
  shared_ptr<vector<string>> loadBalancers{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};

  DetachLoadBalancersRequest() {}

  explicit DetachLoadBalancersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (forceDetach) {
      res["ForceDetach"] = boost::any(*forceDetach);
    }
    if (loadBalancers) {
      res["LoadBalancers"] = boost::any(*loadBalancers);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ForceDetach") != m.end() && !m["ForceDetach"].empty()) {
      forceDetach = make_shared<bool>(boost::any_cast<bool>(m["ForceDetach"]));
    }
    if (m.find("LoadBalancers") != m.end() && !m["LoadBalancers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LoadBalancers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LoadBalancers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      loadBalancers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~DetachLoadBalancersRequest() = default;
};
class DetachLoadBalancersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> scalingActivityId{};

  DetachLoadBalancersResponseBody() {}

  explicit DetachLoadBalancersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingActivityId) {
      res["ScalingActivityId"] = boost::any(*scalingActivityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingActivityId") != m.end() && !m["ScalingActivityId"].empty()) {
      scalingActivityId = make_shared<string>(boost::any_cast<string>(m["ScalingActivityId"]));
    }
  }


  virtual ~DetachLoadBalancersResponseBody() = default;
};
class DetachLoadBalancersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachLoadBalancersResponseBody> body{};

  DetachLoadBalancersResponse() {}

  explicit DetachLoadBalancersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachLoadBalancersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachLoadBalancersResponseBody>(model1);
      }
    }
  }


  virtual ~DetachLoadBalancersResponse() = default;
};
class DetachServerGroupsRequestServerGroups : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> serverGroupId{};
  shared_ptr<string> type{};

  DetachServerGroupsRequestServerGroups() {}

  explicit DetachServerGroupsRequestServerGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (serverGroupId) {
      res["ServerGroupId"] = boost::any(*serverGroupId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("ServerGroupId") != m.end() && !m["ServerGroupId"].empty()) {
      serverGroupId = make_shared<string>(boost::any_cast<string>(m["ServerGroupId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DetachServerGroupsRequestServerGroups() = default;
};
class DetachServerGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> forceDetach{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<vector<DetachServerGroupsRequestServerGroups>> serverGroups{};

  DetachServerGroupsRequest() {}

  explicit DetachServerGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (forceDetach) {
      res["ForceDetach"] = boost::any(*forceDetach);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (serverGroups) {
      vector<boost::any> temp1;
      for(auto item1:*serverGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServerGroups"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ForceDetach") != m.end() && !m["ForceDetach"].empty()) {
      forceDetach = make_shared<bool>(boost::any_cast<bool>(m["ForceDetach"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("ServerGroups") != m.end() && !m["ServerGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["ServerGroups"].type()) {
        vector<DetachServerGroupsRequestServerGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServerGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachServerGroupsRequestServerGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serverGroups = make_shared<vector<DetachServerGroupsRequestServerGroups>>(expect1);
      }
    }
  }


  virtual ~DetachServerGroupsRequest() = default;
};
class DetachServerGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> scalingActivityId{};

  DetachServerGroupsResponseBody() {}

  explicit DetachServerGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingActivityId) {
      res["ScalingActivityId"] = boost::any(*scalingActivityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingActivityId") != m.end() && !m["ScalingActivityId"].empty()) {
      scalingActivityId = make_shared<string>(boost::any_cast<string>(m["ScalingActivityId"]));
    }
  }


  virtual ~DetachServerGroupsResponseBody() = default;
};
class DetachServerGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachServerGroupsResponseBody> body{};

  DetachServerGroupsResponse() {}

  explicit DetachServerGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachServerGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachServerGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DetachServerGroupsResponse() = default;
};
class DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> VServerGroupId{};

  DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes() {}

  explicit DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (VServerGroupId) {
      res["VServerGroupId"] = boost::any(*VServerGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("VServerGroupId") != m.end() && !m["VServerGroupId"].empty()) {
      VServerGroupId = make_shared<string>(boost::any_cast<string>(m["VServerGroupId"]));
    }
  }


  virtual ~DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes() = default;
};
class DetachVServerGroupsRequestVServerGroups : public Darabonba::Model {
public:
  shared_ptr<string> loadBalancerId{};
  shared_ptr<vector<DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes>> VServerGroupAttributes{};

  DetachVServerGroupsRequestVServerGroups() {}

  explicit DetachVServerGroupsRequestVServerGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (VServerGroupAttributes) {
      vector<boost::any> temp1;
      for(auto item1:*VServerGroupAttributes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VServerGroupAttributes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("VServerGroupAttributes") != m.end() && !m["VServerGroupAttributes"].empty()) {
      if (typeid(vector<boost::any>) == m["VServerGroupAttributes"].type()) {
        vector<DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VServerGroupAttributes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        VServerGroupAttributes = make_shared<vector<DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes>>(expect1);
      }
    }
  }


  virtual ~DetachVServerGroupsRequestVServerGroups() = default;
};
class DetachVServerGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> forceDetach{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<vector<DetachVServerGroupsRequestVServerGroups>> VServerGroups{};

  DetachVServerGroupsRequest() {}

  explicit DetachVServerGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (forceDetach) {
      res["ForceDetach"] = boost::any(*forceDetach);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (VServerGroups) {
      vector<boost::any> temp1;
      for(auto item1:*VServerGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VServerGroups"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ForceDetach") != m.end() && !m["ForceDetach"].empty()) {
      forceDetach = make_shared<bool>(boost::any_cast<bool>(m["ForceDetach"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("VServerGroups") != m.end() && !m["VServerGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["VServerGroups"].type()) {
        vector<DetachVServerGroupsRequestVServerGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VServerGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachVServerGroupsRequestVServerGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        VServerGroups = make_shared<vector<DetachVServerGroupsRequestVServerGroups>>(expect1);
      }
    }
  }


  virtual ~DetachVServerGroupsRequest() = default;
};
class DetachVServerGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DetachVServerGroupsResponseBody() {}

  explicit DetachVServerGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetachVServerGroupsResponseBody() = default;
};
class DetachVServerGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachVServerGroupsResponseBody> body{};

  DetachVServerGroupsResponse() {}

  explicit DetachVServerGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachVServerGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachVServerGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DetachVServerGroupsResponse() = default;
};
class DisableAlarmRequest : public Darabonba::Model {
public:
  shared_ptr<string> alarmTaskId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};

  DisableAlarmRequest() {}

  explicit DisableAlarmRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmTaskId) {
      res["AlarmTaskId"] = boost::any(*alarmTaskId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmTaskId") != m.end() && !m["AlarmTaskId"].empty()) {
      alarmTaskId = make_shared<string>(boost::any_cast<string>(m["AlarmTaskId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
  }


  virtual ~DisableAlarmRequest() = default;
};
class DisableAlarmResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableAlarmResponseBody() {}

  explicit DisableAlarmResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableAlarmResponseBody() = default;
};
class DisableAlarmResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableAlarmResponseBody> body{};

  DisableAlarmResponse() {}

  explicit DisableAlarmResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableAlarmResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableAlarmResponseBody>(model1);
      }
    }
  }


  virtual ~DisableAlarmResponse() = default;
};
class DisableScalingGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scalingGroupId{};

  DisableScalingGroupRequest() {}

  explicit DisableScalingGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~DisableScalingGroupRequest() = default;
};
class DisableScalingGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableScalingGroupResponseBody() {}

  explicit DisableScalingGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableScalingGroupResponseBody() = default;
};
class DisableScalingGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableScalingGroupResponseBody> body{};

  DisableScalingGroupResponse() {}

  explicit DisableScalingGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableScalingGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableScalingGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DisableScalingGroupResponse() = default;
};
class EnableAlarmRequest : public Darabonba::Model {
public:
  shared_ptr<string> alarmTaskId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};

  EnableAlarmRequest() {}

  explicit EnableAlarmRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmTaskId) {
      res["AlarmTaskId"] = boost::any(*alarmTaskId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmTaskId") != m.end() && !m["AlarmTaskId"].empty()) {
      alarmTaskId = make_shared<string>(boost::any_cast<string>(m["AlarmTaskId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
  }


  virtual ~EnableAlarmRequest() = default;
};
class EnableAlarmResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableAlarmResponseBody() {}

  explicit EnableAlarmResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableAlarmResponseBody() = default;
};
class EnableAlarmResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableAlarmResponseBody> body{};

  EnableAlarmResponse() {}

  explicit EnableAlarmResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableAlarmResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableAlarmResponseBody>(model1);
      }
    }
  }


  virtual ~EnableAlarmResponse() = default;
};
class EnableScalingGroupRequestLaunchTemplateOverrides : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<long> weightedCapacity{};

  EnableScalingGroupRequestLaunchTemplateOverrides() {}

  explicit EnableScalingGroupRequestLaunchTemplateOverrides(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (weightedCapacity) {
      res["WeightedCapacity"] = boost::any(*weightedCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("WeightedCapacity") != m.end() && !m["WeightedCapacity"].empty()) {
      weightedCapacity = make_shared<long>(boost::any_cast<long>(m["WeightedCapacity"]));
    }
  }


  virtual ~EnableScalingGroupRequestLaunchTemplateOverrides() = default;
};
class EnableScalingGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> activeScalingConfigurationId{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> launchTemplateId{};
  shared_ptr<vector<EnableScalingGroupRequestLaunchTemplateOverrides>> launchTemplateOverrides{};
  shared_ptr<string> launchTemplateVersion{};
  shared_ptr<vector<long>> loadBalancerWeights{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scalingGroupId{};

  EnableScalingGroupRequest() {}

  explicit EnableScalingGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeScalingConfigurationId) {
      res["ActiveScalingConfigurationId"] = boost::any(*activeScalingConfigurationId);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (launchTemplateId) {
      res["LaunchTemplateId"] = boost::any(*launchTemplateId);
    }
    if (launchTemplateOverrides) {
      vector<boost::any> temp1;
      for(auto item1:*launchTemplateOverrides){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LaunchTemplateOverrides"] = boost::any(temp1);
    }
    if (launchTemplateVersion) {
      res["LaunchTemplateVersion"] = boost::any(*launchTemplateVersion);
    }
    if (loadBalancerWeights) {
      res["LoadBalancerWeights"] = boost::any(*loadBalancerWeights);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveScalingConfigurationId") != m.end() && !m["ActiveScalingConfigurationId"].empty()) {
      activeScalingConfigurationId = make_shared<string>(boost::any_cast<string>(m["ActiveScalingConfigurationId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LaunchTemplateId") != m.end() && !m["LaunchTemplateId"].empty()) {
      launchTemplateId = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateId"]));
    }
    if (m.find("LaunchTemplateOverrides") != m.end() && !m["LaunchTemplateOverrides"].empty()) {
      if (typeid(vector<boost::any>) == m["LaunchTemplateOverrides"].type()) {
        vector<EnableScalingGroupRequestLaunchTemplateOverrides> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LaunchTemplateOverrides"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EnableScalingGroupRequestLaunchTemplateOverrides model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        launchTemplateOverrides = make_shared<vector<EnableScalingGroupRequestLaunchTemplateOverrides>>(expect1);
      }
    }
    if (m.find("LaunchTemplateVersion") != m.end() && !m["LaunchTemplateVersion"].empty()) {
      launchTemplateVersion = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateVersion"]));
    }
    if (m.find("LoadBalancerWeights") != m.end() && !m["LoadBalancerWeights"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["LoadBalancerWeights"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LoadBalancerWeights"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      loadBalancerWeights = make_shared<vector<long>>(toVec1);
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~EnableScalingGroupRequest() = default;
};
class EnableScalingGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableScalingGroupResponseBody() {}

  explicit EnableScalingGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableScalingGroupResponseBody() = default;
};
class EnableScalingGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableScalingGroupResponseBody> body{};

  EnableScalingGroupResponse() {}

  explicit EnableScalingGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableScalingGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableScalingGroupResponseBody>(model1);
      }
    }
  }


  virtual ~EnableScalingGroupResponse() = default;
};
class EnterStandbyRequest : public Darabonba::Model {
public:
  shared_ptr<bool> async{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};

  EnterStandbyRequest() {}

  explicit EnterStandbyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~EnterStandbyRequest() = default;
};
class EnterStandbyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> scalingActivityId{};

  EnterStandbyResponseBody() {}

  explicit EnterStandbyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingActivityId) {
      res["ScalingActivityId"] = boost::any(*scalingActivityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingActivityId") != m.end() && !m["ScalingActivityId"].empty()) {
      scalingActivityId = make_shared<string>(boost::any_cast<string>(m["ScalingActivityId"]));
    }
  }


  virtual ~EnterStandbyResponseBody() = default;
};
class EnterStandbyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnterStandbyResponseBody> body{};

  EnterStandbyResponse() {}

  explicit EnterStandbyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnterStandbyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnterStandbyResponseBody>(model1);
      }
    }
  }


  virtual ~EnterStandbyResponse() = default;
};
class ExecuteScalingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<double> breachThreshold{};
  shared_ptr<string> clientToken{};
  shared_ptr<double> metricValue{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scalingRuleAri{};

  ExecuteScalingRuleRequest() {}

  explicit ExecuteScalingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breachThreshold) {
      res["BreachThreshold"] = boost::any(*breachThreshold);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (metricValue) {
      res["MetricValue"] = boost::any(*metricValue);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingRuleAri) {
      res["ScalingRuleAri"] = boost::any(*scalingRuleAri);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreachThreshold") != m.end() && !m["BreachThreshold"].empty()) {
      breachThreshold = make_shared<double>(boost::any_cast<double>(m["BreachThreshold"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("MetricValue") != m.end() && !m["MetricValue"].empty()) {
      metricValue = make_shared<double>(boost::any_cast<double>(m["MetricValue"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingRuleAri") != m.end() && !m["ScalingRuleAri"].empty()) {
      scalingRuleAri = make_shared<string>(boost::any_cast<string>(m["ScalingRuleAri"]));
    }
  }


  virtual ~ExecuteScalingRuleRequest() = default;
};
class ExecuteScalingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> scalingActivityId{};

  ExecuteScalingRuleResponseBody() {}

  explicit ExecuteScalingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingActivityId) {
      res["ScalingActivityId"] = boost::any(*scalingActivityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingActivityId") != m.end() && !m["ScalingActivityId"].empty()) {
      scalingActivityId = make_shared<string>(boost::any_cast<string>(m["ScalingActivityId"]));
    }
  }


  virtual ~ExecuteScalingRuleResponseBody() = default;
};
class ExecuteScalingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExecuteScalingRuleResponseBody> body{};

  ExecuteScalingRuleResponse() {}

  explicit ExecuteScalingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExecuteScalingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExecuteScalingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ExecuteScalingRuleResponse() = default;
};
class ExitStandbyRequest : public Darabonba::Model {
public:
  shared_ptr<bool> async{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};

  ExitStandbyRequest() {}

  explicit ExitStandbyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~ExitStandbyRequest() = default;
};
class ExitStandbyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> scalingActivityId{};

  ExitStandbyResponseBody() {}

  explicit ExitStandbyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingActivityId) {
      res["ScalingActivityId"] = boost::any(*scalingActivityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingActivityId") != m.end() && !m["ScalingActivityId"].empty()) {
      scalingActivityId = make_shared<string>(boost::any_cast<string>(m["ScalingActivityId"]));
    }
  }


  virtual ~ExitStandbyResponseBody() = default;
};
class ExitStandbyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExitStandbyResponseBody> body{};

  ExitStandbyResponse() {}

  explicit ExitStandbyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExitStandbyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExitStandbyResponseBody>(model1);
      }
    }
  }


  virtual ~ExitStandbyResponse() = default;
};
class ListTagKeysRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceType{};

  ListTagKeysRequest() {}

  explicit ListTagKeysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ListTagKeysRequest() = default;
};
class ListTagKeysResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> keys{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};

  ListTagKeysResponseBody() {}

  explicit ListTagKeysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keys) {
      res["Keys"] = boost::any(*keys);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keys") != m.end() && !m["Keys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Keys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Keys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      keys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListTagKeysResponseBody() = default;
};
class ListTagKeysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagKeysResponseBody> body{};

  ListTagKeysResponse() {}

  explicit ListTagKeysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagKeysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagKeysResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagKeysResponse() = default;
};
class ListTagResourcesRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTagResourcesRequestTags() {}

  explicit ListTagResourcesRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTagResourcesRequestTags() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceIds{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<ListTagResourcesRequestTags>> tags{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListTagResourcesRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListTagResourcesRequestTags>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<bool> propagate{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propagate) {
      res["Propagate"] = boost::any(*propagate);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Propagate") != m.end() && !m["Propagate"].empty()) {
      propagate = make_shared<bool>(boost::any_cast<bool>(m["Propagate"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListTagResourcesResponseBodyTagResources>> tagResources{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      vector<boost::any> temp1;
      for(auto item1:*tagResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResources"].type()) {
        vector<ListTagResourcesResponseBodyTagResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResources = make_shared<vector<ListTagResourcesResponseBodyTagResources>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ListTagValuesRequest : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceType{};

  ListTagValuesRequest() {}

  explicit ListTagValuesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ListTagValuesRequest() = default;
};
class ListTagValuesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> values{};

  ListTagValuesResponseBody() {}

  explicit ListTagValuesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListTagValuesResponseBody() = default;
};
class ListTagValuesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagValuesResponseBody> body{};

  ListTagValuesResponse() {}

  explicit ListTagValuesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagValuesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagValuesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagValuesResponse() = default;
};
class ModifyAlarmRequestDimensions : public Darabonba::Model {
public:
  shared_ptr<string> dimensionKey{};
  shared_ptr<string> dimensionValue{};

  ModifyAlarmRequestDimensions() {}

  explicit ModifyAlarmRequestDimensions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimensionKey) {
      res["DimensionKey"] = boost::any(*dimensionKey);
    }
    if (dimensionValue) {
      res["DimensionValue"] = boost::any(*dimensionValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DimensionKey") != m.end() && !m["DimensionKey"].empty()) {
      dimensionKey = make_shared<string>(boost::any_cast<string>(m["DimensionKey"]));
    }
    if (m.find("DimensionValue") != m.end() && !m["DimensionValue"].empty()) {
      dimensionValue = make_shared<string>(boost::any_cast<string>(m["DimensionValue"]));
    }
  }


  virtual ~ModifyAlarmRequestDimensions() = default;
};
class ModifyAlarmRequestExpressions : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> metricName{};
  shared_ptr<long> period{};
  shared_ptr<string> statistics{};
  shared_ptr<double> threshold{};

  ModifyAlarmRequestExpressions() {}

  explicit ModifyAlarmRequestExpressions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
  }


  virtual ~ModifyAlarmRequestExpressions() = default;
};
class ModifyAlarmRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> alarmActions{};
  shared_ptr<string> alarmTaskId{};
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> description{};
  shared_ptr<vector<ModifyAlarmRequestDimensions>> dimensions{};
  shared_ptr<string> effective{};
  shared_ptr<long> evaluationCount{};
  shared_ptr<vector<ModifyAlarmRequestExpressions>> expressions{};
  shared_ptr<string> expressionsLogicOperator{};
  shared_ptr<long> groupId{};
  shared_ptr<string> metricName{};
  shared_ptr<string> metricType{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> period{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> statistics{};
  shared_ptr<double> threshold{};

  ModifyAlarmRequest() {}

  explicit ModifyAlarmRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmActions) {
      res["AlarmActions"] = boost::any(*alarmActions);
    }
    if (alarmTaskId) {
      res["AlarmTaskId"] = boost::any(*alarmTaskId);
    }
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dimensions) {
      vector<boost::any> temp1;
      for(auto item1:*dimensions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dimensions"] = boost::any(temp1);
    }
    if (effective) {
      res["Effective"] = boost::any(*effective);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (expressions) {
      vector<boost::any> temp1;
      for(auto item1:*expressions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Expressions"] = boost::any(temp1);
    }
    if (expressionsLogicOperator) {
      res["ExpressionsLogicOperator"] = boost::any(*expressionsLogicOperator);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmActions") != m.end() && !m["AlarmActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AlarmActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AlarmActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      alarmActions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AlarmTaskId") != m.end() && !m["AlarmTaskId"].empty()) {
      alarmTaskId = make_shared<string>(boost::any_cast<string>(m["AlarmTaskId"]));
    }
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      if (typeid(vector<boost::any>) == m["Dimensions"].type()) {
        vector<ModifyAlarmRequestDimensions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dimensions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyAlarmRequestDimensions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dimensions = make_shared<vector<ModifyAlarmRequestDimensions>>(expect1);
      }
    }
    if (m.find("Effective") != m.end() && !m["Effective"].empty()) {
      effective = make_shared<string>(boost::any_cast<string>(m["Effective"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("Expressions") != m.end() && !m["Expressions"].empty()) {
      if (typeid(vector<boost::any>) == m["Expressions"].type()) {
        vector<ModifyAlarmRequestExpressions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Expressions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyAlarmRequestExpressions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        expressions = make_shared<vector<ModifyAlarmRequestExpressions>>(expect1);
      }
    }
    if (m.find("ExpressionsLogicOperator") != m.end() && !m["ExpressionsLogicOperator"].empty()) {
      expressionsLogicOperator = make_shared<string>(boost::any_cast<string>(m["ExpressionsLogicOperator"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
  }


  virtual ~ModifyAlarmRequest() = default;
};
class ModifyAlarmResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> alarmTaskId{};
  shared_ptr<string> requestId{};

  ModifyAlarmResponseBody() {}

  explicit ModifyAlarmResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmTaskId) {
      res["AlarmTaskId"] = boost::any(*alarmTaskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmTaskId") != m.end() && !m["AlarmTaskId"].empty()) {
      alarmTaskId = make_shared<string>(boost::any_cast<string>(m["AlarmTaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyAlarmResponseBody() = default;
};
class ModifyAlarmResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyAlarmResponseBody> body{};

  ModifyAlarmResponse() {}

  explicit ModifyAlarmResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAlarmResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAlarmResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAlarmResponse() = default;
};
class ModifyAlertConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<vector<string>> scaleStatuses{};
  shared_ptr<string> scalingGroupId{};

  ModifyAlertConfigurationRequest() {}

  explicit ModifyAlertConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scaleStatuses) {
      res["ScaleStatuses"] = boost::any(*scaleStatuses);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScaleStatuses") != m.end() && !m["ScaleStatuses"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScaleStatuses"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScaleStatuses"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scaleStatuses = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~ModifyAlertConfigurationRequest() = default;
};
class ModifyAlertConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyAlertConfigurationResponseBody() {}

  explicit ModifyAlertConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyAlertConfigurationResponseBody() = default;
};
class ModifyAlertConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyAlertConfigurationResponseBody> body{};

  ModifyAlertConfigurationResponse() {}

  explicit ModifyAlertConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAlertConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAlertConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAlertConfigurationResponse() = default;
};
class ModifyEciScalingConfigurationRequestAcrRegistryInfos : public Darabonba::Model {
public:
  shared_ptr<vector<string>> domains{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> regionId{};

  ModifyEciScalingConfigurationRequestAcrRegistryInfos() {}

  explicit ModifyEciScalingConfigurationRequestAcrRegistryInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = boost::any(*domains);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Domains"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domains = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestAcrRegistryInfos() = default;
};
class ModifyEciScalingConfigurationRequestContainersLivenessProbeExec : public Darabonba::Model {
public:
  shared_ptr<vector<string>> commands{};

  ModifyEciScalingConfigurationRequestContainersLivenessProbeExec() {}

  explicit ModifyEciScalingConfigurationRequestContainersLivenessProbeExec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commands) {
      res["Commands"] = boost::any(*commands);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Commands") != m.end() && !m["Commands"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Commands"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Commands"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      commands = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestContainersLivenessProbeExec() = default;
};
class ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet : public Darabonba::Model {
public:
  shared_ptr<string> path{};
  shared_ptr<long> port{};
  shared_ptr<string> scheme{};

  ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet() {}

  explicit ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (scheme) {
      res["Scheme"] = boost::any(*scheme);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Scheme") != m.end() && !m["Scheme"].empty()) {
      scheme = make_shared<string>(boost::any_cast<string>(m["Scheme"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet() = default;
};
class ModifyEciScalingConfigurationRequestContainersLivenessProbeTcpSocket : public Darabonba::Model {
public:
  shared_ptr<long> port{};

  ModifyEciScalingConfigurationRequestContainersLivenessProbeTcpSocket() {}

  explicit ModifyEciScalingConfigurationRequestContainersLivenessProbeTcpSocket(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestContainersLivenessProbeTcpSocket() = default;
};
class ModifyEciScalingConfigurationRequestContainersLivenessProbe : public Darabonba::Model {
public:
  shared_ptr<ModifyEciScalingConfigurationRequestContainersLivenessProbeExec> exec{};
  shared_ptr<long> failureThreshold{};
  shared_ptr<ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet> httpGet{};
  shared_ptr<long> initialDelaySeconds{};
  shared_ptr<long> periodSeconds{};
  shared_ptr<long> successThreshold{};
  shared_ptr<ModifyEciScalingConfigurationRequestContainersLivenessProbeTcpSocket> tcpSocket{};
  shared_ptr<long> timeoutSeconds{};

  ModifyEciScalingConfigurationRequestContainersLivenessProbe() {}

  explicit ModifyEciScalingConfigurationRequestContainersLivenessProbe(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exec) {
      res["Exec"] = exec ? boost::any(exec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failureThreshold) {
      res["FailureThreshold"] = boost::any(*failureThreshold);
    }
    if (httpGet) {
      res["HttpGet"] = httpGet ? boost::any(httpGet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (initialDelaySeconds) {
      res["InitialDelaySeconds"] = boost::any(*initialDelaySeconds);
    }
    if (periodSeconds) {
      res["PeriodSeconds"] = boost::any(*periodSeconds);
    }
    if (successThreshold) {
      res["SuccessThreshold"] = boost::any(*successThreshold);
    }
    if (tcpSocket) {
      res["TcpSocket"] = tcpSocket ? boost::any(tcpSocket->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Exec") != m.end() && !m["Exec"].empty()) {
      if (typeid(map<string, boost::any>) == m["Exec"].type()) {
        ModifyEciScalingConfigurationRequestContainersLivenessProbeExec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Exec"]));
        exec = make_shared<ModifyEciScalingConfigurationRequestContainersLivenessProbeExec>(model1);
      }
    }
    if (m.find("FailureThreshold") != m.end() && !m["FailureThreshold"].empty()) {
      failureThreshold = make_shared<long>(boost::any_cast<long>(m["FailureThreshold"]));
    }
    if (m.find("HttpGet") != m.end() && !m["HttpGet"].empty()) {
      if (typeid(map<string, boost::any>) == m["HttpGet"].type()) {
        ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HttpGet"]));
        httpGet = make_shared<ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet>(model1);
      }
    }
    if (m.find("InitialDelaySeconds") != m.end() && !m["InitialDelaySeconds"].empty()) {
      initialDelaySeconds = make_shared<long>(boost::any_cast<long>(m["InitialDelaySeconds"]));
    }
    if (m.find("PeriodSeconds") != m.end() && !m["PeriodSeconds"].empty()) {
      periodSeconds = make_shared<long>(boost::any_cast<long>(m["PeriodSeconds"]));
    }
    if (m.find("SuccessThreshold") != m.end() && !m["SuccessThreshold"].empty()) {
      successThreshold = make_shared<long>(boost::any_cast<long>(m["SuccessThreshold"]));
    }
    if (m.find("TcpSocket") != m.end() && !m["TcpSocket"].empty()) {
      if (typeid(map<string, boost::any>) == m["TcpSocket"].type()) {
        ModifyEciScalingConfigurationRequestContainersLivenessProbeTcpSocket model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TcpSocket"]));
        tcpSocket = make_shared<ModifyEciScalingConfigurationRequestContainersLivenessProbeTcpSocket>(model1);
      }
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestContainersLivenessProbe() = default;
};
class ModifyEciScalingConfigurationRequestContainersReadinessProbeExec : public Darabonba::Model {
public:
  shared_ptr<vector<string>> commands{};

  ModifyEciScalingConfigurationRequestContainersReadinessProbeExec() {}

  explicit ModifyEciScalingConfigurationRequestContainersReadinessProbeExec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commands) {
      res["Commands"] = boost::any(*commands);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Commands") != m.end() && !m["Commands"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Commands"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Commands"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      commands = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestContainersReadinessProbeExec() = default;
};
class ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet : public Darabonba::Model {
public:
  shared_ptr<string> path{};
  shared_ptr<long> port{};
  shared_ptr<string> scheme{};

  ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet() {}

  explicit ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (scheme) {
      res["Scheme"] = boost::any(*scheme);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Scheme") != m.end() && !m["Scheme"].empty()) {
      scheme = make_shared<string>(boost::any_cast<string>(m["Scheme"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet() = default;
};
class ModifyEciScalingConfigurationRequestContainersReadinessProbeTcpSocket : public Darabonba::Model {
public:
  shared_ptr<long> port{};

  ModifyEciScalingConfigurationRequestContainersReadinessProbeTcpSocket() {}

  explicit ModifyEciScalingConfigurationRequestContainersReadinessProbeTcpSocket(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestContainersReadinessProbeTcpSocket() = default;
};
class ModifyEciScalingConfigurationRequestContainersReadinessProbe : public Darabonba::Model {
public:
  shared_ptr<ModifyEciScalingConfigurationRequestContainersReadinessProbeExec> exec{};
  shared_ptr<long> failureThreshold{};
  shared_ptr<ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet> httpGet{};
  shared_ptr<long> initialDelaySeconds{};
  shared_ptr<long> periodSeconds{};
  shared_ptr<long> successThreshold{};
  shared_ptr<ModifyEciScalingConfigurationRequestContainersReadinessProbeTcpSocket> tcpSocket{};
  shared_ptr<long> timeoutSeconds{};

  ModifyEciScalingConfigurationRequestContainersReadinessProbe() {}

  explicit ModifyEciScalingConfigurationRequestContainersReadinessProbe(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exec) {
      res["Exec"] = exec ? boost::any(exec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failureThreshold) {
      res["FailureThreshold"] = boost::any(*failureThreshold);
    }
    if (httpGet) {
      res["HttpGet"] = httpGet ? boost::any(httpGet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (initialDelaySeconds) {
      res["InitialDelaySeconds"] = boost::any(*initialDelaySeconds);
    }
    if (periodSeconds) {
      res["PeriodSeconds"] = boost::any(*periodSeconds);
    }
    if (successThreshold) {
      res["SuccessThreshold"] = boost::any(*successThreshold);
    }
    if (tcpSocket) {
      res["TcpSocket"] = tcpSocket ? boost::any(tcpSocket->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Exec") != m.end() && !m["Exec"].empty()) {
      if (typeid(map<string, boost::any>) == m["Exec"].type()) {
        ModifyEciScalingConfigurationRequestContainersReadinessProbeExec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Exec"]));
        exec = make_shared<ModifyEciScalingConfigurationRequestContainersReadinessProbeExec>(model1);
      }
    }
    if (m.find("FailureThreshold") != m.end() && !m["FailureThreshold"].empty()) {
      failureThreshold = make_shared<long>(boost::any_cast<long>(m["FailureThreshold"]));
    }
    if (m.find("HttpGet") != m.end() && !m["HttpGet"].empty()) {
      if (typeid(map<string, boost::any>) == m["HttpGet"].type()) {
        ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HttpGet"]));
        httpGet = make_shared<ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet>(model1);
      }
    }
    if (m.find("InitialDelaySeconds") != m.end() && !m["InitialDelaySeconds"].empty()) {
      initialDelaySeconds = make_shared<long>(boost::any_cast<long>(m["InitialDelaySeconds"]));
    }
    if (m.find("PeriodSeconds") != m.end() && !m["PeriodSeconds"].empty()) {
      periodSeconds = make_shared<long>(boost::any_cast<long>(m["PeriodSeconds"]));
    }
    if (m.find("SuccessThreshold") != m.end() && !m["SuccessThreshold"].empty()) {
      successThreshold = make_shared<long>(boost::any_cast<long>(m["SuccessThreshold"]));
    }
    if (m.find("TcpSocket") != m.end() && !m["TcpSocket"].empty()) {
      if (typeid(map<string, boost::any>) == m["TcpSocket"].type()) {
        ModifyEciScalingConfigurationRequestContainersReadinessProbeTcpSocket model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TcpSocket"]));
        tcpSocket = make_shared<ModifyEciScalingConfigurationRequestContainersReadinessProbeTcpSocket>(model1);
      }
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestContainersReadinessProbe() = default;
};
class ModifyEciScalingConfigurationRequestContainersSecurityContextCapability : public Darabonba::Model {
public:
  shared_ptr<vector<string>> adds{};

  ModifyEciScalingConfigurationRequestContainersSecurityContextCapability() {}

  explicit ModifyEciScalingConfigurationRequestContainersSecurityContextCapability(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adds) {
      res["Adds"] = boost::any(*adds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Adds") != m.end() && !m["Adds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Adds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Adds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      adds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestContainersSecurityContextCapability() = default;
};
class ModifyEciScalingConfigurationRequestContainersSecurityContext : public Darabonba::Model {
public:
  shared_ptr<ModifyEciScalingConfigurationRequestContainersSecurityContextCapability> capability{};
  shared_ptr<bool> readOnlyRootFilesystem{};
  shared_ptr<long> runAsUser{};

  ModifyEciScalingConfigurationRequestContainersSecurityContext() {}

  explicit ModifyEciScalingConfigurationRequestContainersSecurityContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capability) {
      res["Capability"] = capability ? boost::any(capability->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (readOnlyRootFilesystem) {
      res["ReadOnlyRootFilesystem"] = boost::any(*readOnlyRootFilesystem);
    }
    if (runAsUser) {
      res["RunAsUser"] = boost::any(*runAsUser);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Capability") != m.end() && !m["Capability"].empty()) {
      if (typeid(map<string, boost::any>) == m["Capability"].type()) {
        ModifyEciScalingConfigurationRequestContainersSecurityContextCapability model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Capability"]));
        capability = make_shared<ModifyEciScalingConfigurationRequestContainersSecurityContextCapability>(model1);
      }
    }
    if (m.find("ReadOnlyRootFilesystem") != m.end() && !m["ReadOnlyRootFilesystem"].empty()) {
      readOnlyRootFilesystem = make_shared<bool>(boost::any_cast<bool>(m["ReadOnlyRootFilesystem"]));
    }
    if (m.find("RunAsUser") != m.end() && !m["RunAsUser"].empty()) {
      runAsUser = make_shared<long>(boost::any_cast<long>(m["RunAsUser"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestContainersSecurityContext() = default;
};
class ModifyEciScalingConfigurationRequestContainersEnvironmentVarsFieldRef : public Darabonba::Model {
public:
  shared_ptr<string> fieldPath{};

  ModifyEciScalingConfigurationRequestContainersEnvironmentVarsFieldRef() {}

  explicit ModifyEciScalingConfigurationRequestContainersEnvironmentVarsFieldRef(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldPath) {
      res["FieldPath"] = boost::any(*fieldPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldPath") != m.end() && !m["FieldPath"].empty()) {
      fieldPath = make_shared<string>(boost::any_cast<string>(m["FieldPath"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestContainersEnvironmentVarsFieldRef() = default;
};
class ModifyEciScalingConfigurationRequestContainersEnvironmentVars : public Darabonba::Model {
public:
  shared_ptr<ModifyEciScalingConfigurationRequestContainersEnvironmentVarsFieldRef> fieldRef{};
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ModifyEciScalingConfigurationRequestContainersEnvironmentVars() {}

  explicit ModifyEciScalingConfigurationRequestContainersEnvironmentVars(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldRef) {
      res["FieldRef"] = fieldRef ? boost::any(fieldRef->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldRef") != m.end() && !m["FieldRef"].empty()) {
      if (typeid(map<string, boost::any>) == m["FieldRef"].type()) {
        ModifyEciScalingConfigurationRequestContainersEnvironmentVarsFieldRef model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FieldRef"]));
        fieldRef = make_shared<ModifyEciScalingConfigurationRequestContainersEnvironmentVarsFieldRef>(model1);
      }
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestContainersEnvironmentVars() = default;
};
class ModifyEciScalingConfigurationRequestContainersPorts : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> protocol{};

  ModifyEciScalingConfigurationRequestContainersPorts() {}

  explicit ModifyEciScalingConfigurationRequestContainersPorts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestContainersPorts() = default;
};
class ModifyEciScalingConfigurationRequestContainersVolumeMounts : public Darabonba::Model {
public:
  shared_ptr<string> mountPath{};
  shared_ptr<string> mountPropagation{};
  shared_ptr<string> name{};
  shared_ptr<bool> readOnly{};
  shared_ptr<string> subPath{};

  ModifyEciScalingConfigurationRequestContainersVolumeMounts() {}

  explicit ModifyEciScalingConfigurationRequestContainersVolumeMounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountPath) {
      res["MountPath"] = boost::any(*mountPath);
    }
    if (mountPropagation) {
      res["MountPropagation"] = boost::any(*mountPropagation);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    if (subPath) {
      res["SubPath"] = boost::any(*subPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MountPath") != m.end() && !m["MountPath"].empty()) {
      mountPath = make_shared<string>(boost::any_cast<string>(m["MountPath"]));
    }
    if (m.find("MountPropagation") != m.end() && !m["MountPropagation"].empty()) {
      mountPropagation = make_shared<string>(boost::any_cast<string>(m["MountPropagation"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
    if (m.find("SubPath") != m.end() && !m["SubPath"].empty()) {
      subPath = make_shared<string>(boost::any_cast<string>(m["SubPath"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestContainersVolumeMounts() = default;
};
class ModifyEciScalingConfigurationRequestContainers : public Darabonba::Model {
public:
  shared_ptr<ModifyEciScalingConfigurationRequestContainersLivenessProbe> livenessProbe{};
  shared_ptr<ModifyEciScalingConfigurationRequestContainersReadinessProbe> readinessProbe{};
  shared_ptr<ModifyEciScalingConfigurationRequestContainersSecurityContext> securityContext{};
  shared_ptr<vector<string>> args{};
  shared_ptr<vector<string>> commands{};
  shared_ptr<double> cpu{};
  shared_ptr<vector<ModifyEciScalingConfigurationRequestContainersEnvironmentVars>> environmentVars{};
  shared_ptr<long> gpu{};
  shared_ptr<string> image{};
  shared_ptr<string> imagePullPolicy{};
  shared_ptr<vector<string>> lifecyclePostStartHandlerExecs{};
  shared_ptr<string> lifecyclePostStartHandlerHttpGetHost{};
  shared_ptr<string> lifecyclePostStartHandlerHttpGetPath{};
  shared_ptr<long> lifecyclePostStartHandlerHttpGetPort{};
  shared_ptr<string> lifecyclePostStartHandlerHttpGetScheme{};
  shared_ptr<string> lifecyclePostStartHandlerTcpSocketHost{};
  shared_ptr<long> lifecyclePostStartHandlerTcpSocketPort{};
  shared_ptr<vector<string>> lifecyclePreStopHandlerExecs{};
  shared_ptr<string> lifecyclePreStopHandlerHttpGetHost{};
  shared_ptr<string> lifecyclePreStopHandlerHttpGetPath{};
  shared_ptr<long> lifecyclePreStopHandlerHttpGetPort{};
  shared_ptr<string> lifecyclePreStopHandlerHttpGetScheme{};
  shared_ptr<string> lifecyclePreStopHandlerTcpSocketHost{};
  shared_ptr<long> lifecyclePreStopHandlerTcpSocketPort{};
  shared_ptr<double> memory{};
  shared_ptr<string> name{};
  shared_ptr<vector<ModifyEciScalingConfigurationRequestContainersPorts>> ports{};
  shared_ptr<bool> stdin{};
  shared_ptr<bool> stdinOnce{};
  shared_ptr<bool> tty{};
  shared_ptr<vector<ModifyEciScalingConfigurationRequestContainersVolumeMounts>> volumeMounts{};
  shared_ptr<string> workingDir{};

  ModifyEciScalingConfigurationRequestContainers() {}

  explicit ModifyEciScalingConfigurationRequestContainers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (livenessProbe) {
      res["LivenessProbe"] = livenessProbe ? boost::any(livenessProbe->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (readinessProbe) {
      res["ReadinessProbe"] = readinessProbe ? boost::any(readinessProbe->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (securityContext) {
      res["SecurityContext"] = securityContext ? boost::any(securityContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (args) {
      res["Args"] = boost::any(*args);
    }
    if (commands) {
      res["Commands"] = boost::any(*commands);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (environmentVars) {
      vector<boost::any> temp1;
      for(auto item1:*environmentVars){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnvironmentVars"] = boost::any(temp1);
    }
    if (gpu) {
      res["Gpu"] = boost::any(*gpu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (imagePullPolicy) {
      res["ImagePullPolicy"] = boost::any(*imagePullPolicy);
    }
    if (lifecyclePostStartHandlerExecs) {
      res["LifecyclePostStartHandlerExecs"] = boost::any(*lifecyclePostStartHandlerExecs);
    }
    if (lifecyclePostStartHandlerHttpGetHost) {
      res["LifecyclePostStartHandlerHttpGetHost"] = boost::any(*lifecyclePostStartHandlerHttpGetHost);
    }
    if (lifecyclePostStartHandlerHttpGetPath) {
      res["LifecyclePostStartHandlerHttpGetPath"] = boost::any(*lifecyclePostStartHandlerHttpGetPath);
    }
    if (lifecyclePostStartHandlerHttpGetPort) {
      res["LifecyclePostStartHandlerHttpGetPort"] = boost::any(*lifecyclePostStartHandlerHttpGetPort);
    }
    if (lifecyclePostStartHandlerHttpGetScheme) {
      res["LifecyclePostStartHandlerHttpGetScheme"] = boost::any(*lifecyclePostStartHandlerHttpGetScheme);
    }
    if (lifecyclePostStartHandlerTcpSocketHost) {
      res["LifecyclePostStartHandlerTcpSocketHost"] = boost::any(*lifecyclePostStartHandlerTcpSocketHost);
    }
    if (lifecyclePostStartHandlerTcpSocketPort) {
      res["LifecyclePostStartHandlerTcpSocketPort"] = boost::any(*lifecyclePostStartHandlerTcpSocketPort);
    }
    if (lifecyclePreStopHandlerExecs) {
      res["LifecyclePreStopHandlerExecs"] = boost::any(*lifecyclePreStopHandlerExecs);
    }
    if (lifecyclePreStopHandlerHttpGetHost) {
      res["LifecyclePreStopHandlerHttpGetHost"] = boost::any(*lifecyclePreStopHandlerHttpGetHost);
    }
    if (lifecyclePreStopHandlerHttpGetPath) {
      res["LifecyclePreStopHandlerHttpGetPath"] = boost::any(*lifecyclePreStopHandlerHttpGetPath);
    }
    if (lifecyclePreStopHandlerHttpGetPort) {
      res["LifecyclePreStopHandlerHttpGetPort"] = boost::any(*lifecyclePreStopHandlerHttpGetPort);
    }
    if (lifecyclePreStopHandlerHttpGetScheme) {
      res["LifecyclePreStopHandlerHttpGetScheme"] = boost::any(*lifecyclePreStopHandlerHttpGetScheme);
    }
    if (lifecyclePreStopHandlerTcpSocketHost) {
      res["LifecyclePreStopHandlerTcpSocketHost"] = boost::any(*lifecyclePreStopHandlerTcpSocketHost);
    }
    if (lifecyclePreStopHandlerTcpSocketPort) {
      res["LifecyclePreStopHandlerTcpSocketPort"] = boost::any(*lifecyclePreStopHandlerTcpSocketPort);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ports) {
      vector<boost::any> temp1;
      for(auto item1:*ports){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ports"] = boost::any(temp1);
    }
    if (stdin) {
      res["Stdin"] = boost::any(*stdin);
    }
    if (stdinOnce) {
      res["StdinOnce"] = boost::any(*stdinOnce);
    }
    if (tty) {
      res["Tty"] = boost::any(*tty);
    }
    if (volumeMounts) {
      vector<boost::any> temp1;
      for(auto item1:*volumeMounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VolumeMounts"] = boost::any(temp1);
    }
    if (workingDir) {
      res["WorkingDir"] = boost::any(*workingDir);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LivenessProbe") != m.end() && !m["LivenessProbe"].empty()) {
      if (typeid(map<string, boost::any>) == m["LivenessProbe"].type()) {
        ModifyEciScalingConfigurationRequestContainersLivenessProbe model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LivenessProbe"]));
        livenessProbe = make_shared<ModifyEciScalingConfigurationRequestContainersLivenessProbe>(model1);
      }
    }
    if (m.find("ReadinessProbe") != m.end() && !m["ReadinessProbe"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReadinessProbe"].type()) {
        ModifyEciScalingConfigurationRequestContainersReadinessProbe model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReadinessProbe"]));
        readinessProbe = make_shared<ModifyEciScalingConfigurationRequestContainersReadinessProbe>(model1);
      }
    }
    if (m.find("SecurityContext") != m.end() && !m["SecurityContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityContext"].type()) {
        ModifyEciScalingConfigurationRequestContainersSecurityContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityContext"]));
        securityContext = make_shared<ModifyEciScalingConfigurationRequestContainersSecurityContext>(model1);
      }
    }
    if (m.find("Args") != m.end() && !m["Args"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Args"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Args"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      args = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Commands") != m.end() && !m["Commands"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Commands"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Commands"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      commands = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<double>(boost::any_cast<double>(m["Cpu"]));
    }
    if (m.find("EnvironmentVars") != m.end() && !m["EnvironmentVars"].empty()) {
      if (typeid(vector<boost::any>) == m["EnvironmentVars"].type()) {
        vector<ModifyEciScalingConfigurationRequestContainersEnvironmentVars> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnvironmentVars"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyEciScalingConfigurationRequestContainersEnvironmentVars model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        environmentVars = make_shared<vector<ModifyEciScalingConfigurationRequestContainersEnvironmentVars>>(expect1);
      }
    }
    if (m.find("Gpu") != m.end() && !m["Gpu"].empty()) {
      gpu = make_shared<long>(boost::any_cast<long>(m["Gpu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ImagePullPolicy") != m.end() && !m["ImagePullPolicy"].empty()) {
      imagePullPolicy = make_shared<string>(boost::any_cast<string>(m["ImagePullPolicy"]));
    }
    if (m.find("LifecyclePostStartHandlerExecs") != m.end() && !m["LifecyclePostStartHandlerExecs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LifecyclePostStartHandlerExecs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LifecyclePostStartHandlerExecs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      lifecyclePostStartHandlerExecs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LifecyclePostStartHandlerHttpGetHost") != m.end() && !m["LifecyclePostStartHandlerHttpGetHost"].empty()) {
      lifecyclePostStartHandlerHttpGetHost = make_shared<string>(boost::any_cast<string>(m["LifecyclePostStartHandlerHttpGetHost"]));
    }
    if (m.find("LifecyclePostStartHandlerHttpGetPath") != m.end() && !m["LifecyclePostStartHandlerHttpGetPath"].empty()) {
      lifecyclePostStartHandlerHttpGetPath = make_shared<string>(boost::any_cast<string>(m["LifecyclePostStartHandlerHttpGetPath"]));
    }
    if (m.find("LifecyclePostStartHandlerHttpGetPort") != m.end() && !m["LifecyclePostStartHandlerHttpGetPort"].empty()) {
      lifecyclePostStartHandlerHttpGetPort = make_shared<long>(boost::any_cast<long>(m["LifecyclePostStartHandlerHttpGetPort"]));
    }
    if (m.find("LifecyclePostStartHandlerHttpGetScheme") != m.end() && !m["LifecyclePostStartHandlerHttpGetScheme"].empty()) {
      lifecyclePostStartHandlerHttpGetScheme = make_shared<string>(boost::any_cast<string>(m["LifecyclePostStartHandlerHttpGetScheme"]));
    }
    if (m.find("LifecyclePostStartHandlerTcpSocketHost") != m.end() && !m["LifecyclePostStartHandlerTcpSocketHost"].empty()) {
      lifecyclePostStartHandlerTcpSocketHost = make_shared<string>(boost::any_cast<string>(m["LifecyclePostStartHandlerTcpSocketHost"]));
    }
    if (m.find("LifecyclePostStartHandlerTcpSocketPort") != m.end() && !m["LifecyclePostStartHandlerTcpSocketPort"].empty()) {
      lifecyclePostStartHandlerTcpSocketPort = make_shared<long>(boost::any_cast<long>(m["LifecyclePostStartHandlerTcpSocketPort"]));
    }
    if (m.find("LifecyclePreStopHandlerExecs") != m.end() && !m["LifecyclePreStopHandlerExecs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LifecyclePreStopHandlerExecs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LifecyclePreStopHandlerExecs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      lifecyclePreStopHandlerExecs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LifecyclePreStopHandlerHttpGetHost") != m.end() && !m["LifecyclePreStopHandlerHttpGetHost"].empty()) {
      lifecyclePreStopHandlerHttpGetHost = make_shared<string>(boost::any_cast<string>(m["LifecyclePreStopHandlerHttpGetHost"]));
    }
    if (m.find("LifecyclePreStopHandlerHttpGetPath") != m.end() && !m["LifecyclePreStopHandlerHttpGetPath"].empty()) {
      lifecyclePreStopHandlerHttpGetPath = make_shared<string>(boost::any_cast<string>(m["LifecyclePreStopHandlerHttpGetPath"]));
    }
    if (m.find("LifecyclePreStopHandlerHttpGetPort") != m.end() && !m["LifecyclePreStopHandlerHttpGetPort"].empty()) {
      lifecyclePreStopHandlerHttpGetPort = make_shared<long>(boost::any_cast<long>(m["LifecyclePreStopHandlerHttpGetPort"]));
    }
    if (m.find("LifecyclePreStopHandlerHttpGetScheme") != m.end() && !m["LifecyclePreStopHandlerHttpGetScheme"].empty()) {
      lifecyclePreStopHandlerHttpGetScheme = make_shared<string>(boost::any_cast<string>(m["LifecyclePreStopHandlerHttpGetScheme"]));
    }
    if (m.find("LifecyclePreStopHandlerTcpSocketHost") != m.end() && !m["LifecyclePreStopHandlerTcpSocketHost"].empty()) {
      lifecyclePreStopHandlerTcpSocketHost = make_shared<string>(boost::any_cast<string>(m["LifecyclePreStopHandlerTcpSocketHost"]));
    }
    if (m.find("LifecyclePreStopHandlerTcpSocketPort") != m.end() && !m["LifecyclePreStopHandlerTcpSocketPort"].empty()) {
      lifecyclePreStopHandlerTcpSocketPort = make_shared<long>(boost::any_cast<long>(m["LifecyclePreStopHandlerTcpSocketPort"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Ports") != m.end() && !m["Ports"].empty()) {
      if (typeid(vector<boost::any>) == m["Ports"].type()) {
        vector<ModifyEciScalingConfigurationRequestContainersPorts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ports"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyEciScalingConfigurationRequestContainersPorts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ports = make_shared<vector<ModifyEciScalingConfigurationRequestContainersPorts>>(expect1);
      }
    }
    if (m.find("Stdin") != m.end() && !m["Stdin"].empty()) {
      stdin = make_shared<bool>(boost::any_cast<bool>(m["Stdin"]));
    }
    if (m.find("StdinOnce") != m.end() && !m["StdinOnce"].empty()) {
      stdinOnce = make_shared<bool>(boost::any_cast<bool>(m["StdinOnce"]));
    }
    if (m.find("Tty") != m.end() && !m["Tty"].empty()) {
      tty = make_shared<bool>(boost::any_cast<bool>(m["Tty"]));
    }
    if (m.find("VolumeMounts") != m.end() && !m["VolumeMounts"].empty()) {
      if (typeid(vector<boost::any>) == m["VolumeMounts"].type()) {
        vector<ModifyEciScalingConfigurationRequestContainersVolumeMounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VolumeMounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyEciScalingConfigurationRequestContainersVolumeMounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        volumeMounts = make_shared<vector<ModifyEciScalingConfigurationRequestContainersVolumeMounts>>(expect1);
      }
    }
    if (m.find("WorkingDir") != m.end() && !m["WorkingDir"].empty()) {
      workingDir = make_shared<string>(boost::any_cast<string>(m["WorkingDir"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestContainers() = default;
};
class ModifyEciScalingConfigurationRequestDnsConfigOptions : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  ModifyEciScalingConfigurationRequestDnsConfigOptions() {}

  explicit ModifyEciScalingConfigurationRequestDnsConfigOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestDnsConfigOptions() = default;
};
class ModifyEciScalingConfigurationRequestHostAliases : public Darabonba::Model {
public:
  shared_ptr<vector<string>> hostnames{};
  shared_ptr<string> ip{};

  ModifyEciScalingConfigurationRequestHostAliases() {}

  explicit ModifyEciScalingConfigurationRequestHostAliases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostnames) {
      res["Hostnames"] = boost::any(*hostnames);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Hostnames") != m.end() && !m["Hostnames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Hostnames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Hostnames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostnames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestHostAliases() = default;
};
class ModifyEciScalingConfigurationRequestImageRegistryCredentials : public Darabonba::Model {
public:
  shared_ptr<string> password{};
  shared_ptr<string> server{};
  shared_ptr<string> userName{};

  ModifyEciScalingConfigurationRequestImageRegistryCredentials() {}

  explicit ModifyEciScalingConfigurationRequestImageRegistryCredentials(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (server) {
      res["Server"] = boost::any(*server);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Server") != m.end() && !m["Server"].empty()) {
      server = make_shared<string>(boost::any_cast<string>(m["Server"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestImageRegistryCredentials() = default;
};
class ModifyEciScalingConfigurationRequestInitContainersSecurityContextCapability : public Darabonba::Model {
public:
  shared_ptr<vector<string>> adds{};

  ModifyEciScalingConfigurationRequestInitContainersSecurityContextCapability() {}

  explicit ModifyEciScalingConfigurationRequestInitContainersSecurityContextCapability(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adds) {
      res["Adds"] = boost::any(*adds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Adds") != m.end() && !m["Adds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Adds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Adds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      adds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestInitContainersSecurityContextCapability() = default;
};
class ModifyEciScalingConfigurationRequestInitContainersSecurityContext : public Darabonba::Model {
public:
  shared_ptr<ModifyEciScalingConfigurationRequestInitContainersSecurityContextCapability> capability{};
  shared_ptr<bool> readOnlyRootFilesystem{};
  shared_ptr<long> runAsUser{};

  ModifyEciScalingConfigurationRequestInitContainersSecurityContext() {}

  explicit ModifyEciScalingConfigurationRequestInitContainersSecurityContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capability) {
      res["Capability"] = capability ? boost::any(capability->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (readOnlyRootFilesystem) {
      res["ReadOnlyRootFilesystem"] = boost::any(*readOnlyRootFilesystem);
    }
    if (runAsUser) {
      res["RunAsUser"] = boost::any(*runAsUser);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Capability") != m.end() && !m["Capability"].empty()) {
      if (typeid(map<string, boost::any>) == m["Capability"].type()) {
        ModifyEciScalingConfigurationRequestInitContainersSecurityContextCapability model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Capability"]));
        capability = make_shared<ModifyEciScalingConfigurationRequestInitContainersSecurityContextCapability>(model1);
      }
    }
    if (m.find("ReadOnlyRootFilesystem") != m.end() && !m["ReadOnlyRootFilesystem"].empty()) {
      readOnlyRootFilesystem = make_shared<bool>(boost::any_cast<bool>(m["ReadOnlyRootFilesystem"]));
    }
    if (m.find("RunAsUser") != m.end() && !m["RunAsUser"].empty()) {
      runAsUser = make_shared<long>(boost::any_cast<long>(m["RunAsUser"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestInitContainersSecurityContext() = default;
};
class ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVarsFieldRef : public Darabonba::Model {
public:
  shared_ptr<string> fieldPath{};

  ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVarsFieldRef() {}

  explicit ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVarsFieldRef(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldPath) {
      res["FieldPath"] = boost::any(*fieldPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldPath") != m.end() && !m["FieldPath"].empty()) {
      fieldPath = make_shared<string>(boost::any_cast<string>(m["FieldPath"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVarsFieldRef() = default;
};
class ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars : public Darabonba::Model {
public:
  shared_ptr<ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVarsFieldRef> fieldRef{};
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars() {}

  explicit ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldRef) {
      res["FieldRef"] = fieldRef ? boost::any(fieldRef->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldRef") != m.end() && !m["FieldRef"].empty()) {
      if (typeid(map<string, boost::any>) == m["FieldRef"].type()) {
        ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVarsFieldRef model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FieldRef"]));
        fieldRef = make_shared<ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVarsFieldRef>(model1);
      }
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars() = default;
};
class ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> protocol{};

  ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts() {}

  explicit ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts() = default;
};
class ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts : public Darabonba::Model {
public:
  shared_ptr<string> mountPath{};
  shared_ptr<string> mountPropagation{};
  shared_ptr<string> name{};
  shared_ptr<bool> readOnly{};
  shared_ptr<string> subPath{};

  ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts() {}

  explicit ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountPath) {
      res["MountPath"] = boost::any(*mountPath);
    }
    if (mountPropagation) {
      res["MountPropagation"] = boost::any(*mountPropagation);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    if (subPath) {
      res["SubPath"] = boost::any(*subPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MountPath") != m.end() && !m["MountPath"].empty()) {
      mountPath = make_shared<string>(boost::any_cast<string>(m["MountPath"]));
    }
    if (m.find("MountPropagation") != m.end() && !m["MountPropagation"].empty()) {
      mountPropagation = make_shared<string>(boost::any_cast<string>(m["MountPropagation"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
    if (m.find("SubPath") != m.end() && !m["SubPath"].empty()) {
      subPath = make_shared<string>(boost::any_cast<string>(m["SubPath"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts() = default;
};
class ModifyEciScalingConfigurationRequestInitContainers : public Darabonba::Model {
public:
  shared_ptr<ModifyEciScalingConfigurationRequestInitContainersSecurityContext> securityContext{};
  shared_ptr<vector<string>> args{};
  shared_ptr<vector<string>> commands{};
  shared_ptr<double> cpu{};
  shared_ptr<long> gpu{};
  shared_ptr<string> image{};
  shared_ptr<string> imagePullPolicy{};
  shared_ptr<vector<ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars>> initContainerEnvironmentVars{};
  shared_ptr<vector<ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts>> initContainerPorts{};
  shared_ptr<vector<ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts>> initContainerVolumeMounts{};
  shared_ptr<double> memory{};
  shared_ptr<string> name{};
  shared_ptr<string> workingDir{};

  ModifyEciScalingConfigurationRequestInitContainers() {}

  explicit ModifyEciScalingConfigurationRequestInitContainers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityContext) {
      res["SecurityContext"] = securityContext ? boost::any(securityContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (args) {
      res["Args"] = boost::any(*args);
    }
    if (commands) {
      res["Commands"] = boost::any(*commands);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (gpu) {
      res["Gpu"] = boost::any(*gpu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (imagePullPolicy) {
      res["ImagePullPolicy"] = boost::any(*imagePullPolicy);
    }
    if (initContainerEnvironmentVars) {
      vector<boost::any> temp1;
      for(auto item1:*initContainerEnvironmentVars){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InitContainerEnvironmentVars"] = boost::any(temp1);
    }
    if (initContainerPorts) {
      vector<boost::any> temp1;
      for(auto item1:*initContainerPorts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InitContainerPorts"] = boost::any(temp1);
    }
    if (initContainerVolumeMounts) {
      vector<boost::any> temp1;
      for(auto item1:*initContainerVolumeMounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InitContainerVolumeMounts"] = boost::any(temp1);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (workingDir) {
      res["WorkingDir"] = boost::any(*workingDir);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityContext") != m.end() && !m["SecurityContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityContext"].type()) {
        ModifyEciScalingConfigurationRequestInitContainersSecurityContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityContext"]));
        securityContext = make_shared<ModifyEciScalingConfigurationRequestInitContainersSecurityContext>(model1);
      }
    }
    if (m.find("Args") != m.end() && !m["Args"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Args"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Args"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      args = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Commands") != m.end() && !m["Commands"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Commands"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Commands"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      commands = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<double>(boost::any_cast<double>(m["Cpu"]));
    }
    if (m.find("Gpu") != m.end() && !m["Gpu"].empty()) {
      gpu = make_shared<long>(boost::any_cast<long>(m["Gpu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ImagePullPolicy") != m.end() && !m["ImagePullPolicy"].empty()) {
      imagePullPolicy = make_shared<string>(boost::any_cast<string>(m["ImagePullPolicy"]));
    }
    if (m.find("InitContainerEnvironmentVars") != m.end() && !m["InitContainerEnvironmentVars"].empty()) {
      if (typeid(vector<boost::any>) == m["InitContainerEnvironmentVars"].type()) {
        vector<ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InitContainerEnvironmentVars"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        initContainerEnvironmentVars = make_shared<vector<ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars>>(expect1);
      }
    }
    if (m.find("InitContainerPorts") != m.end() && !m["InitContainerPorts"].empty()) {
      if (typeid(vector<boost::any>) == m["InitContainerPorts"].type()) {
        vector<ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InitContainerPorts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        initContainerPorts = make_shared<vector<ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts>>(expect1);
      }
    }
    if (m.find("InitContainerVolumeMounts") != m.end() && !m["InitContainerVolumeMounts"].empty()) {
      if (typeid(vector<boost::any>) == m["InitContainerVolumeMounts"].type()) {
        vector<ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InitContainerVolumeMounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        initContainerVolumeMounts = make_shared<vector<ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts>>(expect1);
      }
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("WorkingDir") != m.end() && !m["WorkingDir"].empty()) {
      workingDir = make_shared<string>(boost::any_cast<string>(m["WorkingDir"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestInitContainers() = default;
};
class ModifyEciScalingConfigurationRequestSecurityContextSysCtls : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  ModifyEciScalingConfigurationRequestSecurityContextSysCtls() {}

  explicit ModifyEciScalingConfigurationRequestSecurityContextSysCtls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestSecurityContextSysCtls() = default;
};
class ModifyEciScalingConfigurationRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ModifyEciScalingConfigurationRequestTags() {}

  explicit ModifyEciScalingConfigurationRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestTags() = default;
};
class ModifyEciScalingConfigurationRequestVolumesDiskVolume : public Darabonba::Model {
public:
  shared_ptr<string> diskId{};
  shared_ptr<long> diskSize{};
  shared_ptr<string> fsType{};

  ModifyEciScalingConfigurationRequestVolumesDiskVolume() {}

  explicit ModifyEciScalingConfigurationRequestVolumesDiskVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (diskSize) {
      res["DiskSize"] = boost::any(*diskSize);
    }
    if (fsType) {
      res["FsType"] = boost::any(*fsType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("DiskSize") != m.end() && !m["DiskSize"].empty()) {
      diskSize = make_shared<long>(boost::any_cast<long>(m["DiskSize"]));
    }
    if (m.find("FsType") != m.end() && !m["FsType"].empty()) {
      fsType = make_shared<string>(boost::any_cast<string>(m["FsType"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestVolumesDiskVolume() = default;
};
class ModifyEciScalingConfigurationRequestVolumesEmptyDirVolume : public Darabonba::Model {
public:
  shared_ptr<string> medium{};
  shared_ptr<string> sizeLimit{};

  ModifyEciScalingConfigurationRequestVolumesEmptyDirVolume() {}

  explicit ModifyEciScalingConfigurationRequestVolumesEmptyDirVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (medium) {
      res["Medium"] = boost::any(*medium);
    }
    if (sizeLimit) {
      res["SizeLimit"] = boost::any(*sizeLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Medium") != m.end() && !m["Medium"].empty()) {
      medium = make_shared<string>(boost::any_cast<string>(m["Medium"]));
    }
    if (m.find("SizeLimit") != m.end() && !m["SizeLimit"].empty()) {
      sizeLimit = make_shared<string>(boost::any_cast<string>(m["SizeLimit"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestVolumesEmptyDirVolume() = default;
};
class ModifyEciScalingConfigurationRequestVolumesFlexVolume : public Darabonba::Model {
public:
  shared_ptr<string> driver{};
  shared_ptr<string> fsType{};
  shared_ptr<string> options{};

  ModifyEciScalingConfigurationRequestVolumesFlexVolume() {}

  explicit ModifyEciScalingConfigurationRequestVolumesFlexVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driver) {
      res["Driver"] = boost::any(*driver);
    }
    if (fsType) {
      res["FsType"] = boost::any(*fsType);
    }
    if (options) {
      res["Options"] = boost::any(*options);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Driver") != m.end() && !m["Driver"].empty()) {
      driver = make_shared<string>(boost::any_cast<string>(m["Driver"]));
    }
    if (m.find("FsType") != m.end() && !m["FsType"].empty()) {
      fsType = make_shared<string>(boost::any_cast<string>(m["FsType"]));
    }
    if (m.find("Options") != m.end() && !m["Options"].empty()) {
      options = make_shared<string>(boost::any_cast<string>(m["Options"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestVolumesFlexVolume() = default;
};
class ModifyEciScalingConfigurationRequestVolumesHostPathVolume : public Darabonba::Model {
public:
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  ModifyEciScalingConfigurationRequestVolumesHostPathVolume() {}

  explicit ModifyEciScalingConfigurationRequestVolumesHostPathVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestVolumesHostPathVolume() = default;
};
class ModifyEciScalingConfigurationRequestVolumesNFSVolume : public Darabonba::Model {
public:
  shared_ptr<string> path{};
  shared_ptr<bool> readOnly{};
  shared_ptr<string> server{};

  ModifyEciScalingConfigurationRequestVolumesNFSVolume() {}

  explicit ModifyEciScalingConfigurationRequestVolumesNFSVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    if (server) {
      res["Server"] = boost::any(*server);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
    if (m.find("Server") != m.end() && !m["Server"].empty()) {
      server = make_shared<string>(boost::any_cast<string>(m["Server"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestVolumesNFSVolume() = default;
};
class ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> mode{};
  shared_ptr<string> path{};

  ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath() {}

  explicit ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<long>(boost::any_cast<long>(m["Mode"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath() = default;
};
class ModifyEciScalingConfigurationRequestVolumes : public Darabonba::Model {
public:
  shared_ptr<ModifyEciScalingConfigurationRequestVolumesDiskVolume> diskVolume{};
  shared_ptr<ModifyEciScalingConfigurationRequestVolumesEmptyDirVolume> emptyDirVolume{};
  shared_ptr<ModifyEciScalingConfigurationRequestVolumesFlexVolume> flexVolume{};
  shared_ptr<ModifyEciScalingConfigurationRequestVolumesHostPathVolume> hostPathVolume{};
  shared_ptr<ModifyEciScalingConfigurationRequestVolumesNFSVolume> NFSVolume{};
  shared_ptr<vector<ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath>> configFileVolumeConfigFileToPath{};
  shared_ptr<long> configFileVolumeDefaultMode{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  ModifyEciScalingConfigurationRequestVolumes() {}

  explicit ModifyEciScalingConfigurationRequestVolumes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskVolume) {
      res["DiskVolume"] = diskVolume ? boost::any(diskVolume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyDirVolume) {
      res["EmptyDirVolume"] = emptyDirVolume ? boost::any(emptyDirVolume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flexVolume) {
      res["FlexVolume"] = flexVolume ? boost::any(flexVolume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hostPathVolume) {
      res["HostPathVolume"] = hostPathVolume ? boost::any(hostPathVolume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (NFSVolume) {
      res["NFSVolume"] = NFSVolume ? boost::any(NFSVolume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (configFileVolumeConfigFileToPath) {
      vector<boost::any> temp1;
      for(auto item1:*configFileVolumeConfigFileToPath){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigFileVolumeConfigFileToPath"] = boost::any(temp1);
    }
    if (configFileVolumeDefaultMode) {
      res["ConfigFileVolumeDefaultMode"] = boost::any(*configFileVolumeDefaultMode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskVolume") != m.end() && !m["DiskVolume"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskVolume"].type()) {
        ModifyEciScalingConfigurationRequestVolumesDiskVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskVolume"]));
        diskVolume = make_shared<ModifyEciScalingConfigurationRequestVolumesDiskVolume>(model1);
      }
    }
    if (m.find("EmptyDirVolume") != m.end() && !m["EmptyDirVolume"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyDirVolume"].type()) {
        ModifyEciScalingConfigurationRequestVolumesEmptyDirVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyDirVolume"]));
        emptyDirVolume = make_shared<ModifyEciScalingConfigurationRequestVolumesEmptyDirVolume>(model1);
      }
    }
    if (m.find("FlexVolume") != m.end() && !m["FlexVolume"].empty()) {
      if (typeid(map<string, boost::any>) == m["FlexVolume"].type()) {
        ModifyEciScalingConfigurationRequestVolumesFlexVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FlexVolume"]));
        flexVolume = make_shared<ModifyEciScalingConfigurationRequestVolumesFlexVolume>(model1);
      }
    }
    if (m.find("HostPathVolume") != m.end() && !m["HostPathVolume"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostPathVolume"].type()) {
        ModifyEciScalingConfigurationRequestVolumesHostPathVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostPathVolume"]));
        hostPathVolume = make_shared<ModifyEciScalingConfigurationRequestVolumesHostPathVolume>(model1);
      }
    }
    if (m.find("NFSVolume") != m.end() && !m["NFSVolume"].empty()) {
      if (typeid(map<string, boost::any>) == m["NFSVolume"].type()) {
        ModifyEciScalingConfigurationRequestVolumesNFSVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NFSVolume"]));
        NFSVolume = make_shared<ModifyEciScalingConfigurationRequestVolumesNFSVolume>(model1);
      }
    }
    if (m.find("ConfigFileVolumeConfigFileToPath") != m.end() && !m["ConfigFileVolumeConfigFileToPath"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigFileVolumeConfigFileToPath"].type()) {
        vector<ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigFileVolumeConfigFileToPath"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configFileVolumeConfigFileToPath = make_shared<vector<ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath>>(expect1);
      }
    }
    if (m.find("ConfigFileVolumeDefaultMode") != m.end() && !m["ConfigFileVolumeDefaultMode"].empty()) {
      configFileVolumeDefaultMode = make_shared<long>(boost::any_cast<long>(m["ConfigFileVolumeDefaultMode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationRequestVolumes() = default;
};
class ModifyEciScalingConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyEciScalingConfigurationRequestAcrRegistryInfos>> acrRegistryInfos{};
  shared_ptr<long> activeDeadlineSeconds{};
  shared_ptr<bool> autoCreateEip{};
  shared_ptr<bool> autoMatchImageCache{};
  shared_ptr<string> containerGroupName{};
  shared_ptr<vector<ModifyEciScalingConfigurationRequestContainers>> containers{};
  shared_ptr<string> containersUpdateType{};
  shared_ptr<bool> costOptimization{};
  shared_ptr<double> cpu{};
  shared_ptr<long> cpuOptionsCore{};
  shared_ptr<long> cpuOptionsThreadsPerCore{};
  shared_ptr<string> dataCacheBucket{};
  shared_ptr<bool> dataCacheBurstingEnabled{};
  shared_ptr<string> dataCachePL{};
  shared_ptr<long> dataCacheProvisionedIops{};
  shared_ptr<string> description{};
  shared_ptr<vector<string>> dnsConfigNameServers{};
  shared_ptr<vector<ModifyEciScalingConfigurationRequestDnsConfigOptions>> dnsConfigOptions{};
  shared_ptr<vector<string>> dnsConfigSearchs{};
  shared_ptr<string> dnsPolicy{};
  shared_ptr<long> egressBandwidth{};
  shared_ptr<long> eipBandwidth{};
  shared_ptr<bool> enableSls{};
  shared_ptr<long> ephemeralStorage{};
  shared_ptr<string> gpuDriverVersion{};
  shared_ptr<vector<ModifyEciScalingConfigurationRequestHostAliases>> hostAliases{};
  shared_ptr<string> hostName{};
  shared_ptr<vector<ModifyEciScalingConfigurationRequestImageRegistryCredentials>> imageRegistryCredentials{};
  shared_ptr<string> imageSnapshotId{};
  shared_ptr<long> ingressBandwidth{};
  shared_ptr<vector<ModifyEciScalingConfigurationRequestInitContainers>> initContainers{};
  shared_ptr<string> instanceFamilyLevel{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<long> ipv6AddressCount{};
  shared_ptr<long> loadBalancerWeight{};
  shared_ptr<double> memory{};
  shared_ptr<vector<string>> ntpServers{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> ramRoleName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> restartPolicy{};
  shared_ptr<string> scalingConfigurationId{};
  shared_ptr<string> scalingConfigurationName{};
  shared_ptr<vector<ModifyEciScalingConfigurationRequestSecurityContextSysCtls>> securityContextSysCtls{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<double> spotPriceLimit{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<vector<ModifyEciScalingConfigurationRequestTags>> tags{};
  shared_ptr<long> terminationGracePeriodSeconds{};
  shared_ptr<vector<ModifyEciScalingConfigurationRequestVolumes>> volumes{};

  ModifyEciScalingConfigurationRequest() {}

  explicit ModifyEciScalingConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acrRegistryInfos) {
      vector<boost::any> temp1;
      for(auto item1:*acrRegistryInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AcrRegistryInfos"] = boost::any(temp1);
    }
    if (activeDeadlineSeconds) {
      res["ActiveDeadlineSeconds"] = boost::any(*activeDeadlineSeconds);
    }
    if (autoCreateEip) {
      res["AutoCreateEip"] = boost::any(*autoCreateEip);
    }
    if (autoMatchImageCache) {
      res["AutoMatchImageCache"] = boost::any(*autoMatchImageCache);
    }
    if (containerGroupName) {
      res["ContainerGroupName"] = boost::any(*containerGroupName);
    }
    if (containers) {
      vector<boost::any> temp1;
      for(auto item1:*containers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Containers"] = boost::any(temp1);
    }
    if (containersUpdateType) {
      res["ContainersUpdateType"] = boost::any(*containersUpdateType);
    }
    if (costOptimization) {
      res["CostOptimization"] = boost::any(*costOptimization);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (cpuOptionsCore) {
      res["CpuOptionsCore"] = boost::any(*cpuOptionsCore);
    }
    if (cpuOptionsThreadsPerCore) {
      res["CpuOptionsThreadsPerCore"] = boost::any(*cpuOptionsThreadsPerCore);
    }
    if (dataCacheBucket) {
      res["DataCacheBucket"] = boost::any(*dataCacheBucket);
    }
    if (dataCacheBurstingEnabled) {
      res["DataCacheBurstingEnabled"] = boost::any(*dataCacheBurstingEnabled);
    }
    if (dataCachePL) {
      res["DataCachePL"] = boost::any(*dataCachePL);
    }
    if (dataCacheProvisionedIops) {
      res["DataCacheProvisionedIops"] = boost::any(*dataCacheProvisionedIops);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dnsConfigNameServers) {
      res["DnsConfigNameServers"] = boost::any(*dnsConfigNameServers);
    }
    if (dnsConfigOptions) {
      vector<boost::any> temp1;
      for(auto item1:*dnsConfigOptions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DnsConfigOptions"] = boost::any(temp1);
    }
    if (dnsConfigSearchs) {
      res["DnsConfigSearchs"] = boost::any(*dnsConfigSearchs);
    }
    if (dnsPolicy) {
      res["DnsPolicy"] = boost::any(*dnsPolicy);
    }
    if (egressBandwidth) {
      res["EgressBandwidth"] = boost::any(*egressBandwidth);
    }
    if (eipBandwidth) {
      res["EipBandwidth"] = boost::any(*eipBandwidth);
    }
    if (enableSls) {
      res["EnableSls"] = boost::any(*enableSls);
    }
    if (ephemeralStorage) {
      res["EphemeralStorage"] = boost::any(*ephemeralStorage);
    }
    if (gpuDriverVersion) {
      res["GpuDriverVersion"] = boost::any(*gpuDriverVersion);
    }
    if (hostAliases) {
      vector<boost::any> temp1;
      for(auto item1:*hostAliases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostAliases"] = boost::any(temp1);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (imageRegistryCredentials) {
      vector<boost::any> temp1;
      for(auto item1:*imageRegistryCredentials){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageRegistryCredentials"] = boost::any(temp1);
    }
    if (imageSnapshotId) {
      res["ImageSnapshotId"] = boost::any(*imageSnapshotId);
    }
    if (ingressBandwidth) {
      res["IngressBandwidth"] = boost::any(*ingressBandwidth);
    }
    if (initContainers) {
      vector<boost::any> temp1;
      for(auto item1:*initContainers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InitContainers"] = boost::any(temp1);
    }
    if (instanceFamilyLevel) {
      res["InstanceFamilyLevel"] = boost::any(*instanceFamilyLevel);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = boost::any(*instanceTypes);
    }
    if (ipv6AddressCount) {
      res["Ipv6AddressCount"] = boost::any(*ipv6AddressCount);
    }
    if (loadBalancerWeight) {
      res["LoadBalancerWeight"] = boost::any(*loadBalancerWeight);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (ntpServers) {
      res["NtpServers"] = boost::any(*ntpServers);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (restartPolicy) {
      res["RestartPolicy"] = boost::any(*restartPolicy);
    }
    if (scalingConfigurationId) {
      res["ScalingConfigurationId"] = boost::any(*scalingConfigurationId);
    }
    if (scalingConfigurationName) {
      res["ScalingConfigurationName"] = boost::any(*scalingConfigurationName);
    }
    if (securityContextSysCtls) {
      vector<boost::any> temp1;
      for(auto item1:*securityContextSysCtls){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityContextSysCtls"] = boost::any(temp1);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (spotPriceLimit) {
      res["SpotPriceLimit"] = boost::any(*spotPriceLimit);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (terminationGracePeriodSeconds) {
      res["TerminationGracePeriodSeconds"] = boost::any(*terminationGracePeriodSeconds);
    }
    if (volumes) {
      vector<boost::any> temp1;
      for(auto item1:*volumes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Volumes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcrRegistryInfos") != m.end() && !m["AcrRegistryInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["AcrRegistryInfos"].type()) {
        vector<ModifyEciScalingConfigurationRequestAcrRegistryInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AcrRegistryInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyEciScalingConfigurationRequestAcrRegistryInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        acrRegistryInfos = make_shared<vector<ModifyEciScalingConfigurationRequestAcrRegistryInfos>>(expect1);
      }
    }
    if (m.find("ActiveDeadlineSeconds") != m.end() && !m["ActiveDeadlineSeconds"].empty()) {
      activeDeadlineSeconds = make_shared<long>(boost::any_cast<long>(m["ActiveDeadlineSeconds"]));
    }
    if (m.find("AutoCreateEip") != m.end() && !m["AutoCreateEip"].empty()) {
      autoCreateEip = make_shared<bool>(boost::any_cast<bool>(m["AutoCreateEip"]));
    }
    if (m.find("AutoMatchImageCache") != m.end() && !m["AutoMatchImageCache"].empty()) {
      autoMatchImageCache = make_shared<bool>(boost::any_cast<bool>(m["AutoMatchImageCache"]));
    }
    if (m.find("ContainerGroupName") != m.end() && !m["ContainerGroupName"].empty()) {
      containerGroupName = make_shared<string>(boost::any_cast<string>(m["ContainerGroupName"]));
    }
    if (m.find("Containers") != m.end() && !m["Containers"].empty()) {
      if (typeid(vector<boost::any>) == m["Containers"].type()) {
        vector<ModifyEciScalingConfigurationRequestContainers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Containers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyEciScalingConfigurationRequestContainers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        containers = make_shared<vector<ModifyEciScalingConfigurationRequestContainers>>(expect1);
      }
    }
    if (m.find("ContainersUpdateType") != m.end() && !m["ContainersUpdateType"].empty()) {
      containersUpdateType = make_shared<string>(boost::any_cast<string>(m["ContainersUpdateType"]));
    }
    if (m.find("CostOptimization") != m.end() && !m["CostOptimization"].empty()) {
      costOptimization = make_shared<bool>(boost::any_cast<bool>(m["CostOptimization"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<double>(boost::any_cast<double>(m["Cpu"]));
    }
    if (m.find("CpuOptionsCore") != m.end() && !m["CpuOptionsCore"].empty()) {
      cpuOptionsCore = make_shared<long>(boost::any_cast<long>(m["CpuOptionsCore"]));
    }
    if (m.find("CpuOptionsThreadsPerCore") != m.end() && !m["CpuOptionsThreadsPerCore"].empty()) {
      cpuOptionsThreadsPerCore = make_shared<long>(boost::any_cast<long>(m["CpuOptionsThreadsPerCore"]));
    }
    if (m.find("DataCacheBucket") != m.end() && !m["DataCacheBucket"].empty()) {
      dataCacheBucket = make_shared<string>(boost::any_cast<string>(m["DataCacheBucket"]));
    }
    if (m.find("DataCacheBurstingEnabled") != m.end() && !m["DataCacheBurstingEnabled"].empty()) {
      dataCacheBurstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["DataCacheBurstingEnabled"]));
    }
    if (m.find("DataCachePL") != m.end() && !m["DataCachePL"].empty()) {
      dataCachePL = make_shared<string>(boost::any_cast<string>(m["DataCachePL"]));
    }
    if (m.find("DataCacheProvisionedIops") != m.end() && !m["DataCacheProvisionedIops"].empty()) {
      dataCacheProvisionedIops = make_shared<long>(boost::any_cast<long>(m["DataCacheProvisionedIops"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DnsConfigNameServers") != m.end() && !m["DnsConfigNameServers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DnsConfigNameServers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DnsConfigNameServers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dnsConfigNameServers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DnsConfigOptions") != m.end() && !m["DnsConfigOptions"].empty()) {
      if (typeid(vector<boost::any>) == m["DnsConfigOptions"].type()) {
        vector<ModifyEciScalingConfigurationRequestDnsConfigOptions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DnsConfigOptions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyEciScalingConfigurationRequestDnsConfigOptions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dnsConfigOptions = make_shared<vector<ModifyEciScalingConfigurationRequestDnsConfigOptions>>(expect1);
      }
    }
    if (m.find("DnsConfigSearchs") != m.end() && !m["DnsConfigSearchs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DnsConfigSearchs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DnsConfigSearchs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dnsConfigSearchs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DnsPolicy") != m.end() && !m["DnsPolicy"].empty()) {
      dnsPolicy = make_shared<string>(boost::any_cast<string>(m["DnsPolicy"]));
    }
    if (m.find("EgressBandwidth") != m.end() && !m["EgressBandwidth"].empty()) {
      egressBandwidth = make_shared<long>(boost::any_cast<long>(m["EgressBandwidth"]));
    }
    if (m.find("EipBandwidth") != m.end() && !m["EipBandwidth"].empty()) {
      eipBandwidth = make_shared<long>(boost::any_cast<long>(m["EipBandwidth"]));
    }
    if (m.find("EnableSls") != m.end() && !m["EnableSls"].empty()) {
      enableSls = make_shared<bool>(boost::any_cast<bool>(m["EnableSls"]));
    }
    if (m.find("EphemeralStorage") != m.end() && !m["EphemeralStorage"].empty()) {
      ephemeralStorage = make_shared<long>(boost::any_cast<long>(m["EphemeralStorage"]));
    }
    if (m.find("GpuDriverVersion") != m.end() && !m["GpuDriverVersion"].empty()) {
      gpuDriverVersion = make_shared<string>(boost::any_cast<string>(m["GpuDriverVersion"]));
    }
    if (m.find("HostAliases") != m.end() && !m["HostAliases"].empty()) {
      if (typeid(vector<boost::any>) == m["HostAliases"].type()) {
        vector<ModifyEciScalingConfigurationRequestHostAliases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostAliases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyEciScalingConfigurationRequestHostAliases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostAliases = make_shared<vector<ModifyEciScalingConfigurationRequestHostAliases>>(expect1);
      }
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ImageRegistryCredentials") != m.end() && !m["ImageRegistryCredentials"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageRegistryCredentials"].type()) {
        vector<ModifyEciScalingConfigurationRequestImageRegistryCredentials> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageRegistryCredentials"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyEciScalingConfigurationRequestImageRegistryCredentials model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageRegistryCredentials = make_shared<vector<ModifyEciScalingConfigurationRequestImageRegistryCredentials>>(expect1);
      }
    }
    if (m.find("ImageSnapshotId") != m.end() && !m["ImageSnapshotId"].empty()) {
      imageSnapshotId = make_shared<string>(boost::any_cast<string>(m["ImageSnapshotId"]));
    }
    if (m.find("IngressBandwidth") != m.end() && !m["IngressBandwidth"].empty()) {
      ingressBandwidth = make_shared<long>(boost::any_cast<long>(m["IngressBandwidth"]));
    }
    if (m.find("InitContainers") != m.end() && !m["InitContainers"].empty()) {
      if (typeid(vector<boost::any>) == m["InitContainers"].type()) {
        vector<ModifyEciScalingConfigurationRequestInitContainers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InitContainers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyEciScalingConfigurationRequestInitContainers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        initContainers = make_shared<vector<ModifyEciScalingConfigurationRequestInitContainers>>(expect1);
      }
    }
    if (m.find("InstanceFamilyLevel") != m.end() && !m["InstanceFamilyLevel"].empty()) {
      instanceFamilyLevel = make_shared<string>(boost::any_cast<string>(m["InstanceFamilyLevel"]));
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Ipv6AddressCount") != m.end() && !m["Ipv6AddressCount"].empty()) {
      ipv6AddressCount = make_shared<long>(boost::any_cast<long>(m["Ipv6AddressCount"]));
    }
    if (m.find("LoadBalancerWeight") != m.end() && !m["LoadBalancerWeight"].empty()) {
      loadBalancerWeight = make_shared<long>(boost::any_cast<long>(m["LoadBalancerWeight"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("NtpServers") != m.end() && !m["NtpServers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NtpServers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NtpServers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ntpServers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("RestartPolicy") != m.end() && !m["RestartPolicy"].empty()) {
      restartPolicy = make_shared<string>(boost::any_cast<string>(m["RestartPolicy"]));
    }
    if (m.find("ScalingConfigurationId") != m.end() && !m["ScalingConfigurationId"].empty()) {
      scalingConfigurationId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationId"]));
    }
    if (m.find("ScalingConfigurationName") != m.end() && !m["ScalingConfigurationName"].empty()) {
      scalingConfigurationName = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationName"]));
    }
    if (m.find("SecurityContextSysCtls") != m.end() && !m["SecurityContextSysCtls"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityContextSysCtls"].type()) {
        vector<ModifyEciScalingConfigurationRequestSecurityContextSysCtls> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityContextSysCtls"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyEciScalingConfigurationRequestSecurityContextSysCtls model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityContextSysCtls = make_shared<vector<ModifyEciScalingConfigurationRequestSecurityContextSysCtls>>(expect1);
      }
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SpotPriceLimit") != m.end() && !m["SpotPriceLimit"].empty()) {
      spotPriceLimit = make_shared<double>(boost::any_cast<double>(m["SpotPriceLimit"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ModifyEciScalingConfigurationRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyEciScalingConfigurationRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ModifyEciScalingConfigurationRequestTags>>(expect1);
      }
    }
    if (m.find("TerminationGracePeriodSeconds") != m.end() && !m["TerminationGracePeriodSeconds"].empty()) {
      terminationGracePeriodSeconds = make_shared<long>(boost::any_cast<long>(m["TerminationGracePeriodSeconds"]));
    }
    if (m.find("Volumes") != m.end() && !m["Volumes"].empty()) {
      if (typeid(vector<boost::any>) == m["Volumes"].type()) {
        vector<ModifyEciScalingConfigurationRequestVolumes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Volumes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyEciScalingConfigurationRequestVolumes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        volumes = make_shared<vector<ModifyEciScalingConfigurationRequestVolumes>>(expect1);
      }
    }
  }


  virtual ~ModifyEciScalingConfigurationRequest() = default;
};
class ModifyEciScalingConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyEciScalingConfigurationResponseBody() {}

  explicit ModifyEciScalingConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyEciScalingConfigurationResponseBody() = default;
};
class ModifyEciScalingConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyEciScalingConfigurationResponseBody> body{};

  ModifyEciScalingConfigurationResponse() {}

  explicit ModifyEciScalingConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyEciScalingConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyEciScalingConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyEciScalingConfigurationResponse() = default;
};
class ModifyInstanceAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<bool> entrusted{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};

  ModifyInstanceAttributeRequest() {}

  explicit ModifyInstanceAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entrusted) {
      res["Entrusted"] = boost::any(*entrusted);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Entrusted") != m.end() && !m["Entrusted"].empty()) {
      entrusted = make_shared<bool>(boost::any_cast<bool>(m["Entrusted"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~ModifyInstanceAttributeRequest() = default;
};
class ModifyInstanceAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceAttributeResponseBody() {}

  explicit ModifyInstanceAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceAttributeResponseBody() = default;
};
class ModifyInstanceAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceAttributeResponseBody> body{};

  ModifyInstanceAttributeResponse() {}

  explicit ModifyInstanceAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceAttributeResponse() = default;
};
class ModifyLifecycleHookRequest : public Darabonba::Model {
public:
  shared_ptr<string> defaultResult{};
  shared_ptr<long> heartbeatTimeout{};
  shared_ptr<string> lifecycleHookId{};
  shared_ptr<string> lifecycleHookName{};
  shared_ptr<string> lifecycleHookStatus{};
  shared_ptr<string> lifecycleTransition{};
  shared_ptr<string> notificationArn{};
  shared_ptr<string> notificationMetadata{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};

  ModifyLifecycleHookRequest() {}

  explicit ModifyLifecycleHookRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultResult) {
      res["DefaultResult"] = boost::any(*defaultResult);
    }
    if (heartbeatTimeout) {
      res["HeartbeatTimeout"] = boost::any(*heartbeatTimeout);
    }
    if (lifecycleHookId) {
      res["LifecycleHookId"] = boost::any(*lifecycleHookId);
    }
    if (lifecycleHookName) {
      res["LifecycleHookName"] = boost::any(*lifecycleHookName);
    }
    if (lifecycleHookStatus) {
      res["LifecycleHookStatus"] = boost::any(*lifecycleHookStatus);
    }
    if (lifecycleTransition) {
      res["LifecycleTransition"] = boost::any(*lifecycleTransition);
    }
    if (notificationArn) {
      res["NotificationArn"] = boost::any(*notificationArn);
    }
    if (notificationMetadata) {
      res["NotificationMetadata"] = boost::any(*notificationMetadata);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultResult") != m.end() && !m["DefaultResult"].empty()) {
      defaultResult = make_shared<string>(boost::any_cast<string>(m["DefaultResult"]));
    }
    if (m.find("HeartbeatTimeout") != m.end() && !m["HeartbeatTimeout"].empty()) {
      heartbeatTimeout = make_shared<long>(boost::any_cast<long>(m["HeartbeatTimeout"]));
    }
    if (m.find("LifecycleHookId") != m.end() && !m["LifecycleHookId"].empty()) {
      lifecycleHookId = make_shared<string>(boost::any_cast<string>(m["LifecycleHookId"]));
    }
    if (m.find("LifecycleHookName") != m.end() && !m["LifecycleHookName"].empty()) {
      lifecycleHookName = make_shared<string>(boost::any_cast<string>(m["LifecycleHookName"]));
    }
    if (m.find("LifecycleHookStatus") != m.end() && !m["LifecycleHookStatus"].empty()) {
      lifecycleHookStatus = make_shared<string>(boost::any_cast<string>(m["LifecycleHookStatus"]));
    }
    if (m.find("LifecycleTransition") != m.end() && !m["LifecycleTransition"].empty()) {
      lifecycleTransition = make_shared<string>(boost::any_cast<string>(m["LifecycleTransition"]));
    }
    if (m.find("NotificationArn") != m.end() && !m["NotificationArn"].empty()) {
      notificationArn = make_shared<string>(boost::any_cast<string>(m["NotificationArn"]));
    }
    if (m.find("NotificationMetadata") != m.end() && !m["NotificationMetadata"].empty()) {
      notificationMetadata = make_shared<string>(boost::any_cast<string>(m["NotificationMetadata"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~ModifyLifecycleHookRequest() = default;
};
class ModifyLifecycleHookResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyLifecycleHookResponseBody() {}

  explicit ModifyLifecycleHookResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyLifecycleHookResponseBody() = default;
};
class ModifyLifecycleHookResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyLifecycleHookResponseBody> body{};

  ModifyLifecycleHookResponse() {}

  explicit ModifyLifecycleHookResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyLifecycleHookResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyLifecycleHookResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyLifecycleHookResponse() = default;
};
class ModifyNotificationConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> notificationArn{};
  shared_ptr<vector<string>> notificationTypes{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> timeZone{};

  ModifyNotificationConfigurationRequest() {}

  explicit ModifyNotificationConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notificationArn) {
      res["NotificationArn"] = boost::any(*notificationArn);
    }
    if (notificationTypes) {
      res["NotificationTypes"] = boost::any(*notificationTypes);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotificationArn") != m.end() && !m["NotificationArn"].empty()) {
      notificationArn = make_shared<string>(boost::any_cast<string>(m["NotificationArn"]));
    }
    if (m.find("NotificationTypes") != m.end() && !m["NotificationTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NotificationTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NotificationTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      notificationTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~ModifyNotificationConfigurationRequest() = default;
};
class ModifyNotificationConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyNotificationConfigurationResponseBody() {}

  explicit ModifyNotificationConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyNotificationConfigurationResponseBody() = default;
};
class ModifyNotificationConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyNotificationConfigurationResponseBody> body{};

  ModifyNotificationConfigurationResponse() {}

  explicit ModifyNotificationConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyNotificationConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyNotificationConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyNotificationConfigurationResponse() = default;
};
class ModifyScalingConfigurationRequestImageOptions : public Darabonba::Model {
public:
  shared_ptr<bool> loginAsNonRoot{};

  ModifyScalingConfigurationRequestImageOptions() {}

  explicit ModifyScalingConfigurationRequestImageOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loginAsNonRoot) {
      res["LoginAsNonRoot"] = boost::any(*loginAsNonRoot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoginAsNonRoot") != m.end() && !m["LoginAsNonRoot"].empty()) {
      loginAsNonRoot = make_shared<bool>(boost::any_cast<bool>(m["LoginAsNonRoot"]));
    }
  }


  virtual ~ModifyScalingConfigurationRequestImageOptions() = default;
};
class ModifyScalingConfigurationRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> matchCriteria{};

  ModifyScalingConfigurationRequestPrivatePoolOptions() {}

  explicit ModifyScalingConfigurationRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (matchCriteria) {
      res["MatchCriteria"] = boost::any(*matchCriteria);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MatchCriteria") != m.end() && !m["MatchCriteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["MatchCriteria"]));
    }
  }


  virtual ~ModifyScalingConfigurationRequestPrivatePoolOptions() = default;
};
class ModifyScalingConfigurationRequestSystemDisk : public Darabonba::Model {
public:
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<bool> burstingEnabled{};
  shared_ptr<string> category{};
  shared_ptr<string> description{};
  shared_ptr<string> diskName{};
  shared_ptr<string> encryptAlgorithm{};
  shared_ptr<bool> encrypted{};
  shared_ptr<string> KMSKeyId{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<long> provisionedIops{};
  shared_ptr<long> size{};

  ModifyScalingConfigurationRequestSystemDisk() {}

  explicit ModifyScalingConfigurationRequestSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoSnapshotPolicyId) {
      res["AutoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    if (burstingEnabled) {
      res["BurstingEnabled"] = boost::any(*burstingEnabled);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (encryptAlgorithm) {
      res["EncryptAlgorithm"] = boost::any(*encryptAlgorithm);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (provisionedIops) {
      res["ProvisionedIops"] = boost::any(*provisionedIops);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoSnapshotPolicyId") != m.end() && !m["AutoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["AutoSnapshotPolicyId"]));
    }
    if (m.find("BurstingEnabled") != m.end() && !m["BurstingEnabled"].empty()) {
      burstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["BurstingEnabled"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("EncryptAlgorithm") != m.end() && !m["EncryptAlgorithm"].empty()) {
      encryptAlgorithm = make_shared<string>(boost::any_cast<string>(m["EncryptAlgorithm"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<bool>(boost::any_cast<bool>(m["Encrypted"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("ProvisionedIops") != m.end() && !m["ProvisionedIops"].empty()) {
      provisionedIops = make_shared<long>(boost::any_cast<long>(m["ProvisionedIops"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~ModifyScalingConfigurationRequestSystemDisk() = default;
};
class ModifyScalingConfigurationRequestCustomPriorities : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<string> vswitchId{};

  ModifyScalingConfigurationRequestCustomPriorities() {}

  explicit ModifyScalingConfigurationRequestCustomPriorities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~ModifyScalingConfigurationRequestCustomPriorities() = default;
};
class ModifyScalingConfigurationRequestDataDisks : public Darabonba::Model {
public:
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<bool> burstingEnabled{};
  shared_ptr<vector<string>> categories{};
  shared_ptr<string> category{};
  shared_ptr<bool> deleteWithInstance{};
  shared_ptr<string> description{};
  shared_ptr<string> device{};
  shared_ptr<string> diskName{};
  shared_ptr<string> encrypted{};
  shared_ptr<string> KMSKeyId{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<long> provisionedIops{};
  shared_ptr<long> size{};
  shared_ptr<string> snapshotId{};

  ModifyScalingConfigurationRequestDataDisks() {}

  explicit ModifyScalingConfigurationRequestDataDisks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoSnapshotPolicyId) {
      res["AutoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    if (burstingEnabled) {
      res["BurstingEnabled"] = boost::any(*burstingEnabled);
    }
    if (categories) {
      res["Categories"] = boost::any(*categories);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (provisionedIops) {
      res["ProvisionedIops"] = boost::any(*provisionedIops);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoSnapshotPolicyId") != m.end() && !m["AutoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["AutoSnapshotPolicyId"]));
    }
    if (m.find("BurstingEnabled") != m.end() && !m["BurstingEnabled"].empty()) {
      burstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["BurstingEnabled"]));
    }
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Categories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      categories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<bool>(boost::any_cast<bool>(m["DeleteWithInstance"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<string>(boost::any_cast<string>(m["Encrypted"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("ProvisionedIops") != m.end() && !m["ProvisionedIops"].empty()) {
      provisionedIops = make_shared<long>(boost::any_cast<long>(m["ProvisionedIops"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
  }


  virtual ~ModifyScalingConfigurationRequestDataDisks() = default;
};
class ModifyScalingConfigurationRequestInstancePatternInfos : public Darabonba::Model {
public:
  shared_ptr<vector<string>> architectures{};
  shared_ptr<string> burstablePerformance{};
  shared_ptr<long> cores{};
  shared_ptr<vector<string>> cpuArchitectures{};
  shared_ptr<vector<string>> excludedInstanceTypes{};
  shared_ptr<vector<string>> gpuSpecs{};
  shared_ptr<vector<string>> instanceCategories{};
  shared_ptr<string> instanceFamilyLevel{};
  shared_ptr<vector<string>> instanceTypeFamilies{};
  shared_ptr<double> maxPrice{};
  shared_ptr<long> maximumCpuCoreCount{};
  shared_ptr<long> maximumGpuAmount{};
  shared_ptr<double> maximumMemorySize{};
  shared_ptr<double> memory{};
  shared_ptr<long> minimumBaselineCredit{};
  shared_ptr<long> minimumCpuCoreCount{};
  shared_ptr<long> minimumEniIpv6AddressQuantity{};
  shared_ptr<long> minimumEniPrivateIpAddressQuantity{};
  shared_ptr<long> minimumEniQuantity{};
  shared_ptr<long> minimumGpuAmount{};
  shared_ptr<long> minimumInitialCredit{};
  shared_ptr<double> minimumMemorySize{};
  shared_ptr<vector<string>> physicalProcessorModels{};

  ModifyScalingConfigurationRequestInstancePatternInfos() {}

  explicit ModifyScalingConfigurationRequestInstancePatternInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architectures) {
      res["Architectures"] = boost::any(*architectures);
    }
    if (burstablePerformance) {
      res["BurstablePerformance"] = boost::any(*burstablePerformance);
    }
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (cpuArchitectures) {
      res["CpuArchitectures"] = boost::any(*cpuArchitectures);
    }
    if (excludedInstanceTypes) {
      res["ExcludedInstanceTypes"] = boost::any(*excludedInstanceTypes);
    }
    if (gpuSpecs) {
      res["GpuSpecs"] = boost::any(*gpuSpecs);
    }
    if (instanceCategories) {
      res["InstanceCategories"] = boost::any(*instanceCategories);
    }
    if (instanceFamilyLevel) {
      res["InstanceFamilyLevel"] = boost::any(*instanceFamilyLevel);
    }
    if (instanceTypeFamilies) {
      res["InstanceTypeFamilies"] = boost::any(*instanceTypeFamilies);
    }
    if (maxPrice) {
      res["MaxPrice"] = boost::any(*maxPrice);
    }
    if (maximumCpuCoreCount) {
      res["MaximumCpuCoreCount"] = boost::any(*maximumCpuCoreCount);
    }
    if (maximumGpuAmount) {
      res["MaximumGpuAmount"] = boost::any(*maximumGpuAmount);
    }
    if (maximumMemorySize) {
      res["MaximumMemorySize"] = boost::any(*maximumMemorySize);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (minimumBaselineCredit) {
      res["MinimumBaselineCredit"] = boost::any(*minimumBaselineCredit);
    }
    if (minimumCpuCoreCount) {
      res["MinimumCpuCoreCount"] = boost::any(*minimumCpuCoreCount);
    }
    if (minimumEniIpv6AddressQuantity) {
      res["MinimumEniIpv6AddressQuantity"] = boost::any(*minimumEniIpv6AddressQuantity);
    }
    if (minimumEniPrivateIpAddressQuantity) {
      res["MinimumEniPrivateIpAddressQuantity"] = boost::any(*minimumEniPrivateIpAddressQuantity);
    }
    if (minimumEniQuantity) {
      res["MinimumEniQuantity"] = boost::any(*minimumEniQuantity);
    }
    if (minimumGpuAmount) {
      res["MinimumGpuAmount"] = boost::any(*minimumGpuAmount);
    }
    if (minimumInitialCredit) {
      res["MinimumInitialCredit"] = boost::any(*minimumInitialCredit);
    }
    if (minimumMemorySize) {
      res["MinimumMemorySize"] = boost::any(*minimumMemorySize);
    }
    if (physicalProcessorModels) {
      res["PhysicalProcessorModels"] = boost::any(*physicalProcessorModels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Architectures") != m.end() && !m["Architectures"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Architectures"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Architectures"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      architectures = make_shared<vector<string>>(toVec1);
    }
    if (m.find("BurstablePerformance") != m.end() && !m["BurstablePerformance"].empty()) {
      burstablePerformance = make_shared<string>(boost::any_cast<string>(m["BurstablePerformance"]));
    }
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("CpuArchitectures") != m.end() && !m["CpuArchitectures"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CpuArchitectures"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CpuArchitectures"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cpuArchitectures = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExcludedInstanceTypes") != m.end() && !m["ExcludedInstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludedInstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludedInstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludedInstanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GpuSpecs") != m.end() && !m["GpuSpecs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GpuSpecs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GpuSpecs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      gpuSpecs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceCategories") != m.end() && !m["InstanceCategories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceCategories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceCategories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceCategories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceFamilyLevel") != m.end() && !m["InstanceFamilyLevel"].empty()) {
      instanceFamilyLevel = make_shared<string>(boost::any_cast<string>(m["InstanceFamilyLevel"]));
    }
    if (m.find("InstanceTypeFamilies") != m.end() && !m["InstanceTypeFamilies"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypeFamilies"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypeFamilies"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypeFamilies = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxPrice") != m.end() && !m["MaxPrice"].empty()) {
      maxPrice = make_shared<double>(boost::any_cast<double>(m["MaxPrice"]));
    }
    if (m.find("MaximumCpuCoreCount") != m.end() && !m["MaximumCpuCoreCount"].empty()) {
      maximumCpuCoreCount = make_shared<long>(boost::any_cast<long>(m["MaximumCpuCoreCount"]));
    }
    if (m.find("MaximumGpuAmount") != m.end() && !m["MaximumGpuAmount"].empty()) {
      maximumGpuAmount = make_shared<long>(boost::any_cast<long>(m["MaximumGpuAmount"]));
    }
    if (m.find("MaximumMemorySize") != m.end() && !m["MaximumMemorySize"].empty()) {
      maximumMemorySize = make_shared<double>(boost::any_cast<double>(m["MaximumMemorySize"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("MinimumBaselineCredit") != m.end() && !m["MinimumBaselineCredit"].empty()) {
      minimumBaselineCredit = make_shared<long>(boost::any_cast<long>(m["MinimumBaselineCredit"]));
    }
    if (m.find("MinimumCpuCoreCount") != m.end() && !m["MinimumCpuCoreCount"].empty()) {
      minimumCpuCoreCount = make_shared<long>(boost::any_cast<long>(m["MinimumCpuCoreCount"]));
    }
    if (m.find("MinimumEniIpv6AddressQuantity") != m.end() && !m["MinimumEniIpv6AddressQuantity"].empty()) {
      minimumEniIpv6AddressQuantity = make_shared<long>(boost::any_cast<long>(m["MinimumEniIpv6AddressQuantity"]));
    }
    if (m.find("MinimumEniPrivateIpAddressQuantity") != m.end() && !m["MinimumEniPrivateIpAddressQuantity"].empty()) {
      minimumEniPrivateIpAddressQuantity = make_shared<long>(boost::any_cast<long>(m["MinimumEniPrivateIpAddressQuantity"]));
    }
    if (m.find("MinimumEniQuantity") != m.end() && !m["MinimumEniQuantity"].empty()) {
      minimumEniQuantity = make_shared<long>(boost::any_cast<long>(m["MinimumEniQuantity"]));
    }
    if (m.find("MinimumGpuAmount") != m.end() && !m["MinimumGpuAmount"].empty()) {
      minimumGpuAmount = make_shared<long>(boost::any_cast<long>(m["MinimumGpuAmount"]));
    }
    if (m.find("MinimumInitialCredit") != m.end() && !m["MinimumInitialCredit"].empty()) {
      minimumInitialCredit = make_shared<long>(boost::any_cast<long>(m["MinimumInitialCredit"]));
    }
    if (m.find("MinimumMemorySize") != m.end() && !m["MinimumMemorySize"].empty()) {
      minimumMemorySize = make_shared<double>(boost::any_cast<double>(m["MinimumMemorySize"]));
    }
    if (m.find("PhysicalProcessorModels") != m.end() && !m["PhysicalProcessorModels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PhysicalProcessorModels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PhysicalProcessorModels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      physicalProcessorModels = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyScalingConfigurationRequestInstancePatternInfos() = default;
};
class ModifyScalingConfigurationRequestInstanceTypeOverrides : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<long> weightedCapacity{};

  ModifyScalingConfigurationRequestInstanceTypeOverrides() {}

  explicit ModifyScalingConfigurationRequestInstanceTypeOverrides(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (weightedCapacity) {
      res["WeightedCapacity"] = boost::any(*weightedCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("WeightedCapacity") != m.end() && !m["WeightedCapacity"].empty()) {
      weightedCapacity = make_shared<long>(boost::any_cast<long>(m["WeightedCapacity"]));
    }
  }


  virtual ~ModifyScalingConfigurationRequestInstanceTypeOverrides() = default;
};
class ModifyScalingConfigurationRequestNetworkInterfaces : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<long> ipv6AddressCount{};
  shared_ptr<string> networkInterfaceTrafficMode{};
  shared_ptr<vector<string>> securityGroupIds{};

  ModifyScalingConfigurationRequestNetworkInterfaces() {}

  explicit ModifyScalingConfigurationRequestNetworkInterfaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ipv6AddressCount) {
      res["Ipv6AddressCount"] = boost::any(*ipv6AddressCount);
    }
    if (networkInterfaceTrafficMode) {
      res["NetworkInterfaceTrafficMode"] = boost::any(*networkInterfaceTrafficMode);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ipv6AddressCount") != m.end() && !m["Ipv6AddressCount"].empty()) {
      ipv6AddressCount = make_shared<long>(boost::any_cast<long>(m["Ipv6AddressCount"]));
    }
    if (m.find("NetworkInterfaceTrafficMode") != m.end() && !m["NetworkInterfaceTrafficMode"].empty()) {
      networkInterfaceTrafficMode = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceTrafficMode"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyScalingConfigurationRequestNetworkInterfaces() = default;
};
class ModifyScalingConfigurationRequestSecurityOptions : public Darabonba::Model {
public:
  shared_ptr<string> confidentialComputingMode{};

  ModifyScalingConfigurationRequestSecurityOptions() {}

  explicit ModifyScalingConfigurationRequestSecurityOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (confidentialComputingMode) {
      res["ConfidentialComputingMode"] = boost::any(*confidentialComputingMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfidentialComputingMode") != m.end() && !m["ConfidentialComputingMode"].empty()) {
      confidentialComputingMode = make_shared<string>(boost::any_cast<string>(m["ConfidentialComputingMode"]));
    }
  }


  virtual ~ModifyScalingConfigurationRequestSecurityOptions() = default;
};
class ModifyScalingConfigurationRequestSpotPriceLimits : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<double> priceLimit{};

  ModifyScalingConfigurationRequestSpotPriceLimits() {}

  explicit ModifyScalingConfigurationRequestSpotPriceLimits(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (priceLimit) {
      res["PriceLimit"] = boost::any(*priceLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("PriceLimit") != m.end() && !m["PriceLimit"].empty()) {
      priceLimit = make_shared<double>(boost::any_cast<double>(m["PriceLimit"]));
    }
  }


  virtual ~ModifyScalingConfigurationRequestSpotPriceLimits() = default;
};
class ModifyScalingConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<ModifyScalingConfigurationRequestImageOptions> imageOptions{};
  shared_ptr<ModifyScalingConfigurationRequestPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<ModifyScalingConfigurationRequestSystemDisk> systemDisk{};
  shared_ptr<string> affinity{};
  shared_ptr<long> cpu{};
  shared_ptr<string> creditSpecification{};
  shared_ptr<vector<ModifyScalingConfigurationRequestCustomPriorities>> customPriorities{};
  shared_ptr<vector<ModifyScalingConfigurationRequestDataDisks>> dataDisks{};
  shared_ptr<string> dedicatedHostClusterId{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<bool> deletionProtection{};
  shared_ptr<string> deploymentSetId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> hpcClusterId{};
  shared_ptr<string> httpEndpoint{};
  shared_ptr<string> httpTokens{};
  shared_ptr<string> imageFamily{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<string> instanceDescription{};
  shared_ptr<string> instanceName{};
  shared_ptr<vector<ModifyScalingConfigurationRequestInstancePatternInfos>> instancePatternInfos{};
  shared_ptr<vector<ModifyScalingConfigurationRequestInstanceTypeOverrides>> instanceTypeOverrides{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidthIn{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> ioOptimized{};
  shared_ptr<long> ipv6AddressCount{};
  shared_ptr<string> keyPairName{};
  shared_ptr<long> loadBalancerWeight{};
  shared_ptr<long> memory{};
  shared_ptr<vector<ModifyScalingConfigurationRequestNetworkInterfaces>> networkInterfaces{};
  shared_ptr<bool> override{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> password{};
  shared_ptr<bool> passwordInherit{};
  shared_ptr<string> ramRoleName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingConfigurationId{};
  shared_ptr<string> scalingConfigurationName{};
  shared_ptr<map<string, boost::any>> schedulerOptions{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<ModifyScalingConfigurationRequestSecurityOptions> securityOptions{};
  shared_ptr<long> spotDuration{};
  shared_ptr<string> spotInterruptionBehavior{};
  shared_ptr<vector<ModifyScalingConfigurationRequestSpotPriceLimits>> spotPriceLimits{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<string> storageSetId{};
  shared_ptr<long> storageSetPartitionNumber{};
  shared_ptr<vector<string>> systemDiskCategories{};
  shared_ptr<string> tags{};
  shared_ptr<string> tenancy{};
  shared_ptr<string> userData{};
  shared_ptr<string> zoneId{};

  ModifyScalingConfigurationRequest() {}

  explicit ModifyScalingConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageOptions) {
      res["ImageOptions"] = imageOptions ? boost::any(imageOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (privatePoolOptions) {
      res["PrivatePoolOptions"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (affinity) {
      res["Affinity"] = boost::any(*affinity);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (creditSpecification) {
      res["CreditSpecification"] = boost::any(*creditSpecification);
    }
    if (customPriorities) {
      vector<boost::any> temp1;
      for(auto item1:*customPriorities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomPriorities"] = boost::any(temp1);
    }
    if (dataDisks) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisks"] = boost::any(temp1);
    }
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (deletionProtection) {
      res["DeletionProtection"] = boost::any(*deletionProtection);
    }
    if (deploymentSetId) {
      res["DeploymentSetId"] = boost::any(*deploymentSetId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (hpcClusterId) {
      res["HpcClusterId"] = boost::any(*hpcClusterId);
    }
    if (httpEndpoint) {
      res["HttpEndpoint"] = boost::any(*httpEndpoint);
    }
    if (httpTokens) {
      res["HttpTokens"] = boost::any(*httpTokens);
    }
    if (imageFamily) {
      res["ImageFamily"] = boost::any(*imageFamily);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (instanceDescription) {
      res["InstanceDescription"] = boost::any(*instanceDescription);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instancePatternInfos) {
      vector<boost::any> temp1;
      for(auto item1:*instancePatternInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstancePatternInfos"] = boost::any(temp1);
    }
    if (instanceTypeOverrides) {
      vector<boost::any> temp1;
      for(auto item1:*instanceTypeOverrides){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceTypeOverrides"] = boost::any(temp1);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = boost::any(*instanceTypes);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidthIn) {
      res["InternetMaxBandwidthIn"] = boost::any(*internetMaxBandwidthIn);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (ipv6AddressCount) {
      res["Ipv6AddressCount"] = boost::any(*ipv6AddressCount);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (loadBalancerWeight) {
      res["LoadBalancerWeight"] = boost::any(*loadBalancerWeight);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (networkInterfaces) {
      vector<boost::any> temp1;
      for(auto item1:*networkInterfaces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkInterfaces"] = boost::any(temp1);
    }
    if (override) {
      res["Override"] = boost::any(*override);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (passwordInherit) {
      res["PasswordInherit"] = boost::any(*passwordInherit);
    }
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingConfigurationId) {
      res["ScalingConfigurationId"] = boost::any(*scalingConfigurationId);
    }
    if (scalingConfigurationName) {
      res["ScalingConfigurationName"] = boost::any(*scalingConfigurationName);
    }
    if (schedulerOptions) {
      res["SchedulerOptions"] = boost::any(*schedulerOptions);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    if (securityOptions) {
      res["SecurityOptions"] = securityOptions ? boost::any(securityOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spotDuration) {
      res["SpotDuration"] = boost::any(*spotDuration);
    }
    if (spotInterruptionBehavior) {
      res["SpotInterruptionBehavior"] = boost::any(*spotInterruptionBehavior);
    }
    if (spotPriceLimits) {
      vector<boost::any> temp1;
      for(auto item1:*spotPriceLimits){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpotPriceLimits"] = boost::any(temp1);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    if (storageSetPartitionNumber) {
      res["StorageSetPartitionNumber"] = boost::any(*storageSetPartitionNumber);
    }
    if (systemDiskCategories) {
      res["SystemDiskCategories"] = boost::any(*systemDiskCategories);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (tenancy) {
      res["Tenancy"] = boost::any(*tenancy);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageOptions") != m.end() && !m["ImageOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageOptions"].type()) {
        ModifyScalingConfigurationRequestImageOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageOptions"]));
        imageOptions = make_shared<ModifyScalingConfigurationRequestImageOptions>(model1);
      }
    }
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolOptions"].type()) {
        ModifyScalingConfigurationRequestPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolOptions"]));
        privatePoolOptions = make_shared<ModifyScalingConfigurationRequestPrivatePoolOptions>(model1);
      }
    }
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        ModifyScalingConfigurationRequestSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<ModifyScalingConfigurationRequestSystemDisk>(model1);
      }
    }
    if (m.find("Affinity") != m.end() && !m["Affinity"].empty()) {
      affinity = make_shared<string>(boost::any_cast<string>(m["Affinity"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CreditSpecification") != m.end() && !m["CreditSpecification"].empty()) {
      creditSpecification = make_shared<string>(boost::any_cast<string>(m["CreditSpecification"]));
    }
    if (m.find("CustomPriorities") != m.end() && !m["CustomPriorities"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomPriorities"].type()) {
        vector<ModifyScalingConfigurationRequestCustomPriorities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomPriorities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyScalingConfigurationRequestCustomPriorities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customPriorities = make_shared<vector<ModifyScalingConfigurationRequestCustomPriorities>>(expect1);
      }
    }
    if (m.find("DataDisks") != m.end() && !m["DataDisks"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisks"].type()) {
        vector<ModifyScalingConfigurationRequestDataDisks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyScalingConfigurationRequestDataDisks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisks = make_shared<vector<ModifyScalingConfigurationRequestDataDisks>>(expect1);
      }
    }
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("DeletionProtection") != m.end() && !m["DeletionProtection"].empty()) {
      deletionProtection = make_shared<bool>(boost::any_cast<bool>(m["DeletionProtection"]));
    }
    if (m.find("DeploymentSetId") != m.end() && !m["DeploymentSetId"].empty()) {
      deploymentSetId = make_shared<string>(boost::any_cast<string>(m["DeploymentSetId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("HpcClusterId") != m.end() && !m["HpcClusterId"].empty()) {
      hpcClusterId = make_shared<string>(boost::any_cast<string>(m["HpcClusterId"]));
    }
    if (m.find("HttpEndpoint") != m.end() && !m["HttpEndpoint"].empty()) {
      httpEndpoint = make_shared<string>(boost::any_cast<string>(m["HttpEndpoint"]));
    }
    if (m.find("HttpTokens") != m.end() && !m["HttpTokens"].empty()) {
      httpTokens = make_shared<string>(boost::any_cast<string>(m["HttpTokens"]));
    }
    if (m.find("ImageFamily") != m.end() && !m["ImageFamily"].empty()) {
      imageFamily = make_shared<string>(boost::any_cast<string>(m["ImageFamily"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("InstanceDescription") != m.end() && !m["InstanceDescription"].empty()) {
      instanceDescription = make_shared<string>(boost::any_cast<string>(m["InstanceDescription"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstancePatternInfos") != m.end() && !m["InstancePatternInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["InstancePatternInfos"].type()) {
        vector<ModifyScalingConfigurationRequestInstancePatternInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstancePatternInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyScalingConfigurationRequestInstancePatternInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instancePatternInfos = make_shared<vector<ModifyScalingConfigurationRequestInstancePatternInfos>>(expect1);
      }
    }
    if (m.find("InstanceTypeOverrides") != m.end() && !m["InstanceTypeOverrides"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceTypeOverrides"].type()) {
        vector<ModifyScalingConfigurationRequestInstanceTypeOverrides> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceTypeOverrides"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyScalingConfigurationRequestInstanceTypeOverrides model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceTypeOverrides = make_shared<vector<ModifyScalingConfigurationRequestInstanceTypeOverrides>>(expect1);
      }
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("InternetMaxBandwidthIn") != m.end() && !m["InternetMaxBandwidthIn"].empty()) {
      internetMaxBandwidthIn = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthIn"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("Ipv6AddressCount") != m.end() && !m["Ipv6AddressCount"].empty()) {
      ipv6AddressCount = make_shared<long>(boost::any_cast<long>(m["Ipv6AddressCount"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("LoadBalancerWeight") != m.end() && !m["LoadBalancerWeight"].empty()) {
      loadBalancerWeight = make_shared<long>(boost::any_cast<long>(m["LoadBalancerWeight"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("NetworkInterfaces") != m.end() && !m["NetworkInterfaces"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkInterfaces"].type()) {
        vector<ModifyScalingConfigurationRequestNetworkInterfaces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkInterfaces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyScalingConfigurationRequestNetworkInterfaces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkInterfaces = make_shared<vector<ModifyScalingConfigurationRequestNetworkInterfaces>>(expect1);
      }
    }
    if (m.find("Override") != m.end() && !m["Override"].empty()) {
      override = make_shared<bool>(boost::any_cast<bool>(m["Override"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("PasswordInherit") != m.end() && !m["PasswordInherit"].empty()) {
      passwordInherit = make_shared<bool>(boost::any_cast<bool>(m["PasswordInherit"]));
    }
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingConfigurationId") != m.end() && !m["ScalingConfigurationId"].empty()) {
      scalingConfigurationId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationId"]));
    }
    if (m.find("ScalingConfigurationName") != m.end() && !m["ScalingConfigurationName"].empty()) {
      scalingConfigurationName = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationName"]));
    }
    if (m.find("SchedulerOptions") != m.end() && !m["SchedulerOptions"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SchedulerOptions"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      schedulerOptions = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SecurityOptions") != m.end() && !m["SecurityOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityOptions"].type()) {
        ModifyScalingConfigurationRequestSecurityOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityOptions"]));
        securityOptions = make_shared<ModifyScalingConfigurationRequestSecurityOptions>(model1);
      }
    }
    if (m.find("SpotDuration") != m.end() && !m["SpotDuration"].empty()) {
      spotDuration = make_shared<long>(boost::any_cast<long>(m["SpotDuration"]));
    }
    if (m.find("SpotInterruptionBehavior") != m.end() && !m["SpotInterruptionBehavior"].empty()) {
      spotInterruptionBehavior = make_shared<string>(boost::any_cast<string>(m["SpotInterruptionBehavior"]));
    }
    if (m.find("SpotPriceLimits") != m.end() && !m["SpotPriceLimits"].empty()) {
      if (typeid(vector<boost::any>) == m["SpotPriceLimits"].type()) {
        vector<ModifyScalingConfigurationRequestSpotPriceLimits> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpotPriceLimits"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyScalingConfigurationRequestSpotPriceLimits model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spotPriceLimits = make_shared<vector<ModifyScalingConfigurationRequestSpotPriceLimits>>(expect1);
      }
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
    if (m.find("StorageSetPartitionNumber") != m.end() && !m["StorageSetPartitionNumber"].empty()) {
      storageSetPartitionNumber = make_shared<long>(boost::any_cast<long>(m["StorageSetPartitionNumber"]));
    }
    if (m.find("SystemDiskCategories") != m.end() && !m["SystemDiskCategories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SystemDiskCategories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SystemDiskCategories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      systemDiskCategories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Tenancy") != m.end() && !m["Tenancy"].empty()) {
      tenancy = make_shared<string>(boost::any_cast<string>(m["Tenancy"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~ModifyScalingConfigurationRequest() = default;
};
class ModifyScalingConfigurationShrinkRequestImageOptions : public Darabonba::Model {
public:
  shared_ptr<bool> loginAsNonRoot{};

  ModifyScalingConfigurationShrinkRequestImageOptions() {}

  explicit ModifyScalingConfigurationShrinkRequestImageOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loginAsNonRoot) {
      res["LoginAsNonRoot"] = boost::any(*loginAsNonRoot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoginAsNonRoot") != m.end() && !m["LoginAsNonRoot"].empty()) {
      loginAsNonRoot = make_shared<bool>(boost::any_cast<bool>(m["LoginAsNonRoot"]));
    }
  }


  virtual ~ModifyScalingConfigurationShrinkRequestImageOptions() = default;
};
class ModifyScalingConfigurationShrinkRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> matchCriteria{};

  ModifyScalingConfigurationShrinkRequestPrivatePoolOptions() {}

  explicit ModifyScalingConfigurationShrinkRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (matchCriteria) {
      res["MatchCriteria"] = boost::any(*matchCriteria);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MatchCriteria") != m.end() && !m["MatchCriteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["MatchCriteria"]));
    }
  }


  virtual ~ModifyScalingConfigurationShrinkRequestPrivatePoolOptions() = default;
};
class ModifyScalingConfigurationShrinkRequestSystemDisk : public Darabonba::Model {
public:
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<bool> burstingEnabled{};
  shared_ptr<string> category{};
  shared_ptr<string> description{};
  shared_ptr<string> diskName{};
  shared_ptr<string> encryptAlgorithm{};
  shared_ptr<bool> encrypted{};
  shared_ptr<string> KMSKeyId{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<long> provisionedIops{};
  shared_ptr<long> size{};

  ModifyScalingConfigurationShrinkRequestSystemDisk() {}

  explicit ModifyScalingConfigurationShrinkRequestSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoSnapshotPolicyId) {
      res["AutoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    if (burstingEnabled) {
      res["BurstingEnabled"] = boost::any(*burstingEnabled);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (encryptAlgorithm) {
      res["EncryptAlgorithm"] = boost::any(*encryptAlgorithm);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (provisionedIops) {
      res["ProvisionedIops"] = boost::any(*provisionedIops);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoSnapshotPolicyId") != m.end() && !m["AutoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["AutoSnapshotPolicyId"]));
    }
    if (m.find("BurstingEnabled") != m.end() && !m["BurstingEnabled"].empty()) {
      burstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["BurstingEnabled"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("EncryptAlgorithm") != m.end() && !m["EncryptAlgorithm"].empty()) {
      encryptAlgorithm = make_shared<string>(boost::any_cast<string>(m["EncryptAlgorithm"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<bool>(boost::any_cast<bool>(m["Encrypted"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("ProvisionedIops") != m.end() && !m["ProvisionedIops"].empty()) {
      provisionedIops = make_shared<long>(boost::any_cast<long>(m["ProvisionedIops"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~ModifyScalingConfigurationShrinkRequestSystemDisk() = default;
};
class ModifyScalingConfigurationShrinkRequestCustomPriorities : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<string> vswitchId{};

  ModifyScalingConfigurationShrinkRequestCustomPriorities() {}

  explicit ModifyScalingConfigurationShrinkRequestCustomPriorities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~ModifyScalingConfigurationShrinkRequestCustomPriorities() = default;
};
class ModifyScalingConfigurationShrinkRequestDataDisks : public Darabonba::Model {
public:
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<bool> burstingEnabled{};
  shared_ptr<vector<string>> categories{};
  shared_ptr<string> category{};
  shared_ptr<bool> deleteWithInstance{};
  shared_ptr<string> description{};
  shared_ptr<string> device{};
  shared_ptr<string> diskName{};
  shared_ptr<string> encrypted{};
  shared_ptr<string> KMSKeyId{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<long> provisionedIops{};
  shared_ptr<long> size{};
  shared_ptr<string> snapshotId{};

  ModifyScalingConfigurationShrinkRequestDataDisks() {}

  explicit ModifyScalingConfigurationShrinkRequestDataDisks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoSnapshotPolicyId) {
      res["AutoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    if (burstingEnabled) {
      res["BurstingEnabled"] = boost::any(*burstingEnabled);
    }
    if (categories) {
      res["Categories"] = boost::any(*categories);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (provisionedIops) {
      res["ProvisionedIops"] = boost::any(*provisionedIops);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoSnapshotPolicyId") != m.end() && !m["AutoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["AutoSnapshotPolicyId"]));
    }
    if (m.find("BurstingEnabled") != m.end() && !m["BurstingEnabled"].empty()) {
      burstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["BurstingEnabled"]));
    }
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Categories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      categories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<bool>(boost::any_cast<bool>(m["DeleteWithInstance"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<string>(boost::any_cast<string>(m["Encrypted"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("ProvisionedIops") != m.end() && !m["ProvisionedIops"].empty()) {
      provisionedIops = make_shared<long>(boost::any_cast<long>(m["ProvisionedIops"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
  }


  virtual ~ModifyScalingConfigurationShrinkRequestDataDisks() = default;
};
class ModifyScalingConfigurationShrinkRequestInstancePatternInfos : public Darabonba::Model {
public:
  shared_ptr<vector<string>> architectures{};
  shared_ptr<string> burstablePerformance{};
  shared_ptr<long> cores{};
  shared_ptr<vector<string>> cpuArchitectures{};
  shared_ptr<vector<string>> excludedInstanceTypes{};
  shared_ptr<vector<string>> gpuSpecs{};
  shared_ptr<vector<string>> instanceCategories{};
  shared_ptr<string> instanceFamilyLevel{};
  shared_ptr<vector<string>> instanceTypeFamilies{};
  shared_ptr<double> maxPrice{};
  shared_ptr<long> maximumCpuCoreCount{};
  shared_ptr<long> maximumGpuAmount{};
  shared_ptr<double> maximumMemorySize{};
  shared_ptr<double> memory{};
  shared_ptr<long> minimumBaselineCredit{};
  shared_ptr<long> minimumCpuCoreCount{};
  shared_ptr<long> minimumEniIpv6AddressQuantity{};
  shared_ptr<long> minimumEniPrivateIpAddressQuantity{};
  shared_ptr<long> minimumEniQuantity{};
  shared_ptr<long> minimumGpuAmount{};
  shared_ptr<long> minimumInitialCredit{};
  shared_ptr<double> minimumMemorySize{};
  shared_ptr<vector<string>> physicalProcessorModels{};

  ModifyScalingConfigurationShrinkRequestInstancePatternInfos() {}

  explicit ModifyScalingConfigurationShrinkRequestInstancePatternInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architectures) {
      res["Architectures"] = boost::any(*architectures);
    }
    if (burstablePerformance) {
      res["BurstablePerformance"] = boost::any(*burstablePerformance);
    }
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (cpuArchitectures) {
      res["CpuArchitectures"] = boost::any(*cpuArchitectures);
    }
    if (excludedInstanceTypes) {
      res["ExcludedInstanceTypes"] = boost::any(*excludedInstanceTypes);
    }
    if (gpuSpecs) {
      res["GpuSpecs"] = boost::any(*gpuSpecs);
    }
    if (instanceCategories) {
      res["InstanceCategories"] = boost::any(*instanceCategories);
    }
    if (instanceFamilyLevel) {
      res["InstanceFamilyLevel"] = boost::any(*instanceFamilyLevel);
    }
    if (instanceTypeFamilies) {
      res["InstanceTypeFamilies"] = boost::any(*instanceTypeFamilies);
    }
    if (maxPrice) {
      res["MaxPrice"] = boost::any(*maxPrice);
    }
    if (maximumCpuCoreCount) {
      res["MaximumCpuCoreCount"] = boost::any(*maximumCpuCoreCount);
    }
    if (maximumGpuAmount) {
      res["MaximumGpuAmount"] = boost::any(*maximumGpuAmount);
    }
    if (maximumMemorySize) {
      res["MaximumMemorySize"] = boost::any(*maximumMemorySize);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (minimumBaselineCredit) {
      res["MinimumBaselineCredit"] = boost::any(*minimumBaselineCredit);
    }
    if (minimumCpuCoreCount) {
      res["MinimumCpuCoreCount"] = boost::any(*minimumCpuCoreCount);
    }
    if (minimumEniIpv6AddressQuantity) {
      res["MinimumEniIpv6AddressQuantity"] = boost::any(*minimumEniIpv6AddressQuantity);
    }
    if (minimumEniPrivateIpAddressQuantity) {
      res["MinimumEniPrivateIpAddressQuantity"] = boost::any(*minimumEniPrivateIpAddressQuantity);
    }
    if (minimumEniQuantity) {
      res["MinimumEniQuantity"] = boost::any(*minimumEniQuantity);
    }
    if (minimumGpuAmount) {
      res["MinimumGpuAmount"] = boost::any(*minimumGpuAmount);
    }
    if (minimumInitialCredit) {
      res["MinimumInitialCredit"] = boost::any(*minimumInitialCredit);
    }
    if (minimumMemorySize) {
      res["MinimumMemorySize"] = boost::any(*minimumMemorySize);
    }
    if (physicalProcessorModels) {
      res["PhysicalProcessorModels"] = boost::any(*physicalProcessorModels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Architectures") != m.end() && !m["Architectures"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Architectures"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Architectures"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      architectures = make_shared<vector<string>>(toVec1);
    }
    if (m.find("BurstablePerformance") != m.end() && !m["BurstablePerformance"].empty()) {
      burstablePerformance = make_shared<string>(boost::any_cast<string>(m["BurstablePerformance"]));
    }
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("CpuArchitectures") != m.end() && !m["CpuArchitectures"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CpuArchitectures"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CpuArchitectures"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cpuArchitectures = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExcludedInstanceTypes") != m.end() && !m["ExcludedInstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludedInstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludedInstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludedInstanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GpuSpecs") != m.end() && !m["GpuSpecs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GpuSpecs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GpuSpecs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      gpuSpecs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceCategories") != m.end() && !m["InstanceCategories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceCategories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceCategories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceCategories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceFamilyLevel") != m.end() && !m["InstanceFamilyLevel"].empty()) {
      instanceFamilyLevel = make_shared<string>(boost::any_cast<string>(m["InstanceFamilyLevel"]));
    }
    if (m.find("InstanceTypeFamilies") != m.end() && !m["InstanceTypeFamilies"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypeFamilies"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypeFamilies"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypeFamilies = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxPrice") != m.end() && !m["MaxPrice"].empty()) {
      maxPrice = make_shared<double>(boost::any_cast<double>(m["MaxPrice"]));
    }
    if (m.find("MaximumCpuCoreCount") != m.end() && !m["MaximumCpuCoreCount"].empty()) {
      maximumCpuCoreCount = make_shared<long>(boost::any_cast<long>(m["MaximumCpuCoreCount"]));
    }
    if (m.find("MaximumGpuAmount") != m.end() && !m["MaximumGpuAmount"].empty()) {
      maximumGpuAmount = make_shared<long>(boost::any_cast<long>(m["MaximumGpuAmount"]));
    }
    if (m.find("MaximumMemorySize") != m.end() && !m["MaximumMemorySize"].empty()) {
      maximumMemorySize = make_shared<double>(boost::any_cast<double>(m["MaximumMemorySize"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("MinimumBaselineCredit") != m.end() && !m["MinimumBaselineCredit"].empty()) {
      minimumBaselineCredit = make_shared<long>(boost::any_cast<long>(m["MinimumBaselineCredit"]));
    }
    if (m.find("MinimumCpuCoreCount") != m.end() && !m["MinimumCpuCoreCount"].empty()) {
      minimumCpuCoreCount = make_shared<long>(boost::any_cast<long>(m["MinimumCpuCoreCount"]));
    }
    if (m.find("MinimumEniIpv6AddressQuantity") != m.end() && !m["MinimumEniIpv6AddressQuantity"].empty()) {
      minimumEniIpv6AddressQuantity = make_shared<long>(boost::any_cast<long>(m["MinimumEniIpv6AddressQuantity"]));
    }
    if (m.find("MinimumEniPrivateIpAddressQuantity") != m.end() && !m["MinimumEniPrivateIpAddressQuantity"].empty()) {
      minimumEniPrivateIpAddressQuantity = make_shared<long>(boost::any_cast<long>(m["MinimumEniPrivateIpAddressQuantity"]));
    }
    if (m.find("MinimumEniQuantity") != m.end() && !m["MinimumEniQuantity"].empty()) {
      minimumEniQuantity = make_shared<long>(boost::any_cast<long>(m["MinimumEniQuantity"]));
    }
    if (m.find("MinimumGpuAmount") != m.end() && !m["MinimumGpuAmount"].empty()) {
      minimumGpuAmount = make_shared<long>(boost::any_cast<long>(m["MinimumGpuAmount"]));
    }
    if (m.find("MinimumInitialCredit") != m.end() && !m["MinimumInitialCredit"].empty()) {
      minimumInitialCredit = make_shared<long>(boost::any_cast<long>(m["MinimumInitialCredit"]));
    }
    if (m.find("MinimumMemorySize") != m.end() && !m["MinimumMemorySize"].empty()) {
      minimumMemorySize = make_shared<double>(boost::any_cast<double>(m["MinimumMemorySize"]));
    }
    if (m.find("PhysicalProcessorModels") != m.end() && !m["PhysicalProcessorModels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PhysicalProcessorModels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PhysicalProcessorModels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      physicalProcessorModels = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyScalingConfigurationShrinkRequestInstancePatternInfos() = default;
};
class ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<long> weightedCapacity{};

  ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides() {}

  explicit ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (weightedCapacity) {
      res["WeightedCapacity"] = boost::any(*weightedCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("WeightedCapacity") != m.end() && !m["WeightedCapacity"].empty()) {
      weightedCapacity = make_shared<long>(boost::any_cast<long>(m["WeightedCapacity"]));
    }
  }


  virtual ~ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides() = default;
};
class ModifyScalingConfigurationShrinkRequestNetworkInterfaces : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<long> ipv6AddressCount{};
  shared_ptr<string> networkInterfaceTrafficMode{};
  shared_ptr<vector<string>> securityGroupIds{};

  ModifyScalingConfigurationShrinkRequestNetworkInterfaces() {}

  explicit ModifyScalingConfigurationShrinkRequestNetworkInterfaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ipv6AddressCount) {
      res["Ipv6AddressCount"] = boost::any(*ipv6AddressCount);
    }
    if (networkInterfaceTrafficMode) {
      res["NetworkInterfaceTrafficMode"] = boost::any(*networkInterfaceTrafficMode);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ipv6AddressCount") != m.end() && !m["Ipv6AddressCount"].empty()) {
      ipv6AddressCount = make_shared<long>(boost::any_cast<long>(m["Ipv6AddressCount"]));
    }
    if (m.find("NetworkInterfaceTrafficMode") != m.end() && !m["NetworkInterfaceTrafficMode"].empty()) {
      networkInterfaceTrafficMode = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceTrafficMode"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyScalingConfigurationShrinkRequestNetworkInterfaces() = default;
};
class ModifyScalingConfigurationShrinkRequestSecurityOptions : public Darabonba::Model {
public:
  shared_ptr<string> confidentialComputingMode{};

  ModifyScalingConfigurationShrinkRequestSecurityOptions() {}

  explicit ModifyScalingConfigurationShrinkRequestSecurityOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (confidentialComputingMode) {
      res["ConfidentialComputingMode"] = boost::any(*confidentialComputingMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfidentialComputingMode") != m.end() && !m["ConfidentialComputingMode"].empty()) {
      confidentialComputingMode = make_shared<string>(boost::any_cast<string>(m["ConfidentialComputingMode"]));
    }
  }


  virtual ~ModifyScalingConfigurationShrinkRequestSecurityOptions() = default;
};
class ModifyScalingConfigurationShrinkRequestSpotPriceLimits : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<double> priceLimit{};

  ModifyScalingConfigurationShrinkRequestSpotPriceLimits() {}

  explicit ModifyScalingConfigurationShrinkRequestSpotPriceLimits(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (priceLimit) {
      res["PriceLimit"] = boost::any(*priceLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("PriceLimit") != m.end() && !m["PriceLimit"].empty()) {
      priceLimit = make_shared<double>(boost::any_cast<double>(m["PriceLimit"]));
    }
  }


  virtual ~ModifyScalingConfigurationShrinkRequestSpotPriceLimits() = default;
};
class ModifyScalingConfigurationShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<ModifyScalingConfigurationShrinkRequestImageOptions> imageOptions{};
  shared_ptr<ModifyScalingConfigurationShrinkRequestPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<ModifyScalingConfigurationShrinkRequestSystemDisk> systemDisk{};
  shared_ptr<string> affinity{};
  shared_ptr<long> cpu{};
  shared_ptr<string> creditSpecification{};
  shared_ptr<vector<ModifyScalingConfigurationShrinkRequestCustomPriorities>> customPriorities{};
  shared_ptr<vector<ModifyScalingConfigurationShrinkRequestDataDisks>> dataDisks{};
  shared_ptr<string> dedicatedHostClusterId{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<bool> deletionProtection{};
  shared_ptr<string> deploymentSetId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> hpcClusterId{};
  shared_ptr<string> httpEndpoint{};
  shared_ptr<string> httpTokens{};
  shared_ptr<string> imageFamily{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<string> instanceDescription{};
  shared_ptr<string> instanceName{};
  shared_ptr<vector<ModifyScalingConfigurationShrinkRequestInstancePatternInfos>> instancePatternInfos{};
  shared_ptr<vector<ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides>> instanceTypeOverrides{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidthIn{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> ioOptimized{};
  shared_ptr<long> ipv6AddressCount{};
  shared_ptr<string> keyPairName{};
  shared_ptr<long> loadBalancerWeight{};
  shared_ptr<long> memory{};
  shared_ptr<vector<ModifyScalingConfigurationShrinkRequestNetworkInterfaces>> networkInterfaces{};
  shared_ptr<bool> override{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> password{};
  shared_ptr<bool> passwordInherit{};
  shared_ptr<string> ramRoleName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingConfigurationId{};
  shared_ptr<string> scalingConfigurationName{};
  shared_ptr<string> schedulerOptionsShrink{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<ModifyScalingConfigurationShrinkRequestSecurityOptions> securityOptions{};
  shared_ptr<long> spotDuration{};
  shared_ptr<string> spotInterruptionBehavior{};
  shared_ptr<vector<ModifyScalingConfigurationShrinkRequestSpotPriceLimits>> spotPriceLimits{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<string> storageSetId{};
  shared_ptr<long> storageSetPartitionNumber{};
  shared_ptr<vector<string>> systemDiskCategories{};
  shared_ptr<string> tags{};
  shared_ptr<string> tenancy{};
  shared_ptr<string> userData{};
  shared_ptr<string> zoneId{};

  ModifyScalingConfigurationShrinkRequest() {}

  explicit ModifyScalingConfigurationShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageOptions) {
      res["ImageOptions"] = imageOptions ? boost::any(imageOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (privatePoolOptions) {
      res["PrivatePoolOptions"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (affinity) {
      res["Affinity"] = boost::any(*affinity);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (creditSpecification) {
      res["CreditSpecification"] = boost::any(*creditSpecification);
    }
    if (customPriorities) {
      vector<boost::any> temp1;
      for(auto item1:*customPriorities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomPriorities"] = boost::any(temp1);
    }
    if (dataDisks) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisks"] = boost::any(temp1);
    }
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (deletionProtection) {
      res["DeletionProtection"] = boost::any(*deletionProtection);
    }
    if (deploymentSetId) {
      res["DeploymentSetId"] = boost::any(*deploymentSetId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (hpcClusterId) {
      res["HpcClusterId"] = boost::any(*hpcClusterId);
    }
    if (httpEndpoint) {
      res["HttpEndpoint"] = boost::any(*httpEndpoint);
    }
    if (httpTokens) {
      res["HttpTokens"] = boost::any(*httpTokens);
    }
    if (imageFamily) {
      res["ImageFamily"] = boost::any(*imageFamily);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (instanceDescription) {
      res["InstanceDescription"] = boost::any(*instanceDescription);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instancePatternInfos) {
      vector<boost::any> temp1;
      for(auto item1:*instancePatternInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstancePatternInfos"] = boost::any(temp1);
    }
    if (instanceTypeOverrides) {
      vector<boost::any> temp1;
      for(auto item1:*instanceTypeOverrides){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceTypeOverrides"] = boost::any(temp1);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = boost::any(*instanceTypes);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidthIn) {
      res["InternetMaxBandwidthIn"] = boost::any(*internetMaxBandwidthIn);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (ipv6AddressCount) {
      res["Ipv6AddressCount"] = boost::any(*ipv6AddressCount);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (loadBalancerWeight) {
      res["LoadBalancerWeight"] = boost::any(*loadBalancerWeight);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (networkInterfaces) {
      vector<boost::any> temp1;
      for(auto item1:*networkInterfaces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkInterfaces"] = boost::any(temp1);
    }
    if (override) {
      res["Override"] = boost::any(*override);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (passwordInherit) {
      res["PasswordInherit"] = boost::any(*passwordInherit);
    }
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingConfigurationId) {
      res["ScalingConfigurationId"] = boost::any(*scalingConfigurationId);
    }
    if (scalingConfigurationName) {
      res["ScalingConfigurationName"] = boost::any(*scalingConfigurationName);
    }
    if (schedulerOptionsShrink) {
      res["SchedulerOptions"] = boost::any(*schedulerOptionsShrink);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    if (securityOptions) {
      res["SecurityOptions"] = securityOptions ? boost::any(securityOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spotDuration) {
      res["SpotDuration"] = boost::any(*spotDuration);
    }
    if (spotInterruptionBehavior) {
      res["SpotInterruptionBehavior"] = boost::any(*spotInterruptionBehavior);
    }
    if (spotPriceLimits) {
      vector<boost::any> temp1;
      for(auto item1:*spotPriceLimits){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpotPriceLimits"] = boost::any(temp1);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    if (storageSetPartitionNumber) {
      res["StorageSetPartitionNumber"] = boost::any(*storageSetPartitionNumber);
    }
    if (systemDiskCategories) {
      res["SystemDiskCategories"] = boost::any(*systemDiskCategories);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (tenancy) {
      res["Tenancy"] = boost::any(*tenancy);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageOptions") != m.end() && !m["ImageOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageOptions"].type()) {
        ModifyScalingConfigurationShrinkRequestImageOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageOptions"]));
        imageOptions = make_shared<ModifyScalingConfigurationShrinkRequestImageOptions>(model1);
      }
    }
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolOptions"].type()) {
        ModifyScalingConfigurationShrinkRequestPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolOptions"]));
        privatePoolOptions = make_shared<ModifyScalingConfigurationShrinkRequestPrivatePoolOptions>(model1);
      }
    }
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        ModifyScalingConfigurationShrinkRequestSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<ModifyScalingConfigurationShrinkRequestSystemDisk>(model1);
      }
    }
    if (m.find("Affinity") != m.end() && !m["Affinity"].empty()) {
      affinity = make_shared<string>(boost::any_cast<string>(m["Affinity"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CreditSpecification") != m.end() && !m["CreditSpecification"].empty()) {
      creditSpecification = make_shared<string>(boost::any_cast<string>(m["CreditSpecification"]));
    }
    if (m.find("CustomPriorities") != m.end() && !m["CustomPriorities"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomPriorities"].type()) {
        vector<ModifyScalingConfigurationShrinkRequestCustomPriorities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomPriorities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyScalingConfigurationShrinkRequestCustomPriorities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customPriorities = make_shared<vector<ModifyScalingConfigurationShrinkRequestCustomPriorities>>(expect1);
      }
    }
    if (m.find("DataDisks") != m.end() && !m["DataDisks"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisks"].type()) {
        vector<ModifyScalingConfigurationShrinkRequestDataDisks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyScalingConfigurationShrinkRequestDataDisks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisks = make_shared<vector<ModifyScalingConfigurationShrinkRequestDataDisks>>(expect1);
      }
    }
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("DeletionProtection") != m.end() && !m["DeletionProtection"].empty()) {
      deletionProtection = make_shared<bool>(boost::any_cast<bool>(m["DeletionProtection"]));
    }
    if (m.find("DeploymentSetId") != m.end() && !m["DeploymentSetId"].empty()) {
      deploymentSetId = make_shared<string>(boost::any_cast<string>(m["DeploymentSetId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("HpcClusterId") != m.end() && !m["HpcClusterId"].empty()) {
      hpcClusterId = make_shared<string>(boost::any_cast<string>(m["HpcClusterId"]));
    }
    if (m.find("HttpEndpoint") != m.end() && !m["HttpEndpoint"].empty()) {
      httpEndpoint = make_shared<string>(boost::any_cast<string>(m["HttpEndpoint"]));
    }
    if (m.find("HttpTokens") != m.end() && !m["HttpTokens"].empty()) {
      httpTokens = make_shared<string>(boost::any_cast<string>(m["HttpTokens"]));
    }
    if (m.find("ImageFamily") != m.end() && !m["ImageFamily"].empty()) {
      imageFamily = make_shared<string>(boost::any_cast<string>(m["ImageFamily"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("InstanceDescription") != m.end() && !m["InstanceDescription"].empty()) {
      instanceDescription = make_shared<string>(boost::any_cast<string>(m["InstanceDescription"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstancePatternInfos") != m.end() && !m["InstancePatternInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["InstancePatternInfos"].type()) {
        vector<ModifyScalingConfigurationShrinkRequestInstancePatternInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstancePatternInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyScalingConfigurationShrinkRequestInstancePatternInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instancePatternInfos = make_shared<vector<ModifyScalingConfigurationShrinkRequestInstancePatternInfos>>(expect1);
      }
    }
    if (m.find("InstanceTypeOverrides") != m.end() && !m["InstanceTypeOverrides"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceTypeOverrides"].type()) {
        vector<ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceTypeOverrides"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceTypeOverrides = make_shared<vector<ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides>>(expect1);
      }
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("InternetMaxBandwidthIn") != m.end() && !m["InternetMaxBandwidthIn"].empty()) {
      internetMaxBandwidthIn = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthIn"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("Ipv6AddressCount") != m.end() && !m["Ipv6AddressCount"].empty()) {
      ipv6AddressCount = make_shared<long>(boost::any_cast<long>(m["Ipv6AddressCount"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("LoadBalancerWeight") != m.end() && !m["LoadBalancerWeight"].empty()) {
      loadBalancerWeight = make_shared<long>(boost::any_cast<long>(m["LoadBalancerWeight"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("NetworkInterfaces") != m.end() && !m["NetworkInterfaces"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkInterfaces"].type()) {
        vector<ModifyScalingConfigurationShrinkRequestNetworkInterfaces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkInterfaces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyScalingConfigurationShrinkRequestNetworkInterfaces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkInterfaces = make_shared<vector<ModifyScalingConfigurationShrinkRequestNetworkInterfaces>>(expect1);
      }
    }
    if (m.find("Override") != m.end() && !m["Override"].empty()) {
      override = make_shared<bool>(boost::any_cast<bool>(m["Override"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("PasswordInherit") != m.end() && !m["PasswordInherit"].empty()) {
      passwordInherit = make_shared<bool>(boost::any_cast<bool>(m["PasswordInherit"]));
    }
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingConfigurationId") != m.end() && !m["ScalingConfigurationId"].empty()) {
      scalingConfigurationId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationId"]));
    }
    if (m.find("ScalingConfigurationName") != m.end() && !m["ScalingConfigurationName"].empty()) {
      scalingConfigurationName = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationName"]));
    }
    if (m.find("SchedulerOptions") != m.end() && !m["SchedulerOptions"].empty()) {
      schedulerOptionsShrink = make_shared<string>(boost::any_cast<string>(m["SchedulerOptions"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SecurityOptions") != m.end() && !m["SecurityOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityOptions"].type()) {
        ModifyScalingConfigurationShrinkRequestSecurityOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityOptions"]));
        securityOptions = make_shared<ModifyScalingConfigurationShrinkRequestSecurityOptions>(model1);
      }
    }
    if (m.find("SpotDuration") != m.end() && !m["SpotDuration"].empty()) {
      spotDuration = make_shared<long>(boost::any_cast<long>(m["SpotDuration"]));
    }
    if (m.find("SpotInterruptionBehavior") != m.end() && !m["SpotInterruptionBehavior"].empty()) {
      spotInterruptionBehavior = make_shared<string>(boost::any_cast<string>(m["SpotInterruptionBehavior"]));
    }
    if (m.find("SpotPriceLimits") != m.end() && !m["SpotPriceLimits"].empty()) {
      if (typeid(vector<boost::any>) == m["SpotPriceLimits"].type()) {
        vector<ModifyScalingConfigurationShrinkRequestSpotPriceLimits> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpotPriceLimits"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyScalingConfigurationShrinkRequestSpotPriceLimits model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spotPriceLimits = make_shared<vector<ModifyScalingConfigurationShrinkRequestSpotPriceLimits>>(expect1);
      }
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
    if (m.find("StorageSetPartitionNumber") != m.end() && !m["StorageSetPartitionNumber"].empty()) {
      storageSetPartitionNumber = make_shared<long>(boost::any_cast<long>(m["StorageSetPartitionNumber"]));
    }
    if (m.find("SystemDiskCategories") != m.end() && !m["SystemDiskCategories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SystemDiskCategories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SystemDiskCategories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      systemDiskCategories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Tenancy") != m.end() && !m["Tenancy"].empty()) {
      tenancy = make_shared<string>(boost::any_cast<string>(m["Tenancy"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~ModifyScalingConfigurationShrinkRequest() = default;
};
class ModifyScalingConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyScalingConfigurationResponseBody() {}

  explicit ModifyScalingConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyScalingConfigurationResponseBody() = default;
};
class ModifyScalingConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyScalingConfigurationResponseBody> body{};

  ModifyScalingConfigurationResponse() {}

  explicit ModifyScalingConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyScalingConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyScalingConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyScalingConfigurationResponse() = default;
};
class ModifyScalingGroupRequestCapacityOptions : public Darabonba::Model {
public:
  shared_ptr<bool> compensateWithOnDemand{};
  shared_ptr<long> onDemandBaseCapacity{};
  shared_ptr<long> onDemandPercentageAboveBaseCapacity{};
  shared_ptr<bool> spotAutoReplaceOnDemand{};

  ModifyScalingGroupRequestCapacityOptions() {}

  explicit ModifyScalingGroupRequestCapacityOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compensateWithOnDemand) {
      res["CompensateWithOnDemand"] = boost::any(*compensateWithOnDemand);
    }
    if (onDemandBaseCapacity) {
      res["OnDemandBaseCapacity"] = boost::any(*onDemandBaseCapacity);
    }
    if (onDemandPercentageAboveBaseCapacity) {
      res["OnDemandPercentageAboveBaseCapacity"] = boost::any(*onDemandPercentageAboveBaseCapacity);
    }
    if (spotAutoReplaceOnDemand) {
      res["SpotAutoReplaceOnDemand"] = boost::any(*spotAutoReplaceOnDemand);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompensateWithOnDemand") != m.end() && !m["CompensateWithOnDemand"].empty()) {
      compensateWithOnDemand = make_shared<bool>(boost::any_cast<bool>(m["CompensateWithOnDemand"]));
    }
    if (m.find("OnDemandBaseCapacity") != m.end() && !m["OnDemandBaseCapacity"].empty()) {
      onDemandBaseCapacity = make_shared<long>(boost::any_cast<long>(m["OnDemandBaseCapacity"]));
    }
    if (m.find("OnDemandPercentageAboveBaseCapacity") != m.end() && !m["OnDemandPercentageAboveBaseCapacity"].empty()) {
      onDemandPercentageAboveBaseCapacity = make_shared<long>(boost::any_cast<long>(m["OnDemandPercentageAboveBaseCapacity"]));
    }
    if (m.find("SpotAutoReplaceOnDemand") != m.end() && !m["SpotAutoReplaceOnDemand"].empty()) {
      spotAutoReplaceOnDemand = make_shared<bool>(boost::any_cast<bool>(m["SpotAutoReplaceOnDemand"]));
    }
  }


  virtual ~ModifyScalingGroupRequestCapacityOptions() = default;
};
class ModifyScalingGroupRequestLaunchTemplateOverrides : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<double> spotPriceLimit{};
  shared_ptr<long> weightedCapacity{};

  ModifyScalingGroupRequestLaunchTemplateOverrides() {}

  explicit ModifyScalingGroupRequestLaunchTemplateOverrides(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (spotPriceLimit) {
      res["SpotPriceLimit"] = boost::any(*spotPriceLimit);
    }
    if (weightedCapacity) {
      res["WeightedCapacity"] = boost::any(*weightedCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("SpotPriceLimit") != m.end() && !m["SpotPriceLimit"].empty()) {
      spotPriceLimit = make_shared<double>(boost::any_cast<double>(m["SpotPriceLimit"]));
    }
    if (m.find("WeightedCapacity") != m.end() && !m["WeightedCapacity"].empty()) {
      weightedCapacity = make_shared<long>(boost::any_cast<long>(m["WeightedCapacity"]));
    }
  }


  virtual ~ModifyScalingGroupRequestLaunchTemplateOverrides() = default;
};
class ModifyScalingGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> activeScalingConfigurationId{};
  shared_ptr<string> allocationStrategy{};
  shared_ptr<bool> azBalance{};
  shared_ptr<ModifyScalingGroupRequestCapacityOptions> capacityOptions{};
  shared_ptr<bool> compensateWithOnDemand{};
  shared_ptr<string> customPolicyARN{};
  shared_ptr<long> defaultCooldown{};
  shared_ptr<long> desiredCapacity{};
  shared_ptr<bool> disableDesiredCapacity{};
  shared_ptr<bool> groupDeletionProtection{};
  shared_ptr<string> healthCheckType{};
  shared_ptr<vector<string>> healthCheckTypes{};
  shared_ptr<string> launchTemplateId{};
  shared_ptr<vector<ModifyScalingGroupRequestLaunchTemplateOverrides>> launchTemplateOverrides{};
  shared_ptr<string> launchTemplateVersion{};
  shared_ptr<long> maxInstanceLifetime{};
  shared_ptr<long> maxSize{};
  shared_ptr<long> minSize{};
  shared_ptr<string> multiAZPolicy{};
  shared_ptr<long> onDemandBaseCapacity{};
  shared_ptr<long> onDemandPercentageAboveBaseCapacity{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<vector<string>> removalPolicies{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> scalingGroupName{};
  shared_ptr<string> scalingPolicy{};
  shared_ptr<string> spotAllocationStrategy{};
  shared_ptr<long> spotInstancePools{};
  shared_ptr<bool> spotInstanceRemedy{};
  shared_ptr<long> stopInstanceTimeout{};
  shared_ptr<vector<string>> vSwitchIds{};

  ModifyScalingGroupRequest() {}

  explicit ModifyScalingGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeScalingConfigurationId) {
      res["ActiveScalingConfigurationId"] = boost::any(*activeScalingConfigurationId);
    }
    if (allocationStrategy) {
      res["AllocationStrategy"] = boost::any(*allocationStrategy);
    }
    if (azBalance) {
      res["AzBalance"] = boost::any(*azBalance);
    }
    if (capacityOptions) {
      res["CapacityOptions"] = capacityOptions ? boost::any(capacityOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (compensateWithOnDemand) {
      res["CompensateWithOnDemand"] = boost::any(*compensateWithOnDemand);
    }
    if (customPolicyARN) {
      res["CustomPolicyARN"] = boost::any(*customPolicyARN);
    }
    if (defaultCooldown) {
      res["DefaultCooldown"] = boost::any(*defaultCooldown);
    }
    if (desiredCapacity) {
      res["DesiredCapacity"] = boost::any(*desiredCapacity);
    }
    if (disableDesiredCapacity) {
      res["DisableDesiredCapacity"] = boost::any(*disableDesiredCapacity);
    }
    if (groupDeletionProtection) {
      res["GroupDeletionProtection"] = boost::any(*groupDeletionProtection);
    }
    if (healthCheckType) {
      res["HealthCheckType"] = boost::any(*healthCheckType);
    }
    if (healthCheckTypes) {
      res["HealthCheckTypes"] = boost::any(*healthCheckTypes);
    }
    if (launchTemplateId) {
      res["LaunchTemplateId"] = boost::any(*launchTemplateId);
    }
    if (launchTemplateOverrides) {
      vector<boost::any> temp1;
      for(auto item1:*launchTemplateOverrides){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LaunchTemplateOverrides"] = boost::any(temp1);
    }
    if (launchTemplateVersion) {
      res["LaunchTemplateVersion"] = boost::any(*launchTemplateVersion);
    }
    if (maxInstanceLifetime) {
      res["MaxInstanceLifetime"] = boost::any(*maxInstanceLifetime);
    }
    if (maxSize) {
      res["MaxSize"] = boost::any(*maxSize);
    }
    if (minSize) {
      res["MinSize"] = boost::any(*minSize);
    }
    if (multiAZPolicy) {
      res["MultiAZPolicy"] = boost::any(*multiAZPolicy);
    }
    if (onDemandBaseCapacity) {
      res["OnDemandBaseCapacity"] = boost::any(*onDemandBaseCapacity);
    }
    if (onDemandPercentageAboveBaseCapacity) {
      res["OnDemandPercentageAboveBaseCapacity"] = boost::any(*onDemandPercentageAboveBaseCapacity);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (removalPolicies) {
      res["RemovalPolicies"] = boost::any(*removalPolicies);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (scalingGroupName) {
      res["ScalingGroupName"] = boost::any(*scalingGroupName);
    }
    if (scalingPolicy) {
      res["ScalingPolicy"] = boost::any(*scalingPolicy);
    }
    if (spotAllocationStrategy) {
      res["SpotAllocationStrategy"] = boost::any(*spotAllocationStrategy);
    }
    if (spotInstancePools) {
      res["SpotInstancePools"] = boost::any(*spotInstancePools);
    }
    if (spotInstanceRemedy) {
      res["SpotInstanceRemedy"] = boost::any(*spotInstanceRemedy);
    }
    if (stopInstanceTimeout) {
      res["StopInstanceTimeout"] = boost::any(*stopInstanceTimeout);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = boost::any(*vSwitchIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveScalingConfigurationId") != m.end() && !m["ActiveScalingConfigurationId"].empty()) {
      activeScalingConfigurationId = make_shared<string>(boost::any_cast<string>(m["ActiveScalingConfigurationId"]));
    }
    if (m.find("AllocationStrategy") != m.end() && !m["AllocationStrategy"].empty()) {
      allocationStrategy = make_shared<string>(boost::any_cast<string>(m["AllocationStrategy"]));
    }
    if (m.find("AzBalance") != m.end() && !m["AzBalance"].empty()) {
      azBalance = make_shared<bool>(boost::any_cast<bool>(m["AzBalance"]));
    }
    if (m.find("CapacityOptions") != m.end() && !m["CapacityOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["CapacityOptions"].type()) {
        ModifyScalingGroupRequestCapacityOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CapacityOptions"]));
        capacityOptions = make_shared<ModifyScalingGroupRequestCapacityOptions>(model1);
      }
    }
    if (m.find("CompensateWithOnDemand") != m.end() && !m["CompensateWithOnDemand"].empty()) {
      compensateWithOnDemand = make_shared<bool>(boost::any_cast<bool>(m["CompensateWithOnDemand"]));
    }
    if (m.find("CustomPolicyARN") != m.end() && !m["CustomPolicyARN"].empty()) {
      customPolicyARN = make_shared<string>(boost::any_cast<string>(m["CustomPolicyARN"]));
    }
    if (m.find("DefaultCooldown") != m.end() && !m["DefaultCooldown"].empty()) {
      defaultCooldown = make_shared<long>(boost::any_cast<long>(m["DefaultCooldown"]));
    }
    if (m.find("DesiredCapacity") != m.end() && !m["DesiredCapacity"].empty()) {
      desiredCapacity = make_shared<long>(boost::any_cast<long>(m["DesiredCapacity"]));
    }
    if (m.find("DisableDesiredCapacity") != m.end() && !m["DisableDesiredCapacity"].empty()) {
      disableDesiredCapacity = make_shared<bool>(boost::any_cast<bool>(m["DisableDesiredCapacity"]));
    }
    if (m.find("GroupDeletionProtection") != m.end() && !m["GroupDeletionProtection"].empty()) {
      groupDeletionProtection = make_shared<bool>(boost::any_cast<bool>(m["GroupDeletionProtection"]));
    }
    if (m.find("HealthCheckType") != m.end() && !m["HealthCheckType"].empty()) {
      healthCheckType = make_shared<string>(boost::any_cast<string>(m["HealthCheckType"]));
    }
    if (m.find("HealthCheckTypes") != m.end() && !m["HealthCheckTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HealthCheckTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HealthCheckTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      healthCheckTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LaunchTemplateId") != m.end() && !m["LaunchTemplateId"].empty()) {
      launchTemplateId = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateId"]));
    }
    if (m.find("LaunchTemplateOverrides") != m.end() && !m["LaunchTemplateOverrides"].empty()) {
      if (typeid(vector<boost::any>) == m["LaunchTemplateOverrides"].type()) {
        vector<ModifyScalingGroupRequestLaunchTemplateOverrides> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LaunchTemplateOverrides"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyScalingGroupRequestLaunchTemplateOverrides model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        launchTemplateOverrides = make_shared<vector<ModifyScalingGroupRequestLaunchTemplateOverrides>>(expect1);
      }
    }
    if (m.find("LaunchTemplateVersion") != m.end() && !m["LaunchTemplateVersion"].empty()) {
      launchTemplateVersion = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateVersion"]));
    }
    if (m.find("MaxInstanceLifetime") != m.end() && !m["MaxInstanceLifetime"].empty()) {
      maxInstanceLifetime = make_shared<long>(boost::any_cast<long>(m["MaxInstanceLifetime"]));
    }
    if (m.find("MaxSize") != m.end() && !m["MaxSize"].empty()) {
      maxSize = make_shared<long>(boost::any_cast<long>(m["MaxSize"]));
    }
    if (m.find("MinSize") != m.end() && !m["MinSize"].empty()) {
      minSize = make_shared<long>(boost::any_cast<long>(m["MinSize"]));
    }
    if (m.find("MultiAZPolicy") != m.end() && !m["MultiAZPolicy"].empty()) {
      multiAZPolicy = make_shared<string>(boost::any_cast<string>(m["MultiAZPolicy"]));
    }
    if (m.find("OnDemandBaseCapacity") != m.end() && !m["OnDemandBaseCapacity"].empty()) {
      onDemandBaseCapacity = make_shared<long>(boost::any_cast<long>(m["OnDemandBaseCapacity"]));
    }
    if (m.find("OnDemandPercentageAboveBaseCapacity") != m.end() && !m["OnDemandPercentageAboveBaseCapacity"].empty()) {
      onDemandPercentageAboveBaseCapacity = make_shared<long>(boost::any_cast<long>(m["OnDemandPercentageAboveBaseCapacity"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RemovalPolicies") != m.end() && !m["RemovalPolicies"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RemovalPolicies"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RemovalPolicies"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      removalPolicies = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("ScalingGroupName") != m.end() && !m["ScalingGroupName"].empty()) {
      scalingGroupName = make_shared<string>(boost::any_cast<string>(m["ScalingGroupName"]));
    }
    if (m.find("ScalingPolicy") != m.end() && !m["ScalingPolicy"].empty()) {
      scalingPolicy = make_shared<string>(boost::any_cast<string>(m["ScalingPolicy"]));
    }
    if (m.find("SpotAllocationStrategy") != m.end() && !m["SpotAllocationStrategy"].empty()) {
      spotAllocationStrategy = make_shared<string>(boost::any_cast<string>(m["SpotAllocationStrategy"]));
    }
    if (m.find("SpotInstancePools") != m.end() && !m["SpotInstancePools"].empty()) {
      spotInstancePools = make_shared<long>(boost::any_cast<long>(m["SpotInstancePools"]));
    }
    if (m.find("SpotInstanceRemedy") != m.end() && !m["SpotInstanceRemedy"].empty()) {
      spotInstanceRemedy = make_shared<bool>(boost::any_cast<bool>(m["SpotInstanceRemedy"]));
    }
    if (m.find("StopInstanceTimeout") != m.end() && !m["StopInstanceTimeout"].empty()) {
      stopInstanceTimeout = make_shared<long>(boost::any_cast<long>(m["StopInstanceTimeout"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyScalingGroupRequest() = default;
};
class ModifyScalingGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyScalingGroupResponseBody() {}

  explicit ModifyScalingGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyScalingGroupResponseBody() = default;
};
class ModifyScalingGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyScalingGroupResponseBody> body{};

  ModifyScalingGroupResponse() {}

  explicit ModifyScalingGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyScalingGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyScalingGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyScalingGroupResponse() = default;
};
class ModifyScalingRuleRequestAlarmDimensions : public Darabonba::Model {
public:
  shared_ptr<string> dimensionKey{};
  shared_ptr<string> dimensionValue{};

  ModifyScalingRuleRequestAlarmDimensions() {}

  explicit ModifyScalingRuleRequestAlarmDimensions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimensionKey) {
      res["DimensionKey"] = boost::any(*dimensionKey);
    }
    if (dimensionValue) {
      res["DimensionValue"] = boost::any(*dimensionValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DimensionKey") != m.end() && !m["DimensionKey"].empty()) {
      dimensionKey = make_shared<string>(boost::any_cast<string>(m["DimensionKey"]));
    }
    if (m.find("DimensionValue") != m.end() && !m["DimensionValue"].empty()) {
      dimensionValue = make_shared<string>(boost::any_cast<string>(m["DimensionValue"]));
    }
  }


  virtual ~ModifyScalingRuleRequestAlarmDimensions() = default;
};
class ModifyScalingRuleRequestHybridMetricsDimensions : public Darabonba::Model {
public:
  shared_ptr<string> dimensionKey{};
  shared_ptr<string> dimensionValue{};

  ModifyScalingRuleRequestHybridMetricsDimensions() {}

  explicit ModifyScalingRuleRequestHybridMetricsDimensions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimensionKey) {
      res["DimensionKey"] = boost::any(*dimensionKey);
    }
    if (dimensionValue) {
      res["DimensionValue"] = boost::any(*dimensionValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DimensionKey") != m.end() && !m["DimensionKey"].empty()) {
      dimensionKey = make_shared<string>(boost::any_cast<string>(m["DimensionKey"]));
    }
    if (m.find("DimensionValue") != m.end() && !m["DimensionValue"].empty()) {
      dimensionValue = make_shared<string>(boost::any_cast<string>(m["DimensionValue"]));
    }
  }


  virtual ~ModifyScalingRuleRequestHybridMetricsDimensions() = default;
};
class ModifyScalingRuleRequestHybridMetrics : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyScalingRuleRequestHybridMetricsDimensions>> dimensions{};
  shared_ptr<string> expression{};
  shared_ptr<string> id{};
  shared_ptr<string> metricName{};
  shared_ptr<string> statistic{};

  ModifyScalingRuleRequestHybridMetrics() {}

  explicit ModifyScalingRuleRequestHybridMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimensions) {
      vector<boost::any> temp1;
      for(auto item1:*dimensions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dimensions"] = boost::any(temp1);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (statistic) {
      res["Statistic"] = boost::any(*statistic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      if (typeid(vector<boost::any>) == m["Dimensions"].type()) {
        vector<ModifyScalingRuleRequestHybridMetricsDimensions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dimensions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyScalingRuleRequestHybridMetricsDimensions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dimensions = make_shared<vector<ModifyScalingRuleRequestHybridMetricsDimensions>>(expect1);
      }
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Statistic") != m.end() && !m["Statistic"].empty()) {
      statistic = make_shared<string>(boost::any_cast<string>(m["Statistic"]));
    }
  }


  virtual ~ModifyScalingRuleRequestHybridMetrics() = default;
};
class ModifyScalingRuleRequestStepAdjustments : public Darabonba::Model {
public:
  shared_ptr<double> metricIntervalLowerBound{};
  shared_ptr<double> metricIntervalUpperBound{};
  shared_ptr<long> scalingAdjustment{};

  ModifyScalingRuleRequestStepAdjustments() {}

  explicit ModifyScalingRuleRequestStepAdjustments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricIntervalLowerBound) {
      res["MetricIntervalLowerBound"] = boost::any(*metricIntervalLowerBound);
    }
    if (metricIntervalUpperBound) {
      res["MetricIntervalUpperBound"] = boost::any(*metricIntervalUpperBound);
    }
    if (scalingAdjustment) {
      res["ScalingAdjustment"] = boost::any(*scalingAdjustment);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricIntervalLowerBound") != m.end() && !m["MetricIntervalLowerBound"].empty()) {
      metricIntervalLowerBound = make_shared<double>(boost::any_cast<double>(m["MetricIntervalLowerBound"]));
    }
    if (m.find("MetricIntervalUpperBound") != m.end() && !m["MetricIntervalUpperBound"].empty()) {
      metricIntervalUpperBound = make_shared<double>(boost::any_cast<double>(m["MetricIntervalUpperBound"]));
    }
    if (m.find("ScalingAdjustment") != m.end() && !m["ScalingAdjustment"].empty()) {
      scalingAdjustment = make_shared<long>(boost::any_cast<long>(m["ScalingAdjustment"]));
    }
  }


  virtual ~ModifyScalingRuleRequestStepAdjustments() = default;
};
class ModifyScalingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> adjustmentType{};
  shared_ptr<long> adjustmentValue{};
  shared_ptr<vector<ModifyScalingRuleRequestAlarmDimensions>> alarmDimensions{};
  shared_ptr<long> cooldown{};
  shared_ptr<bool> disableScaleIn{};
  shared_ptr<long> estimatedInstanceWarmup{};
  shared_ptr<vector<ModifyScalingRuleRequestHybridMetrics>> hybridMetrics{};
  shared_ptr<string> hybridMonitorNamespace{};
  shared_ptr<long> initialMaxSize{};
  shared_ptr<string> metricName{};
  shared_ptr<string> metricType{};
  shared_ptr<long> minAdjustmentMagnitude{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> predictiveScalingMode{};
  shared_ptr<long> predictiveTaskBufferTime{};
  shared_ptr<string> predictiveValueBehavior{};
  shared_ptr<long> predictiveValueBuffer{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> scaleInEvaluationCount{};
  shared_ptr<long> scaleOutEvaluationCount{};
  shared_ptr<string> scalingRuleId{};
  shared_ptr<string> scalingRuleName{};
  shared_ptr<vector<ModifyScalingRuleRequestStepAdjustments>> stepAdjustments{};
  shared_ptr<double> targetValue{};

  ModifyScalingRuleRequest() {}

  explicit ModifyScalingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjustmentType) {
      res["AdjustmentType"] = boost::any(*adjustmentType);
    }
    if (adjustmentValue) {
      res["AdjustmentValue"] = boost::any(*adjustmentValue);
    }
    if (alarmDimensions) {
      vector<boost::any> temp1;
      for(auto item1:*alarmDimensions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlarmDimensions"] = boost::any(temp1);
    }
    if (cooldown) {
      res["Cooldown"] = boost::any(*cooldown);
    }
    if (disableScaleIn) {
      res["DisableScaleIn"] = boost::any(*disableScaleIn);
    }
    if (estimatedInstanceWarmup) {
      res["EstimatedInstanceWarmup"] = boost::any(*estimatedInstanceWarmup);
    }
    if (hybridMetrics) {
      vector<boost::any> temp1;
      for(auto item1:*hybridMetrics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HybridMetrics"] = boost::any(temp1);
    }
    if (hybridMonitorNamespace) {
      res["HybridMonitorNamespace"] = boost::any(*hybridMonitorNamespace);
    }
    if (initialMaxSize) {
      res["InitialMaxSize"] = boost::any(*initialMaxSize);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (minAdjustmentMagnitude) {
      res["MinAdjustmentMagnitude"] = boost::any(*minAdjustmentMagnitude);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (predictiveScalingMode) {
      res["PredictiveScalingMode"] = boost::any(*predictiveScalingMode);
    }
    if (predictiveTaskBufferTime) {
      res["PredictiveTaskBufferTime"] = boost::any(*predictiveTaskBufferTime);
    }
    if (predictiveValueBehavior) {
      res["PredictiveValueBehavior"] = boost::any(*predictiveValueBehavior);
    }
    if (predictiveValueBuffer) {
      res["PredictiveValueBuffer"] = boost::any(*predictiveValueBuffer);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scaleInEvaluationCount) {
      res["ScaleInEvaluationCount"] = boost::any(*scaleInEvaluationCount);
    }
    if (scaleOutEvaluationCount) {
      res["ScaleOutEvaluationCount"] = boost::any(*scaleOutEvaluationCount);
    }
    if (scalingRuleId) {
      res["ScalingRuleId"] = boost::any(*scalingRuleId);
    }
    if (scalingRuleName) {
      res["ScalingRuleName"] = boost::any(*scalingRuleName);
    }
    if (stepAdjustments) {
      vector<boost::any> temp1;
      for(auto item1:*stepAdjustments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StepAdjustments"] = boost::any(temp1);
    }
    if (targetValue) {
      res["TargetValue"] = boost::any(*targetValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjustmentType") != m.end() && !m["AdjustmentType"].empty()) {
      adjustmentType = make_shared<string>(boost::any_cast<string>(m["AdjustmentType"]));
    }
    if (m.find("AdjustmentValue") != m.end() && !m["AdjustmentValue"].empty()) {
      adjustmentValue = make_shared<long>(boost::any_cast<long>(m["AdjustmentValue"]));
    }
    if (m.find("AlarmDimensions") != m.end() && !m["AlarmDimensions"].empty()) {
      if (typeid(vector<boost::any>) == m["AlarmDimensions"].type()) {
        vector<ModifyScalingRuleRequestAlarmDimensions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlarmDimensions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyScalingRuleRequestAlarmDimensions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alarmDimensions = make_shared<vector<ModifyScalingRuleRequestAlarmDimensions>>(expect1);
      }
    }
    if (m.find("Cooldown") != m.end() && !m["Cooldown"].empty()) {
      cooldown = make_shared<long>(boost::any_cast<long>(m["Cooldown"]));
    }
    if (m.find("DisableScaleIn") != m.end() && !m["DisableScaleIn"].empty()) {
      disableScaleIn = make_shared<bool>(boost::any_cast<bool>(m["DisableScaleIn"]));
    }
    if (m.find("EstimatedInstanceWarmup") != m.end() && !m["EstimatedInstanceWarmup"].empty()) {
      estimatedInstanceWarmup = make_shared<long>(boost::any_cast<long>(m["EstimatedInstanceWarmup"]));
    }
    if (m.find("HybridMetrics") != m.end() && !m["HybridMetrics"].empty()) {
      if (typeid(vector<boost::any>) == m["HybridMetrics"].type()) {
        vector<ModifyScalingRuleRequestHybridMetrics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HybridMetrics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyScalingRuleRequestHybridMetrics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hybridMetrics = make_shared<vector<ModifyScalingRuleRequestHybridMetrics>>(expect1);
      }
    }
    if (m.find("HybridMonitorNamespace") != m.end() && !m["HybridMonitorNamespace"].empty()) {
      hybridMonitorNamespace = make_shared<string>(boost::any_cast<string>(m["HybridMonitorNamespace"]));
    }
    if (m.find("InitialMaxSize") != m.end() && !m["InitialMaxSize"].empty()) {
      initialMaxSize = make_shared<long>(boost::any_cast<long>(m["InitialMaxSize"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("MinAdjustmentMagnitude") != m.end() && !m["MinAdjustmentMagnitude"].empty()) {
      minAdjustmentMagnitude = make_shared<long>(boost::any_cast<long>(m["MinAdjustmentMagnitude"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PredictiveScalingMode") != m.end() && !m["PredictiveScalingMode"].empty()) {
      predictiveScalingMode = make_shared<string>(boost::any_cast<string>(m["PredictiveScalingMode"]));
    }
    if (m.find("PredictiveTaskBufferTime") != m.end() && !m["PredictiveTaskBufferTime"].empty()) {
      predictiveTaskBufferTime = make_shared<long>(boost::any_cast<long>(m["PredictiveTaskBufferTime"]));
    }
    if (m.find("PredictiveValueBehavior") != m.end() && !m["PredictiveValueBehavior"].empty()) {
      predictiveValueBehavior = make_shared<string>(boost::any_cast<string>(m["PredictiveValueBehavior"]));
    }
    if (m.find("PredictiveValueBuffer") != m.end() && !m["PredictiveValueBuffer"].empty()) {
      predictiveValueBuffer = make_shared<long>(boost::any_cast<long>(m["PredictiveValueBuffer"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScaleInEvaluationCount") != m.end() && !m["ScaleInEvaluationCount"].empty()) {
      scaleInEvaluationCount = make_shared<long>(boost::any_cast<long>(m["ScaleInEvaluationCount"]));
    }
    if (m.find("ScaleOutEvaluationCount") != m.end() && !m["ScaleOutEvaluationCount"].empty()) {
      scaleOutEvaluationCount = make_shared<long>(boost::any_cast<long>(m["ScaleOutEvaluationCount"]));
    }
    if (m.find("ScalingRuleId") != m.end() && !m["ScalingRuleId"].empty()) {
      scalingRuleId = make_shared<string>(boost::any_cast<string>(m["ScalingRuleId"]));
    }
    if (m.find("ScalingRuleName") != m.end() && !m["ScalingRuleName"].empty()) {
      scalingRuleName = make_shared<string>(boost::any_cast<string>(m["ScalingRuleName"]));
    }
    if (m.find("StepAdjustments") != m.end() && !m["StepAdjustments"].empty()) {
      if (typeid(vector<boost::any>) == m["StepAdjustments"].type()) {
        vector<ModifyScalingRuleRequestStepAdjustments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StepAdjustments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyScalingRuleRequestStepAdjustments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stepAdjustments = make_shared<vector<ModifyScalingRuleRequestStepAdjustments>>(expect1);
      }
    }
    if (m.find("TargetValue") != m.end() && !m["TargetValue"].empty()) {
      targetValue = make_shared<double>(boost::any_cast<double>(m["TargetValue"]));
    }
  }


  virtual ~ModifyScalingRuleRequest() = default;
};
class ModifyScalingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyScalingRuleResponseBody() {}

  explicit ModifyScalingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyScalingRuleResponseBody() = default;
};
class ModifyScalingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyScalingRuleResponseBody> body{};

  ModifyScalingRuleResponse() {}

  explicit ModifyScalingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyScalingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyScalingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyScalingRuleResponse() = default;
};
class ModifyScheduledTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> desiredCapacity{};
  shared_ptr<long> launchExpirationTime{};
  shared_ptr<string> launchTime{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minValue{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> recurrenceEndTime{};
  shared_ptr<string> recurrenceType{};
  shared_ptr<string> recurrenceValue{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> scheduledAction{};
  shared_ptr<string> scheduledTaskId{};
  shared_ptr<string> scheduledTaskName{};
  shared_ptr<bool> taskEnabled{};

  ModifyScheduledTaskRequest() {}

  explicit ModifyScheduledTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (desiredCapacity) {
      res["DesiredCapacity"] = boost::any(*desiredCapacity);
    }
    if (launchExpirationTime) {
      res["LaunchExpirationTime"] = boost::any(*launchExpirationTime);
    }
    if (launchTime) {
      res["LaunchTime"] = boost::any(*launchTime);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (recurrenceEndTime) {
      res["RecurrenceEndTime"] = boost::any(*recurrenceEndTime);
    }
    if (recurrenceType) {
      res["RecurrenceType"] = boost::any(*recurrenceType);
    }
    if (recurrenceValue) {
      res["RecurrenceValue"] = boost::any(*recurrenceValue);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (scheduledAction) {
      res["ScheduledAction"] = boost::any(*scheduledAction);
    }
    if (scheduledTaskId) {
      res["ScheduledTaskId"] = boost::any(*scheduledTaskId);
    }
    if (scheduledTaskName) {
      res["ScheduledTaskName"] = boost::any(*scheduledTaskName);
    }
    if (taskEnabled) {
      res["TaskEnabled"] = boost::any(*taskEnabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DesiredCapacity") != m.end() && !m["DesiredCapacity"].empty()) {
      desiredCapacity = make_shared<long>(boost::any_cast<long>(m["DesiredCapacity"]));
    }
    if (m.find("LaunchExpirationTime") != m.end() && !m["LaunchExpirationTime"].empty()) {
      launchExpirationTime = make_shared<long>(boost::any_cast<long>(m["LaunchExpirationTime"]));
    }
    if (m.find("LaunchTime") != m.end() && !m["LaunchTime"].empty()) {
      launchTime = make_shared<string>(boost::any_cast<string>(m["LaunchTime"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RecurrenceEndTime") != m.end() && !m["RecurrenceEndTime"].empty()) {
      recurrenceEndTime = make_shared<string>(boost::any_cast<string>(m["RecurrenceEndTime"]));
    }
    if (m.find("RecurrenceType") != m.end() && !m["RecurrenceType"].empty()) {
      recurrenceType = make_shared<string>(boost::any_cast<string>(m["RecurrenceType"]));
    }
    if (m.find("RecurrenceValue") != m.end() && !m["RecurrenceValue"].empty()) {
      recurrenceValue = make_shared<string>(boost::any_cast<string>(m["RecurrenceValue"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("ScheduledAction") != m.end() && !m["ScheduledAction"].empty()) {
      scheduledAction = make_shared<string>(boost::any_cast<string>(m["ScheduledAction"]));
    }
    if (m.find("ScheduledTaskId") != m.end() && !m["ScheduledTaskId"].empty()) {
      scheduledTaskId = make_shared<string>(boost::any_cast<string>(m["ScheduledTaskId"]));
    }
    if (m.find("ScheduledTaskName") != m.end() && !m["ScheduledTaskName"].empty()) {
      scheduledTaskName = make_shared<string>(boost::any_cast<string>(m["ScheduledTaskName"]));
    }
    if (m.find("TaskEnabled") != m.end() && !m["TaskEnabled"].empty()) {
      taskEnabled = make_shared<bool>(boost::any_cast<bool>(m["TaskEnabled"]));
    }
  }


  virtual ~ModifyScheduledTaskRequest() = default;
};
class ModifyScheduledTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyScheduledTaskResponseBody() {}

  explicit ModifyScheduledTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyScheduledTaskResponseBody() = default;
};
class ModifyScheduledTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyScheduledTaskResponseBody> body{};

  ModifyScheduledTaskResponse() {}

  explicit ModifyScheduledTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyScheduledTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyScheduledTaskResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyScheduledTaskResponse() = default;
};
class RebalanceInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scalingGroupId{};

  RebalanceInstancesRequest() {}

  explicit RebalanceInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~RebalanceInstancesRequest() = default;
};
class RebalanceInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> scalingActivityId{};

  RebalanceInstancesResponseBody() {}

  explicit RebalanceInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingActivityId) {
      res["ScalingActivityId"] = boost::any(*scalingActivityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingActivityId") != m.end() && !m["ScalingActivityId"].empty()) {
      scalingActivityId = make_shared<string>(boost::any_cast<string>(m["ScalingActivityId"]));
    }
  }


  virtual ~RebalanceInstancesResponseBody() = default;
};
class RebalanceInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RebalanceInstancesResponseBody> body{};

  RebalanceInstancesResponse() {}

  explicit RebalanceInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RebalanceInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RebalanceInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~RebalanceInstancesResponse() = default;
};
class RecordLifecycleActionHeartbeatRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> heartbeatTimeout{};
  shared_ptr<string> lifecycleActionToken{};
  shared_ptr<string> lifecycleHookId{};

  RecordLifecycleActionHeartbeatRequest() {}

  explicit RecordLifecycleActionHeartbeatRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (heartbeatTimeout) {
      res["heartbeatTimeout"] = boost::any(*heartbeatTimeout);
    }
    if (lifecycleActionToken) {
      res["lifecycleActionToken"] = boost::any(*lifecycleActionToken);
    }
    if (lifecycleHookId) {
      res["lifecycleHookId"] = boost::any(*lifecycleHookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("heartbeatTimeout") != m.end() && !m["heartbeatTimeout"].empty()) {
      heartbeatTimeout = make_shared<long>(boost::any_cast<long>(m["heartbeatTimeout"]));
    }
    if (m.find("lifecycleActionToken") != m.end() && !m["lifecycleActionToken"].empty()) {
      lifecycleActionToken = make_shared<string>(boost::any_cast<string>(m["lifecycleActionToken"]));
    }
    if (m.find("lifecycleHookId") != m.end() && !m["lifecycleHookId"].empty()) {
      lifecycleHookId = make_shared<string>(boost::any_cast<string>(m["lifecycleHookId"]));
    }
  }


  virtual ~RecordLifecycleActionHeartbeatRequest() = default;
};
class RecordLifecycleActionHeartbeatResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RecordLifecycleActionHeartbeatResponseBody() {}

  explicit RecordLifecycleActionHeartbeatResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RecordLifecycleActionHeartbeatResponseBody() = default;
};
class RecordLifecycleActionHeartbeatResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RecordLifecycleActionHeartbeatResponseBody> body{};

  RecordLifecycleActionHeartbeatResponse() {}

  explicit RecordLifecycleActionHeartbeatResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RecordLifecycleActionHeartbeatResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RecordLifecycleActionHeartbeatResponseBody>(model1);
      }
    }
  }


  virtual ~RecordLifecycleActionHeartbeatResponse() = default;
};
class RemoveInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> decreaseDesiredCapacity{};
  shared_ptr<bool> ignoreInvalidInstance{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> removePolicy{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<long> stopInstanceTimeout{};

  RemoveInstancesRequest() {}

  explicit RemoveInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (decreaseDesiredCapacity) {
      res["DecreaseDesiredCapacity"] = boost::any(*decreaseDesiredCapacity);
    }
    if (ignoreInvalidInstance) {
      res["IgnoreInvalidInstance"] = boost::any(*ignoreInvalidInstance);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (removePolicy) {
      res["RemovePolicy"] = boost::any(*removePolicy);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (stopInstanceTimeout) {
      res["StopInstanceTimeout"] = boost::any(*stopInstanceTimeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DecreaseDesiredCapacity") != m.end() && !m["DecreaseDesiredCapacity"].empty()) {
      decreaseDesiredCapacity = make_shared<bool>(boost::any_cast<bool>(m["DecreaseDesiredCapacity"]));
    }
    if (m.find("IgnoreInvalidInstance") != m.end() && !m["IgnoreInvalidInstance"].empty()) {
      ignoreInvalidInstance = make_shared<bool>(boost::any_cast<bool>(m["IgnoreInvalidInstance"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemovePolicy") != m.end() && !m["RemovePolicy"].empty()) {
      removePolicy = make_shared<string>(boost::any_cast<string>(m["RemovePolicy"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("StopInstanceTimeout") != m.end() && !m["StopInstanceTimeout"].empty()) {
      stopInstanceTimeout = make_shared<long>(boost::any_cast<long>(m["StopInstanceTimeout"]));
    }
  }


  virtual ~RemoveInstancesRequest() = default;
};
class RemoveInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> scalingActivityId{};

  RemoveInstancesResponseBody() {}

  explicit RemoveInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingActivityId) {
      res["ScalingActivityId"] = boost::any(*scalingActivityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingActivityId") != m.end() && !m["ScalingActivityId"].empty()) {
      scalingActivityId = make_shared<string>(boost::any_cast<string>(m["ScalingActivityId"]));
    }
  }


  virtual ~RemoveInstancesResponseBody() = default;
};
class RemoveInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveInstancesResponseBody> body{};

  RemoveInstancesResponse() {}

  explicit RemoveInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveInstancesResponse() = default;
};
class ResumeInstanceRefreshRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceRefreshTaskId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};

  ResumeInstanceRefreshRequest() {}

  explicit ResumeInstanceRefreshRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceRefreshTaskId) {
      res["InstanceRefreshTaskId"] = boost::any(*instanceRefreshTaskId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceRefreshTaskId") != m.end() && !m["InstanceRefreshTaskId"].empty()) {
      instanceRefreshTaskId = make_shared<string>(boost::any_cast<string>(m["InstanceRefreshTaskId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~ResumeInstanceRefreshRequest() = default;
};
class ResumeInstanceRefreshResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResumeInstanceRefreshResponseBody() {}

  explicit ResumeInstanceRefreshResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResumeInstanceRefreshResponseBody() = default;
};
class ResumeInstanceRefreshResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResumeInstanceRefreshResponseBody> body{};

  ResumeInstanceRefreshResponse() {}

  explicit ResumeInstanceRefreshResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResumeInstanceRefreshResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResumeInstanceRefreshResponseBody>(model1);
      }
    }
  }


  virtual ~ResumeInstanceRefreshResponse() = default;
};
class ResumeProcessesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<vector<string>> processes{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};

  ResumeProcessesRequest() {}

  explicit ResumeProcessesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (processes) {
      res["Processes"] = boost::any(*processes);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Processes") != m.end() && !m["Processes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Processes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Processes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      processes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~ResumeProcessesRequest() = default;
};
class ResumeProcessesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResumeProcessesResponseBody() {}

  explicit ResumeProcessesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResumeProcessesResponseBody() = default;
};
class ResumeProcessesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResumeProcessesResponseBody> body{};

  ResumeProcessesResponse() {}

  explicit ResumeProcessesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResumeProcessesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResumeProcessesResponseBody>(model1);
      }
    }
  }


  virtual ~ResumeProcessesResponse() = default;
};
class RollbackInstanceRefreshRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceRefreshTaskId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};

  RollbackInstanceRefreshRequest() {}

  explicit RollbackInstanceRefreshRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceRefreshTaskId) {
      res["InstanceRefreshTaskId"] = boost::any(*instanceRefreshTaskId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceRefreshTaskId") != m.end() && !m["InstanceRefreshTaskId"].empty()) {
      instanceRefreshTaskId = make_shared<string>(boost::any_cast<string>(m["InstanceRefreshTaskId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~RollbackInstanceRefreshRequest() = default;
};
class RollbackInstanceRefreshResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RollbackInstanceRefreshResponseBody() {}

  explicit RollbackInstanceRefreshResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RollbackInstanceRefreshResponseBody() = default;
};
class RollbackInstanceRefreshResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RollbackInstanceRefreshResponseBody> body{};

  RollbackInstanceRefreshResponse() {}

  explicit RollbackInstanceRefreshResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RollbackInstanceRefreshResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RollbackInstanceRefreshResponseBody>(model1);
      }
    }
  }


  virtual ~RollbackInstanceRefreshResponse() = default;
};
class ScaleWithAdjustmentRequestLifecycleHookContext : public Darabonba::Model {
public:
  shared_ptr<bool> disableLifecycleHook{};
  shared_ptr<vector<string>> ignoredLifecycleHookIds{};

  ScaleWithAdjustmentRequestLifecycleHookContext() {}

  explicit ScaleWithAdjustmentRequestLifecycleHookContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disableLifecycleHook) {
      res["DisableLifecycleHook"] = boost::any(*disableLifecycleHook);
    }
    if (ignoredLifecycleHookIds) {
      res["IgnoredLifecycleHookIds"] = boost::any(*ignoredLifecycleHookIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisableLifecycleHook") != m.end() && !m["DisableLifecycleHook"].empty()) {
      disableLifecycleHook = make_shared<bool>(boost::any_cast<bool>(m["DisableLifecycleHook"]));
    }
    if (m.find("IgnoredLifecycleHookIds") != m.end() && !m["IgnoredLifecycleHookIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IgnoredLifecycleHookIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IgnoredLifecycleHookIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ignoredLifecycleHookIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ScaleWithAdjustmentRequestLifecycleHookContext() = default;
};
class ScaleWithAdjustmentRequestOverridesContainerOverridesEnvironmentVars : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ScaleWithAdjustmentRequestOverridesContainerOverridesEnvironmentVars() {}

  explicit ScaleWithAdjustmentRequestOverridesContainerOverridesEnvironmentVars(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ScaleWithAdjustmentRequestOverridesContainerOverridesEnvironmentVars() = default;
};
class ScaleWithAdjustmentRequestOverridesContainerOverrides : public Darabonba::Model {
public:
  shared_ptr<vector<string>> args{};
  shared_ptr<vector<string>> commands{};
  shared_ptr<double> cpu{};
  shared_ptr<vector<ScaleWithAdjustmentRequestOverridesContainerOverridesEnvironmentVars>> environmentVars{};
  shared_ptr<double> memory{};
  shared_ptr<string> name{};

  ScaleWithAdjustmentRequestOverridesContainerOverrides() {}

  explicit ScaleWithAdjustmentRequestOverridesContainerOverrides(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (args) {
      res["Args"] = boost::any(*args);
    }
    if (commands) {
      res["Commands"] = boost::any(*commands);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (environmentVars) {
      vector<boost::any> temp1;
      for(auto item1:*environmentVars){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnvironmentVars"] = boost::any(temp1);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Args") != m.end() && !m["Args"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Args"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Args"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      args = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Commands") != m.end() && !m["Commands"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Commands"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Commands"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      commands = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<double>(boost::any_cast<double>(m["Cpu"]));
    }
    if (m.find("EnvironmentVars") != m.end() && !m["EnvironmentVars"].empty()) {
      if (typeid(vector<boost::any>) == m["EnvironmentVars"].type()) {
        vector<ScaleWithAdjustmentRequestOverridesContainerOverridesEnvironmentVars> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnvironmentVars"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ScaleWithAdjustmentRequestOverridesContainerOverridesEnvironmentVars model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        environmentVars = make_shared<vector<ScaleWithAdjustmentRequestOverridesContainerOverridesEnvironmentVars>>(expect1);
      }
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ScaleWithAdjustmentRequestOverridesContainerOverrides() = default;
};
class ScaleWithAdjustmentRequestOverrides : public Darabonba::Model {
public:
  shared_ptr<vector<ScaleWithAdjustmentRequestOverridesContainerOverrides>> containerOverrides{};
  shared_ptr<double> cpu{};
  shared_ptr<double> memory{};

  ScaleWithAdjustmentRequestOverrides() {}

  explicit ScaleWithAdjustmentRequestOverrides(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerOverrides) {
      vector<boost::any> temp1;
      for(auto item1:*containerOverrides){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContainerOverrides"] = boost::any(temp1);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerOverrides") != m.end() && !m["ContainerOverrides"].empty()) {
      if (typeid(vector<boost::any>) == m["ContainerOverrides"].type()) {
        vector<ScaleWithAdjustmentRequestOverridesContainerOverrides> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContainerOverrides"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ScaleWithAdjustmentRequestOverridesContainerOverrides model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        containerOverrides = make_shared<vector<ScaleWithAdjustmentRequestOverridesContainerOverrides>>(expect1);
      }
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<double>(boost::any_cast<double>(m["Cpu"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
  }


  virtual ~ScaleWithAdjustmentRequestOverrides() = default;
};
class ScaleWithAdjustmentRequest : public Darabonba::Model {
public:
  shared_ptr<string> activityMetadata{};
  shared_ptr<string> adjustmentType{};
  shared_ptr<long> adjustmentValue{};
  shared_ptr<string> clientToken{};
  shared_ptr<ScaleWithAdjustmentRequestLifecycleHookContext> lifecycleHookContext{};
  shared_ptr<long> minAdjustmentMagnitude{};
  shared_ptr<ScaleWithAdjustmentRequestOverrides> overrides{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<bool> syncActivity{};

  ScaleWithAdjustmentRequest() {}

  explicit ScaleWithAdjustmentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityMetadata) {
      res["ActivityMetadata"] = boost::any(*activityMetadata);
    }
    if (adjustmentType) {
      res["AdjustmentType"] = boost::any(*adjustmentType);
    }
    if (adjustmentValue) {
      res["AdjustmentValue"] = boost::any(*adjustmentValue);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (lifecycleHookContext) {
      res["LifecycleHookContext"] = lifecycleHookContext ? boost::any(lifecycleHookContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (minAdjustmentMagnitude) {
      res["MinAdjustmentMagnitude"] = boost::any(*minAdjustmentMagnitude);
    }
    if (overrides) {
      res["Overrides"] = overrides ? boost::any(overrides->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (syncActivity) {
      res["SyncActivity"] = boost::any(*syncActivity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityMetadata") != m.end() && !m["ActivityMetadata"].empty()) {
      activityMetadata = make_shared<string>(boost::any_cast<string>(m["ActivityMetadata"]));
    }
    if (m.find("AdjustmentType") != m.end() && !m["AdjustmentType"].empty()) {
      adjustmentType = make_shared<string>(boost::any_cast<string>(m["AdjustmentType"]));
    }
    if (m.find("AdjustmentValue") != m.end() && !m["AdjustmentValue"].empty()) {
      adjustmentValue = make_shared<long>(boost::any_cast<long>(m["AdjustmentValue"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("LifecycleHookContext") != m.end() && !m["LifecycleHookContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["LifecycleHookContext"].type()) {
        ScaleWithAdjustmentRequestLifecycleHookContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LifecycleHookContext"]));
        lifecycleHookContext = make_shared<ScaleWithAdjustmentRequestLifecycleHookContext>(model1);
      }
    }
    if (m.find("MinAdjustmentMagnitude") != m.end() && !m["MinAdjustmentMagnitude"].empty()) {
      minAdjustmentMagnitude = make_shared<long>(boost::any_cast<long>(m["MinAdjustmentMagnitude"]));
    }
    if (m.find("Overrides") != m.end() && !m["Overrides"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overrides"].type()) {
        ScaleWithAdjustmentRequestOverrides model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overrides"]));
        overrides = make_shared<ScaleWithAdjustmentRequestOverrides>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("SyncActivity") != m.end() && !m["SyncActivity"].empty()) {
      syncActivity = make_shared<bool>(boost::any_cast<bool>(m["SyncActivity"]));
    }
  }


  virtual ~ScaleWithAdjustmentRequest() = default;
};
class ScaleWithAdjustmentShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> activityMetadata{};
  shared_ptr<string> adjustmentType{};
  shared_ptr<long> adjustmentValue{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> lifecycleHookContextShrink{};
  shared_ptr<long> minAdjustmentMagnitude{};
  shared_ptr<string> overridesShrink{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<bool> syncActivity{};

  ScaleWithAdjustmentShrinkRequest() {}

  explicit ScaleWithAdjustmentShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityMetadata) {
      res["ActivityMetadata"] = boost::any(*activityMetadata);
    }
    if (adjustmentType) {
      res["AdjustmentType"] = boost::any(*adjustmentType);
    }
    if (adjustmentValue) {
      res["AdjustmentValue"] = boost::any(*adjustmentValue);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (lifecycleHookContextShrink) {
      res["LifecycleHookContext"] = boost::any(*lifecycleHookContextShrink);
    }
    if (minAdjustmentMagnitude) {
      res["MinAdjustmentMagnitude"] = boost::any(*minAdjustmentMagnitude);
    }
    if (overridesShrink) {
      res["Overrides"] = boost::any(*overridesShrink);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (syncActivity) {
      res["SyncActivity"] = boost::any(*syncActivity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityMetadata") != m.end() && !m["ActivityMetadata"].empty()) {
      activityMetadata = make_shared<string>(boost::any_cast<string>(m["ActivityMetadata"]));
    }
    if (m.find("AdjustmentType") != m.end() && !m["AdjustmentType"].empty()) {
      adjustmentType = make_shared<string>(boost::any_cast<string>(m["AdjustmentType"]));
    }
    if (m.find("AdjustmentValue") != m.end() && !m["AdjustmentValue"].empty()) {
      adjustmentValue = make_shared<long>(boost::any_cast<long>(m["AdjustmentValue"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("LifecycleHookContext") != m.end() && !m["LifecycleHookContext"].empty()) {
      lifecycleHookContextShrink = make_shared<string>(boost::any_cast<string>(m["LifecycleHookContext"]));
    }
    if (m.find("MinAdjustmentMagnitude") != m.end() && !m["MinAdjustmentMagnitude"].empty()) {
      minAdjustmentMagnitude = make_shared<long>(boost::any_cast<long>(m["MinAdjustmentMagnitude"]));
    }
    if (m.find("Overrides") != m.end() && !m["Overrides"].empty()) {
      overridesShrink = make_shared<string>(boost::any_cast<string>(m["Overrides"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("SyncActivity") != m.end() && !m["SyncActivity"].empty()) {
      syncActivity = make_shared<bool>(boost::any_cast<bool>(m["SyncActivity"]));
    }
  }


  virtual ~ScaleWithAdjustmentShrinkRequest() = default;
};
class ScaleWithAdjustmentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> activityType{};
  shared_ptr<string> requestId{};
  shared_ptr<string> scalingActivityId{};

  ScaleWithAdjustmentResponseBody() {}

  explicit ScaleWithAdjustmentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityType) {
      res["ActivityType"] = boost::any(*activityType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingActivityId) {
      res["ScalingActivityId"] = boost::any(*scalingActivityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityType") != m.end() && !m["ActivityType"].empty()) {
      activityType = make_shared<string>(boost::any_cast<string>(m["ActivityType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingActivityId") != m.end() && !m["ScalingActivityId"].empty()) {
      scalingActivityId = make_shared<string>(boost::any_cast<string>(m["ScalingActivityId"]));
    }
  }


  virtual ~ScaleWithAdjustmentResponseBody() = default;
};
class ScaleWithAdjustmentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ScaleWithAdjustmentResponseBody> body{};

  ScaleWithAdjustmentResponse() {}

  explicit ScaleWithAdjustmentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ScaleWithAdjustmentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ScaleWithAdjustmentResponseBody>(model1);
      }
    }
  }


  virtual ~ScaleWithAdjustmentResponse() = default;
};
class SetGroupDeletionProtectionRequest : public Darabonba::Model {
public:
  shared_ptr<bool> groupDeletionProtection{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};

  SetGroupDeletionProtectionRequest() {}

  explicit SetGroupDeletionProtectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupDeletionProtection) {
      res["GroupDeletionProtection"] = boost::any(*groupDeletionProtection);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupDeletionProtection") != m.end() && !m["GroupDeletionProtection"].empty()) {
      groupDeletionProtection = make_shared<bool>(boost::any_cast<bool>(m["GroupDeletionProtection"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~SetGroupDeletionProtectionRequest() = default;
};
class SetGroupDeletionProtectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetGroupDeletionProtectionResponseBody() {}

  explicit SetGroupDeletionProtectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetGroupDeletionProtectionResponseBody() = default;
};
class SetGroupDeletionProtectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetGroupDeletionProtectionResponseBody> body{};

  SetGroupDeletionProtectionResponse() {}

  explicit SetGroupDeletionProtectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetGroupDeletionProtectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetGroupDeletionProtectionResponseBody>(model1);
      }
    }
  }


  virtual ~SetGroupDeletionProtectionResponse() = default;
};
class SetInstanceHealthRequest : public Darabonba::Model {
public:
  shared_ptr<string> healthStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};

  SetInstanceHealthRequest() {}

  explicit SetInstanceHealthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
  }


  virtual ~SetInstanceHealthRequest() = default;
};
class SetInstanceHealthResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetInstanceHealthResponseBody() {}

  explicit SetInstanceHealthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetInstanceHealthResponseBody() = default;
};
class SetInstanceHealthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetInstanceHealthResponseBody> body{};

  SetInstanceHealthResponse() {}

  explicit SetInstanceHealthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetInstanceHealthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetInstanceHealthResponseBody>(model1);
      }
    }
  }


  virtual ~SetInstanceHealthResponse() = default;
};
class SetInstancesProtectionRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<long> ownerId{};
  shared_ptr<bool> protectedFromScaleIn{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};

  SetInstancesProtectionRequest() {}

  explicit SetInstancesProtectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (protectedFromScaleIn) {
      res["ProtectedFromScaleIn"] = boost::any(*protectedFromScaleIn);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProtectedFromScaleIn") != m.end() && !m["ProtectedFromScaleIn"].empty()) {
      protectedFromScaleIn = make_shared<bool>(boost::any_cast<bool>(m["ProtectedFromScaleIn"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~SetInstancesProtectionRequest() = default;
};
class SetInstancesProtectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetInstancesProtectionResponseBody() {}

  explicit SetInstancesProtectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetInstancesProtectionResponseBody() = default;
};
class SetInstancesProtectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetInstancesProtectionResponseBody> body{};

  SetInstancesProtectionResponse() {}

  explicit SetInstancesProtectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetInstancesProtectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetInstancesProtectionResponseBody>(model1);
      }
    }
  }


  virtual ~SetInstancesProtectionResponse() = default;
};
class StartInstanceRefreshRequestDesiredConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> scalingConfigurationId{};

  StartInstanceRefreshRequestDesiredConfiguration() {}

  explicit StartInstanceRefreshRequestDesiredConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (scalingConfigurationId) {
      res["ScalingConfigurationId"] = boost::any(*scalingConfigurationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ScalingConfigurationId") != m.end() && !m["ScalingConfigurationId"].empty()) {
      scalingConfigurationId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigurationId"]));
    }
  }


  virtual ~StartInstanceRefreshRequestDesiredConfiguration() = default;
};
class StartInstanceRefreshRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<StartInstanceRefreshRequestDesiredConfiguration> desiredConfiguration{};
  shared_ptr<long> maxHealthyPercentage{};
  shared_ptr<long> minHealthyPercentage{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<bool> skipMatching{};

  StartInstanceRefreshRequest() {}

  explicit StartInstanceRefreshRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (desiredConfiguration) {
      res["DesiredConfiguration"] = desiredConfiguration ? boost::any(desiredConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (maxHealthyPercentage) {
      res["MaxHealthyPercentage"] = boost::any(*maxHealthyPercentage);
    }
    if (minHealthyPercentage) {
      res["MinHealthyPercentage"] = boost::any(*minHealthyPercentage);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (skipMatching) {
      res["SkipMatching"] = boost::any(*skipMatching);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DesiredConfiguration") != m.end() && !m["DesiredConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["DesiredConfiguration"].type()) {
        StartInstanceRefreshRequestDesiredConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DesiredConfiguration"]));
        desiredConfiguration = make_shared<StartInstanceRefreshRequestDesiredConfiguration>(model1);
      }
    }
    if (m.find("MaxHealthyPercentage") != m.end() && !m["MaxHealthyPercentage"].empty()) {
      maxHealthyPercentage = make_shared<long>(boost::any_cast<long>(m["MaxHealthyPercentage"]));
    }
    if (m.find("MinHealthyPercentage") != m.end() && !m["MinHealthyPercentage"].empty()) {
      minHealthyPercentage = make_shared<long>(boost::any_cast<long>(m["MinHealthyPercentage"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("SkipMatching") != m.end() && !m["SkipMatching"].empty()) {
      skipMatching = make_shared<bool>(boost::any_cast<bool>(m["SkipMatching"]));
    }
  }


  virtual ~StartInstanceRefreshRequest() = default;
};
class StartInstanceRefreshResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> instanceRefreshTaskId{};
  shared_ptr<string> requestId{};

  StartInstanceRefreshResponseBody() {}

  explicit StartInstanceRefreshResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceRefreshTaskId) {
      res["InstanceRefreshTaskId"] = boost::any(*instanceRefreshTaskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceRefreshTaskId") != m.end() && !m["InstanceRefreshTaskId"].empty()) {
      instanceRefreshTaskId = make_shared<string>(boost::any_cast<string>(m["InstanceRefreshTaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartInstanceRefreshResponseBody() = default;
};
class StartInstanceRefreshResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartInstanceRefreshResponseBody> body{};

  StartInstanceRefreshResponse() {}

  explicit StartInstanceRefreshResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartInstanceRefreshResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartInstanceRefreshResponseBody>(model1);
      }
    }
  }


  virtual ~StartInstanceRefreshResponse() = default;
};
class SuspendInstanceRefreshRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceRefreshTaskId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};

  SuspendInstanceRefreshRequest() {}

  explicit SuspendInstanceRefreshRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceRefreshTaskId) {
      res["InstanceRefreshTaskId"] = boost::any(*instanceRefreshTaskId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceRefreshTaskId") != m.end() && !m["InstanceRefreshTaskId"].empty()) {
      instanceRefreshTaskId = make_shared<string>(boost::any_cast<string>(m["InstanceRefreshTaskId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~SuspendInstanceRefreshRequest() = default;
};
class SuspendInstanceRefreshResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SuspendInstanceRefreshResponseBody() {}

  explicit SuspendInstanceRefreshResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SuspendInstanceRefreshResponseBody() = default;
};
class SuspendInstanceRefreshResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SuspendInstanceRefreshResponseBody> body{};

  SuspendInstanceRefreshResponse() {}

  explicit SuspendInstanceRefreshResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SuspendInstanceRefreshResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SuspendInstanceRefreshResponseBody>(model1);
      }
    }
  }


  virtual ~SuspendInstanceRefreshResponse() = default;
};
class SuspendProcessesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<vector<string>> processes{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> scalingGroupId{};

  SuspendProcessesRequest() {}

  explicit SuspendProcessesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (processes) {
      res["Processes"] = boost::any(*processes);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Processes") != m.end() && !m["Processes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Processes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Processes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      processes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
  }


  virtual ~SuspendProcessesRequest() = default;
};
class SuspendProcessesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SuspendProcessesResponseBody() {}

  explicit SuspendProcessesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SuspendProcessesResponseBody() = default;
};
class SuspendProcessesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SuspendProcessesResponseBody> body{};

  SuspendProcessesResponse() {}

  explicit SuspendProcessesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SuspendProcessesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SuspendProcessesResponseBody>(model1);
      }
    }
  }


  virtual ~SuspendProcessesResponse() = default;
};
class TagResourcesRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<bool> propagate{};
  shared_ptr<string> value{};

  TagResourcesRequestTags() {}

  explicit TagResourcesRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (propagate) {
      res["Propagate"] = boost::any(*propagate);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Propagate") != m.end() && !m["Propagate"].empty()) {
      propagate = make_shared<bool>(boost::any_cast<bool>(m["Propagate"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesRequestTags() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceIds{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagResourcesRequestTags>> tags{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<TagResourcesRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<TagResourcesRequestTags>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceIds{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKeys{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKeys) {
      res["TagKeys"] = boost::any(*tagKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKeys") != m.end() && !m["TagKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class VerifyAuthenticationRequest : public Darabonba::Model {
public:
  shared_ptr<bool> onlyCheck{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> uid{};

  VerifyAuthenticationRequest() {}

  explicit VerifyAuthenticationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (onlyCheck) {
      res["OnlyCheck"] = boost::any(*onlyCheck);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OnlyCheck") != m.end() && !m["OnlyCheck"].empty()) {
      onlyCheck = make_shared<bool>(boost::any_cast<bool>(m["OnlyCheck"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<long>(boost::any_cast<long>(m["Uid"]));
    }
  }


  virtual ~VerifyAuthenticationRequest() = default;
};
class VerifyAuthenticationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  VerifyAuthenticationResponseBody() {}

  explicit VerifyAuthenticationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~VerifyAuthenticationResponseBody() = default;
};
class VerifyAuthenticationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<VerifyAuthenticationResponseBody> body{};

  VerifyAuthenticationResponse() {}

  explicit VerifyAuthenticationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        VerifyAuthenticationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<VerifyAuthenticationResponseBody>(model1);
      }
    }
  }


  virtual ~VerifyAuthenticationResponse() = default;
};
class VerifyUserRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  VerifyUserRequest() {}

  explicit VerifyUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~VerifyUserRequest() = default;
};
class VerifyUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  VerifyUserResponseBody() {}

  explicit VerifyUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~VerifyUserResponseBody() = default;
};
class VerifyUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<VerifyUserResponseBody> body{};

  VerifyUserResponse() {}

  explicit VerifyUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        VerifyUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<VerifyUserResponseBody>(model1);
      }
    }
  }


  virtual ~VerifyUserResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  ApplyEciScalingConfigurationResponse applyEciScalingConfigurationWithOptions(shared_ptr<ApplyEciScalingConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyEciScalingConfigurationResponse applyEciScalingConfiguration(shared_ptr<ApplyEciScalingConfigurationRequest> request);
  ApplyScalingGroupResponse applyScalingGroupWithOptions(shared_ptr<ApplyScalingGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyScalingGroupResponse applyScalingGroup(shared_ptr<ApplyScalingGroupRequest> request);
  AttachAlbServerGroupsResponse attachAlbServerGroupsWithOptions(shared_ptr<AttachAlbServerGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachAlbServerGroupsResponse attachAlbServerGroups(shared_ptr<AttachAlbServerGroupsRequest> request);
  AttachDBInstancesResponse attachDBInstancesWithOptions(shared_ptr<AttachDBInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachDBInstancesResponse attachDBInstances(shared_ptr<AttachDBInstancesRequest> request);
  AttachInstancesResponse attachInstancesWithOptions(shared_ptr<AttachInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachInstancesResponse attachInstances(shared_ptr<AttachInstancesRequest> request);
  AttachLoadBalancersResponse attachLoadBalancersWithOptions(shared_ptr<AttachLoadBalancersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachLoadBalancersResponse attachLoadBalancers(shared_ptr<AttachLoadBalancersRequest> request);
  AttachServerGroupsResponse attachServerGroupsWithOptions(shared_ptr<AttachServerGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachServerGroupsResponse attachServerGroups(shared_ptr<AttachServerGroupsRequest> request);
  AttachVServerGroupsResponse attachVServerGroupsWithOptions(shared_ptr<AttachVServerGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachVServerGroupsResponse attachVServerGroups(shared_ptr<AttachVServerGroupsRequest> request);
  CancelInstanceRefreshResponse cancelInstanceRefreshWithOptions(shared_ptr<CancelInstanceRefreshRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelInstanceRefreshResponse cancelInstanceRefresh(shared_ptr<CancelInstanceRefreshRequest> request);
  ChangeResourceGroupResponse changeResourceGroupWithOptions(shared_ptr<ChangeResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeResourceGroupResponse changeResourceGroup(shared_ptr<ChangeResourceGroupRequest> request);
  CompleteLifecycleActionResponse completeLifecycleActionWithOptions(shared_ptr<CompleteLifecycleActionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CompleteLifecycleActionResponse completeLifecycleAction(shared_ptr<CompleteLifecycleActionRequest> request);
  CreateAlarmResponse createAlarmWithOptions(shared_ptr<CreateAlarmRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAlarmResponse createAlarm(shared_ptr<CreateAlarmRequest> request);
  CreateDiagnoseReportResponse createDiagnoseReportWithOptions(shared_ptr<CreateDiagnoseReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDiagnoseReportResponse createDiagnoseReport(shared_ptr<CreateDiagnoseReportRequest> request);
  CreateEciScalingConfigurationResponse createEciScalingConfigurationWithOptions(shared_ptr<CreateEciScalingConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEciScalingConfigurationResponse createEciScalingConfiguration(shared_ptr<CreateEciScalingConfigurationRequest> request);
  CreateLifecycleHookResponse createLifecycleHookWithOptions(shared_ptr<CreateLifecycleHookRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLifecycleHookResponse createLifecycleHook(shared_ptr<CreateLifecycleHookRequest> request);
  CreateNotificationConfigurationResponse createNotificationConfigurationWithOptions(shared_ptr<CreateNotificationConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNotificationConfigurationResponse createNotificationConfiguration(shared_ptr<CreateNotificationConfigurationRequest> request);
  CreateScalingConfigurationResponse createScalingConfigurationWithOptions(shared_ptr<CreateScalingConfigurationRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateScalingConfigurationResponse createScalingConfiguration(shared_ptr<CreateScalingConfigurationRequest> request);
  CreateScalingGroupResponse createScalingGroupWithOptions(shared_ptr<CreateScalingGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateScalingGroupResponse createScalingGroup(shared_ptr<CreateScalingGroupRequest> request);
  CreateScalingRuleResponse createScalingRuleWithOptions(shared_ptr<CreateScalingRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateScalingRuleResponse createScalingRule(shared_ptr<CreateScalingRuleRequest> request);
  CreateScheduledTaskResponse createScheduledTaskWithOptions(shared_ptr<CreateScheduledTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateScheduledTaskResponse createScheduledTask(shared_ptr<CreateScheduledTaskRequest> request);
  DeactivateScalingConfigurationResponse deactivateScalingConfigurationWithOptions(shared_ptr<DeactivateScalingConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeactivateScalingConfigurationResponse deactivateScalingConfiguration(shared_ptr<DeactivateScalingConfigurationRequest> request);
  DeleteAlarmResponse deleteAlarmWithOptions(shared_ptr<DeleteAlarmRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAlarmResponse deleteAlarm(shared_ptr<DeleteAlarmRequest> request);
  DeleteEciScalingConfigurationResponse deleteEciScalingConfigurationWithOptions(shared_ptr<DeleteEciScalingConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEciScalingConfigurationResponse deleteEciScalingConfiguration(shared_ptr<DeleteEciScalingConfigurationRequest> request);
  DeleteLifecycleHookResponse deleteLifecycleHookWithOptions(shared_ptr<DeleteLifecycleHookRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLifecycleHookResponse deleteLifecycleHook(shared_ptr<DeleteLifecycleHookRequest> request);
  DeleteNotificationConfigurationResponse deleteNotificationConfigurationWithOptions(shared_ptr<DeleteNotificationConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNotificationConfigurationResponse deleteNotificationConfiguration(shared_ptr<DeleteNotificationConfigurationRequest> request);
  DeleteScalingConfigurationResponse deleteScalingConfigurationWithOptions(shared_ptr<DeleteScalingConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteScalingConfigurationResponse deleteScalingConfiguration(shared_ptr<DeleteScalingConfigurationRequest> request);
  DeleteScalingGroupResponse deleteScalingGroupWithOptions(shared_ptr<DeleteScalingGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteScalingGroupResponse deleteScalingGroup(shared_ptr<DeleteScalingGroupRequest> request);
  DeleteScalingRuleResponse deleteScalingRuleWithOptions(shared_ptr<DeleteScalingRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteScalingRuleResponse deleteScalingRule(shared_ptr<DeleteScalingRuleRequest> request);
  DeleteScheduledTaskResponse deleteScheduledTaskWithOptions(shared_ptr<DeleteScheduledTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteScheduledTaskResponse deleteScheduledTask(shared_ptr<DeleteScheduledTaskRequest> request);
  DescribeAlarmsResponse describeAlarmsWithOptions(shared_ptr<DescribeAlarmsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAlarmsResponse describeAlarms(shared_ptr<DescribeAlarmsRequest> request);
  DescribeAlertConfigurationResponse describeAlertConfigurationWithOptions(shared_ptr<DescribeAlertConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAlertConfigurationResponse describeAlertConfiguration(shared_ptr<DescribeAlertConfigurationRequest> request);
  DescribeDiagnoseReportsResponse describeDiagnoseReportsWithOptions(shared_ptr<DescribeDiagnoseReportsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDiagnoseReportsResponse describeDiagnoseReports(shared_ptr<DescribeDiagnoseReportsRequest> request);
  DescribeEciScalingConfigurationDetailResponse describeEciScalingConfigurationDetailWithOptions(shared_ptr<DescribeEciScalingConfigurationDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEciScalingConfigurationDetailResponse describeEciScalingConfigurationDetail(shared_ptr<DescribeEciScalingConfigurationDetailRequest> request);
  DescribeEciScalingConfigurationsResponse describeEciScalingConfigurationsWithOptions(shared_ptr<DescribeEciScalingConfigurationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEciScalingConfigurationsResponse describeEciScalingConfigurations(shared_ptr<DescribeEciScalingConfigurationsRequest> request);
  DescribeElasticStrengthResponse describeElasticStrengthWithOptions(shared_ptr<DescribeElasticStrengthRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeElasticStrengthResponse describeElasticStrength(shared_ptr<DescribeElasticStrengthRequest> request);
  DescribeInstanceRefreshesResponse describeInstanceRefreshesWithOptions(shared_ptr<DescribeInstanceRefreshesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceRefreshesResponse describeInstanceRefreshes(shared_ptr<DescribeInstanceRefreshesRequest> request);
  DescribeLifecycleActionsResponse describeLifecycleActionsWithOptions(shared_ptr<DescribeLifecycleActionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLifecycleActionsResponse describeLifecycleActions(shared_ptr<DescribeLifecycleActionsRequest> request);
  DescribeLifecycleHooksResponse describeLifecycleHooksWithOptions(shared_ptr<DescribeLifecycleHooksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLifecycleHooksResponse describeLifecycleHooks(shared_ptr<DescribeLifecycleHooksRequest> request);
  DescribeLimitationResponse describeLimitationWithOptions(shared_ptr<DescribeLimitationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLimitationResponse describeLimitation(shared_ptr<DescribeLimitationRequest> request);
  DescribeNotificationConfigurationsResponse describeNotificationConfigurationsWithOptions(shared_ptr<DescribeNotificationConfigurationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNotificationConfigurationsResponse describeNotificationConfigurations(shared_ptr<DescribeNotificationConfigurationsRequest> request);
  DescribeNotificationTypesResponse describeNotificationTypesWithOptions(shared_ptr<DescribeNotificationTypesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNotificationTypesResponse describeNotificationTypes(shared_ptr<DescribeNotificationTypesRequest> request);
  DescribePatternTypesResponse describePatternTypesWithOptions(shared_ptr<DescribePatternTypesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePatternTypesResponse describePatternTypes(shared_ptr<DescribePatternTypesRequest> request);
  DescribeRegionsResponse describeRegionsWithOptions(shared_ptr<DescribeRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRegionsResponse describeRegions(shared_ptr<DescribeRegionsRequest> request);
  DescribeScalingActivitiesResponse describeScalingActivitiesWithOptions(shared_ptr<DescribeScalingActivitiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScalingActivitiesResponse describeScalingActivities(shared_ptr<DescribeScalingActivitiesRequest> request);
  DescribeScalingActivityDetailResponse describeScalingActivityDetailWithOptions(shared_ptr<DescribeScalingActivityDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScalingActivityDetailResponse describeScalingActivityDetail(shared_ptr<DescribeScalingActivityDetailRequest> request);
  DescribeScalingConfigurationsResponse describeScalingConfigurationsWithOptions(shared_ptr<DescribeScalingConfigurationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScalingConfigurationsResponse describeScalingConfigurations(shared_ptr<DescribeScalingConfigurationsRequest> request);
  DescribeScalingGroupDetailResponse describeScalingGroupDetailWithOptions(shared_ptr<DescribeScalingGroupDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScalingGroupDetailResponse describeScalingGroupDetail(shared_ptr<DescribeScalingGroupDetailRequest> request);
  DescribeScalingGroupDiagnoseDetailsResponse describeScalingGroupDiagnoseDetailsWithOptions(shared_ptr<DescribeScalingGroupDiagnoseDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScalingGroupDiagnoseDetailsResponse describeScalingGroupDiagnoseDetails(shared_ptr<DescribeScalingGroupDiagnoseDetailsRequest> request);
  DescribeScalingGroupsResponse describeScalingGroupsWithOptions(shared_ptr<DescribeScalingGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScalingGroupsResponse describeScalingGroups(shared_ptr<DescribeScalingGroupsRequest> request);
  DescribeScalingInstancesResponse describeScalingInstancesWithOptions(shared_ptr<DescribeScalingInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScalingInstancesResponse describeScalingInstances(shared_ptr<DescribeScalingInstancesRequest> request);
  DescribeScalingRulesResponse describeScalingRulesWithOptions(shared_ptr<DescribeScalingRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScalingRulesResponse describeScalingRules(shared_ptr<DescribeScalingRulesRequest> request);
  DescribeScheduledTasksResponse describeScheduledTasksWithOptions(shared_ptr<DescribeScheduledTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScheduledTasksResponse describeScheduledTasks(shared_ptr<DescribeScheduledTasksRequest> request);
  DetachAlbServerGroupsResponse detachAlbServerGroupsWithOptions(shared_ptr<DetachAlbServerGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachAlbServerGroupsResponse detachAlbServerGroups(shared_ptr<DetachAlbServerGroupsRequest> request);
  DetachDBInstancesResponse detachDBInstancesWithOptions(shared_ptr<DetachDBInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachDBInstancesResponse detachDBInstances(shared_ptr<DetachDBInstancesRequest> request);
  DetachInstancesResponse detachInstancesWithOptions(shared_ptr<DetachInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachInstancesResponse detachInstances(shared_ptr<DetachInstancesRequest> request);
  DetachLoadBalancersResponse detachLoadBalancersWithOptions(shared_ptr<DetachLoadBalancersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachLoadBalancersResponse detachLoadBalancers(shared_ptr<DetachLoadBalancersRequest> request);
  DetachServerGroupsResponse detachServerGroupsWithOptions(shared_ptr<DetachServerGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachServerGroupsResponse detachServerGroups(shared_ptr<DetachServerGroupsRequest> request);
  DetachVServerGroupsResponse detachVServerGroupsWithOptions(shared_ptr<DetachVServerGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachVServerGroupsResponse detachVServerGroups(shared_ptr<DetachVServerGroupsRequest> request);
  DisableAlarmResponse disableAlarmWithOptions(shared_ptr<DisableAlarmRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableAlarmResponse disableAlarm(shared_ptr<DisableAlarmRequest> request);
  DisableScalingGroupResponse disableScalingGroupWithOptions(shared_ptr<DisableScalingGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableScalingGroupResponse disableScalingGroup(shared_ptr<DisableScalingGroupRequest> request);
  EnableAlarmResponse enableAlarmWithOptions(shared_ptr<EnableAlarmRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableAlarmResponse enableAlarm(shared_ptr<EnableAlarmRequest> request);
  EnableScalingGroupResponse enableScalingGroupWithOptions(shared_ptr<EnableScalingGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableScalingGroupResponse enableScalingGroup(shared_ptr<EnableScalingGroupRequest> request);
  EnterStandbyResponse enterStandbyWithOptions(shared_ptr<EnterStandbyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnterStandbyResponse enterStandby(shared_ptr<EnterStandbyRequest> request);
  ExecuteScalingRuleResponse executeScalingRuleWithOptions(shared_ptr<ExecuteScalingRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExecuteScalingRuleResponse executeScalingRule(shared_ptr<ExecuteScalingRuleRequest> request);
  ExitStandbyResponse exitStandbyWithOptions(shared_ptr<ExitStandbyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExitStandbyResponse exitStandby(shared_ptr<ExitStandbyRequest> request);
  ListTagKeysResponse listTagKeysWithOptions(shared_ptr<ListTagKeysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagKeysResponse listTagKeys(shared_ptr<ListTagKeysRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ListTagValuesResponse listTagValuesWithOptions(shared_ptr<ListTagValuesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagValuesResponse listTagValues(shared_ptr<ListTagValuesRequest> request);
  ModifyAlarmResponse modifyAlarmWithOptions(shared_ptr<ModifyAlarmRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAlarmResponse modifyAlarm(shared_ptr<ModifyAlarmRequest> request);
  ModifyAlertConfigurationResponse modifyAlertConfigurationWithOptions(shared_ptr<ModifyAlertConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAlertConfigurationResponse modifyAlertConfiguration(shared_ptr<ModifyAlertConfigurationRequest> request);
  ModifyEciScalingConfigurationResponse modifyEciScalingConfigurationWithOptions(shared_ptr<ModifyEciScalingConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyEciScalingConfigurationResponse modifyEciScalingConfiguration(shared_ptr<ModifyEciScalingConfigurationRequest> request);
  ModifyInstanceAttributeResponse modifyInstanceAttributeWithOptions(shared_ptr<ModifyInstanceAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceAttributeResponse modifyInstanceAttribute(shared_ptr<ModifyInstanceAttributeRequest> request);
  ModifyLifecycleHookResponse modifyLifecycleHookWithOptions(shared_ptr<ModifyLifecycleHookRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyLifecycleHookResponse modifyLifecycleHook(shared_ptr<ModifyLifecycleHookRequest> request);
  ModifyNotificationConfigurationResponse modifyNotificationConfigurationWithOptions(shared_ptr<ModifyNotificationConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyNotificationConfigurationResponse modifyNotificationConfiguration(shared_ptr<ModifyNotificationConfigurationRequest> request);
  ModifyScalingConfigurationResponse modifyScalingConfigurationWithOptions(shared_ptr<ModifyScalingConfigurationRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyScalingConfigurationResponse modifyScalingConfiguration(shared_ptr<ModifyScalingConfigurationRequest> request);
  ModifyScalingGroupResponse modifyScalingGroupWithOptions(shared_ptr<ModifyScalingGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyScalingGroupResponse modifyScalingGroup(shared_ptr<ModifyScalingGroupRequest> request);
  ModifyScalingRuleResponse modifyScalingRuleWithOptions(shared_ptr<ModifyScalingRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyScalingRuleResponse modifyScalingRule(shared_ptr<ModifyScalingRuleRequest> request);
  ModifyScheduledTaskResponse modifyScheduledTaskWithOptions(shared_ptr<ModifyScheduledTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyScheduledTaskResponse modifyScheduledTask(shared_ptr<ModifyScheduledTaskRequest> request);
  RebalanceInstancesResponse rebalanceInstancesWithOptions(shared_ptr<RebalanceInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RebalanceInstancesResponse rebalanceInstances(shared_ptr<RebalanceInstancesRequest> request);
  RecordLifecycleActionHeartbeatResponse recordLifecycleActionHeartbeatWithOptions(shared_ptr<RecordLifecycleActionHeartbeatRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RecordLifecycleActionHeartbeatResponse recordLifecycleActionHeartbeat(shared_ptr<RecordLifecycleActionHeartbeatRequest> request);
  RemoveInstancesResponse removeInstancesWithOptions(shared_ptr<RemoveInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveInstancesResponse removeInstances(shared_ptr<RemoveInstancesRequest> request);
  ResumeInstanceRefreshResponse resumeInstanceRefreshWithOptions(shared_ptr<ResumeInstanceRefreshRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeInstanceRefreshResponse resumeInstanceRefresh(shared_ptr<ResumeInstanceRefreshRequest> request);
  ResumeProcessesResponse resumeProcessesWithOptions(shared_ptr<ResumeProcessesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeProcessesResponse resumeProcesses(shared_ptr<ResumeProcessesRequest> request);
  RollbackInstanceRefreshResponse rollbackInstanceRefreshWithOptions(shared_ptr<RollbackInstanceRefreshRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RollbackInstanceRefreshResponse rollbackInstanceRefresh(shared_ptr<RollbackInstanceRefreshRequest> request);
  ScaleWithAdjustmentResponse scaleWithAdjustmentWithOptions(shared_ptr<ScaleWithAdjustmentRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ScaleWithAdjustmentResponse scaleWithAdjustment(shared_ptr<ScaleWithAdjustmentRequest> request);
  SetGroupDeletionProtectionResponse setGroupDeletionProtectionWithOptions(shared_ptr<SetGroupDeletionProtectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetGroupDeletionProtectionResponse setGroupDeletionProtection(shared_ptr<SetGroupDeletionProtectionRequest> request);
  SetInstanceHealthResponse setInstanceHealthWithOptions(shared_ptr<SetInstanceHealthRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetInstanceHealthResponse setInstanceHealth(shared_ptr<SetInstanceHealthRequest> request);
  SetInstancesProtectionResponse setInstancesProtectionWithOptions(shared_ptr<SetInstancesProtectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetInstancesProtectionResponse setInstancesProtection(shared_ptr<SetInstancesProtectionRequest> request);
  StartInstanceRefreshResponse startInstanceRefreshWithOptions(shared_ptr<StartInstanceRefreshRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartInstanceRefreshResponse startInstanceRefresh(shared_ptr<StartInstanceRefreshRequest> request);
  SuspendInstanceRefreshResponse suspendInstanceRefreshWithOptions(shared_ptr<SuspendInstanceRefreshRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SuspendInstanceRefreshResponse suspendInstanceRefresh(shared_ptr<SuspendInstanceRefreshRequest> request);
  SuspendProcessesResponse suspendProcessesWithOptions(shared_ptr<SuspendProcessesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SuspendProcessesResponse suspendProcesses(shared_ptr<SuspendProcessesRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  VerifyAuthenticationResponse verifyAuthenticationWithOptions(shared_ptr<VerifyAuthenticationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  VerifyAuthenticationResponse verifyAuthentication(shared_ptr<VerifyAuthenticationRequest> request);
  VerifyUserResponse verifyUserWithOptions(shared_ptr<VerifyUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  VerifyUserResponse verifyUser(shared_ptr<VerifyUserRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Ess20220222

#endif
