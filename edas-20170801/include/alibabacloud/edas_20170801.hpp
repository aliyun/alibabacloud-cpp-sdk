// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_EDAS20170801_H_
#define ALIBABACLOUD_EDAS20170801_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Edas20170801 {
class AppConfigConfigMountDescsMountItems : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> path{};

  AppConfigConfigMountDescsMountItems() {}

  explicit AppConfigConfigMountDescsMountItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~AppConfigConfigMountDescsMountItems() = default;
};
class AppConfigConfigMountDescs : public Darabonba::Model {
public:
  shared_ptr<vector<AppConfigConfigMountDescsMountItems>> mountItems{};
  shared_ptr<string> mountPath{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  AppConfigConfigMountDescs() {}

  explicit AppConfigConfigMountDescs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountItems) {
      vector<boost::any> temp1;
      for(auto item1:*mountItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MountItems"] = boost::any(temp1);
    }
    if (mountPath) {
      res["MountPath"] = boost::any(*mountPath);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MountItems") != m.end() && !m["MountItems"].empty()) {
      if (typeid(vector<boost::any>) == m["MountItems"].type()) {
        vector<AppConfigConfigMountDescsMountItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MountItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AppConfigConfigMountDescsMountItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mountItems = make_shared<vector<AppConfigConfigMountDescsMountItems>>(expect1);
      }
    }
    if (m.find("MountPath") != m.end() && !m["MountPath"].empty()) {
      mountPath = make_shared<string>(boost::any_cast<string>(m["MountPath"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AppConfigConfigMountDescs() = default;
};
class AppConfigEmptyDirs : public Darabonba::Model {
public:
  shared_ptr<string> mountPath{};
  shared_ptr<string> name{};
  shared_ptr<bool> readOnly{};
  shared_ptr<string> subPathExpr{};

  AppConfigEmptyDirs() {}

  explicit AppConfigEmptyDirs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountPath) {
      res["MountPath"] = boost::any(*mountPath);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    if (subPathExpr) {
      res["SubPathExpr"] = boost::any(*subPathExpr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MountPath") != m.end() && !m["MountPath"].empty()) {
      mountPath = make_shared<string>(boost::any_cast<string>(m["MountPath"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
    if (m.find("SubPathExpr") != m.end() && !m["SubPathExpr"].empty()) {
      subPathExpr = make_shared<string>(boost::any_cast<string>(m["SubPathExpr"]));
    }
  }


  virtual ~AppConfigEmptyDirs() = default;
};
class AppConfigEnvFroms : public Darabonba::Model {
public:
  shared_ptr<string> configMapRef{};
  shared_ptr<string> secretRef{};

  AppConfigEnvFroms() {}

  explicit AppConfigEnvFroms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configMapRef) {
      res["ConfigMapRef"] = boost::any(*configMapRef);
    }
    if (secretRef) {
      res["SecretRef"] = boost::any(*secretRef);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigMapRef") != m.end() && !m["ConfigMapRef"].empty()) {
      configMapRef = make_shared<string>(boost::any_cast<string>(m["ConfigMapRef"]));
    }
    if (m.find("SecretRef") != m.end() && !m["SecretRef"].empty()) {
      secretRef = make_shared<string>(boost::any_cast<string>(m["SecretRef"]));
    }
  }


  virtual ~AppConfigEnvFroms() = default;
};
class AppConfigEnvs : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};
  shared_ptr<string> valueFrom{};

  AppConfigEnvs() {}

  explicit AppConfigEnvs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (valueFrom) {
      res["ValueFrom"] = boost::any(*valueFrom);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("ValueFrom") != m.end() && !m["ValueFrom"].empty()) {
      valueFrom = make_shared<string>(boost::any_cast<string>(m["ValueFrom"]));
    }
  }


  virtual ~AppConfigEnvs() = default;
};
class AppConfigImageConfig : public Darabonba::Model {
public:
  shared_ptr<string> containerRegistryId{};
  shared_ptr<string> crInstanceId{};
  shared_ptr<string> crRegionId{};
  shared_ptr<string> imageUrl{};

  AppConfigImageConfig() {}

  explicit AppConfigImageConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerRegistryId) {
      res["ContainerRegistryId"] = boost::any(*containerRegistryId);
    }
    if (crInstanceId) {
      res["CrInstanceId"] = boost::any(*crInstanceId);
    }
    if (crRegionId) {
      res["CrRegionId"] = boost::any(*crRegionId);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerRegistryId") != m.end() && !m["ContainerRegistryId"].empty()) {
      containerRegistryId = make_shared<string>(boost::any_cast<string>(m["ContainerRegistryId"]));
    }
    if (m.find("CrInstanceId") != m.end() && !m["CrInstanceId"].empty()) {
      crInstanceId = make_shared<string>(boost::any_cast<string>(m["CrInstanceId"]));
    }
    if (m.find("CrRegionId") != m.end() && !m["CrRegionId"].empty()) {
      crRegionId = make_shared<string>(boost::any_cast<string>(m["CrRegionId"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
  }


  virtual ~AppConfigImageConfig() = default;
};
class AppConfigLocalVolumes : public Darabonba::Model {
public:
  shared_ptr<string> mountPath{};
  shared_ptr<string> name{};
  shared_ptr<string> nodePath{};
  shared_ptr<long> opsAuth{};
  shared_ptr<string> type{};

  AppConfigLocalVolumes() {}

  explicit AppConfigLocalVolumes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountPath) {
      res["MountPath"] = boost::any(*mountPath);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodePath) {
      res["NodePath"] = boost::any(*nodePath);
    }
    if (opsAuth) {
      res["OpsAuth"] = boost::any(*opsAuth);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MountPath") != m.end() && !m["MountPath"].empty()) {
      mountPath = make_shared<string>(boost::any_cast<string>(m["MountPath"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodePath") != m.end() && !m["NodePath"].empty()) {
      nodePath = make_shared<string>(boost::any_cast<string>(m["NodePath"]));
    }
    if (m.find("OpsAuth") != m.end() && !m["OpsAuth"].empty()) {
      opsAuth = make_shared<long>(boost::any_cast<long>(m["OpsAuth"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AppConfigLocalVolumes() = default;
};
class AppConfigNasMountDescs : public Darabonba::Model {
public:
  shared_ptr<string> mountPath{};
  shared_ptr<string> nasPath{};

  AppConfigNasMountDescs() {}

  explicit AppConfigNasMountDescs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountPath) {
      res["MountPath"] = boost::any(*mountPath);
    }
    if (nasPath) {
      res["NasPath"] = boost::any(*nasPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MountPath") != m.end() && !m["MountPath"].empty()) {
      mountPath = make_shared<string>(boost::any_cast<string>(m["MountPath"]));
    }
    if (m.find("NasPath") != m.end() && !m["NasPath"].empty()) {
      nasPath = make_shared<string>(boost::any_cast<string>(m["NasPath"]));
    }
  }


  virtual ~AppConfigNasMountDescs() = default;
};
class AppConfigPackageConfig : public Darabonba::Model {
public:
  shared_ptr<string> edasContainerVersion{};
  shared_ptr<string> jdk{};
  shared_ptr<string> packageType{};
  shared_ptr<string> packageUrl{};
  shared_ptr<string> packageVersion{};
  shared_ptr<string> timezone{};
  shared_ptr<string> uriEncoding{};
  shared_ptr<bool> useBodyEncoding{};
  shared_ptr<string> webContainer{};

  AppConfigPackageConfig() {}

  explicit AppConfigPackageConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edasContainerVersion) {
      res["EdasContainerVersion"] = boost::any(*edasContainerVersion);
    }
    if (jdk) {
      res["Jdk"] = boost::any(*jdk);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (packageUrl) {
      res["PackageUrl"] = boost::any(*packageUrl);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (uriEncoding) {
      res["UriEncoding"] = boost::any(*uriEncoding);
    }
    if (useBodyEncoding) {
      res["UseBodyEncoding"] = boost::any(*useBodyEncoding);
    }
    if (webContainer) {
      res["WebContainer"] = boost::any(*webContainer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EdasContainerVersion") != m.end() && !m["EdasContainerVersion"].empty()) {
      edasContainerVersion = make_shared<string>(boost::any_cast<string>(m["EdasContainerVersion"]));
    }
    if (m.find("Jdk") != m.end() && !m["Jdk"].empty()) {
      jdk = make_shared<string>(boost::any_cast<string>(m["Jdk"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("PackageUrl") != m.end() && !m["PackageUrl"].empty()) {
      packageUrl = make_shared<string>(boost::any_cast<string>(m["PackageUrl"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("UriEncoding") != m.end() && !m["UriEncoding"].empty()) {
      uriEncoding = make_shared<string>(boost::any_cast<string>(m["UriEncoding"]));
    }
    if (m.find("UseBodyEncoding") != m.end() && !m["UseBodyEncoding"].empty()) {
      useBodyEncoding = make_shared<bool>(boost::any_cast<bool>(m["UseBodyEncoding"]));
    }
    if (m.find("WebContainer") != m.end() && !m["WebContainer"].empty()) {
      webContainer = make_shared<string>(boost::any_cast<string>(m["WebContainer"]));
    }
  }


  virtual ~AppConfigPackageConfig() = default;
};
class AppConfigPvcMountDescsMountPaths : public Darabonba::Model {
public:
  shared_ptr<string> mountPath{};
  shared_ptr<bool> readOnly{};
  shared_ptr<string> subPathExpr{};

  AppConfigPvcMountDescsMountPaths() {}

  explicit AppConfigPvcMountDescsMountPaths(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountPath) {
      res["MountPath"] = boost::any(*mountPath);
    }
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    if (subPathExpr) {
      res["SubPathExpr"] = boost::any(*subPathExpr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MountPath") != m.end() && !m["MountPath"].empty()) {
      mountPath = make_shared<string>(boost::any_cast<string>(m["MountPath"]));
    }
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
    if (m.find("SubPathExpr") != m.end() && !m["SubPathExpr"].empty()) {
      subPathExpr = make_shared<string>(boost::any_cast<string>(m["SubPathExpr"]));
    }
  }


  virtual ~AppConfigPvcMountDescsMountPaths() = default;
};
class AppConfigPvcMountDescs : public Darabonba::Model {
public:
  shared_ptr<vector<AppConfigPvcMountDescsMountPaths>> mountPaths{};
  shared_ptr<string> pvcName{};

  AppConfigPvcMountDescs() {}

  explicit AppConfigPvcMountDescs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountPaths) {
      vector<boost::any> temp1;
      for(auto item1:*mountPaths){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MountPaths"] = boost::any(temp1);
    }
    if (pvcName) {
      res["PvcName"] = boost::any(*pvcName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MountPaths") != m.end() && !m["MountPaths"].empty()) {
      if (typeid(vector<boost::any>) == m["MountPaths"].type()) {
        vector<AppConfigPvcMountDescsMountPaths> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MountPaths"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AppConfigPvcMountDescsMountPaths model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mountPaths = make_shared<vector<AppConfigPvcMountDescsMountPaths>>(expect1);
      }
    }
    if (m.find("PvcName") != m.end() && !m["PvcName"].empty()) {
      pvcName = make_shared<string>(boost::any_cast<string>(m["PvcName"]));
    }
  }


  virtual ~AppConfigPvcMountDescs() = default;
};
class AppConfigSlsConfigs : public Darabonba::Model {
public:
  shared_ptr<string> logDir{};
  shared_ptr<string> logstore{};
  shared_ptr<string> project{};
  shared_ptr<string> type{};

  AppConfigSlsConfigs() {}

  explicit AppConfigSlsConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logDir) {
      res["LogDir"] = boost::any(*logDir);
    }
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogDir") != m.end() && !m["LogDir"].empty()) {
      logDir = make_shared<string>(boost::any_cast<string>(m["LogDir"]));
    }
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AppConfigSlsConfigs() = default;
};
class AppConfigWebContainerConfig : public Darabonba::Model {
public:
  shared_ptr<string> connectorType{};
  shared_ptr<string> contextInputType{};
  shared_ptr<string> contextPath{};
  shared_ptr<long> httpPort{};
  shared_ptr<long> maxThreads{};
  shared_ptr<string> serverXml{};
  shared_ptr<string> uriEncoding{};
  shared_ptr<bool> useAdvancedServerXml{};
  shared_ptr<bool> useBodyEncoding{};
  shared_ptr<bool> useDefaultConfig{};

  AppConfigWebContainerConfig() {}

  explicit AppConfigWebContainerConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectorType) {
      res["ConnectorType"] = boost::any(*connectorType);
    }
    if (contextInputType) {
      res["ContextInputType"] = boost::any(*contextInputType);
    }
    if (contextPath) {
      res["ContextPath"] = boost::any(*contextPath);
    }
    if (httpPort) {
      res["HttpPort"] = boost::any(*httpPort);
    }
    if (maxThreads) {
      res["MaxThreads"] = boost::any(*maxThreads);
    }
    if (serverXml) {
      res["ServerXml"] = boost::any(*serverXml);
    }
    if (uriEncoding) {
      res["UriEncoding"] = boost::any(*uriEncoding);
    }
    if (useAdvancedServerXml) {
      res["UseAdvancedServerXml"] = boost::any(*useAdvancedServerXml);
    }
    if (useBodyEncoding) {
      res["UseBodyEncoding"] = boost::any(*useBodyEncoding);
    }
    if (useDefaultConfig) {
      res["UseDefaultConfig"] = boost::any(*useDefaultConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectorType") != m.end() && !m["ConnectorType"].empty()) {
      connectorType = make_shared<string>(boost::any_cast<string>(m["ConnectorType"]));
    }
    if (m.find("ContextInputType") != m.end() && !m["ContextInputType"].empty()) {
      contextInputType = make_shared<string>(boost::any_cast<string>(m["ContextInputType"]));
    }
    if (m.find("ContextPath") != m.end() && !m["ContextPath"].empty()) {
      contextPath = make_shared<string>(boost::any_cast<string>(m["ContextPath"]));
    }
    if (m.find("HttpPort") != m.end() && !m["HttpPort"].empty()) {
      httpPort = make_shared<long>(boost::any_cast<long>(m["HttpPort"]));
    }
    if (m.find("MaxThreads") != m.end() && !m["MaxThreads"].empty()) {
      maxThreads = make_shared<long>(boost::any_cast<long>(m["MaxThreads"]));
    }
    if (m.find("ServerXml") != m.end() && !m["ServerXml"].empty()) {
      serverXml = make_shared<string>(boost::any_cast<string>(m["ServerXml"]));
    }
    if (m.find("UriEncoding") != m.end() && !m["UriEncoding"].empty()) {
      uriEncoding = make_shared<string>(boost::any_cast<string>(m["UriEncoding"]));
    }
    if (m.find("UseAdvancedServerXml") != m.end() && !m["UseAdvancedServerXml"].empty()) {
      useAdvancedServerXml = make_shared<bool>(boost::any_cast<bool>(m["UseAdvancedServerXml"]));
    }
    if (m.find("UseBodyEncoding") != m.end() && !m["UseBodyEncoding"].empty()) {
      useBodyEncoding = make_shared<bool>(boost::any_cast<bool>(m["UseBodyEncoding"]));
    }
    if (m.find("UseDefaultConfig") != m.end() && !m["UseDefaultConfig"].empty()) {
      useDefaultConfig = make_shared<bool>(boost::any_cast<bool>(m["UseDefaultConfig"]));
    }
  }


  virtual ~AppConfigWebContainerConfig() = default;
};
class AppConfig : public Darabonba::Model {
public:
  shared_ptr<string> command{};
  shared_ptr<vector<string>> commandArgs{};
  shared_ptr<vector<AppConfigConfigMountDescs>> configMountDescs{};
  shared_ptr<bool> deployAcrossNodes{};
  shared_ptr<bool> deployAcrossZones{};
  shared_ptr<vector<AppConfigEmptyDirs>> emptyDirs{};
  shared_ptr<bool> enableAhas{};
  shared_ptr<vector<AppConfigEnvFroms>> envFroms{};
  shared_ptr<vector<AppConfigEnvs>> envs{};
  shared_ptr<AppConfigImageConfig> imageConfig{};
  shared_ptr<bool> isMultilingualApp{};
  shared_ptr<string> javaStartUpConfig{};
  shared_ptr<string> limitCpu{};
  shared_ptr<string> limitMem{};
  shared_ptr<string> liveness{};
  shared_ptr<vector<AppConfigLocalVolumes>> localVolumes{};
  shared_ptr<string> nasId{};
  shared_ptr<vector<AppConfigNasMountDescs>> nasMountDescs{};
  shared_ptr<string> nasStorageType{};
  shared_ptr<AppConfigPackageConfig> packageConfig{};
  shared_ptr<string> postStart{};
  shared_ptr<string> preStop{};
  shared_ptr<vector<AppConfigPvcMountDescs>> pvcMountDescs{};
  shared_ptr<string> readiness{};
  shared_ptr<long> replicas{};
  shared_ptr<string> requestCpu{};
  shared_ptr<string> requestMem{};
  shared_ptr<string> runtimeClassName{};
  shared_ptr<vector<AppConfigSlsConfigs>> slsConfigs{};
  shared_ptr<AppConfigWebContainerConfig> webContainerConfig{};

  AppConfig() {}

  explicit AppConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (commandArgs) {
      res["CommandArgs"] = boost::any(*commandArgs);
    }
    if (configMountDescs) {
      vector<boost::any> temp1;
      for(auto item1:*configMountDescs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigMountDescs"] = boost::any(temp1);
    }
    if (deployAcrossNodes) {
      res["DeployAcrossNodes"] = boost::any(*deployAcrossNodes);
    }
    if (deployAcrossZones) {
      res["DeployAcrossZones"] = boost::any(*deployAcrossZones);
    }
    if (emptyDirs) {
      vector<boost::any> temp1;
      for(auto item1:*emptyDirs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EmptyDirs"] = boost::any(temp1);
    }
    if (enableAhas) {
      res["EnableAhas"] = boost::any(*enableAhas);
    }
    if (envFroms) {
      vector<boost::any> temp1;
      for(auto item1:*envFroms){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnvFroms"] = boost::any(temp1);
    }
    if (envs) {
      vector<boost::any> temp1;
      for(auto item1:*envs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Envs"] = boost::any(temp1);
    }
    if (imageConfig) {
      res["ImageConfig"] = imageConfig ? boost::any(imageConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isMultilingualApp) {
      res["IsMultilingualApp"] = boost::any(*isMultilingualApp);
    }
    if (javaStartUpConfig) {
      res["JavaStartUpConfig"] = boost::any(*javaStartUpConfig);
    }
    if (limitCpu) {
      res["LimitCpu"] = boost::any(*limitCpu);
    }
    if (limitMem) {
      res["LimitMem"] = boost::any(*limitMem);
    }
    if (liveness) {
      res["Liveness"] = boost::any(*liveness);
    }
    if (localVolumes) {
      vector<boost::any> temp1;
      for(auto item1:*localVolumes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LocalVolumes"] = boost::any(temp1);
    }
    if (nasId) {
      res["NasId"] = boost::any(*nasId);
    }
    if (nasMountDescs) {
      vector<boost::any> temp1;
      for(auto item1:*nasMountDescs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NasMountDescs"] = boost::any(temp1);
    }
    if (nasStorageType) {
      res["NasStorageType"] = boost::any(*nasStorageType);
    }
    if (packageConfig) {
      res["PackageConfig"] = packageConfig ? boost::any(packageConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (postStart) {
      res["PostStart"] = boost::any(*postStart);
    }
    if (preStop) {
      res["PreStop"] = boost::any(*preStop);
    }
    if (pvcMountDescs) {
      vector<boost::any> temp1;
      for(auto item1:*pvcMountDescs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PvcMountDescs"] = boost::any(temp1);
    }
    if (readiness) {
      res["Readiness"] = boost::any(*readiness);
    }
    if (replicas) {
      res["Replicas"] = boost::any(*replicas);
    }
    if (requestCpu) {
      res["RequestCpu"] = boost::any(*requestCpu);
    }
    if (requestMem) {
      res["RequestMem"] = boost::any(*requestMem);
    }
    if (runtimeClassName) {
      res["RuntimeClassName"] = boost::any(*runtimeClassName);
    }
    if (slsConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*slsConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SlsConfigs"] = boost::any(temp1);
    }
    if (webContainerConfig) {
      res["WebContainerConfig"] = webContainerConfig ? boost::any(webContainerConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("CommandArgs") != m.end() && !m["CommandArgs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CommandArgs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CommandArgs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      commandArgs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ConfigMountDescs") != m.end() && !m["ConfigMountDescs"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigMountDescs"].type()) {
        vector<AppConfigConfigMountDescs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigMountDescs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AppConfigConfigMountDescs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configMountDescs = make_shared<vector<AppConfigConfigMountDescs>>(expect1);
      }
    }
    if (m.find("DeployAcrossNodes") != m.end() && !m["DeployAcrossNodes"].empty()) {
      deployAcrossNodes = make_shared<bool>(boost::any_cast<bool>(m["DeployAcrossNodes"]));
    }
    if (m.find("DeployAcrossZones") != m.end() && !m["DeployAcrossZones"].empty()) {
      deployAcrossZones = make_shared<bool>(boost::any_cast<bool>(m["DeployAcrossZones"]));
    }
    if (m.find("EmptyDirs") != m.end() && !m["EmptyDirs"].empty()) {
      if (typeid(vector<boost::any>) == m["EmptyDirs"].type()) {
        vector<AppConfigEmptyDirs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EmptyDirs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AppConfigEmptyDirs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        emptyDirs = make_shared<vector<AppConfigEmptyDirs>>(expect1);
      }
    }
    if (m.find("EnableAhas") != m.end() && !m["EnableAhas"].empty()) {
      enableAhas = make_shared<bool>(boost::any_cast<bool>(m["EnableAhas"]));
    }
    if (m.find("EnvFroms") != m.end() && !m["EnvFroms"].empty()) {
      if (typeid(vector<boost::any>) == m["EnvFroms"].type()) {
        vector<AppConfigEnvFroms> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnvFroms"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AppConfigEnvFroms model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        envFroms = make_shared<vector<AppConfigEnvFroms>>(expect1);
      }
    }
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      if (typeid(vector<boost::any>) == m["Envs"].type()) {
        vector<AppConfigEnvs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Envs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AppConfigEnvs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        envs = make_shared<vector<AppConfigEnvs>>(expect1);
      }
    }
    if (m.find("ImageConfig") != m.end() && !m["ImageConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageConfig"].type()) {
        AppConfigImageConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageConfig"]));
        imageConfig = make_shared<AppConfigImageConfig>(model1);
      }
    }
    if (m.find("IsMultilingualApp") != m.end() && !m["IsMultilingualApp"].empty()) {
      isMultilingualApp = make_shared<bool>(boost::any_cast<bool>(m["IsMultilingualApp"]));
    }
    if (m.find("JavaStartUpConfig") != m.end() && !m["JavaStartUpConfig"].empty()) {
      javaStartUpConfig = make_shared<string>(boost::any_cast<string>(m["JavaStartUpConfig"]));
    }
    if (m.find("LimitCpu") != m.end() && !m["LimitCpu"].empty()) {
      limitCpu = make_shared<string>(boost::any_cast<string>(m["LimitCpu"]));
    }
    if (m.find("LimitMem") != m.end() && !m["LimitMem"].empty()) {
      limitMem = make_shared<string>(boost::any_cast<string>(m["LimitMem"]));
    }
    if (m.find("Liveness") != m.end() && !m["Liveness"].empty()) {
      liveness = make_shared<string>(boost::any_cast<string>(m["Liveness"]));
    }
    if (m.find("LocalVolumes") != m.end() && !m["LocalVolumes"].empty()) {
      if (typeid(vector<boost::any>) == m["LocalVolumes"].type()) {
        vector<AppConfigLocalVolumes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LocalVolumes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AppConfigLocalVolumes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        localVolumes = make_shared<vector<AppConfigLocalVolumes>>(expect1);
      }
    }
    if (m.find("NasId") != m.end() && !m["NasId"].empty()) {
      nasId = make_shared<string>(boost::any_cast<string>(m["NasId"]));
    }
    if (m.find("NasMountDescs") != m.end() && !m["NasMountDescs"].empty()) {
      if (typeid(vector<boost::any>) == m["NasMountDescs"].type()) {
        vector<AppConfigNasMountDescs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NasMountDescs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AppConfigNasMountDescs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nasMountDescs = make_shared<vector<AppConfigNasMountDescs>>(expect1);
      }
    }
    if (m.find("NasStorageType") != m.end() && !m["NasStorageType"].empty()) {
      nasStorageType = make_shared<string>(boost::any_cast<string>(m["NasStorageType"]));
    }
    if (m.find("PackageConfig") != m.end() && !m["PackageConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["PackageConfig"].type()) {
        AppConfigPackageConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PackageConfig"]));
        packageConfig = make_shared<AppConfigPackageConfig>(model1);
      }
    }
    if (m.find("PostStart") != m.end() && !m["PostStart"].empty()) {
      postStart = make_shared<string>(boost::any_cast<string>(m["PostStart"]));
    }
    if (m.find("PreStop") != m.end() && !m["PreStop"].empty()) {
      preStop = make_shared<string>(boost::any_cast<string>(m["PreStop"]));
    }
    if (m.find("PvcMountDescs") != m.end() && !m["PvcMountDescs"].empty()) {
      if (typeid(vector<boost::any>) == m["PvcMountDescs"].type()) {
        vector<AppConfigPvcMountDescs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PvcMountDescs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AppConfigPvcMountDescs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pvcMountDescs = make_shared<vector<AppConfigPvcMountDescs>>(expect1);
      }
    }
    if (m.find("Readiness") != m.end() && !m["Readiness"].empty()) {
      readiness = make_shared<string>(boost::any_cast<string>(m["Readiness"]));
    }
    if (m.find("Replicas") != m.end() && !m["Replicas"].empty()) {
      replicas = make_shared<long>(boost::any_cast<long>(m["Replicas"]));
    }
    if (m.find("RequestCpu") != m.end() && !m["RequestCpu"].empty()) {
      requestCpu = make_shared<string>(boost::any_cast<string>(m["RequestCpu"]));
    }
    if (m.find("RequestMem") != m.end() && !m["RequestMem"].empty()) {
      requestMem = make_shared<string>(boost::any_cast<string>(m["RequestMem"]));
    }
    if (m.find("RuntimeClassName") != m.end() && !m["RuntimeClassName"].empty()) {
      runtimeClassName = make_shared<string>(boost::any_cast<string>(m["RuntimeClassName"]));
    }
    if (m.find("SlsConfigs") != m.end() && !m["SlsConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["SlsConfigs"].type()) {
        vector<AppConfigSlsConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SlsConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AppConfigSlsConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        slsConfigs = make_shared<vector<AppConfigSlsConfigs>>(expect1);
      }
    }
    if (m.find("WebContainerConfig") != m.end() && !m["WebContainerConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebContainerConfig"].type()) {
        AppConfigWebContainerConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebContainerConfig"]));
        webContainerConfig = make_shared<AppConfigWebContainerConfig>(model1);
      }
    }
  }


  virtual ~AppConfig() = default;
};
class AbortAndRollbackChangeOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  AbortAndRollbackChangeOrderRequest() {}

  explicit AbortAndRollbackChangeOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~AbortAndRollbackChangeOrderRequest() = default;
};
class AbortAndRollbackChangeOrderResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  AbortAndRollbackChangeOrderResponseBodyData() {}

  explicit AbortAndRollbackChangeOrderResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~AbortAndRollbackChangeOrderResponseBodyData() = default;
};
class AbortAndRollbackChangeOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<AbortAndRollbackChangeOrderResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> traceId{};

  AbortAndRollbackChangeOrderResponseBody() {}

  explicit AbortAndRollbackChangeOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AbortAndRollbackChangeOrderResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AbortAndRollbackChangeOrderResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~AbortAndRollbackChangeOrderResponseBody() = default;
};
class AbortAndRollbackChangeOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AbortAndRollbackChangeOrderResponseBody> body{};

  AbortAndRollbackChangeOrderResponse() {}

  explicit AbortAndRollbackChangeOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AbortAndRollbackChangeOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AbortAndRollbackChangeOrderResponseBody>(model1);
      }
    }
  }


  virtual ~AbortAndRollbackChangeOrderResponse() = default;
};
class AbortChangeOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  AbortChangeOrderRequest() {}

  explicit AbortChangeOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~AbortChangeOrderRequest() = default;
};
class AbortChangeOrderResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  AbortChangeOrderResponseBodyData() {}

  explicit AbortChangeOrderResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~AbortChangeOrderResponseBodyData() = default;
};
class AbortChangeOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<AbortChangeOrderResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> traceId{};

  AbortChangeOrderResponseBody() {}

  explicit AbortChangeOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AbortChangeOrderResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AbortChangeOrderResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~AbortChangeOrderResponseBody() = default;
};
class AbortChangeOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AbortChangeOrderResponseBody> body{};

  AbortChangeOrderResponse() {}

  explicit AbortChangeOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AbortChangeOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AbortChangeOrderResponseBody>(model1);
      }
    }
  }


  virtual ~AbortChangeOrderResponse() = default;
};
class AddLogPathRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> path{};

  AddLogPathRequest() {}

  explicit AddLogPathRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~AddLogPathRequest() = default;
};
class AddLogPathResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddLogPathResponseBody() {}

  explicit AddLogPathResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLogPathResponseBody() = default;
};
class AddLogPathResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLogPathResponseBody> body{};

  AddLogPathResponse() {}

  explicit AddLogPathResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLogPathResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLogPathResponseBody>(model1);
      }
    }
  }


  virtual ~AddLogPathResponse() = default;
};
class AuthorizeApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appIds{};
  shared_ptr<string> targetUserId{};

  AuthorizeApplicationRequest() {}

  explicit AuthorizeApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (targetUserId) {
      res["TargetUserId"] = boost::any(*targetUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      appIds = make_shared<string>(boost::any_cast<string>(m["AppIds"]));
    }
    if (m.find("TargetUserId") != m.end() && !m["TargetUserId"].empty()) {
      targetUserId = make_shared<string>(boost::any_cast<string>(m["TargetUserId"]));
    }
  }


  virtual ~AuthorizeApplicationRequest() = default;
};
class AuthorizeApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AuthorizeApplicationResponseBody() {}

  explicit AuthorizeApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AuthorizeApplicationResponseBody() = default;
};
class AuthorizeApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AuthorizeApplicationResponseBody> body{};

  AuthorizeApplicationResponse() {}

  explicit AuthorizeApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AuthorizeApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AuthorizeApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~AuthorizeApplicationResponse() = default;
};
class AuthorizeResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroupIds{};
  shared_ptr<string> targetUserId{};

  AuthorizeResourceGroupRequest() {}

  explicit AuthorizeResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupIds) {
      res["ResourceGroupIds"] = boost::any(*resourceGroupIds);
    }
    if (targetUserId) {
      res["TargetUserId"] = boost::any(*targetUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupIds") != m.end() && !m["ResourceGroupIds"].empty()) {
      resourceGroupIds = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIds"]));
    }
    if (m.find("TargetUserId") != m.end() && !m["TargetUserId"].empty()) {
      targetUserId = make_shared<string>(boost::any_cast<string>(m["TargetUserId"]));
    }
  }


  virtual ~AuthorizeResourceGroupRequest() = default;
};
class AuthorizeResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AuthorizeResourceGroupResponseBody() {}

  explicit AuthorizeResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AuthorizeResourceGroupResponseBody() = default;
};
class AuthorizeResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AuthorizeResourceGroupResponseBody> body{};

  AuthorizeResourceGroupResponse() {}

  explicit AuthorizeResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AuthorizeResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AuthorizeResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AuthorizeResourceGroupResponse() = default;
};
class AuthorizeRoleRequest : public Darabonba::Model {
public:
  shared_ptr<string> roleIds{};
  shared_ptr<string> targetUserId{};

  AuthorizeRoleRequest() {}

  explicit AuthorizeRoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleIds) {
      res["RoleIds"] = boost::any(*roleIds);
    }
    if (targetUserId) {
      res["TargetUserId"] = boost::any(*targetUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleIds") != m.end() && !m["RoleIds"].empty()) {
      roleIds = make_shared<string>(boost::any_cast<string>(m["RoleIds"]));
    }
    if (m.find("TargetUserId") != m.end() && !m["TargetUserId"].empty()) {
      targetUserId = make_shared<string>(boost::any_cast<string>(m["TargetUserId"]));
    }
  }


  virtual ~AuthorizeRoleRequest() = default;
};
class AuthorizeRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AuthorizeRoleResponseBody() {}

  explicit AuthorizeRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AuthorizeRoleResponseBody() = default;
};
class AuthorizeRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AuthorizeRoleResponseBody> body{};

  AuthorizeRoleResponse() {}

  explicit AuthorizeRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AuthorizeRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AuthorizeRoleResponseBody>(model1);
      }
    }
  }


  virtual ~AuthorizeRoleResponse() = default;
};
class BindEcsSlbRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> deployGroupId{};
  shared_ptr<string> listenerHealthCheckUrl{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> listenerProtocol{};
  shared_ptr<string> slbId{};
  shared_ptr<string> VForwardingUrlRule{};
  shared_ptr<string> VServerGroupId{};
  shared_ptr<string> VServerGroupName{};

  BindEcsSlbRequest() {}

  explicit BindEcsSlbRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (deployGroupId) {
      res["DeployGroupId"] = boost::any(*deployGroupId);
    }
    if (listenerHealthCheckUrl) {
      res["ListenerHealthCheckUrl"] = boost::any(*listenerHealthCheckUrl);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (listenerProtocol) {
      res["ListenerProtocol"] = boost::any(*listenerProtocol);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (VForwardingUrlRule) {
      res["VForwardingUrlRule"] = boost::any(*VForwardingUrlRule);
    }
    if (VServerGroupId) {
      res["VServerGroupId"] = boost::any(*VServerGroupId);
    }
    if (VServerGroupName) {
      res["VServerGroupName"] = boost::any(*VServerGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DeployGroupId") != m.end() && !m["DeployGroupId"].empty()) {
      deployGroupId = make_shared<string>(boost::any_cast<string>(m["DeployGroupId"]));
    }
    if (m.find("ListenerHealthCheckUrl") != m.end() && !m["ListenerHealthCheckUrl"].empty()) {
      listenerHealthCheckUrl = make_shared<string>(boost::any_cast<string>(m["ListenerHealthCheckUrl"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("ListenerProtocol") != m.end() && !m["ListenerProtocol"].empty()) {
      listenerProtocol = make_shared<string>(boost::any_cast<string>(m["ListenerProtocol"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("VForwardingUrlRule") != m.end() && !m["VForwardingUrlRule"].empty()) {
      VForwardingUrlRule = make_shared<string>(boost::any_cast<string>(m["VForwardingUrlRule"]));
    }
    if (m.find("VServerGroupId") != m.end() && !m["VServerGroupId"].empty()) {
      VServerGroupId = make_shared<string>(boost::any_cast<string>(m["VServerGroupId"]));
    }
    if (m.find("VServerGroupName") != m.end() && !m["VServerGroupName"].empty()) {
      VServerGroupName = make_shared<string>(boost::any_cast<string>(m["VServerGroupName"]));
    }
  }


  virtual ~BindEcsSlbRequest() = default;
};
class BindEcsSlbResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  BindEcsSlbResponseBody() {}

  explicit BindEcsSlbResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BindEcsSlbResponseBody() = default;
};
class BindEcsSlbResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindEcsSlbResponseBody> body{};

  BindEcsSlbResponse() {}

  explicit BindEcsSlbResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindEcsSlbResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindEcsSlbResponseBody>(model1);
      }
    }
  }


  virtual ~BindEcsSlbResponse() = default;
};
class BindK8sSlbRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> port{};
  shared_ptr<string> scheduler{};
  shared_ptr<string> servicePortInfos{};
  shared_ptr<string> slbId{};
  shared_ptr<string> slbProtocol{};
  shared_ptr<string> specification{};
  shared_ptr<string> targetPort{};
  shared_ptr<string> type{};

  BindK8sSlbRequest() {}

  explicit BindK8sSlbRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (servicePortInfos) {
      res["ServicePortInfos"] = boost::any(*servicePortInfos);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (slbProtocol) {
      res["SlbProtocol"] = boost::any(*slbProtocol);
    }
    if (specification) {
      res["Specification"] = boost::any(*specification);
    }
    if (targetPort) {
      res["TargetPort"] = boost::any(*targetPort);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("ServicePortInfos") != m.end() && !m["ServicePortInfos"].empty()) {
      servicePortInfos = make_shared<string>(boost::any_cast<string>(m["ServicePortInfos"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("SlbProtocol") != m.end() && !m["SlbProtocol"].empty()) {
      slbProtocol = make_shared<string>(boost::any_cast<string>(m["SlbProtocol"]));
    }
    if (m.find("Specification") != m.end() && !m["Specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["Specification"]));
    }
    if (m.find("TargetPort") != m.end() && !m["TargetPort"].empty()) {
      targetPort = make_shared<string>(boost::any_cast<string>(m["TargetPort"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~BindK8sSlbRequest() = default;
};
class BindK8sSlbResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  BindK8sSlbResponseBody() {}

  explicit BindK8sSlbResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BindK8sSlbResponseBody() = default;
};
class BindK8sSlbResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindK8sSlbResponseBody> body{};

  BindK8sSlbResponse() {}

  explicit BindK8sSlbResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindK8sSlbResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindK8sSlbResponseBody>(model1);
      }
    }
  }


  virtual ~BindK8sSlbResponse() = default;
};
class BindSlbRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> slbId{};
  shared_ptr<string> slbIp{};
  shared_ptr<string> type{};
  shared_ptr<string> VServerGroupId{};

  BindSlbRequest() {}

  explicit BindSlbRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (slbIp) {
      res["SlbIp"] = boost::any(*slbIp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (VServerGroupId) {
      res["VServerGroupId"] = boost::any(*VServerGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("SlbIp") != m.end() && !m["SlbIp"].empty()) {
      slbIp = make_shared<string>(boost::any_cast<string>(m["SlbIp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VServerGroupId") != m.end() && !m["VServerGroupId"].empty()) {
      VServerGroupId = make_shared<string>(boost::any_cast<string>(m["VServerGroupId"]));
    }
  }


  virtual ~BindSlbRequest() = default;
};
class BindSlbResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> extSlbId{};
  shared_ptr<string> extSlbIp{};
  shared_ptr<string> extSlbName{};
  shared_ptr<string> extVServerGroupId{};
  shared_ptr<string> slbId{};
  shared_ptr<string> slbIp{};
  shared_ptr<string> slbName{};
  shared_ptr<long> slbPort{};
  shared_ptr<string> VServerGroupId{};

  BindSlbResponseBodyData() {}

  explicit BindSlbResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSlbId) {
      res["ExtSlbId"] = boost::any(*extSlbId);
    }
    if (extSlbIp) {
      res["ExtSlbIp"] = boost::any(*extSlbIp);
    }
    if (extSlbName) {
      res["ExtSlbName"] = boost::any(*extSlbName);
    }
    if (extVServerGroupId) {
      res["ExtVServerGroupId"] = boost::any(*extVServerGroupId);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (slbIp) {
      res["SlbIp"] = boost::any(*slbIp);
    }
    if (slbName) {
      res["SlbName"] = boost::any(*slbName);
    }
    if (slbPort) {
      res["SlbPort"] = boost::any(*slbPort);
    }
    if (VServerGroupId) {
      res["VServerGroupId"] = boost::any(*VServerGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSlbId") != m.end() && !m["ExtSlbId"].empty()) {
      extSlbId = make_shared<string>(boost::any_cast<string>(m["ExtSlbId"]));
    }
    if (m.find("ExtSlbIp") != m.end() && !m["ExtSlbIp"].empty()) {
      extSlbIp = make_shared<string>(boost::any_cast<string>(m["ExtSlbIp"]));
    }
    if (m.find("ExtSlbName") != m.end() && !m["ExtSlbName"].empty()) {
      extSlbName = make_shared<string>(boost::any_cast<string>(m["ExtSlbName"]));
    }
    if (m.find("ExtVServerGroupId") != m.end() && !m["ExtVServerGroupId"].empty()) {
      extVServerGroupId = make_shared<string>(boost::any_cast<string>(m["ExtVServerGroupId"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("SlbIp") != m.end() && !m["SlbIp"].empty()) {
      slbIp = make_shared<string>(boost::any_cast<string>(m["SlbIp"]));
    }
    if (m.find("SlbName") != m.end() && !m["SlbName"].empty()) {
      slbName = make_shared<string>(boost::any_cast<string>(m["SlbName"]));
    }
    if (m.find("SlbPort") != m.end() && !m["SlbPort"].empty()) {
      slbPort = make_shared<long>(boost::any_cast<long>(m["SlbPort"]));
    }
    if (m.find("VServerGroupId") != m.end() && !m["VServerGroupId"].empty()) {
      VServerGroupId = make_shared<string>(boost::any_cast<string>(m["VServerGroupId"]));
    }
  }


  virtual ~BindSlbResponseBodyData() = default;
};
class BindSlbResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<BindSlbResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  BindSlbResponseBody() {}

  explicit BindSlbResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BindSlbResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BindSlbResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BindSlbResponseBody() = default;
};
class BindSlbResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindSlbResponseBody> body{};

  BindSlbResponse() {}

  explicit BindSlbResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindSlbResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindSlbResponseBody>(model1);
      }
    }
  }


  virtual ~BindSlbResponse() = default;
};
class ChangeDeployGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> eccInfo{};
  shared_ptr<bool> forceStatus{};
  shared_ptr<string> groupName{};

  ChangeDeployGroupRequest() {}

  explicit ChangeDeployGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (eccInfo) {
      res["EccInfo"] = boost::any(*eccInfo);
    }
    if (forceStatus) {
      res["ForceStatus"] = boost::any(*forceStatus);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EccInfo") != m.end() && !m["EccInfo"].empty()) {
      eccInfo = make_shared<string>(boost::any_cast<string>(m["EccInfo"]));
    }
    if (m.find("ForceStatus") != m.end() && !m["ForceStatus"].empty()) {
      forceStatus = make_shared<bool>(boost::any_cast<bool>(m["ForceStatus"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~ChangeDeployGroupRequest() = default;
};
class ChangeDeployGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ChangeDeployGroupResponseBody() {}

  explicit ChangeDeployGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ChangeDeployGroupResponseBody() = default;
};
class ChangeDeployGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeDeployGroupResponseBody> body{};

  ChangeDeployGroupResponse() {}

  explicit ChangeDeployGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeDeployGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeDeployGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeDeployGroupResponse() = default;
};
class ContinuePipelineRequest : public Darabonba::Model {
public:
  shared_ptr<bool> confirm{};
  shared_ptr<string> pipelineId{};

  ContinuePipelineRequest() {}

  explicit ContinuePipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (confirm) {
      res["Confirm"] = boost::any(*confirm);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Confirm") != m.end() && !m["Confirm"].empty()) {
      confirm = make_shared<bool>(boost::any_cast<bool>(m["Confirm"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
  }


  virtual ~ContinuePipelineRequest() = default;
};
class ContinuePipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ContinuePipelineResponseBody() {}

  explicit ContinuePipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ContinuePipelineResponseBody() = default;
};
class ContinuePipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ContinuePipelineResponseBody> body{};

  ContinuePipelineResponse() {}

  explicit ContinuePipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ContinuePipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ContinuePipelineResponseBody>(model1);
      }
    }
  }


  virtual ~ContinuePipelineResponse() = default;
};
class ConvertK8sResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> resourceType{};

  ConvertK8sResourceRequest() {}

  explicit ConvertK8sResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ConvertK8sResourceRequest() = default;
};
class ConvertK8sResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ConvertK8sResourceResponseBody() {}

  explicit ConvertK8sResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConvertK8sResourceResponseBody() = default;
};
class ConvertK8sResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConvertK8sResourceResponseBody> body{};

  ConvertK8sResourceResponse() {}

  explicit ConvertK8sResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConvertK8sResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConvertK8sResourceResponseBody>(model1);
      }
    }
  }


  virtual ~ConvertK8sResourceResponse() = default;
};
class CreateApplicationScalingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> scalingBehaviour{};
  shared_ptr<bool> scalingRuleEnable{};
  shared_ptr<string> scalingRuleMetric{};
  shared_ptr<string> scalingRuleName{};
  shared_ptr<string> scalingRuleTimer{};
  shared_ptr<string> scalingRuleTrigger{};
  shared_ptr<string> scalingRuleType{};

  CreateApplicationScalingRuleRequest() {}

  explicit CreateApplicationScalingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (scalingBehaviour) {
      res["ScalingBehaviour"] = boost::any(*scalingBehaviour);
    }
    if (scalingRuleEnable) {
      res["ScalingRuleEnable"] = boost::any(*scalingRuleEnable);
    }
    if (scalingRuleMetric) {
      res["ScalingRuleMetric"] = boost::any(*scalingRuleMetric);
    }
    if (scalingRuleName) {
      res["ScalingRuleName"] = boost::any(*scalingRuleName);
    }
    if (scalingRuleTimer) {
      res["ScalingRuleTimer"] = boost::any(*scalingRuleTimer);
    }
    if (scalingRuleTrigger) {
      res["ScalingRuleTrigger"] = boost::any(*scalingRuleTrigger);
    }
    if (scalingRuleType) {
      res["ScalingRuleType"] = boost::any(*scalingRuleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ScalingBehaviour") != m.end() && !m["ScalingBehaviour"].empty()) {
      scalingBehaviour = make_shared<string>(boost::any_cast<string>(m["ScalingBehaviour"]));
    }
    if (m.find("ScalingRuleEnable") != m.end() && !m["ScalingRuleEnable"].empty()) {
      scalingRuleEnable = make_shared<bool>(boost::any_cast<bool>(m["ScalingRuleEnable"]));
    }
    if (m.find("ScalingRuleMetric") != m.end() && !m["ScalingRuleMetric"].empty()) {
      scalingRuleMetric = make_shared<string>(boost::any_cast<string>(m["ScalingRuleMetric"]));
    }
    if (m.find("ScalingRuleName") != m.end() && !m["ScalingRuleName"].empty()) {
      scalingRuleName = make_shared<string>(boost::any_cast<string>(m["ScalingRuleName"]));
    }
    if (m.find("ScalingRuleTimer") != m.end() && !m["ScalingRuleTimer"].empty()) {
      scalingRuleTimer = make_shared<string>(boost::any_cast<string>(m["ScalingRuleTimer"]));
    }
    if (m.find("ScalingRuleTrigger") != m.end() && !m["ScalingRuleTrigger"].empty()) {
      scalingRuleTrigger = make_shared<string>(boost::any_cast<string>(m["ScalingRuleTrigger"]));
    }
    if (m.find("ScalingRuleType") != m.end() && !m["ScalingRuleType"].empty()) {
      scalingRuleType = make_shared<string>(boost::any_cast<string>(m["ScalingRuleType"]));
    }
  }


  virtual ~CreateApplicationScalingRuleRequest() = default;
};
class CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies : public Darabonba::Model {
public:
  shared_ptr<long> periodSeconds{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies() {}

  explicit CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (periodSeconds) {
      res["PeriodSeconds"] = boost::any(*periodSeconds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PeriodSeconds") != m.end() && !m["PeriodSeconds"].empty()) {
      periodSeconds = make_shared<long>(boost::any_cast<long>(m["PeriodSeconds"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies() = default;
};
class CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown : public Darabonba::Model {
public:
  shared_ptr<vector<CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies>> policies{};
  shared_ptr<string> selectPolicy{};
  shared_ptr<long> stabilizationWindowSeconds{};

  CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown() {}

  explicit CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policies) {
      vector<boost::any> temp1;
      for(auto item1:*policies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Policies"] = boost::any(temp1);
    }
    if (selectPolicy) {
      res["SelectPolicy"] = boost::any(*selectPolicy);
    }
    if (stabilizationWindowSeconds) {
      res["StabilizationWindowSeconds"] = boost::any(*stabilizationWindowSeconds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Policies") != m.end() && !m["Policies"].empty()) {
      if (typeid(vector<boost::any>) == m["Policies"].type()) {
        vector<CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Policies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        policies = make_shared<vector<CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies>>(expect1);
      }
    }
    if (m.find("SelectPolicy") != m.end() && !m["SelectPolicy"].empty()) {
      selectPolicy = make_shared<string>(boost::any_cast<string>(m["SelectPolicy"]));
    }
    if (m.find("StabilizationWindowSeconds") != m.end() && !m["StabilizationWindowSeconds"].empty()) {
      stabilizationWindowSeconds = make_shared<long>(boost::any_cast<long>(m["StabilizationWindowSeconds"]));
    }
  }


  virtual ~CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown() = default;
};
class CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies : public Darabonba::Model {
public:
  shared_ptr<long> periodSeconds{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies() {}

  explicit CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (periodSeconds) {
      res["PeriodSeconds"] = boost::any(*periodSeconds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PeriodSeconds") != m.end() && !m["PeriodSeconds"].empty()) {
      periodSeconds = make_shared<long>(boost::any_cast<long>(m["PeriodSeconds"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies() = default;
};
class CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp : public Darabonba::Model {
public:
  shared_ptr<vector<CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies>> policies{};
  shared_ptr<string> selectPolicy{};
  shared_ptr<long> stabilizationWindowSeconds{};

  CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp() {}

  explicit CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policies) {
      vector<boost::any> temp1;
      for(auto item1:*policies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Policies"] = boost::any(temp1);
    }
    if (selectPolicy) {
      res["SelectPolicy"] = boost::any(*selectPolicy);
    }
    if (stabilizationWindowSeconds) {
      res["StabilizationWindowSeconds"] = boost::any(*stabilizationWindowSeconds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Policies") != m.end() && !m["Policies"].empty()) {
      if (typeid(vector<boost::any>) == m["Policies"].type()) {
        vector<CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Policies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        policies = make_shared<vector<CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies>>(expect1);
      }
    }
    if (m.find("SelectPolicy") != m.end() && !m["SelectPolicy"].empty()) {
      selectPolicy = make_shared<string>(boost::any_cast<string>(m["SelectPolicy"]));
    }
    if (m.find("StabilizationWindowSeconds") != m.end() && !m["StabilizationWindowSeconds"].empty()) {
      stabilizationWindowSeconds = make_shared<long>(boost::any_cast<long>(m["StabilizationWindowSeconds"]));
    }
  }


  virtual ~CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp() = default;
};
class CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour : public Darabonba::Model {
public:
  shared_ptr<CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown> scaleDown{};
  shared_ptr<CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp> scaleUp{};

  CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour() {}

  explicit CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scaleDown) {
      res["ScaleDown"] = scaleDown ? boost::any(scaleDown->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scaleUp) {
      res["ScaleUp"] = scaleUp ? boost::any(scaleUp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScaleDown") != m.end() && !m["ScaleDown"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScaleDown"].type()) {
        CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScaleDown"]));
        scaleDown = make_shared<CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown>(model1);
      }
    }
    if (m.find("ScaleUp") != m.end() && !m["ScaleUp"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScaleUp"].type()) {
        CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScaleUp"]));
        scaleUp = make_shared<CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp>(model1);
      }
    }
  }


  virtual ~CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour() = default;
};
class CreateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics : public Darabonba::Model {
public:
  shared_ptr<long> metricTargetAverageUtilization{};
  shared_ptr<string> metricType{};

  CreateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics() {}

  explicit CreateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricTargetAverageUtilization) {
      res["MetricTargetAverageUtilization"] = boost::any(*metricTargetAverageUtilization);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricTargetAverageUtilization") != m.end() && !m["MetricTargetAverageUtilization"].empty()) {
      metricTargetAverageUtilization = make_shared<long>(boost::any_cast<long>(m["MetricTargetAverageUtilization"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
  }


  virtual ~CreateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics() = default;
};
class CreateApplicationScalingRuleResponseBodyAppScalingRuleMetric : public Darabonba::Model {
public:
  shared_ptr<long> maxReplicas{};
  shared_ptr<vector<CreateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics>> metrics{};
  shared_ptr<long> minReplicas{};

  CreateApplicationScalingRuleResponseBodyAppScalingRuleMetric() {}

  explicit CreateApplicationScalingRuleResponseBodyAppScalingRuleMetric(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (metrics) {
      vector<boost::any> temp1;
      for(auto item1:*metrics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Metrics"] = boost::any(temp1);
    }
    if (minReplicas) {
      res["MinReplicas"] = boost::any(*minReplicas);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(vector<boost::any>) == m["Metrics"].type()) {
        vector<CreateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Metrics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        metrics = make_shared<vector<CreateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics>>(expect1);
      }
    }
    if (m.find("MinReplicas") != m.end() && !m["MinReplicas"].empty()) {
      minReplicas = make_shared<long>(boost::any_cast<long>(m["MinReplicas"]));
    }
  }


  virtual ~CreateApplicationScalingRuleResponseBodyAppScalingRuleMetric() = default;
};
class CreateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers : public Darabonba::Model {
public:
  shared_ptr<string> metaData{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  CreateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers() {}

  explicit CreateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metaData) {
      res["MetaData"] = boost::any(*metaData);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetaData") != m.end() && !m["MetaData"].empty()) {
      metaData = make_shared<string>(boost::any_cast<string>(m["MetaData"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers() = default;
};
class CreateApplicationScalingRuleResponseBodyAppScalingRuleTrigger : public Darabonba::Model {
public:
  shared_ptr<long> maxReplicas{};
  shared_ptr<long> minReplicas{};
  shared_ptr<vector<CreateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers>> triggers{};

  CreateApplicationScalingRuleResponseBodyAppScalingRuleTrigger() {}

  explicit CreateApplicationScalingRuleResponseBodyAppScalingRuleTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (minReplicas) {
      res["MinReplicas"] = boost::any(*minReplicas);
    }
    if (triggers) {
      vector<boost::any> temp1;
      for(auto item1:*triggers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Triggers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("MinReplicas") != m.end() && !m["MinReplicas"].empty()) {
      minReplicas = make_shared<long>(boost::any_cast<long>(m["MinReplicas"]));
    }
    if (m.find("Triggers") != m.end() && !m["Triggers"].empty()) {
      if (typeid(vector<boost::any>) == m["Triggers"].type()) {
        vector<CreateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Triggers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        triggers = make_shared<vector<CreateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers>>(expect1);
      }
    }
  }


  virtual ~CreateApplicationScalingRuleResponseBodyAppScalingRuleTrigger() = default;
};
class CreateApplicationScalingRuleResponseBodyAppScalingRule : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour> behaviour{};
  shared_ptr<long> createTime{};
  shared_ptr<long> lastDisableTime{};
  shared_ptr<long> maxReplicas{};
  shared_ptr<CreateApplicationScalingRuleResponseBodyAppScalingRuleMetric> metric{};
  shared_ptr<long> minReplicas{};
  shared_ptr<bool> scaleRuleEnabled{};
  shared_ptr<string> scaleRuleName{};
  shared_ptr<string> scaleRuleType{};
  shared_ptr<CreateApplicationScalingRuleResponseBodyAppScalingRuleTrigger> trigger{};
  shared_ptr<long> updateTime{};

  CreateApplicationScalingRuleResponseBodyAppScalingRule() {}

  explicit CreateApplicationScalingRuleResponseBodyAppScalingRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (behaviour) {
      res["Behaviour"] = behaviour ? boost::any(behaviour->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastDisableTime) {
      res["LastDisableTime"] = boost::any(*lastDisableTime);
    }
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (metric) {
      res["Metric"] = metric ? boost::any(metric->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (minReplicas) {
      res["MinReplicas"] = boost::any(*minReplicas);
    }
    if (scaleRuleEnabled) {
      res["ScaleRuleEnabled"] = boost::any(*scaleRuleEnabled);
    }
    if (scaleRuleName) {
      res["ScaleRuleName"] = boost::any(*scaleRuleName);
    }
    if (scaleRuleType) {
      res["ScaleRuleType"] = boost::any(*scaleRuleType);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Behaviour") != m.end() && !m["Behaviour"].empty()) {
      if (typeid(map<string, boost::any>) == m["Behaviour"].type()) {
        CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Behaviour"]));
        behaviour = make_shared<CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("LastDisableTime") != m.end() && !m["LastDisableTime"].empty()) {
      lastDisableTime = make_shared<long>(boost::any_cast<long>(m["LastDisableTime"]));
    }
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metric"].type()) {
        CreateApplicationScalingRuleResponseBodyAppScalingRuleMetric model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metric"]));
        metric = make_shared<CreateApplicationScalingRuleResponseBodyAppScalingRuleMetric>(model1);
      }
    }
    if (m.find("MinReplicas") != m.end() && !m["MinReplicas"].empty()) {
      minReplicas = make_shared<long>(boost::any_cast<long>(m["MinReplicas"]));
    }
    if (m.find("ScaleRuleEnabled") != m.end() && !m["ScaleRuleEnabled"].empty()) {
      scaleRuleEnabled = make_shared<bool>(boost::any_cast<bool>(m["ScaleRuleEnabled"]));
    }
    if (m.find("ScaleRuleName") != m.end() && !m["ScaleRuleName"].empty()) {
      scaleRuleName = make_shared<string>(boost::any_cast<string>(m["ScaleRuleName"]));
    }
    if (m.find("ScaleRuleType") != m.end() && !m["ScaleRuleType"].empty()) {
      scaleRuleType = make_shared<string>(boost::any_cast<string>(m["ScaleRuleType"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        CreateApplicationScalingRuleResponseBodyAppScalingRuleTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<CreateApplicationScalingRuleResponseBodyAppScalingRuleTrigger>(model1);
      }
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~CreateApplicationScalingRuleResponseBodyAppScalingRule() = default;
};
class CreateApplicationScalingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateApplicationScalingRuleResponseBodyAppScalingRule> appScalingRule{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateApplicationScalingRuleResponseBody() {}

  explicit CreateApplicationScalingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appScalingRule) {
      res["AppScalingRule"] = appScalingRule ? boost::any(appScalingRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppScalingRule") != m.end() && !m["AppScalingRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppScalingRule"].type()) {
        CreateApplicationScalingRuleResponseBodyAppScalingRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppScalingRule"]));
        appScalingRule = make_shared<CreateApplicationScalingRuleResponseBodyAppScalingRule>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateApplicationScalingRuleResponseBody() = default;
};
class CreateApplicationScalingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateApplicationScalingRuleResponseBody> body{};

  CreateApplicationScalingRuleResponse() {}

  explicit CreateApplicationScalingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateApplicationScalingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateApplicationScalingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateApplicationScalingRuleResponse() = default;
};
class CreateConfigTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> description{};
  shared_ptr<string> format{};
  shared_ptr<string> name{};

  CreateConfigTemplateRequest() {}

  explicit CreateConfigTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateConfigTemplateRequest() = default;
};
class CreateConfigTemplateResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  CreateConfigTemplateResponseBodyData() {}

  explicit CreateConfigTemplateResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~CreateConfigTemplateResponseBodyData() = default;
};
class CreateConfigTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<CreateConfigTemplateResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateConfigTemplateResponseBody() {}

  explicit CreateConfigTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateConfigTemplateResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateConfigTemplateResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateConfigTemplateResponseBody() = default;
};
class CreateConfigTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateConfigTemplateResponseBody> body{};

  CreateConfigTemplateResponse() {}

  explicit CreateConfigTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateConfigTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateConfigTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateConfigTemplateResponse() = default;
};
class CreateIDCImportCommandRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};

  CreateIDCImportCommandRequest() {}

  explicit CreateIDCImportCommandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~CreateIDCImportCommandRequest() = default;
};
class CreateIDCImportCommandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateIDCImportCommandResponseBody() {}

  explicit CreateIDCImportCommandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateIDCImportCommandResponseBody() = default;
};
class CreateIDCImportCommandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateIDCImportCommandResponseBody> body{};

  CreateIDCImportCommandResponse() {}

  explicit CreateIDCImportCommandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIDCImportCommandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIDCImportCommandResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIDCImportCommandResponse() = default;
};
class CreateK8sConfigMapRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<map<string, boost::any>> data{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};

  CreateK8sConfigMapRequest() {}

  explicit CreateK8sConfigMapRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Data"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      data = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~CreateK8sConfigMapRequest() = default;
};
class CreateK8sConfigMapResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateK8sConfigMapResponseBody() {}

  explicit CreateK8sConfigMapResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateK8sConfigMapResponseBody() = default;
};
class CreateK8sConfigMapResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateK8sConfigMapResponseBody> body{};

  CreateK8sConfigMapResponse() {}

  explicit CreateK8sConfigMapResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateK8sConfigMapResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateK8sConfigMapResponseBody>(model1);
      }
    }
  }


  virtual ~CreateK8sConfigMapResponse() = default;
};
class CreateK8sIngressRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> annotations{};
  shared_ptr<string> clusterId{};
  shared_ptr<map<string, boost::any>> ingressConf{};
  shared_ptr<string> labels{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};

  CreateK8sIngressRuleRequest() {}

  explicit CreateK8sIngressRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotations) {
      res["Annotations"] = boost::any(*annotations);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (ingressConf) {
      res["IngressConf"] = boost::any(*ingressConf);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      annotations = make_shared<string>(boost::any_cast<string>(m["Annotations"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("IngressConf") != m.end() && !m["IngressConf"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["IngressConf"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      ingressConf = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~CreateK8sIngressRuleRequest() = default;
};
class CreateK8sIngressRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};

  CreateK8sIngressRuleResponseBody() {}

  explicit CreateK8sIngressRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~CreateK8sIngressRuleResponseBody() = default;
};
class CreateK8sIngressRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateK8sIngressRuleResponseBody> body{};

  CreateK8sIngressRuleResponse() {}

  explicit CreateK8sIngressRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateK8sIngressRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateK8sIngressRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateK8sIngressRuleResponse() = default;
};
class CreateK8sSecretRequest : public Darabonba::Model {
public:
  shared_ptr<bool> base64Encoded{};
  shared_ptr<string> certId{};
  shared_ptr<string> certRegionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> data{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> type{};

  CreateK8sSecretRequest() {}

  explicit CreateK8sSecretRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (base64Encoded) {
      res["Base64Encoded"] = boost::any(*base64Encoded);
    }
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certRegionId) {
      res["CertRegionId"] = boost::any(*certRegionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Base64Encoded") != m.end() && !m["Base64Encoded"].empty()) {
      base64Encoded = make_shared<bool>(boost::any_cast<bool>(m["Base64Encoded"]));
    }
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<string>(boost::any_cast<string>(m["CertId"]));
    }
    if (m.find("CertRegionId") != m.end() && !m["CertRegionId"].empty()) {
      certRegionId = make_shared<string>(boost::any_cast<string>(m["CertRegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateK8sSecretRequest() = default;
};
class CreateK8sSecretResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateK8sSecretResponseBody() {}

  explicit CreateK8sSecretResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateK8sSecretResponseBody() = default;
};
class CreateK8sSecretResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateK8sSecretResponseBody> body{};

  CreateK8sSecretResponse() {}

  explicit CreateK8sSecretResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateK8sSecretResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateK8sSecretResponseBody>(model1);
      }
    }
  }


  virtual ~CreateK8sSecretResponse() = default;
};
class CreateK8sServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> externalTrafficPolicy{};
  shared_ptr<string> name{};
  shared_ptr<map<string, boost::any>> servicePorts{};
  shared_ptr<string> type{};

  CreateK8sServiceRequest() {}

  explicit CreateK8sServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (externalTrafficPolicy) {
      res["ExternalTrafficPolicy"] = boost::any(*externalTrafficPolicy);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (servicePorts) {
      res["ServicePorts"] = boost::any(*servicePorts);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ExternalTrafficPolicy") != m.end() && !m["ExternalTrafficPolicy"].empty()) {
      externalTrafficPolicy = make_shared<string>(boost::any_cast<string>(m["ExternalTrafficPolicy"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ServicePorts") != m.end() && !m["ServicePorts"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ServicePorts"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      servicePorts = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateK8sServiceRequest() = default;
};
class CreateK8sServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateK8sServiceResponseBody() {}

  explicit CreateK8sServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateK8sServiceResponseBody() = default;
};
class CreateK8sServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateK8sServiceResponseBody> body{};

  CreateK8sServiceResponse() {}

  explicit CreateK8sServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateK8sServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateK8sServiceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateK8sServiceResponse() = default;
};
class DeleteApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  DeleteApplicationRequest() {}

  explicit DeleteApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~DeleteApplicationRequest() = default;
};
class DeleteApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteApplicationResponseBody() {}

  explicit DeleteApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteApplicationResponseBody() = default;
};
class DeleteApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteApplicationResponseBody> body{};

  DeleteApplicationResponse() {}

  explicit DeleteApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteApplicationResponse() = default;
};
class DeleteApplicationScalingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> scalingRuleName{};

  DeleteApplicationScalingRuleRequest() {}

  explicit DeleteApplicationScalingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (scalingRuleName) {
      res["ScalingRuleName"] = boost::any(*scalingRuleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ScalingRuleName") != m.end() && !m["ScalingRuleName"].empty()) {
      scalingRuleName = make_shared<string>(boost::any_cast<string>(m["ScalingRuleName"]));
    }
  }


  virtual ~DeleteApplicationScalingRuleRequest() = default;
};
class DeleteApplicationScalingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteApplicationScalingRuleResponseBody() {}

  explicit DeleteApplicationScalingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteApplicationScalingRuleResponseBody() = default;
};
class DeleteApplicationScalingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteApplicationScalingRuleResponseBody> body{};

  DeleteApplicationScalingRuleResponse() {}

  explicit DeleteApplicationScalingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteApplicationScalingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteApplicationScalingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteApplicationScalingRuleResponse() = default;
};
class DeleteClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> mode{};

  DeleteClusterRequest() {}

  explicit DeleteClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<long>(boost::any_cast<long>(m["Mode"]));
    }
  }


  virtual ~DeleteClusterRequest() = default;
};
class DeleteClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteClusterResponseBody() {}

  explicit DeleteClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteClusterResponseBody() = default;
};
class DeleteClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteClusterResponseBody> body{};

  DeleteClusterResponse() {}

  explicit DeleteClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteClusterResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteClusterResponse() = default;
};
class DeleteClusterMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterMemberId{};

  DeleteClusterMemberRequest() {}

  explicit DeleteClusterMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterMemberId) {
      res["ClusterMemberId"] = boost::any(*clusterMemberId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterMemberId") != m.end() && !m["ClusterMemberId"].empty()) {
      clusterMemberId = make_shared<string>(boost::any_cast<string>(m["ClusterMemberId"]));
    }
  }


  virtual ~DeleteClusterMemberRequest() = default;
};
class DeleteClusterMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteClusterMemberResponseBody() {}

  explicit DeleteClusterMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteClusterMemberResponseBody() = default;
};
class DeleteClusterMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteClusterMemberResponseBody> body{};

  DeleteClusterMemberResponse() {}

  explicit DeleteClusterMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteClusterMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteClusterMemberResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteClusterMemberResponse() = default;
};
class DeleteConfigTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DeleteConfigTemplateRequest() {}

  explicit DeleteConfigTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteConfigTemplateRequest() = default;
};
class DeleteConfigTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteConfigTemplateResponseBody() {}

  explicit DeleteConfigTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteConfigTemplateResponseBody() = default;
};
class DeleteConfigTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteConfigTemplateResponseBody> body{};

  DeleteConfigTemplateResponse() {}

  explicit DeleteConfigTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteConfigTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteConfigTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteConfigTemplateResponse() = default;
};
class DeleteDeployGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupName{};

  DeleteDeployGroupRequest() {}

  explicit DeleteDeployGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~DeleteDeployGroupRequest() = default;
};
class DeleteDeployGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteDeployGroupResponseBody() {}

  explicit DeleteDeployGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDeployGroupResponseBody() = default;
};
class DeleteDeployGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDeployGroupResponseBody> body{};

  DeleteDeployGroupResponse() {}

  explicit DeleteDeployGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDeployGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDeployGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDeployGroupResponse() = default;
};
class DeleteEcuRequest : public Darabonba::Model {
public:
  shared_ptr<string> ecuId{};

  DeleteEcuRequest() {}

  explicit DeleteEcuRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecuId) {
      res["EcuId"] = boost::any(*ecuId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcuId") != m.end() && !m["EcuId"].empty()) {
      ecuId = make_shared<string>(boost::any_cast<string>(m["EcuId"]));
    }
  }


  virtual ~DeleteEcuRequest() = default;
};
class DeleteEcuResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteEcuResponseBody() {}

  explicit DeleteEcuResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEcuResponseBody() = default;
};
class DeleteEcuResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEcuResponseBody> body{};

  DeleteEcuResponse() {}

  explicit DeleteEcuResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEcuResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEcuResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEcuResponse() = default;
};
class DeleteK8sApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> force{};

  DeleteK8sApplicationRequest() {}

  explicit DeleteK8sApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
  }


  virtual ~DeleteK8sApplicationRequest() = default;
};
class DeleteK8sApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteK8sApplicationResponseBody() {}

  explicit DeleteK8sApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteK8sApplicationResponseBody() = default;
};
class DeleteK8sApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteK8sApplicationResponseBody> body{};

  DeleteK8sApplicationResponse() {}

  explicit DeleteK8sApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteK8sApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteK8sApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteK8sApplicationResponse() = default;
};
class DeleteK8sConfigMapRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};

  DeleteK8sConfigMapRequest() {}

  explicit DeleteK8sConfigMapRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~DeleteK8sConfigMapRequest() = default;
};
class DeleteK8sConfigMapResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteK8sConfigMapResponseBody() {}

  explicit DeleteK8sConfigMapResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteK8sConfigMapResponseBody() = default;
};
class DeleteK8sConfigMapResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteK8sConfigMapResponseBody> body{};

  DeleteK8sConfigMapResponse() {}

  explicit DeleteK8sConfigMapResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteK8sConfigMapResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteK8sConfigMapResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteK8sConfigMapResponse() = default;
};
class DeleteK8sIngressRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};

  DeleteK8sIngressRuleRequest() {}

  explicit DeleteK8sIngressRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~DeleteK8sIngressRuleRequest() = default;
};
class DeleteK8sIngressRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};

  DeleteK8sIngressRuleResponseBody() {}

  explicit DeleteK8sIngressRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DeleteK8sIngressRuleResponseBody() = default;
};
class DeleteK8sIngressRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteK8sIngressRuleResponseBody> body{};

  DeleteK8sIngressRuleResponse() {}

  explicit DeleteK8sIngressRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteK8sIngressRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteK8sIngressRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteK8sIngressRuleResponse() = default;
};
class DeleteK8sSecretRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};

  DeleteK8sSecretRequest() {}

  explicit DeleteK8sSecretRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~DeleteK8sSecretRequest() = default;
};
class DeleteK8sSecretResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteK8sSecretResponseBody() {}

  explicit DeleteK8sSecretResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteK8sSecretResponseBody() = default;
};
class DeleteK8sSecretResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteK8sSecretResponseBody> body{};

  DeleteK8sSecretResponse() {}

  explicit DeleteK8sSecretResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteK8sSecretResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteK8sSecretResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteK8sSecretResponse() = default;
};
class DeleteK8sServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> name{};

  DeleteK8sServiceRequest() {}

  explicit DeleteK8sServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DeleteK8sServiceRequest() = default;
};
class DeleteK8sServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteK8sServiceResponseBody() {}

  explicit DeleteK8sServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteK8sServiceResponseBody() = default;
};
class DeleteK8sServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteK8sServiceResponseBody> body{};

  DeleteK8sServiceResponse() {}

  explicit DeleteK8sServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteK8sServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteK8sServiceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteK8sServiceResponse() = default;
};
class DeleteLogPathRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> path{};

  DeleteLogPathRequest() {}

  explicit DeleteLogPathRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~DeleteLogPathRequest() = default;
};
class DeleteLogPathResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteLogPathResponseBody() {}

  explicit DeleteLogPathResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLogPathResponseBody() = default;
};
class DeleteLogPathResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLogPathResponseBody> body{};

  DeleteLogPathResponse() {}

  explicit DeleteLogPathResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLogPathResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLogPathResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLogPathResponse() = default;
};
class DeleteRoleRequest : public Darabonba::Model {
public:
  shared_ptr<long> roleId{};

  DeleteRoleRequest() {}

  explicit DeleteRoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<long>(boost::any_cast<long>(m["RoleId"]));
    }
  }


  virtual ~DeleteRoleRequest() = default;
};
class DeleteRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteRoleResponseBody() {}

  explicit DeleteRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRoleResponseBody() = default;
};
class DeleteRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRoleResponseBody> body{};

  DeleteRoleResponse() {}

  explicit DeleteRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRoleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRoleResponse() = default;
};
class DeleteServiceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};

  DeleteServiceGroupRequest() {}

  explicit DeleteServiceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~DeleteServiceGroupRequest() = default;
};
class DeleteServiceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteServiceGroupResponseBody() {}

  explicit DeleteServiceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteServiceGroupResponseBody() = default;
};
class DeleteServiceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteServiceGroupResponseBody> body{};

  DeleteServiceGroupResponse() {}

  explicit DeleteServiceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteServiceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteServiceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteServiceGroupResponse() = default;
};
class DeleteSwimmingLaneRequest : public Darabonba::Model {
public:
  shared_ptr<long> laneId{};

  DeleteSwimmingLaneRequest() {}

  explicit DeleteSwimmingLaneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (laneId) {
      res["LaneId"] = boost::any(*laneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LaneId") != m.end() && !m["LaneId"].empty()) {
      laneId = make_shared<long>(boost::any_cast<long>(m["LaneId"]));
    }
  }


  virtual ~DeleteSwimmingLaneRequest() = default;
};
class DeleteSwimmingLaneResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteSwimmingLaneResponseBody() {}

  explicit DeleteSwimmingLaneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSwimmingLaneResponseBody() = default;
};
class DeleteSwimmingLaneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSwimmingLaneResponseBody> body{};

  DeleteSwimmingLaneResponse() {}

  explicit DeleteSwimmingLaneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSwimmingLaneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSwimmingLaneResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSwimmingLaneResponse() = default;
};
class DeleteUserDefineRegionRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> regionTag{};

  DeleteUserDefineRegionRequest() {}

  explicit DeleteUserDefineRegionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionTag) {
      res["RegionTag"] = boost::any(*regionTag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RegionTag") != m.end() && !m["RegionTag"].empty()) {
      regionTag = make_shared<string>(boost::any_cast<string>(m["RegionTag"]));
    }
  }


  virtual ~DeleteUserDefineRegionRequest() = default;
};
class DeleteUserDefineRegionResponseBodyRegionDefine : public Darabonba::Model {
public:
  shared_ptr<string> belongRegion{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> regionId{};
  shared_ptr<string> regionName{};
  shared_ptr<string> userId{};

  DeleteUserDefineRegionResponseBodyRegionDefine() {}

  explicit DeleteUserDefineRegionResponseBodyRegionDefine(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (belongRegion) {
      res["BelongRegion"] = boost::any(*belongRegion);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BelongRegion") != m.end() && !m["BelongRegion"].empty()) {
      belongRegion = make_shared<string>(boost::any_cast<string>(m["BelongRegion"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~DeleteUserDefineRegionResponseBodyRegionDefine() = default;
};
class DeleteUserDefineRegionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<DeleteUserDefineRegionResponseBodyRegionDefine> regionDefine{};
  shared_ptr<string> requestId{};

  DeleteUserDefineRegionResponseBody() {}

  explicit DeleteUserDefineRegionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (regionDefine) {
      res["RegionDefine"] = regionDefine ? boost::any(regionDefine->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RegionDefine") != m.end() && !m["RegionDefine"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegionDefine"].type()) {
        DeleteUserDefineRegionResponseBodyRegionDefine model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegionDefine"]));
        regionDefine = make_shared<DeleteUserDefineRegionResponseBodyRegionDefine>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteUserDefineRegionResponseBody() = default;
};
class DeleteUserDefineRegionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteUserDefineRegionResponseBody> body{};

  DeleteUserDefineRegionResponse() {}

  explicit DeleteUserDefineRegionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteUserDefineRegionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteUserDefineRegionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteUserDefineRegionResponse() = default;
};
class DeployApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appEnv{};
  shared_ptr<string> appId{};
  shared_ptr<long> batch{};
  shared_ptr<long> batchWaitTime{};
  shared_ptr<long> buildPackId{};
  shared_ptr<string> componentIds{};
  shared_ptr<string> deployType{};
  shared_ptr<string> desc{};
  shared_ptr<bool> gray{};
  shared_ptr<string> groupId{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> packageVersion{};
  shared_ptr<long> releaseType{};
  shared_ptr<string> trafficControlStrategy{};
  shared_ptr<string> warUrl{};

  DeployApplicationRequest() {}

  explicit DeployApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appEnv) {
      res["AppEnv"] = boost::any(*appEnv);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (batch) {
      res["Batch"] = boost::any(*batch);
    }
    if (batchWaitTime) {
      res["BatchWaitTime"] = boost::any(*batchWaitTime);
    }
    if (buildPackId) {
      res["BuildPackId"] = boost::any(*buildPackId);
    }
    if (componentIds) {
      res["ComponentIds"] = boost::any(*componentIds);
    }
    if (deployType) {
      res["DeployType"] = boost::any(*deployType);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (gray) {
      res["Gray"] = boost::any(*gray);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    if (releaseType) {
      res["ReleaseType"] = boost::any(*releaseType);
    }
    if (trafficControlStrategy) {
      res["TrafficControlStrategy"] = boost::any(*trafficControlStrategy);
    }
    if (warUrl) {
      res["WarUrl"] = boost::any(*warUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppEnv") != m.end() && !m["AppEnv"].empty()) {
      appEnv = make_shared<string>(boost::any_cast<string>(m["AppEnv"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Batch") != m.end() && !m["Batch"].empty()) {
      batch = make_shared<long>(boost::any_cast<long>(m["Batch"]));
    }
    if (m.find("BatchWaitTime") != m.end() && !m["BatchWaitTime"].empty()) {
      batchWaitTime = make_shared<long>(boost::any_cast<long>(m["BatchWaitTime"]));
    }
    if (m.find("BuildPackId") != m.end() && !m["BuildPackId"].empty()) {
      buildPackId = make_shared<long>(boost::any_cast<long>(m["BuildPackId"]));
    }
    if (m.find("ComponentIds") != m.end() && !m["ComponentIds"].empty()) {
      componentIds = make_shared<string>(boost::any_cast<string>(m["ComponentIds"]));
    }
    if (m.find("DeployType") != m.end() && !m["DeployType"].empty()) {
      deployType = make_shared<string>(boost::any_cast<string>(m["DeployType"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Gray") != m.end() && !m["Gray"].empty()) {
      gray = make_shared<bool>(boost::any_cast<bool>(m["Gray"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
    if (m.find("ReleaseType") != m.end() && !m["ReleaseType"].empty()) {
      releaseType = make_shared<long>(boost::any_cast<long>(m["ReleaseType"]));
    }
    if (m.find("TrafficControlStrategy") != m.end() && !m["TrafficControlStrategy"].empty()) {
      trafficControlStrategy = make_shared<string>(boost::any_cast<string>(m["TrafficControlStrategy"]));
    }
    if (m.find("WarUrl") != m.end() && !m["WarUrl"].empty()) {
      warUrl = make_shared<string>(boost::any_cast<string>(m["WarUrl"]));
    }
  }


  virtual ~DeployApplicationRequest() = default;
};
class DeployApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeployApplicationResponseBody() {}

  explicit DeployApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeployApplicationResponseBody() = default;
};
class DeployApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeployApplicationResponseBody> body{};

  DeployApplicationResponse() {}

  explicit DeployApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeployApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeployApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~DeployApplicationResponse() = default;
};
class DeployK8sApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> annotations{};
  shared_ptr<string> appId{};
  shared_ptr<string> args{};
  shared_ptr<long> batchTimeout{};
  shared_ptr<long> batchWaitTime{};
  shared_ptr<string> buildPackId{};
  shared_ptr<string> canaryRuleId{};
  shared_ptr<string> changeOrderDesc{};
  shared_ptr<string> command{};
  shared_ptr<string> configMountDescs{};
  shared_ptr<long> cpuLimit{};
  shared_ptr<long> cpuRequest{};
  shared_ptr<string> customAffinity{};
  shared_ptr<string> customAgentVersion{};
  shared_ptr<string> customTolerations{};
  shared_ptr<string> deployAcrossNodes{};
  shared_ptr<string> deployAcrossZones{};
  shared_ptr<string> edasContainerVersion{};
  shared_ptr<string> emptyDirs{};
  shared_ptr<bool> enableAhas{};
  shared_ptr<bool> enableEmptyPushReject{};
  shared_ptr<bool> enableLosslessRule{};
  shared_ptr<string> envFroms{};
  shared_ptr<string> envs{};
  shared_ptr<string> image{};
  shared_ptr<string> imagePlatforms{};
  shared_ptr<string> imageTag{};
  shared_ptr<string> initContainers{};
  shared_ptr<string> JDK{};
  shared_ptr<string> javaStartUpConfig{};
  shared_ptr<string> labels{};
  shared_ptr<long> limitEphemeralStorage{};
  shared_ptr<string> liveness{};
  shared_ptr<string> localVolume{};
  shared_ptr<bool> losslessRuleAligned{};
  shared_ptr<long> losslessRuleDelayTime{};
  shared_ptr<long> losslessRuleFuncType{};
  shared_ptr<bool> losslessRuleRelated{};
  shared_ptr<long> losslessRuleWarmupTime{};
  shared_ptr<long> mcpuLimit{};
  shared_ptr<long> mcpuRequest{};
  shared_ptr<long> memoryLimit{};
  shared_ptr<long> memoryRequest{};
  shared_ptr<string> mountDescs{};
  shared_ptr<string> nasId{};
  shared_ptr<string> packageUrl{};
  shared_ptr<string> packageVersion{};
  shared_ptr<string> packageVersionId{};
  shared_ptr<string> postStart{};
  shared_ptr<string> preStop{};
  shared_ptr<string> pvcMountDescs{};
  shared_ptr<string> readiness{};
  shared_ptr<long> replicas{};
  shared_ptr<long> requestsEphemeralStorage{};
  shared_ptr<string> runtimeClassName{};
  shared_ptr<string> sidecars{};
  shared_ptr<string> slsConfigs{};
  shared_ptr<string> startup{};
  shared_ptr<string> storageType{};
  shared_ptr<long> terminateGracePeriod{};
  shared_ptr<string> trafficControlStrategy{};
  shared_ptr<string> updateStrategy{};
  shared_ptr<string> uriEncoding{};
  shared_ptr<bool> useBodyEncoding{};
  shared_ptr<string> userBaseImageUrl{};
  shared_ptr<string> volumesStr{};
  shared_ptr<string> webContainer{};
  shared_ptr<string> webContainerConfig{};

  DeployK8sApplicationRequest() {}

  explicit DeployK8sApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotations) {
      res["Annotations"] = boost::any(*annotations);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (args) {
      res["Args"] = boost::any(*args);
    }
    if (batchTimeout) {
      res["BatchTimeout"] = boost::any(*batchTimeout);
    }
    if (batchWaitTime) {
      res["BatchWaitTime"] = boost::any(*batchWaitTime);
    }
    if (buildPackId) {
      res["BuildPackId"] = boost::any(*buildPackId);
    }
    if (canaryRuleId) {
      res["CanaryRuleId"] = boost::any(*canaryRuleId);
    }
    if (changeOrderDesc) {
      res["ChangeOrderDesc"] = boost::any(*changeOrderDesc);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (configMountDescs) {
      res["ConfigMountDescs"] = boost::any(*configMountDescs);
    }
    if (cpuLimit) {
      res["CpuLimit"] = boost::any(*cpuLimit);
    }
    if (cpuRequest) {
      res["CpuRequest"] = boost::any(*cpuRequest);
    }
    if (customAffinity) {
      res["CustomAffinity"] = boost::any(*customAffinity);
    }
    if (customAgentVersion) {
      res["CustomAgentVersion"] = boost::any(*customAgentVersion);
    }
    if (customTolerations) {
      res["CustomTolerations"] = boost::any(*customTolerations);
    }
    if (deployAcrossNodes) {
      res["DeployAcrossNodes"] = boost::any(*deployAcrossNodes);
    }
    if (deployAcrossZones) {
      res["DeployAcrossZones"] = boost::any(*deployAcrossZones);
    }
    if (edasContainerVersion) {
      res["EdasContainerVersion"] = boost::any(*edasContainerVersion);
    }
    if (emptyDirs) {
      res["EmptyDirs"] = boost::any(*emptyDirs);
    }
    if (enableAhas) {
      res["EnableAhas"] = boost::any(*enableAhas);
    }
    if (enableEmptyPushReject) {
      res["EnableEmptyPushReject"] = boost::any(*enableEmptyPushReject);
    }
    if (enableLosslessRule) {
      res["EnableLosslessRule"] = boost::any(*enableLosslessRule);
    }
    if (envFroms) {
      res["EnvFroms"] = boost::any(*envFroms);
    }
    if (envs) {
      res["Envs"] = boost::any(*envs);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (imagePlatforms) {
      res["ImagePlatforms"] = boost::any(*imagePlatforms);
    }
    if (imageTag) {
      res["ImageTag"] = boost::any(*imageTag);
    }
    if (initContainers) {
      res["InitContainers"] = boost::any(*initContainers);
    }
    if (JDK) {
      res["JDK"] = boost::any(*JDK);
    }
    if (javaStartUpConfig) {
      res["JavaStartUpConfig"] = boost::any(*javaStartUpConfig);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (limitEphemeralStorage) {
      res["LimitEphemeralStorage"] = boost::any(*limitEphemeralStorage);
    }
    if (liveness) {
      res["Liveness"] = boost::any(*liveness);
    }
    if (localVolume) {
      res["LocalVolume"] = boost::any(*localVolume);
    }
    if (losslessRuleAligned) {
      res["LosslessRuleAligned"] = boost::any(*losslessRuleAligned);
    }
    if (losslessRuleDelayTime) {
      res["LosslessRuleDelayTime"] = boost::any(*losslessRuleDelayTime);
    }
    if (losslessRuleFuncType) {
      res["LosslessRuleFuncType"] = boost::any(*losslessRuleFuncType);
    }
    if (losslessRuleRelated) {
      res["LosslessRuleRelated"] = boost::any(*losslessRuleRelated);
    }
    if (losslessRuleWarmupTime) {
      res["LosslessRuleWarmupTime"] = boost::any(*losslessRuleWarmupTime);
    }
    if (mcpuLimit) {
      res["McpuLimit"] = boost::any(*mcpuLimit);
    }
    if (mcpuRequest) {
      res["McpuRequest"] = boost::any(*mcpuRequest);
    }
    if (memoryLimit) {
      res["MemoryLimit"] = boost::any(*memoryLimit);
    }
    if (memoryRequest) {
      res["MemoryRequest"] = boost::any(*memoryRequest);
    }
    if (mountDescs) {
      res["MountDescs"] = boost::any(*mountDescs);
    }
    if (nasId) {
      res["NasId"] = boost::any(*nasId);
    }
    if (packageUrl) {
      res["PackageUrl"] = boost::any(*packageUrl);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    if (packageVersionId) {
      res["PackageVersionId"] = boost::any(*packageVersionId);
    }
    if (postStart) {
      res["PostStart"] = boost::any(*postStart);
    }
    if (preStop) {
      res["PreStop"] = boost::any(*preStop);
    }
    if (pvcMountDescs) {
      res["PvcMountDescs"] = boost::any(*pvcMountDescs);
    }
    if (readiness) {
      res["Readiness"] = boost::any(*readiness);
    }
    if (replicas) {
      res["Replicas"] = boost::any(*replicas);
    }
    if (requestsEphemeralStorage) {
      res["RequestsEphemeralStorage"] = boost::any(*requestsEphemeralStorage);
    }
    if (runtimeClassName) {
      res["RuntimeClassName"] = boost::any(*runtimeClassName);
    }
    if (sidecars) {
      res["Sidecars"] = boost::any(*sidecars);
    }
    if (slsConfigs) {
      res["SlsConfigs"] = boost::any(*slsConfigs);
    }
    if (startup) {
      res["Startup"] = boost::any(*startup);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    if (terminateGracePeriod) {
      res["TerminateGracePeriod"] = boost::any(*terminateGracePeriod);
    }
    if (trafficControlStrategy) {
      res["TrafficControlStrategy"] = boost::any(*trafficControlStrategy);
    }
    if (updateStrategy) {
      res["UpdateStrategy"] = boost::any(*updateStrategy);
    }
    if (uriEncoding) {
      res["UriEncoding"] = boost::any(*uriEncoding);
    }
    if (useBodyEncoding) {
      res["UseBodyEncoding"] = boost::any(*useBodyEncoding);
    }
    if (userBaseImageUrl) {
      res["UserBaseImageUrl"] = boost::any(*userBaseImageUrl);
    }
    if (volumesStr) {
      res["VolumesStr"] = boost::any(*volumesStr);
    }
    if (webContainer) {
      res["WebContainer"] = boost::any(*webContainer);
    }
    if (webContainerConfig) {
      res["WebContainerConfig"] = boost::any(*webContainerConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      annotations = make_shared<string>(boost::any_cast<string>(m["Annotations"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Args") != m.end() && !m["Args"].empty()) {
      args = make_shared<string>(boost::any_cast<string>(m["Args"]));
    }
    if (m.find("BatchTimeout") != m.end() && !m["BatchTimeout"].empty()) {
      batchTimeout = make_shared<long>(boost::any_cast<long>(m["BatchTimeout"]));
    }
    if (m.find("BatchWaitTime") != m.end() && !m["BatchWaitTime"].empty()) {
      batchWaitTime = make_shared<long>(boost::any_cast<long>(m["BatchWaitTime"]));
    }
    if (m.find("BuildPackId") != m.end() && !m["BuildPackId"].empty()) {
      buildPackId = make_shared<string>(boost::any_cast<string>(m["BuildPackId"]));
    }
    if (m.find("CanaryRuleId") != m.end() && !m["CanaryRuleId"].empty()) {
      canaryRuleId = make_shared<string>(boost::any_cast<string>(m["CanaryRuleId"]));
    }
    if (m.find("ChangeOrderDesc") != m.end() && !m["ChangeOrderDesc"].empty()) {
      changeOrderDesc = make_shared<string>(boost::any_cast<string>(m["ChangeOrderDesc"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("ConfigMountDescs") != m.end() && !m["ConfigMountDescs"].empty()) {
      configMountDescs = make_shared<string>(boost::any_cast<string>(m["ConfigMountDescs"]));
    }
    if (m.find("CpuLimit") != m.end() && !m["CpuLimit"].empty()) {
      cpuLimit = make_shared<long>(boost::any_cast<long>(m["CpuLimit"]));
    }
    if (m.find("CpuRequest") != m.end() && !m["CpuRequest"].empty()) {
      cpuRequest = make_shared<long>(boost::any_cast<long>(m["CpuRequest"]));
    }
    if (m.find("CustomAffinity") != m.end() && !m["CustomAffinity"].empty()) {
      customAffinity = make_shared<string>(boost::any_cast<string>(m["CustomAffinity"]));
    }
    if (m.find("CustomAgentVersion") != m.end() && !m["CustomAgentVersion"].empty()) {
      customAgentVersion = make_shared<string>(boost::any_cast<string>(m["CustomAgentVersion"]));
    }
    if (m.find("CustomTolerations") != m.end() && !m["CustomTolerations"].empty()) {
      customTolerations = make_shared<string>(boost::any_cast<string>(m["CustomTolerations"]));
    }
    if (m.find("DeployAcrossNodes") != m.end() && !m["DeployAcrossNodes"].empty()) {
      deployAcrossNodes = make_shared<string>(boost::any_cast<string>(m["DeployAcrossNodes"]));
    }
    if (m.find("DeployAcrossZones") != m.end() && !m["DeployAcrossZones"].empty()) {
      deployAcrossZones = make_shared<string>(boost::any_cast<string>(m["DeployAcrossZones"]));
    }
    if (m.find("EdasContainerVersion") != m.end() && !m["EdasContainerVersion"].empty()) {
      edasContainerVersion = make_shared<string>(boost::any_cast<string>(m["EdasContainerVersion"]));
    }
    if (m.find("EmptyDirs") != m.end() && !m["EmptyDirs"].empty()) {
      emptyDirs = make_shared<string>(boost::any_cast<string>(m["EmptyDirs"]));
    }
    if (m.find("EnableAhas") != m.end() && !m["EnableAhas"].empty()) {
      enableAhas = make_shared<bool>(boost::any_cast<bool>(m["EnableAhas"]));
    }
    if (m.find("EnableEmptyPushReject") != m.end() && !m["EnableEmptyPushReject"].empty()) {
      enableEmptyPushReject = make_shared<bool>(boost::any_cast<bool>(m["EnableEmptyPushReject"]));
    }
    if (m.find("EnableLosslessRule") != m.end() && !m["EnableLosslessRule"].empty()) {
      enableLosslessRule = make_shared<bool>(boost::any_cast<bool>(m["EnableLosslessRule"]));
    }
    if (m.find("EnvFroms") != m.end() && !m["EnvFroms"].empty()) {
      envFroms = make_shared<string>(boost::any_cast<string>(m["EnvFroms"]));
    }
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      envs = make_shared<string>(boost::any_cast<string>(m["Envs"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ImagePlatforms") != m.end() && !m["ImagePlatforms"].empty()) {
      imagePlatforms = make_shared<string>(boost::any_cast<string>(m["ImagePlatforms"]));
    }
    if (m.find("ImageTag") != m.end() && !m["ImageTag"].empty()) {
      imageTag = make_shared<string>(boost::any_cast<string>(m["ImageTag"]));
    }
    if (m.find("InitContainers") != m.end() && !m["InitContainers"].empty()) {
      initContainers = make_shared<string>(boost::any_cast<string>(m["InitContainers"]));
    }
    if (m.find("JDK") != m.end() && !m["JDK"].empty()) {
      JDK = make_shared<string>(boost::any_cast<string>(m["JDK"]));
    }
    if (m.find("JavaStartUpConfig") != m.end() && !m["JavaStartUpConfig"].empty()) {
      javaStartUpConfig = make_shared<string>(boost::any_cast<string>(m["JavaStartUpConfig"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("LimitEphemeralStorage") != m.end() && !m["LimitEphemeralStorage"].empty()) {
      limitEphemeralStorage = make_shared<long>(boost::any_cast<long>(m["LimitEphemeralStorage"]));
    }
    if (m.find("Liveness") != m.end() && !m["Liveness"].empty()) {
      liveness = make_shared<string>(boost::any_cast<string>(m["Liveness"]));
    }
    if (m.find("LocalVolume") != m.end() && !m["LocalVolume"].empty()) {
      localVolume = make_shared<string>(boost::any_cast<string>(m["LocalVolume"]));
    }
    if (m.find("LosslessRuleAligned") != m.end() && !m["LosslessRuleAligned"].empty()) {
      losslessRuleAligned = make_shared<bool>(boost::any_cast<bool>(m["LosslessRuleAligned"]));
    }
    if (m.find("LosslessRuleDelayTime") != m.end() && !m["LosslessRuleDelayTime"].empty()) {
      losslessRuleDelayTime = make_shared<long>(boost::any_cast<long>(m["LosslessRuleDelayTime"]));
    }
    if (m.find("LosslessRuleFuncType") != m.end() && !m["LosslessRuleFuncType"].empty()) {
      losslessRuleFuncType = make_shared<long>(boost::any_cast<long>(m["LosslessRuleFuncType"]));
    }
    if (m.find("LosslessRuleRelated") != m.end() && !m["LosslessRuleRelated"].empty()) {
      losslessRuleRelated = make_shared<bool>(boost::any_cast<bool>(m["LosslessRuleRelated"]));
    }
    if (m.find("LosslessRuleWarmupTime") != m.end() && !m["LosslessRuleWarmupTime"].empty()) {
      losslessRuleWarmupTime = make_shared<long>(boost::any_cast<long>(m["LosslessRuleWarmupTime"]));
    }
    if (m.find("McpuLimit") != m.end() && !m["McpuLimit"].empty()) {
      mcpuLimit = make_shared<long>(boost::any_cast<long>(m["McpuLimit"]));
    }
    if (m.find("McpuRequest") != m.end() && !m["McpuRequest"].empty()) {
      mcpuRequest = make_shared<long>(boost::any_cast<long>(m["McpuRequest"]));
    }
    if (m.find("MemoryLimit") != m.end() && !m["MemoryLimit"].empty()) {
      memoryLimit = make_shared<long>(boost::any_cast<long>(m["MemoryLimit"]));
    }
    if (m.find("MemoryRequest") != m.end() && !m["MemoryRequest"].empty()) {
      memoryRequest = make_shared<long>(boost::any_cast<long>(m["MemoryRequest"]));
    }
    if (m.find("MountDescs") != m.end() && !m["MountDescs"].empty()) {
      mountDescs = make_shared<string>(boost::any_cast<string>(m["MountDescs"]));
    }
    if (m.find("NasId") != m.end() && !m["NasId"].empty()) {
      nasId = make_shared<string>(boost::any_cast<string>(m["NasId"]));
    }
    if (m.find("PackageUrl") != m.end() && !m["PackageUrl"].empty()) {
      packageUrl = make_shared<string>(boost::any_cast<string>(m["PackageUrl"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
    if (m.find("PackageVersionId") != m.end() && !m["PackageVersionId"].empty()) {
      packageVersionId = make_shared<string>(boost::any_cast<string>(m["PackageVersionId"]));
    }
    if (m.find("PostStart") != m.end() && !m["PostStart"].empty()) {
      postStart = make_shared<string>(boost::any_cast<string>(m["PostStart"]));
    }
    if (m.find("PreStop") != m.end() && !m["PreStop"].empty()) {
      preStop = make_shared<string>(boost::any_cast<string>(m["PreStop"]));
    }
    if (m.find("PvcMountDescs") != m.end() && !m["PvcMountDescs"].empty()) {
      pvcMountDescs = make_shared<string>(boost::any_cast<string>(m["PvcMountDescs"]));
    }
    if (m.find("Readiness") != m.end() && !m["Readiness"].empty()) {
      readiness = make_shared<string>(boost::any_cast<string>(m["Readiness"]));
    }
    if (m.find("Replicas") != m.end() && !m["Replicas"].empty()) {
      replicas = make_shared<long>(boost::any_cast<long>(m["Replicas"]));
    }
    if (m.find("RequestsEphemeralStorage") != m.end() && !m["RequestsEphemeralStorage"].empty()) {
      requestsEphemeralStorage = make_shared<long>(boost::any_cast<long>(m["RequestsEphemeralStorage"]));
    }
    if (m.find("RuntimeClassName") != m.end() && !m["RuntimeClassName"].empty()) {
      runtimeClassName = make_shared<string>(boost::any_cast<string>(m["RuntimeClassName"]));
    }
    if (m.find("Sidecars") != m.end() && !m["Sidecars"].empty()) {
      sidecars = make_shared<string>(boost::any_cast<string>(m["Sidecars"]));
    }
    if (m.find("SlsConfigs") != m.end() && !m["SlsConfigs"].empty()) {
      slsConfigs = make_shared<string>(boost::any_cast<string>(m["SlsConfigs"]));
    }
    if (m.find("Startup") != m.end() && !m["Startup"].empty()) {
      startup = make_shared<string>(boost::any_cast<string>(m["Startup"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
    if (m.find("TerminateGracePeriod") != m.end() && !m["TerminateGracePeriod"].empty()) {
      terminateGracePeriod = make_shared<long>(boost::any_cast<long>(m["TerminateGracePeriod"]));
    }
    if (m.find("TrafficControlStrategy") != m.end() && !m["TrafficControlStrategy"].empty()) {
      trafficControlStrategy = make_shared<string>(boost::any_cast<string>(m["TrafficControlStrategy"]));
    }
    if (m.find("UpdateStrategy") != m.end() && !m["UpdateStrategy"].empty()) {
      updateStrategy = make_shared<string>(boost::any_cast<string>(m["UpdateStrategy"]));
    }
    if (m.find("UriEncoding") != m.end() && !m["UriEncoding"].empty()) {
      uriEncoding = make_shared<string>(boost::any_cast<string>(m["UriEncoding"]));
    }
    if (m.find("UseBodyEncoding") != m.end() && !m["UseBodyEncoding"].empty()) {
      useBodyEncoding = make_shared<bool>(boost::any_cast<bool>(m["UseBodyEncoding"]));
    }
    if (m.find("UserBaseImageUrl") != m.end() && !m["UserBaseImageUrl"].empty()) {
      userBaseImageUrl = make_shared<string>(boost::any_cast<string>(m["UserBaseImageUrl"]));
    }
    if (m.find("VolumesStr") != m.end() && !m["VolumesStr"].empty()) {
      volumesStr = make_shared<string>(boost::any_cast<string>(m["VolumesStr"]));
    }
    if (m.find("WebContainer") != m.end() && !m["WebContainer"].empty()) {
      webContainer = make_shared<string>(boost::any_cast<string>(m["WebContainer"]));
    }
    if (m.find("WebContainerConfig") != m.end() && !m["WebContainerConfig"].empty()) {
      webContainerConfig = make_shared<string>(boost::any_cast<string>(m["WebContainerConfig"]));
    }
  }


  virtual ~DeployK8sApplicationRequest() = default;
};
class DeployK8sApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeployK8sApplicationResponseBody() {}

  explicit DeployK8sApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeployK8sApplicationResponseBody() = default;
};
class DeployK8sApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeployK8sApplicationResponseBody> body{};

  DeployK8sApplicationResponse() {}

  explicit DeployK8sApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeployK8sApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeployK8sApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~DeployK8sApplicationResponse() = default;
};
class DescribeAppInstanceListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> withNodeInfo{};

  DescribeAppInstanceListRequest() {}

  explicit DescribeAppInstanceListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (withNodeInfo) {
      res["WithNodeInfo"] = boost::any(*withNodeInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("WithNodeInfo") != m.end() && !m["WithNodeInfo"].empty()) {
      withNodeInfo = make_shared<bool>(boost::any_cast<bool>(m["WithNodeInfo"]));
    }
  }


  virtual ~DescribeAppInstanceListRequest() = default;
};
class DescribeAppInstanceListResponseBodyInstanceList : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> canary{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> nodeLabels{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> podRaw{};
  shared_ptr<string> version{};

  DescribeAppInstanceListResponseBodyInstanceList() {}

  explicit DescribeAppInstanceListResponseBodyInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (canary) {
      res["Canary"] = boost::any(*canary);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (nodeLabels) {
      res["NodeLabels"] = boost::any(*nodeLabels);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (podRaw) {
      res["PodRaw"] = boost::any(*podRaw);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Canary") != m.end() && !m["Canary"].empty()) {
      canary = make_shared<bool>(boost::any_cast<bool>(m["Canary"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("NodeLabels") != m.end() && !m["NodeLabels"].empty()) {
      nodeLabels = make_shared<string>(boost::any_cast<string>(m["NodeLabels"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("PodRaw") != m.end() && !m["PodRaw"].empty()) {
      podRaw = make_shared<string>(boost::any_cast<string>(m["PodRaw"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeAppInstanceListResponseBodyInstanceList() = default;
};
class DescribeAppInstanceListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<DescribeAppInstanceListResponseBodyInstanceList>> instanceList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DescribeAppInstanceListResponseBody() {}

  explicit DescribeAppInstanceListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (instanceList) {
      vector<boost::any> temp1;
      for(auto item1:*instanceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceList"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("InstanceList") != m.end() && !m["InstanceList"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceList"].type()) {
        vector<DescribeAppInstanceListResponseBodyInstanceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAppInstanceListResponseBodyInstanceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceList = make_shared<vector<DescribeAppInstanceListResponseBodyInstanceList>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAppInstanceListResponseBody() = default;
};
class DescribeAppInstanceListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAppInstanceListResponseBody> body{};

  DescribeAppInstanceListResponse() {}

  explicit DescribeAppInstanceListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAppInstanceListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAppInstanceListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAppInstanceListResponse() = default;
};
class DescribeApplicationScalingRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  DescribeApplicationScalingRulesRequest() {}

  explicit DescribeApplicationScalingRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~DescribeApplicationScalingRulesRequest() = default;
};
class DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDownPolicies : public Darabonba::Model {
public:
  shared_ptr<long> periodSeconds{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDownPolicies() {}

  explicit DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDownPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (periodSeconds) {
      res["PeriodSeconds"] = boost::any(*periodSeconds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PeriodSeconds") != m.end() && !m["PeriodSeconds"].empty()) {
      periodSeconds = make_shared<long>(boost::any_cast<long>(m["PeriodSeconds"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDownPolicies() = default;
};
class DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDown : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDownPolicies>> policies{};
  shared_ptr<string> selectPolicy{};
  shared_ptr<long> stabilizationWindowSeconds{};

  DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDown() {}

  explicit DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDown(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policies) {
      vector<boost::any> temp1;
      for(auto item1:*policies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Policies"] = boost::any(temp1);
    }
    if (selectPolicy) {
      res["SelectPolicy"] = boost::any(*selectPolicy);
    }
    if (stabilizationWindowSeconds) {
      res["StabilizationWindowSeconds"] = boost::any(*stabilizationWindowSeconds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Policies") != m.end() && !m["Policies"].empty()) {
      if (typeid(vector<boost::any>) == m["Policies"].type()) {
        vector<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDownPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Policies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDownPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        policies = make_shared<vector<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDownPolicies>>(expect1);
      }
    }
    if (m.find("SelectPolicy") != m.end() && !m["SelectPolicy"].empty()) {
      selectPolicy = make_shared<string>(boost::any_cast<string>(m["SelectPolicy"]));
    }
    if (m.find("StabilizationWindowSeconds") != m.end() && !m["StabilizationWindowSeconds"].empty()) {
      stabilizationWindowSeconds = make_shared<long>(boost::any_cast<long>(m["StabilizationWindowSeconds"]));
    }
  }


  virtual ~DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDown() = default;
};
class DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUpPolicies : public Darabonba::Model {
public:
  shared_ptr<long> periodSeconds{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUpPolicies() {}

  explicit DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUpPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (periodSeconds) {
      res["PeriodSeconds"] = boost::any(*periodSeconds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PeriodSeconds") != m.end() && !m["PeriodSeconds"].empty()) {
      periodSeconds = make_shared<long>(boost::any_cast<long>(m["PeriodSeconds"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUpPolicies() = default;
};
class DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUp : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUpPolicies>> policies{};
  shared_ptr<string> selectPolicy{};
  shared_ptr<long> stabilizationWindowSeconds{};

  DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUp() {}

  explicit DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policies) {
      vector<boost::any> temp1;
      for(auto item1:*policies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Policies"] = boost::any(temp1);
    }
    if (selectPolicy) {
      res["SelectPolicy"] = boost::any(*selectPolicy);
    }
    if (stabilizationWindowSeconds) {
      res["StabilizationWindowSeconds"] = boost::any(*stabilizationWindowSeconds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Policies") != m.end() && !m["Policies"].empty()) {
      if (typeid(vector<boost::any>) == m["Policies"].type()) {
        vector<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUpPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Policies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUpPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        policies = make_shared<vector<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUpPolicies>>(expect1);
      }
    }
    if (m.find("SelectPolicy") != m.end() && !m["SelectPolicy"].empty()) {
      selectPolicy = make_shared<string>(boost::any_cast<string>(m["SelectPolicy"]));
    }
    if (m.find("StabilizationWindowSeconds") != m.end() && !m["StabilizationWindowSeconds"].empty()) {
      stabilizationWindowSeconds = make_shared<long>(boost::any_cast<long>(m["StabilizationWindowSeconds"]));
    }
  }


  virtual ~DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUp() = default;
};
class DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviour : public Darabonba::Model {
public:
  shared_ptr<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDown> scaleDown{};
  shared_ptr<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUp> scaleUp{};

  DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviour() {}

  explicit DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviour(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scaleDown) {
      res["ScaleDown"] = scaleDown ? boost::any(scaleDown->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scaleUp) {
      res["ScaleUp"] = scaleUp ? boost::any(scaleUp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScaleDown") != m.end() && !m["ScaleDown"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScaleDown"].type()) {
        DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDown model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScaleDown"]));
        scaleDown = make_shared<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDown>(model1);
      }
    }
    if (m.find("ScaleUp") != m.end() && !m["ScaleUp"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScaleUp"].type()) {
        DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScaleUp"]));
        scaleUp = make_shared<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUp>(model1);
      }
    }
  }


  virtual ~DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviour() = default;
};
class DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetricMetrics : public Darabonba::Model {
public:
  shared_ptr<long> metricTargetAverageUtilization{};
  shared_ptr<string> metricType{};

  DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetricMetrics() {}

  explicit DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetricMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricTargetAverageUtilization) {
      res["MetricTargetAverageUtilization"] = boost::any(*metricTargetAverageUtilization);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricTargetAverageUtilization") != m.end() && !m["MetricTargetAverageUtilization"].empty()) {
      metricTargetAverageUtilization = make_shared<long>(boost::any_cast<long>(m["MetricTargetAverageUtilization"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
  }


  virtual ~DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetricMetrics() = default;
};
class DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetric : public Darabonba::Model {
public:
  shared_ptr<long> maxReplicas{};
  shared_ptr<vector<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetricMetrics>> metrics{};
  shared_ptr<long> minReplicas{};

  DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetric() {}

  explicit DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetric(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (metrics) {
      vector<boost::any> temp1;
      for(auto item1:*metrics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Metrics"] = boost::any(temp1);
    }
    if (minReplicas) {
      res["MinReplicas"] = boost::any(*minReplicas);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(vector<boost::any>) == m["Metrics"].type()) {
        vector<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetricMetrics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Metrics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetricMetrics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        metrics = make_shared<vector<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetricMetrics>>(expect1);
      }
    }
    if (m.find("MinReplicas") != m.end() && !m["MinReplicas"].empty()) {
      minReplicas = make_shared<long>(boost::any_cast<long>(m["MinReplicas"]));
    }
  }


  virtual ~DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetric() = default;
};
class DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTriggerTriggers : public Darabonba::Model {
public:
  shared_ptr<string> metaData{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTriggerTriggers() {}

  explicit DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTriggerTriggers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metaData) {
      res["MetaData"] = boost::any(*metaData);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetaData") != m.end() && !m["MetaData"].empty()) {
      metaData = make_shared<string>(boost::any_cast<string>(m["MetaData"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTriggerTriggers() = default;
};
class DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTrigger : public Darabonba::Model {
public:
  shared_ptr<long> maxReplicas{};
  shared_ptr<long> minReplicas{};
  shared_ptr<vector<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTriggerTriggers>> triggers{};

  DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTrigger() {}

  explicit DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (minReplicas) {
      res["MinReplicas"] = boost::any(*minReplicas);
    }
    if (triggers) {
      vector<boost::any> temp1;
      for(auto item1:*triggers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Triggers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("MinReplicas") != m.end() && !m["MinReplicas"].empty()) {
      minReplicas = make_shared<long>(boost::any_cast<long>(m["MinReplicas"]));
    }
    if (m.find("Triggers") != m.end() && !m["Triggers"].empty()) {
      if (typeid(vector<boost::any>) == m["Triggers"].type()) {
        vector<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTriggerTriggers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Triggers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTriggerTriggers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        triggers = make_shared<vector<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTriggerTriggers>>(expect1);
      }
    }
  }


  virtual ~DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTrigger() = default;
};
class DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviour> behaviour{};
  shared_ptr<long> createTime{};
  shared_ptr<long> lastDisableTime{};
  shared_ptr<long> maxReplicas{};
  shared_ptr<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetric> metric{};
  shared_ptr<long> minReplicas{};
  shared_ptr<bool> scaleRuleEnabled{};
  shared_ptr<string> scaleRuleName{};
  shared_ptr<string> scaleRuleType{};
  shared_ptr<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTrigger> trigger{};
  shared_ptr<long> updateTime{};

  DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult() {}

  explicit DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (behaviour) {
      res["Behaviour"] = behaviour ? boost::any(behaviour->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastDisableTime) {
      res["LastDisableTime"] = boost::any(*lastDisableTime);
    }
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (metric) {
      res["Metric"] = metric ? boost::any(metric->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (minReplicas) {
      res["MinReplicas"] = boost::any(*minReplicas);
    }
    if (scaleRuleEnabled) {
      res["ScaleRuleEnabled"] = boost::any(*scaleRuleEnabled);
    }
    if (scaleRuleName) {
      res["ScaleRuleName"] = boost::any(*scaleRuleName);
    }
    if (scaleRuleType) {
      res["ScaleRuleType"] = boost::any(*scaleRuleType);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Behaviour") != m.end() && !m["Behaviour"].empty()) {
      if (typeid(map<string, boost::any>) == m["Behaviour"].type()) {
        DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviour model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Behaviour"]));
        behaviour = make_shared<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviour>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("LastDisableTime") != m.end() && !m["LastDisableTime"].empty()) {
      lastDisableTime = make_shared<long>(boost::any_cast<long>(m["LastDisableTime"]));
    }
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metric"].type()) {
        DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetric model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metric"]));
        metric = make_shared<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetric>(model1);
      }
    }
    if (m.find("MinReplicas") != m.end() && !m["MinReplicas"].empty()) {
      minReplicas = make_shared<long>(boost::any_cast<long>(m["MinReplicas"]));
    }
    if (m.find("ScaleRuleEnabled") != m.end() && !m["ScaleRuleEnabled"].empty()) {
      scaleRuleEnabled = make_shared<bool>(boost::any_cast<bool>(m["ScaleRuleEnabled"]));
    }
    if (m.find("ScaleRuleName") != m.end() && !m["ScaleRuleName"].empty()) {
      scaleRuleName = make_shared<string>(boost::any_cast<string>(m["ScaleRuleName"]));
    }
    if (m.find("ScaleRuleType") != m.end() && !m["ScaleRuleType"].empty()) {
      scaleRuleType = make_shared<string>(boost::any_cast<string>(m["ScaleRuleType"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTrigger>(model1);
      }
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult() = default;
};
class DescribeApplicationScalingRulesResponseBodyAppScalingRules : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult>> result{};
  shared_ptr<long> totalSize{};

  DescribeApplicationScalingRulesResponseBodyAppScalingRules() {}

  explicit DescribeApplicationScalingRulesResponseBodyAppScalingRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~DescribeApplicationScalingRulesResponseBodyAppScalingRules() = default;
};
class DescribeApplicationScalingRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApplicationScalingRulesResponseBodyAppScalingRules> appScalingRules{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DescribeApplicationScalingRulesResponseBody() {}

  explicit DescribeApplicationScalingRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appScalingRules) {
      res["AppScalingRules"] = appScalingRules ? boost::any(appScalingRules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppScalingRules") != m.end() && !m["AppScalingRules"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppScalingRules"].type()) {
        DescribeApplicationScalingRulesResponseBodyAppScalingRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppScalingRules"]));
        appScalingRules = make_shared<DescribeApplicationScalingRulesResponseBodyAppScalingRules>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeApplicationScalingRulesResponseBody() = default;
};
class DescribeApplicationScalingRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApplicationScalingRulesResponseBody> body{};

  DescribeApplicationScalingRulesResponse() {}

  explicit DescribeApplicationScalingRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApplicationScalingRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApplicationScalingRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApplicationScalingRulesResponse() = default;
};
class DisableApplicationScalingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> scalingRuleName{};

  DisableApplicationScalingRuleRequest() {}

  explicit DisableApplicationScalingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (scalingRuleName) {
      res["ScalingRuleName"] = boost::any(*scalingRuleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ScalingRuleName") != m.end() && !m["ScalingRuleName"].empty()) {
      scalingRuleName = make_shared<string>(boost::any_cast<string>(m["ScalingRuleName"]));
    }
  }


  virtual ~DisableApplicationScalingRuleRequest() = default;
};
class DisableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics : public Darabonba::Model {
public:
  shared_ptr<long> metricTargetAverageUtilization{};
  shared_ptr<string> metricType{};

  DisableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics() {}

  explicit DisableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricTargetAverageUtilization) {
      res["MetricTargetAverageUtilization"] = boost::any(*metricTargetAverageUtilization);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricTargetAverageUtilization") != m.end() && !m["MetricTargetAverageUtilization"].empty()) {
      metricTargetAverageUtilization = make_shared<long>(boost::any_cast<long>(m["MetricTargetAverageUtilization"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
  }


  virtual ~DisableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics() = default;
};
class DisableApplicationScalingRuleResponseBodyAppScalingRuleMetric : public Darabonba::Model {
public:
  shared_ptr<long> maxReplicas{};
  shared_ptr<vector<DisableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics>> metrics{};
  shared_ptr<long> minReplicas{};

  DisableApplicationScalingRuleResponseBodyAppScalingRuleMetric() {}

  explicit DisableApplicationScalingRuleResponseBodyAppScalingRuleMetric(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (metrics) {
      vector<boost::any> temp1;
      for(auto item1:*metrics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Metrics"] = boost::any(temp1);
    }
    if (minReplicas) {
      res["MinReplicas"] = boost::any(*minReplicas);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(vector<boost::any>) == m["Metrics"].type()) {
        vector<DisableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Metrics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DisableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        metrics = make_shared<vector<DisableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics>>(expect1);
      }
    }
    if (m.find("MinReplicas") != m.end() && !m["MinReplicas"].empty()) {
      minReplicas = make_shared<long>(boost::any_cast<long>(m["MinReplicas"]));
    }
  }


  virtual ~DisableApplicationScalingRuleResponseBodyAppScalingRuleMetric() = default;
};
class DisableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers : public Darabonba::Model {
public:
  shared_ptr<string> metaData{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  DisableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers() {}

  explicit DisableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metaData) {
      res["MetaData"] = boost::any(*metaData);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetaData") != m.end() && !m["MetaData"].empty()) {
      metaData = make_shared<string>(boost::any_cast<string>(m["MetaData"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DisableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers() = default;
};
class DisableApplicationScalingRuleResponseBodyAppScalingRuleTrigger : public Darabonba::Model {
public:
  shared_ptr<long> maxReplicas{};
  shared_ptr<long> minReplicas{};
  shared_ptr<vector<DisableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers>> triggers{};

  DisableApplicationScalingRuleResponseBodyAppScalingRuleTrigger() {}

  explicit DisableApplicationScalingRuleResponseBodyAppScalingRuleTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (minReplicas) {
      res["MinReplicas"] = boost::any(*minReplicas);
    }
    if (triggers) {
      vector<boost::any> temp1;
      for(auto item1:*triggers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Triggers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("MinReplicas") != m.end() && !m["MinReplicas"].empty()) {
      minReplicas = make_shared<long>(boost::any_cast<long>(m["MinReplicas"]));
    }
    if (m.find("Triggers") != m.end() && !m["Triggers"].empty()) {
      if (typeid(vector<boost::any>) == m["Triggers"].type()) {
        vector<DisableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Triggers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DisableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        triggers = make_shared<vector<DisableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers>>(expect1);
      }
    }
  }


  virtual ~DisableApplicationScalingRuleResponseBodyAppScalingRuleTrigger() = default;
};
class DisableApplicationScalingRuleResponseBodyAppScalingRule : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> createTime{};
  shared_ptr<long> lastDisableTime{};
  shared_ptr<long> maxReplicas{};
  shared_ptr<DisableApplicationScalingRuleResponseBodyAppScalingRuleMetric> metric{};
  shared_ptr<long> minReplicas{};
  shared_ptr<bool> scaleRuleEnabled{};
  shared_ptr<string> scaleRuleName{};
  shared_ptr<string> scaleRuleType{};
  shared_ptr<DisableApplicationScalingRuleResponseBodyAppScalingRuleTrigger> trigger{};
  shared_ptr<long> updateTime{};

  DisableApplicationScalingRuleResponseBodyAppScalingRule() {}

  explicit DisableApplicationScalingRuleResponseBodyAppScalingRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastDisableTime) {
      res["LastDisableTime"] = boost::any(*lastDisableTime);
    }
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (metric) {
      res["Metric"] = metric ? boost::any(metric->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (minReplicas) {
      res["MinReplicas"] = boost::any(*minReplicas);
    }
    if (scaleRuleEnabled) {
      res["ScaleRuleEnabled"] = boost::any(*scaleRuleEnabled);
    }
    if (scaleRuleName) {
      res["ScaleRuleName"] = boost::any(*scaleRuleName);
    }
    if (scaleRuleType) {
      res["ScaleRuleType"] = boost::any(*scaleRuleType);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("LastDisableTime") != m.end() && !m["LastDisableTime"].empty()) {
      lastDisableTime = make_shared<long>(boost::any_cast<long>(m["LastDisableTime"]));
    }
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metric"].type()) {
        DisableApplicationScalingRuleResponseBodyAppScalingRuleMetric model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metric"]));
        metric = make_shared<DisableApplicationScalingRuleResponseBodyAppScalingRuleMetric>(model1);
      }
    }
    if (m.find("MinReplicas") != m.end() && !m["MinReplicas"].empty()) {
      minReplicas = make_shared<long>(boost::any_cast<long>(m["MinReplicas"]));
    }
    if (m.find("ScaleRuleEnabled") != m.end() && !m["ScaleRuleEnabled"].empty()) {
      scaleRuleEnabled = make_shared<bool>(boost::any_cast<bool>(m["ScaleRuleEnabled"]));
    }
    if (m.find("ScaleRuleName") != m.end() && !m["ScaleRuleName"].empty()) {
      scaleRuleName = make_shared<string>(boost::any_cast<string>(m["ScaleRuleName"]));
    }
    if (m.find("ScaleRuleType") != m.end() && !m["ScaleRuleType"].empty()) {
      scaleRuleType = make_shared<string>(boost::any_cast<string>(m["ScaleRuleType"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        DisableApplicationScalingRuleResponseBodyAppScalingRuleTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<DisableApplicationScalingRuleResponseBodyAppScalingRuleTrigger>(model1);
      }
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~DisableApplicationScalingRuleResponseBodyAppScalingRule() = default;
};
class DisableApplicationScalingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<DisableApplicationScalingRuleResponseBodyAppScalingRule> appScalingRule{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DisableApplicationScalingRuleResponseBody() {}

  explicit DisableApplicationScalingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appScalingRule) {
      res["AppScalingRule"] = appScalingRule ? boost::any(appScalingRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppScalingRule") != m.end() && !m["AppScalingRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppScalingRule"].type()) {
        DisableApplicationScalingRuleResponseBodyAppScalingRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppScalingRule"]));
        appScalingRule = make_shared<DisableApplicationScalingRuleResponseBodyAppScalingRule>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableApplicationScalingRuleResponseBody() = default;
};
class DisableApplicationScalingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableApplicationScalingRuleResponseBody> body{};

  DisableApplicationScalingRuleResponse() {}

  explicit DisableApplicationScalingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableApplicationScalingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableApplicationScalingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DisableApplicationScalingRuleResponse() = default;
};
class EnableApplicationScalingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> scalingRuleName{};

  EnableApplicationScalingRuleRequest() {}

  explicit EnableApplicationScalingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (scalingRuleName) {
      res["ScalingRuleName"] = boost::any(*scalingRuleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ScalingRuleName") != m.end() && !m["ScalingRuleName"].empty()) {
      scalingRuleName = make_shared<string>(boost::any_cast<string>(m["ScalingRuleName"]));
    }
  }


  virtual ~EnableApplicationScalingRuleRequest() = default;
};
class EnableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics : public Darabonba::Model {
public:
  shared_ptr<long> metricTargetAverageUtilization{};
  shared_ptr<string> metricType{};

  EnableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics() {}

  explicit EnableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricTargetAverageUtilization) {
      res["MetricTargetAverageUtilization"] = boost::any(*metricTargetAverageUtilization);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricTargetAverageUtilization") != m.end() && !m["MetricTargetAverageUtilization"].empty()) {
      metricTargetAverageUtilization = make_shared<long>(boost::any_cast<long>(m["MetricTargetAverageUtilization"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
  }


  virtual ~EnableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics() = default;
};
class EnableApplicationScalingRuleResponseBodyAppScalingRuleMetric : public Darabonba::Model {
public:
  shared_ptr<long> maxReplicas{};
  shared_ptr<vector<EnableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics>> metrics{};
  shared_ptr<long> minReplicas{};

  EnableApplicationScalingRuleResponseBodyAppScalingRuleMetric() {}

  explicit EnableApplicationScalingRuleResponseBodyAppScalingRuleMetric(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (metrics) {
      vector<boost::any> temp1;
      for(auto item1:*metrics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Metrics"] = boost::any(temp1);
    }
    if (minReplicas) {
      res["MinReplicas"] = boost::any(*minReplicas);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(vector<boost::any>) == m["Metrics"].type()) {
        vector<EnableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Metrics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EnableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        metrics = make_shared<vector<EnableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics>>(expect1);
      }
    }
    if (m.find("MinReplicas") != m.end() && !m["MinReplicas"].empty()) {
      minReplicas = make_shared<long>(boost::any_cast<long>(m["MinReplicas"]));
    }
  }


  virtual ~EnableApplicationScalingRuleResponseBodyAppScalingRuleMetric() = default;
};
class EnableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers : public Darabonba::Model {
public:
  shared_ptr<string> metaData{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  EnableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers() {}

  explicit EnableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metaData) {
      res["MetaData"] = boost::any(*metaData);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetaData") != m.end() && !m["MetaData"].empty()) {
      metaData = make_shared<string>(boost::any_cast<string>(m["MetaData"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~EnableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers() = default;
};
class EnableApplicationScalingRuleResponseBodyAppScalingRuleTrigger : public Darabonba::Model {
public:
  shared_ptr<long> maxReplicas{};
  shared_ptr<long> minReplicas{};
  shared_ptr<vector<EnableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers>> triggers{};

  EnableApplicationScalingRuleResponseBodyAppScalingRuleTrigger() {}

  explicit EnableApplicationScalingRuleResponseBodyAppScalingRuleTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (minReplicas) {
      res["MinReplicas"] = boost::any(*minReplicas);
    }
    if (triggers) {
      vector<boost::any> temp1;
      for(auto item1:*triggers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Triggers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("MinReplicas") != m.end() && !m["MinReplicas"].empty()) {
      minReplicas = make_shared<long>(boost::any_cast<long>(m["MinReplicas"]));
    }
    if (m.find("Triggers") != m.end() && !m["Triggers"].empty()) {
      if (typeid(vector<boost::any>) == m["Triggers"].type()) {
        vector<EnableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Triggers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EnableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        triggers = make_shared<vector<EnableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers>>(expect1);
      }
    }
  }


  virtual ~EnableApplicationScalingRuleResponseBodyAppScalingRuleTrigger() = default;
};
class EnableApplicationScalingRuleResponseBodyAppScalingRule : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> createTime{};
  shared_ptr<long> lastDisableTime{};
  shared_ptr<long> maxReplicas{};
  shared_ptr<EnableApplicationScalingRuleResponseBodyAppScalingRuleMetric> metric{};
  shared_ptr<long> minReplicas{};
  shared_ptr<bool> scaleRuleEnabled{};
  shared_ptr<string> scaleRuleName{};
  shared_ptr<string> scaleRuleType{};
  shared_ptr<EnableApplicationScalingRuleResponseBodyAppScalingRuleTrigger> trigger{};
  shared_ptr<long> updateTime{};

  EnableApplicationScalingRuleResponseBodyAppScalingRule() {}

  explicit EnableApplicationScalingRuleResponseBodyAppScalingRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastDisableTime) {
      res["LastDisableTime"] = boost::any(*lastDisableTime);
    }
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (metric) {
      res["Metric"] = metric ? boost::any(metric->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (minReplicas) {
      res["MinReplicas"] = boost::any(*minReplicas);
    }
    if (scaleRuleEnabled) {
      res["ScaleRuleEnabled"] = boost::any(*scaleRuleEnabled);
    }
    if (scaleRuleName) {
      res["ScaleRuleName"] = boost::any(*scaleRuleName);
    }
    if (scaleRuleType) {
      res["ScaleRuleType"] = boost::any(*scaleRuleType);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("LastDisableTime") != m.end() && !m["LastDisableTime"].empty()) {
      lastDisableTime = make_shared<long>(boost::any_cast<long>(m["LastDisableTime"]));
    }
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metric"].type()) {
        EnableApplicationScalingRuleResponseBodyAppScalingRuleMetric model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metric"]));
        metric = make_shared<EnableApplicationScalingRuleResponseBodyAppScalingRuleMetric>(model1);
      }
    }
    if (m.find("MinReplicas") != m.end() && !m["MinReplicas"].empty()) {
      minReplicas = make_shared<long>(boost::any_cast<long>(m["MinReplicas"]));
    }
    if (m.find("ScaleRuleEnabled") != m.end() && !m["ScaleRuleEnabled"].empty()) {
      scaleRuleEnabled = make_shared<bool>(boost::any_cast<bool>(m["ScaleRuleEnabled"]));
    }
    if (m.find("ScaleRuleName") != m.end() && !m["ScaleRuleName"].empty()) {
      scaleRuleName = make_shared<string>(boost::any_cast<string>(m["ScaleRuleName"]));
    }
    if (m.find("ScaleRuleType") != m.end() && !m["ScaleRuleType"].empty()) {
      scaleRuleType = make_shared<string>(boost::any_cast<string>(m["ScaleRuleType"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        EnableApplicationScalingRuleResponseBodyAppScalingRuleTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<EnableApplicationScalingRuleResponseBodyAppScalingRuleTrigger>(model1);
      }
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~EnableApplicationScalingRuleResponseBodyAppScalingRule() = default;
};
class EnableApplicationScalingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<EnableApplicationScalingRuleResponseBodyAppScalingRule> appScalingRule{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  EnableApplicationScalingRuleResponseBody() {}

  explicit EnableApplicationScalingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appScalingRule) {
      res["AppScalingRule"] = appScalingRule ? boost::any(appScalingRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppScalingRule") != m.end() && !m["AppScalingRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppScalingRule"].type()) {
        EnableApplicationScalingRuleResponseBodyAppScalingRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppScalingRule"]));
        appScalingRule = make_shared<EnableApplicationScalingRuleResponseBodyAppScalingRule>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableApplicationScalingRuleResponseBody() = default;
};
class EnableApplicationScalingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableApplicationScalingRuleResponseBody> body{};

  EnableApplicationScalingRuleResponse() {}

  explicit EnableApplicationScalingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableApplicationScalingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableApplicationScalingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~EnableApplicationScalingRuleResponse() = default;
};
class GetAppDeploymentRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  GetAppDeploymentRequest() {}

  explicit GetAppDeploymentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~GetAppDeploymentRequest() = default;
};
class GetAppDeploymentResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetAppDeploymentResponseBody() {}

  explicit GetAppDeploymentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAppDeploymentResponseBody() = default;
};
class GetAppDeploymentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAppDeploymentResponseBody> body{};

  GetAppDeploymentResponse() {}

  explicit GetAppDeploymentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAppDeploymentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAppDeploymentResponseBody>(model1);
      }
    }
  }


  virtual ~GetAppDeploymentResponse() = default;
};
class GetApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  GetApplicationRequest() {}

  explicit GetApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~GetApplicationRequest() = default;
};
class GetApplicationResponseBodyApplication : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appPhase{};
  shared_ptr<string> applicationType{};
  shared_ptr<long> buildPackageId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterType{};
  shared_ptr<long> cpu{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<bool> dockerize{};
  shared_ptr<string> email{};
  shared_ptr<bool> enablePortCheck{};
  shared_ptr<bool> enableUrlCheck{};
  shared_ptr<string> extSlbId{};
  shared_ptr<string> extSlbIp{};
  shared_ptr<string> extSlbName{};
  shared_ptr<string> haveManageAccess{};
  shared_ptr<string> healthCheckUrl{};
  shared_ptr<long> instanceCount{};
  shared_ptr<long> memory{};
  shared_ptr<string> name{};
  shared_ptr<string> nameSpace_{};
  shared_ptr<string> owner{};
  shared_ptr<long> port{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> runningInstanceCount{};
  shared_ptr<string> slbId{};
  shared_ptr<string> slbInfo{};
  shared_ptr<string> slbIp{};
  shared_ptr<string> slbName{};
  shared_ptr<long> slbPort{};
  shared_ptr<string> userId{};
  shared_ptr<string> workloadType{};

  GetApplicationResponseBodyApplication() {}

  explicit GetApplicationResponseBodyApplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appPhase) {
      res["AppPhase"] = boost::any(*appPhase);
    }
    if (applicationType) {
      res["ApplicationType"] = boost::any(*applicationType);
    }
    if (buildPackageId) {
      res["BuildPackageId"] = boost::any(*buildPackageId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dockerize) {
      res["Dockerize"] = boost::any(*dockerize);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (enablePortCheck) {
      res["EnablePortCheck"] = boost::any(*enablePortCheck);
    }
    if (enableUrlCheck) {
      res["EnableUrlCheck"] = boost::any(*enableUrlCheck);
    }
    if (extSlbId) {
      res["ExtSlbId"] = boost::any(*extSlbId);
    }
    if (extSlbIp) {
      res["ExtSlbIp"] = boost::any(*extSlbIp);
    }
    if (extSlbName) {
      res["ExtSlbName"] = boost::any(*extSlbName);
    }
    if (haveManageAccess) {
      res["HaveManageAccess"] = boost::any(*haveManageAccess);
    }
    if (healthCheckUrl) {
      res["HealthCheckUrl"] = boost::any(*healthCheckUrl);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nameSpace_) {
      res["NameSpace"] = boost::any(*nameSpace_);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (runningInstanceCount) {
      res["RunningInstanceCount"] = boost::any(*runningInstanceCount);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (slbInfo) {
      res["SlbInfo"] = boost::any(*slbInfo);
    }
    if (slbIp) {
      res["SlbIp"] = boost::any(*slbIp);
    }
    if (slbName) {
      res["SlbName"] = boost::any(*slbName);
    }
    if (slbPort) {
      res["SlbPort"] = boost::any(*slbPort);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (workloadType) {
      res["WorkloadType"] = boost::any(*workloadType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppPhase") != m.end() && !m["AppPhase"].empty()) {
      appPhase = make_shared<string>(boost::any_cast<string>(m["AppPhase"]));
    }
    if (m.find("ApplicationType") != m.end() && !m["ApplicationType"].empty()) {
      applicationType = make_shared<string>(boost::any_cast<string>(m["ApplicationType"]));
    }
    if (m.find("BuildPackageId") != m.end() && !m["BuildPackageId"].empty()) {
      buildPackageId = make_shared<long>(boost::any_cast<long>(m["BuildPackageId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Dockerize") != m.end() && !m["Dockerize"].empty()) {
      dockerize = make_shared<bool>(boost::any_cast<bool>(m["Dockerize"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("EnablePortCheck") != m.end() && !m["EnablePortCheck"].empty()) {
      enablePortCheck = make_shared<bool>(boost::any_cast<bool>(m["EnablePortCheck"]));
    }
    if (m.find("EnableUrlCheck") != m.end() && !m["EnableUrlCheck"].empty()) {
      enableUrlCheck = make_shared<bool>(boost::any_cast<bool>(m["EnableUrlCheck"]));
    }
    if (m.find("ExtSlbId") != m.end() && !m["ExtSlbId"].empty()) {
      extSlbId = make_shared<string>(boost::any_cast<string>(m["ExtSlbId"]));
    }
    if (m.find("ExtSlbIp") != m.end() && !m["ExtSlbIp"].empty()) {
      extSlbIp = make_shared<string>(boost::any_cast<string>(m["ExtSlbIp"]));
    }
    if (m.find("ExtSlbName") != m.end() && !m["ExtSlbName"].empty()) {
      extSlbName = make_shared<string>(boost::any_cast<string>(m["ExtSlbName"]));
    }
    if (m.find("HaveManageAccess") != m.end() && !m["HaveManageAccess"].empty()) {
      haveManageAccess = make_shared<string>(boost::any_cast<string>(m["HaveManageAccess"]));
    }
    if (m.find("HealthCheckUrl") != m.end() && !m["HealthCheckUrl"].empty()) {
      healthCheckUrl = make_shared<string>(boost::any_cast<string>(m["HealthCheckUrl"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NameSpace") != m.end() && !m["NameSpace"].empty()) {
      nameSpace_ = make_shared<string>(boost::any_cast<string>(m["NameSpace"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RunningInstanceCount") != m.end() && !m["RunningInstanceCount"].empty()) {
      runningInstanceCount = make_shared<long>(boost::any_cast<long>(m["RunningInstanceCount"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("SlbInfo") != m.end() && !m["SlbInfo"].empty()) {
      slbInfo = make_shared<string>(boost::any_cast<string>(m["SlbInfo"]));
    }
    if (m.find("SlbIp") != m.end() && !m["SlbIp"].empty()) {
      slbIp = make_shared<string>(boost::any_cast<string>(m["SlbIp"]));
    }
    if (m.find("SlbName") != m.end() && !m["SlbName"].empty()) {
      slbName = make_shared<string>(boost::any_cast<string>(m["SlbName"]));
    }
    if (m.find("SlbPort") != m.end() && !m["SlbPort"].empty()) {
      slbPort = make_shared<long>(boost::any_cast<long>(m["SlbPort"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WorkloadType") != m.end() && !m["WorkloadType"].empty()) {
      workloadType = make_shared<string>(boost::any_cast<string>(m["WorkloadType"]));
    }
  }


  virtual ~GetApplicationResponseBodyApplication() = default;
};
class GetApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetApplicationResponseBodyApplication> application{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetApplicationResponseBody() {}

  explicit GetApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (application) {
      res["Application"] = application ? boost::any(application->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Application") != m.end() && !m["Application"].empty()) {
      if (typeid(map<string, boost::any>) == m["Application"].type()) {
        GetApplicationResponseBodyApplication model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Application"]));
        application = make_shared<GetApplicationResponseBodyApplication>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetApplicationResponseBody() = default;
};
class GetApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetApplicationResponseBody> body{};

  GetApplicationResponse() {}

  explicit GetApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~GetApplicationResponse() = default;
};
class GetChangeOrderInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  GetChangeOrderInfoRequest() {}

  explicit GetChangeOrderInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~GetChangeOrderInfoRequest() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO : public Darabonba::Model {
public:
  shared_ptr<long> retryType{};
  shared_ptr<bool> showManualIgnorance{};
  shared_ptr<string> taskErrorCode{};
  shared_ptr<long> taskErrorIgnorance{};
  shared_ptr<string> taskErrorMessage{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskMessage{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskStatus{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (retryType) {
      res["RetryType"] = boost::any(*retryType);
    }
    if (showManualIgnorance) {
      res["ShowManualIgnorance"] = boost::any(*showManualIgnorance);
    }
    if (taskErrorCode) {
      res["TaskErrorCode"] = boost::any(*taskErrorCode);
    }
    if (taskErrorIgnorance) {
      res["TaskErrorIgnorance"] = boost::any(*taskErrorIgnorance);
    }
    if (taskErrorMessage) {
      res["TaskErrorMessage"] = boost::any(*taskErrorMessage);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskMessage) {
      res["TaskMessage"] = boost::any(*taskMessage);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RetryType") != m.end() && !m["RetryType"].empty()) {
      retryType = make_shared<long>(boost::any_cast<long>(m["RetryType"]));
    }
    if (m.find("ShowManualIgnorance") != m.end() && !m["ShowManualIgnorance"].empty()) {
      showManualIgnorance = make_shared<bool>(boost::any_cast<bool>(m["ShowManualIgnorance"]));
    }
    if (m.find("TaskErrorCode") != m.end() && !m["TaskErrorCode"].empty()) {
      taskErrorCode = make_shared<string>(boost::any_cast<string>(m["TaskErrorCode"]));
    }
    if (m.find("TaskErrorIgnorance") != m.end() && !m["TaskErrorIgnorance"].empty()) {
      taskErrorIgnorance = make_shared<long>(boost::any_cast<long>(m["TaskErrorIgnorance"]));
    }
    if (m.find("TaskErrorMessage") != m.end() && !m["TaskErrorMessage"].empty()) {
      taskErrorMessage = make_shared<string>(boost::any_cast<string>(m["TaskErrorMessage"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskMessage") != m.end() && !m["TaskMessage"].empty()) {
      taskMessage = make_shared<string>(boost::any_cast<string>(m["TaskMessage"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskList : public Darabonba::Model {
public:
  shared_ptr<vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO>> taskInfoDTO{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskList() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskInfoDTO) {
      vector<boost::any> temp1;
      for(auto item1:*taskInfoDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskInfoDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskInfoDTO") != m.end() && !m["TaskInfoDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskInfoDTO"].type()) {
        vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskInfoDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskInfoDTO = make_shared<vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO>>(expect1);
      }
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskList() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO : public Darabonba::Model {
public:
  shared_ptr<string> stageId{};
  shared_ptr<string> stageName{};
  shared_ptr<long> stageStatus{};
  shared_ptr<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskList> taskList{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (stageStatus) {
      res["StageStatus"] = boost::any(*stageStatus);
    }
    if (taskList) {
      res["TaskList"] = taskList ? boost::any(taskList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("StageStatus") != m.end() && !m["StageStatus"].empty()) {
      stageStatus = make_shared<long>(boost::any_cast<long>(m["StageStatus"]));
    }
    if (m.find("TaskList") != m.end() && !m["TaskList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskList"].type()) {
        GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskList"]));
        taskList = make_shared<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskList>(model1);
      }
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailList : public Darabonba::Model {
public:
  shared_ptr<vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO>> stageDetailDTO{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailList() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stageDetailDTO) {
      vector<boost::any> temp1;
      for(auto item1:*stageDetailDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StageDetailDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StageDetailDTO") != m.end() && !m["StageDetailDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["StageDetailDTO"].type()) {
        vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StageDetailDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stageDetailDTO = make_shared<vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO>>(expect1);
      }
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailList() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO : public Darabonba::Model {
public:
  shared_ptr<string> finishTime{};
  shared_ptr<string> stageId{};
  shared_ptr<string> stageMessage{};
  shared_ptr<string> stageName{};
  shared_ptr<string> startTime{};
  shared_ptr<long> status{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (stageMessage) {
      res["StageMessage"] = boost::any(*stageMessage);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("StageMessage") != m.end() && !m["StageMessage"].empty()) {
      stageMessage = make_shared<string>(boost::any_cast<string>(m["StageMessage"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOList : public Darabonba::Model {
public:
  shared_ptr<vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO>> instanceStageDTO{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOList() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceStageDTO) {
      vector<boost::any> temp1;
      for(auto item1:*instanceStageDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceStageDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceStageDTO") != m.end() && !m["InstanceStageDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceStageDTO"].type()) {
        vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceStageDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceStageDTO = make_shared<vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO>>(expect1);
      }
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOList() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO : public Darabonba::Model {
public:
  shared_ptr<string> instanceIp{};
  shared_ptr<string> instanceName{};
  shared_ptr<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOList> instanceStageDTOList{};
  shared_ptr<string> podName{};
  shared_ptr<string> podStatus{};
  shared_ptr<long> status{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIp) {
      res["InstanceIp"] = boost::any(*instanceIp);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceStageDTOList) {
      res["InstanceStageDTOList"] = instanceStageDTOList ? boost::any(instanceStageDTOList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (podName) {
      res["PodName"] = boost::any(*podName);
    }
    if (podStatus) {
      res["PodStatus"] = boost::any(*podStatus);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIp") != m.end() && !m["InstanceIp"].empty()) {
      instanceIp = make_shared<string>(boost::any_cast<string>(m["InstanceIp"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceStageDTOList") != m.end() && !m["InstanceStageDTOList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceStageDTOList"].type()) {
        GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceStageDTOList"]));
        instanceStageDTOList = make_shared<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOList>(model1);
      }
    }
    if (m.find("PodName") != m.end() && !m["PodName"].empty()) {
      podName = make_shared<string>(boost::any_cast<string>(m["PodName"]));
    }
    if (m.find("PodStatus") != m.end() && !m["PodStatus"].empty()) {
      podStatus = make_shared<string>(boost::any_cast<string>(m["PodStatus"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOList : public Darabonba::Model {
public:
  shared_ptr<vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO>> instanceDTO{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOList() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceDTO) {
      vector<boost::any> temp1;
      for(auto item1:*instanceDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceDTO") != m.end() && !m["InstanceDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceDTO"].type()) {
        vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceDTO = make_shared<vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO>>(expect1);
      }
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOList() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> stageId{};
  shared_ptr<string> stageName{};
  shared_ptr<long> status{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO : public Darabonba::Model {
public:
  shared_ptr<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOList> instanceDTOList{};
  shared_ptr<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage> serviceStage{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceDTOList) {
      res["InstanceDTOList"] = instanceDTOList ? boost::any(instanceDTOList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceStage) {
      res["ServiceStage"] = serviceStage ? boost::any(serviceStage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceDTOList") != m.end() && !m["InstanceDTOList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceDTOList"].type()) {
        GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceDTOList"]));
        instanceDTOList = make_shared<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOList>(model1);
      }
    }
    if (m.find("ServiceStage") != m.end() && !m["ServiceStage"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceStage"].type()) {
        GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceStage"]));
        serviceStage = make_shared<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage>(model1);
      }
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO : public Darabonba::Model {
public:
  shared_ptr<string> stageId{};
  shared_ptr<string> stageName{};
  shared_ptr<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO> stageResultDTO{};
  shared_ptr<long> status{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (stageResultDTO) {
      res["StageResultDTO"] = stageResultDTO ? boost::any(stageResultDTO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("StageResultDTO") != m.end() && !m["StageResultDTO"].empty()) {
      if (typeid(map<string, boost::any>) == m["StageResultDTO"].type()) {
        GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StageResultDTO"]));
        stageResultDTO = make_shared<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageList : public Darabonba::Model {
public:
  shared_ptr<vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO>> stageInfoDTO{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageList() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stageInfoDTO) {
      vector<boost::any> temp1;
      for(auto item1:*stageInfoDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StageInfoDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StageInfoDTO") != m.end() && !m["StageInfoDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["StageInfoDTO"].type()) {
        vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StageInfoDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stageInfoDTO = make_shared<vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO>>(expect1);
      }
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageList() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<string> pipelineName{};
  shared_ptr<long> pipelineStatus{};
  shared_ptr<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailList> stageDetailList{};
  shared_ptr<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageList> stageList{};
  shared_ptr<string> startTime{};
  shared_ptr<string> updateTime{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (pipelineName) {
      res["PipelineName"] = boost::any(*pipelineName);
    }
    if (pipelineStatus) {
      res["PipelineStatus"] = boost::any(*pipelineStatus);
    }
    if (stageDetailList) {
      res["StageDetailList"] = stageDetailList ? boost::any(stageDetailList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stageList) {
      res["StageList"] = stageList ? boost::any(stageList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("PipelineName") != m.end() && !m["PipelineName"].empty()) {
      pipelineName = make_shared<string>(boost::any_cast<string>(m["PipelineName"]));
    }
    if (m.find("PipelineStatus") != m.end() && !m["PipelineStatus"].empty()) {
      pipelineStatus = make_shared<long>(boost::any_cast<long>(m["PipelineStatus"]));
    }
    if (m.find("StageDetailList") != m.end() && !m["StageDetailList"].empty()) {
      if (typeid(map<string, boost::any>) == m["StageDetailList"].type()) {
        GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StageDetailList"]));
        stageDetailList = make_shared<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailList>(model1);
      }
    }
    if (m.find("StageList") != m.end() && !m["StageList"].empty()) {
      if (typeid(map<string, boost::any>) == m["StageList"].type()) {
        GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StageList"]));
        stageList = make_shared<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageList>(model1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo>> pipelineInfo{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoList() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineInfo) {
      vector<boost::any> temp1;
      for(auto item1:*pipelineInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PipelineInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineInfo") != m.end() && !m["PipelineInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PipelineInfo"].type()) {
        vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PipelineInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipelineInfo = make_shared<vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo>>(expect1);
      }
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoList() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoTargets : public Darabonba::Model {
public:
  shared_ptr<vector<string>> items{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoTargets() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoTargets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      res["Items"] = boost::any(*items);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Items"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      items = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoTargets() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl : public Darabonba::Model {
public:
  shared_ptr<string> routes{};
  shared_ptr<string> rules{};
  shared_ptr<string> tips{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routes) {
      res["Routes"] = boost::any(*routes);
    }
    if (rules) {
      res["Rules"] = boost::any(*rules);
    }
    if (tips) {
      res["Tips"] = boost::any(*tips);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Routes") != m.end() && !m["Routes"].empty()) {
      routes = make_shared<string>(boost::any_cast<string>(m["Routes"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rules = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
    if (m.find("Tips") != m.end() && !m["Tips"].empty()) {
      tips = make_shared<string>(boost::any_cast<string>(m["Tips"]));
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfo : public Darabonba::Model {
public:
  shared_ptr<long> batchCount{};
  shared_ptr<string> batchType{};
  shared_ptr<string> changeOrderDescription{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<string> coType{};
  shared_ptr<string> createTime{};
  shared_ptr<string> createUserId{};
  shared_ptr<string> desc{};
  shared_ptr<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoList> pipelineInfoList{};
  shared_ptr<long> status{};
  shared_ptr<bool> supportRollback{};
  shared_ptr<GetChangeOrderInfoResponseBodyChangeOrderInfoTargets> targets{};
  shared_ptr<GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl> trafficControl{};

  GetChangeOrderInfoResponseBodyChangeOrderInfo() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchCount) {
      res["BatchCount"] = boost::any(*batchCount);
    }
    if (batchType) {
      res["BatchType"] = boost::any(*batchType);
    }
    if (changeOrderDescription) {
      res["ChangeOrderDescription"] = boost::any(*changeOrderDescription);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (coType) {
      res["CoType"] = boost::any(*coType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUserId) {
      res["CreateUserId"] = boost::any(*createUserId);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (pipelineInfoList) {
      res["PipelineInfoList"] = pipelineInfoList ? boost::any(pipelineInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (supportRollback) {
      res["SupportRollback"] = boost::any(*supportRollback);
    }
    if (targets) {
      res["Targets"] = targets ? boost::any(targets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trafficControl) {
      res["TrafficControl"] = trafficControl ? boost::any(trafficControl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchCount") != m.end() && !m["BatchCount"].empty()) {
      batchCount = make_shared<long>(boost::any_cast<long>(m["BatchCount"]));
    }
    if (m.find("BatchType") != m.end() && !m["BatchType"].empty()) {
      batchType = make_shared<string>(boost::any_cast<string>(m["BatchType"]));
    }
    if (m.find("ChangeOrderDescription") != m.end() && !m["ChangeOrderDescription"].empty()) {
      changeOrderDescription = make_shared<string>(boost::any_cast<string>(m["ChangeOrderDescription"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("CoType") != m.end() && !m["CoType"].empty()) {
      coType = make_shared<string>(boost::any_cast<string>(m["CoType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateUserId") != m.end() && !m["CreateUserId"].empty()) {
      createUserId = make_shared<string>(boost::any_cast<string>(m["CreateUserId"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("PipelineInfoList") != m.end() && !m["PipelineInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PipelineInfoList"].type()) {
        GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PipelineInfoList"]));
        pipelineInfoList = make_shared<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoList>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("SupportRollback") != m.end() && !m["SupportRollback"].empty()) {
      supportRollback = make_shared<bool>(boost::any_cast<bool>(m["SupportRollback"]));
    }
    if (m.find("Targets") != m.end() && !m["Targets"].empty()) {
      if (typeid(map<string, boost::any>) == m["Targets"].type()) {
        GetChangeOrderInfoResponseBodyChangeOrderInfoTargets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Targets"]));
        targets = make_shared<GetChangeOrderInfoResponseBodyChangeOrderInfoTargets>(model1);
      }
    }
    if (m.find("TrafficControl") != m.end() && !m["TrafficControl"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficControl"].type()) {
        GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficControl"]));
        trafficControl = make_shared<GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl>(model1);
      }
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfo() = default;
};
class GetChangeOrderInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<GetChangeOrderInfoResponseBodyChangeOrderInfo> changeOrderInfo{};

  GetChangeOrderInfoResponseBody() {}

  explicit GetChangeOrderInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderInfo) {
      res["changeOrderInfo"] = changeOrderInfo ? boost::any(changeOrderInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("changeOrderInfo") != m.end() && !m["changeOrderInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["changeOrderInfo"].type()) {
        GetChangeOrderInfoResponseBodyChangeOrderInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["changeOrderInfo"]));
        changeOrderInfo = make_shared<GetChangeOrderInfoResponseBodyChangeOrderInfo>(model1);
      }
    }
  }


  virtual ~GetChangeOrderInfoResponseBody() = default;
};
class GetChangeOrderInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetChangeOrderInfoResponseBody> body{};

  GetChangeOrderInfoResponse() {}

  explicit GetChangeOrderInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetChangeOrderInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetChangeOrderInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetChangeOrderInfoResponse() = default;
};
class GetClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};

  GetClusterRequest() {}

  explicit GetClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~GetClusterRequest() = default;
};
class GetClusterResponseBodyCluster : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> clusterImportStatus{};
  shared_ptr<string> clusterName{};
  shared_ptr<long> clusterType{};
  shared_ptr<long> cpu{};
  shared_ptr<long> cpuUsed{};
  shared_ptr<long> createTime{};
  shared_ptr<string> csClusterId{};
  shared_ptr<string> description{};
  shared_ptr<string> iaasProvider{};
  shared_ptr<long> mem{};
  shared_ptr<long> memUsed{};
  shared_ptr<long> networkMode{};
  shared_ptr<long> nodeNum{};
  shared_ptr<long> oversoldFactor{};
  shared_ptr<string> regionId{};
  shared_ptr<string> subClusterType{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> vpcId{};

  GetClusterResponseBodyCluster() {}

  explicit GetClusterResponseBodyCluster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterImportStatus) {
      res["ClusterImportStatus"] = boost::any(*clusterImportStatus);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (cpuUsed) {
      res["CpuUsed"] = boost::any(*cpuUsed);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (csClusterId) {
      res["CsClusterId"] = boost::any(*csClusterId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (iaasProvider) {
      res["IaasProvider"] = boost::any(*iaasProvider);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (memUsed) {
      res["MemUsed"] = boost::any(*memUsed);
    }
    if (networkMode) {
      res["NetworkMode"] = boost::any(*networkMode);
    }
    if (nodeNum) {
      res["NodeNum"] = boost::any(*nodeNum);
    }
    if (oversoldFactor) {
      res["OversoldFactor"] = boost::any(*oversoldFactor);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (subClusterType) {
      res["SubClusterType"] = boost::any(*subClusterType);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterImportStatus") != m.end() && !m["ClusterImportStatus"].empty()) {
      clusterImportStatus = make_shared<long>(boost::any_cast<long>(m["ClusterImportStatus"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<long>(boost::any_cast<long>(m["ClusterType"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CpuUsed") != m.end() && !m["CpuUsed"].empty()) {
      cpuUsed = make_shared<long>(boost::any_cast<long>(m["CpuUsed"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CsClusterId") != m.end() && !m["CsClusterId"].empty()) {
      csClusterId = make_shared<string>(boost::any_cast<string>(m["CsClusterId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IaasProvider") != m.end() && !m["IaasProvider"].empty()) {
      iaasProvider = make_shared<string>(boost::any_cast<string>(m["IaasProvider"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("MemUsed") != m.end() && !m["MemUsed"].empty()) {
      memUsed = make_shared<long>(boost::any_cast<long>(m["MemUsed"]));
    }
    if (m.find("NetworkMode") != m.end() && !m["NetworkMode"].empty()) {
      networkMode = make_shared<long>(boost::any_cast<long>(m["NetworkMode"]));
    }
    if (m.find("NodeNum") != m.end() && !m["NodeNum"].empty()) {
      nodeNum = make_shared<long>(boost::any_cast<long>(m["NodeNum"]));
    }
    if (m.find("OversoldFactor") != m.end() && !m["OversoldFactor"].empty()) {
      oversoldFactor = make_shared<long>(boost::any_cast<long>(m["OversoldFactor"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SubClusterType") != m.end() && !m["SubClusterType"].empty()) {
      subClusterType = make_shared<string>(boost::any_cast<string>(m["SubClusterType"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~GetClusterResponseBodyCluster() = default;
};
class GetClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetClusterResponseBodyCluster> cluster{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetClusterResponseBody() {}

  explicit GetClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cluster) {
      res["Cluster"] = cluster ? boost::any(cluster->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cluster") != m.end() && !m["Cluster"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cluster"].type()) {
        GetClusterResponseBodyCluster model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cluster"]));
        cluster = make_shared<GetClusterResponseBodyCluster>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetClusterResponseBody() = default;
};
class GetClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetClusterResponseBody> body{};

  GetClusterResponse() {}

  explicit GetClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetClusterResponseBody>(model1);
      }
    }
  }


  virtual ~GetClusterResponse() = default;
};
class GetContainerConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};

  GetContainerConfigurationRequest() {}

  explicit GetContainerConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~GetContainerConfigurationRequest() = default;
};
class GetContainerConfigurationResponseBodyContainerConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> contextPath{};
  shared_ptr<long> httpPort{};
  shared_ptr<long> maxThreads{};
  shared_ptr<string> URIEncoding{};
  shared_ptr<bool> useBodyEncoding{};

  GetContainerConfigurationResponseBodyContainerConfiguration() {}

  explicit GetContainerConfigurationResponseBodyContainerConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contextPath) {
      res["ContextPath"] = boost::any(*contextPath);
    }
    if (httpPort) {
      res["HttpPort"] = boost::any(*httpPort);
    }
    if (maxThreads) {
      res["MaxThreads"] = boost::any(*maxThreads);
    }
    if (URIEncoding) {
      res["URIEncoding"] = boost::any(*URIEncoding);
    }
    if (useBodyEncoding) {
      res["UseBodyEncoding"] = boost::any(*useBodyEncoding);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContextPath") != m.end() && !m["ContextPath"].empty()) {
      contextPath = make_shared<string>(boost::any_cast<string>(m["ContextPath"]));
    }
    if (m.find("HttpPort") != m.end() && !m["HttpPort"].empty()) {
      httpPort = make_shared<long>(boost::any_cast<long>(m["HttpPort"]));
    }
    if (m.find("MaxThreads") != m.end() && !m["MaxThreads"].empty()) {
      maxThreads = make_shared<long>(boost::any_cast<long>(m["MaxThreads"]));
    }
    if (m.find("URIEncoding") != m.end() && !m["URIEncoding"].empty()) {
      URIEncoding = make_shared<string>(boost::any_cast<string>(m["URIEncoding"]));
    }
    if (m.find("UseBodyEncoding") != m.end() && !m["UseBodyEncoding"].empty()) {
      useBodyEncoding = make_shared<bool>(boost::any_cast<bool>(m["UseBodyEncoding"]));
    }
  }


  virtual ~GetContainerConfigurationResponseBodyContainerConfiguration() = default;
};
class GetContainerConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetContainerConfigurationResponseBodyContainerConfiguration> containerConfiguration{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetContainerConfigurationResponseBody() {}

  explicit GetContainerConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (containerConfiguration) {
      res["ContainerConfiguration"] = containerConfiguration ? boost::any(containerConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("ContainerConfiguration") != m.end() && !m["ContainerConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContainerConfiguration"].type()) {
        GetContainerConfigurationResponseBodyContainerConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContainerConfiguration"]));
        containerConfiguration = make_shared<GetContainerConfigurationResponseBodyContainerConfiguration>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetContainerConfigurationResponseBody() = default;
};
class GetContainerConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetContainerConfigurationResponseBody> body{};

  GetContainerConfigurationResponse() {}

  explicit GetContainerConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetContainerConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetContainerConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~GetContainerConfigurationResponse() = default;
};
class GetJavaStartUpConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  GetJavaStartUpConfigRequest() {}

  explicit GetJavaStartUpConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~GetJavaStartUpConfigRequest() = default;
};
class GetJavaStartUpConfigResponseBodyJavaStartUpConfig : public Darabonba::Model {
public:
  shared_ptr<string> originalConfigs{};
  shared_ptr<string> startUpArgs{};

  GetJavaStartUpConfigResponseBodyJavaStartUpConfig() {}

  explicit GetJavaStartUpConfigResponseBodyJavaStartUpConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originalConfigs) {
      res["OriginalConfigs"] = boost::any(*originalConfigs);
    }
    if (startUpArgs) {
      res["StartUpArgs"] = boost::any(*startUpArgs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginalConfigs") != m.end() && !m["OriginalConfigs"].empty()) {
      originalConfigs = make_shared<string>(boost::any_cast<string>(m["OriginalConfigs"]));
    }
    if (m.find("StartUpArgs") != m.end() && !m["StartUpArgs"].empty()) {
      startUpArgs = make_shared<string>(boost::any_cast<string>(m["StartUpArgs"]));
    }
  }


  virtual ~GetJavaStartUpConfigResponseBodyJavaStartUpConfig() = default;
};
class GetJavaStartUpConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetJavaStartUpConfigResponseBodyJavaStartUpConfig> javaStartUpConfig{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetJavaStartUpConfigResponseBody() {}

  explicit GetJavaStartUpConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (javaStartUpConfig) {
      res["JavaStartUpConfig"] = javaStartUpConfig ? boost::any(javaStartUpConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("JavaStartUpConfig") != m.end() && !m["JavaStartUpConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["JavaStartUpConfig"].type()) {
        GetJavaStartUpConfigResponseBodyJavaStartUpConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JavaStartUpConfig"]));
        javaStartUpConfig = make_shared<GetJavaStartUpConfigResponseBodyJavaStartUpConfig>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetJavaStartUpConfigResponseBody() = default;
};
class GetJavaStartUpConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetJavaStartUpConfigResponseBody> body{};

  GetJavaStartUpConfigResponse() {}

  explicit GetJavaStartUpConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetJavaStartUpConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetJavaStartUpConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GetJavaStartUpConfigResponse() = default;
};
class GetJvmConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};

  GetJvmConfigurationRequest() {}

  explicit GetJvmConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~GetJvmConfigurationRequest() = default;
};
class GetJvmConfigurationResponseBodyJvmConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> maxHeapSize{};
  shared_ptr<long> maxPermSize{};
  shared_ptr<long> minHeapSize{};
  shared_ptr<string> options{};

  GetJvmConfigurationResponseBodyJvmConfiguration() {}

  explicit GetJvmConfigurationResponseBodyJvmConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxHeapSize) {
      res["MaxHeapSize"] = boost::any(*maxHeapSize);
    }
    if (maxPermSize) {
      res["MaxPermSize"] = boost::any(*maxPermSize);
    }
    if (minHeapSize) {
      res["MinHeapSize"] = boost::any(*minHeapSize);
    }
    if (options) {
      res["Options"] = boost::any(*options);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxHeapSize") != m.end() && !m["MaxHeapSize"].empty()) {
      maxHeapSize = make_shared<long>(boost::any_cast<long>(m["MaxHeapSize"]));
    }
    if (m.find("MaxPermSize") != m.end() && !m["MaxPermSize"].empty()) {
      maxPermSize = make_shared<long>(boost::any_cast<long>(m["MaxPermSize"]));
    }
    if (m.find("MinHeapSize") != m.end() && !m["MinHeapSize"].empty()) {
      minHeapSize = make_shared<long>(boost::any_cast<long>(m["MinHeapSize"]));
    }
    if (m.find("Options") != m.end() && !m["Options"].empty()) {
      options = make_shared<string>(boost::any_cast<string>(m["Options"]));
    }
  }


  virtual ~GetJvmConfigurationResponseBodyJvmConfiguration() = default;
};
class GetJvmConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetJvmConfigurationResponseBodyJvmConfiguration> jvmConfiguration{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetJvmConfigurationResponseBody() {}

  explicit GetJvmConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (jvmConfiguration) {
      res["JvmConfiguration"] = jvmConfiguration ? boost::any(jvmConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("JvmConfiguration") != m.end() && !m["JvmConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["JvmConfiguration"].type()) {
        GetJvmConfigurationResponseBodyJvmConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JvmConfiguration"]));
        jvmConfiguration = make_shared<GetJvmConfigurationResponseBodyJvmConfiguration>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetJvmConfigurationResponseBody() = default;
};
class GetJvmConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetJvmConfigurationResponseBody> body{};

  GetJvmConfigurationResponse() {}

  explicit GetJvmConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetJvmConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetJvmConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~GetJvmConfigurationResponse() = default;
};
class GetK8sAppPrecheckResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> namespace_{};

  GetK8sAppPrecheckResultRequest() {}

  explicit GetK8sAppPrecheckResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~GetK8sAppPrecheckResultRequest() = default;
};
class GetK8sAppPrecheckResultResponseBodyDataJobResults : public Darabonba::Model {
public:
  shared_ptr<bool> interrupted{};
  shared_ptr<string> name{};
  shared_ptr<bool> pass{};
  shared_ptr<string> reason{};

  GetK8sAppPrecheckResultResponseBodyDataJobResults() {}

  explicit GetK8sAppPrecheckResultResponseBodyDataJobResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interrupted) {
      res["Interrupted"] = boost::any(*interrupted);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pass) {
      res["Pass"] = boost::any(*pass);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Interrupted") != m.end() && !m["Interrupted"].empty()) {
      interrupted = make_shared<bool>(boost::any_cast<bool>(m["Interrupted"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Pass") != m.end() && !m["Pass"].empty()) {
      pass = make_shared<bool>(boost::any_cast<bool>(m["Pass"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~GetK8sAppPrecheckResultResponseBodyDataJobResults() = default;
};
class GetK8sAppPrecheckResultResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetK8sAppPrecheckResultResponseBodyDataJobResults>> jobResults{};
  shared_ptr<string> reason{};
  shared_ptr<string> status{};

  GetK8sAppPrecheckResultResponseBodyData() {}

  explicit GetK8sAppPrecheckResultResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobResults) {
      vector<boost::any> temp1;
      for(auto item1:*jobResults){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JobResults"] = boost::any(temp1);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobResults") != m.end() && !m["JobResults"].empty()) {
      if (typeid(vector<boost::any>) == m["JobResults"].type()) {
        vector<GetK8sAppPrecheckResultResponseBodyDataJobResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JobResults"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetK8sAppPrecheckResultResponseBodyDataJobResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobResults = make_shared<vector<GetK8sAppPrecheckResultResponseBodyDataJobResults>>(expect1);
      }
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetK8sAppPrecheckResultResponseBodyData() = default;
};
class GetK8sAppPrecheckResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetK8sAppPrecheckResultResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetK8sAppPrecheckResultResponseBody() {}

  explicit GetK8sAppPrecheckResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetK8sAppPrecheckResultResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetK8sAppPrecheckResultResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetK8sAppPrecheckResultResponseBody() = default;
};
class GetK8sAppPrecheckResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetK8sAppPrecheckResultResponseBody> body{};

  GetK8sAppPrecheckResultResponse() {}

  explicit GetK8sAppPrecheckResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetK8sAppPrecheckResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetK8sAppPrecheckResultResponseBody>(model1);
      }
    }
  }


  virtual ~GetK8sAppPrecheckResultResponse() = default;
};
class GetK8sApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> from{};

  GetK8sApplicationRequest() {}

  explicit GetK8sApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
  }


  virtual ~GetK8sApplicationRequest() = default;
};
class GetK8sApplicationResponseBodyApplcationAppCmdArgs : public Darabonba::Model {
public:
  shared_ptr<vector<string>> cmdArg{};

  GetK8sApplicationResponseBodyApplcationAppCmdArgs() {}

  explicit GetK8sApplicationResponseBodyApplcationAppCmdArgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cmdArg) {
      res["CmdArg"] = boost::any(*cmdArg);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CmdArg") != m.end() && !m["CmdArg"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CmdArg"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CmdArg"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cmdArg = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetK8sApplicationResponseBodyApplcationAppCmdArgs() = default;
};
class GetK8sApplicationResponseBodyApplcationAppEnvListEnv : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  GetK8sApplicationResponseBodyApplcationAppEnvListEnv() {}

  explicit GetK8sApplicationResponseBodyApplcationAppEnvListEnv(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetK8sApplicationResponseBodyApplcationAppEnvListEnv() = default;
};
class GetK8sApplicationResponseBodyApplcationAppEnvList : public Darabonba::Model {
public:
  shared_ptr<vector<GetK8sApplicationResponseBodyApplcationAppEnvListEnv>> env{};

  GetK8sApplicationResponseBodyApplcationAppEnvList() {}

  explicit GetK8sApplicationResponseBodyApplcationAppEnvList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      vector<boost::any> temp1;
      for(auto item1:*env){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Env"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      if (typeid(vector<boost::any>) == m["Env"].type()) {
        vector<GetK8sApplicationResponseBodyApplcationAppEnvListEnv> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Env"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetK8sApplicationResponseBodyApplcationAppEnvListEnv model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        env = make_shared<vector<GetK8sApplicationResponseBodyApplcationAppEnvListEnv>>(expect1);
      }
    }
  }


  virtual ~GetK8sApplicationResponseBodyApplcationAppEnvList() = default;
};
class GetK8sApplicationResponseBodyApplcationApp : public Darabonba::Model {
public:
  shared_ptr<string> annotations{};
  shared_ptr<string> appId{};
  shared_ptr<string> applicationName{};
  shared_ptr<string> applicationType{};
  shared_ptr<long> buildpackId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> cmd{};
  shared_ptr<GetK8sApplicationResponseBodyApplcationAppCmdArgs> cmdArgs{};
  shared_ptr<string> csClusterId{};
  shared_ptr<string> deployType{};
  shared_ptr<string> developType{};
  shared_ptr<string> edasContainerVersion{};
  shared_ptr<bool> enableEmptyPushReject{};
  shared_ptr<bool> enableLosslessRule{};
  shared_ptr<GetK8sApplicationResponseBodyApplcationAppEnvList> envList{};
  shared_ptr<string> featureAnnotations{};
  shared_ptr<long> instances{};
  shared_ptr<long> instancesBeforeScaling{};
  shared_ptr<string> k8sNamespace{};
  shared_ptr<string> labels{};
  shared_ptr<long> limitCpuM{};
  shared_ptr<string> limitEphemeralStorage{};
  shared_ptr<long> limitMem{};
  shared_ptr<bool> losslessRuleAligned{};
  shared_ptr<long> losslessRuleDelayTime{};
  shared_ptr<long> losslessRuleFuncType{};
  shared_ptr<bool> losslessRuleRelated{};
  shared_ptr<long> losslessRuleWarmupTime{};
  shared_ptr<string> regionId{};
  shared_ptr<long> requestCpuM{};
  shared_ptr<string> requestEphemeralStorage{};
  shared_ptr<long> requestMem{};
  shared_ptr<string> slbInfo{};
  shared_ptr<string> tomcatVersion{};
  shared_ptr<string> workloadType{};

  GetK8sApplicationResponseBodyApplcationApp() {}

  explicit GetK8sApplicationResponseBodyApplcationApp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotations) {
      res["Annotations"] = boost::any(*annotations);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (applicationType) {
      res["ApplicationType"] = boost::any(*applicationType);
    }
    if (buildpackId) {
      res["BuildpackId"] = boost::any(*buildpackId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (cmd) {
      res["Cmd"] = boost::any(*cmd);
    }
    if (cmdArgs) {
      res["CmdArgs"] = cmdArgs ? boost::any(cmdArgs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (csClusterId) {
      res["CsClusterId"] = boost::any(*csClusterId);
    }
    if (deployType) {
      res["DeployType"] = boost::any(*deployType);
    }
    if (developType) {
      res["DevelopType"] = boost::any(*developType);
    }
    if (edasContainerVersion) {
      res["EdasContainerVersion"] = boost::any(*edasContainerVersion);
    }
    if (enableEmptyPushReject) {
      res["EnableEmptyPushReject"] = boost::any(*enableEmptyPushReject);
    }
    if (enableLosslessRule) {
      res["EnableLosslessRule"] = boost::any(*enableLosslessRule);
    }
    if (envList) {
      res["EnvList"] = envList ? boost::any(envList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (featureAnnotations) {
      res["FeatureAnnotations"] = boost::any(*featureAnnotations);
    }
    if (instances) {
      res["Instances"] = boost::any(*instances);
    }
    if (instancesBeforeScaling) {
      res["InstancesBeforeScaling"] = boost::any(*instancesBeforeScaling);
    }
    if (k8sNamespace) {
      res["K8sNamespace"] = boost::any(*k8sNamespace);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (limitCpuM) {
      res["LimitCpuM"] = boost::any(*limitCpuM);
    }
    if (limitEphemeralStorage) {
      res["LimitEphemeralStorage"] = boost::any(*limitEphemeralStorage);
    }
    if (limitMem) {
      res["LimitMem"] = boost::any(*limitMem);
    }
    if (losslessRuleAligned) {
      res["LosslessRuleAligned"] = boost::any(*losslessRuleAligned);
    }
    if (losslessRuleDelayTime) {
      res["LosslessRuleDelayTime"] = boost::any(*losslessRuleDelayTime);
    }
    if (losslessRuleFuncType) {
      res["LosslessRuleFuncType"] = boost::any(*losslessRuleFuncType);
    }
    if (losslessRuleRelated) {
      res["LosslessRuleRelated"] = boost::any(*losslessRuleRelated);
    }
    if (losslessRuleWarmupTime) {
      res["LosslessRuleWarmupTime"] = boost::any(*losslessRuleWarmupTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestCpuM) {
      res["RequestCpuM"] = boost::any(*requestCpuM);
    }
    if (requestEphemeralStorage) {
      res["RequestEphemeralStorage"] = boost::any(*requestEphemeralStorage);
    }
    if (requestMem) {
      res["RequestMem"] = boost::any(*requestMem);
    }
    if (slbInfo) {
      res["SlbInfo"] = boost::any(*slbInfo);
    }
    if (tomcatVersion) {
      res["TomcatVersion"] = boost::any(*tomcatVersion);
    }
    if (workloadType) {
      res["WorkloadType"] = boost::any(*workloadType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      annotations = make_shared<string>(boost::any_cast<string>(m["Annotations"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ApplicationType") != m.end() && !m["ApplicationType"].empty()) {
      applicationType = make_shared<string>(boost::any_cast<string>(m["ApplicationType"]));
    }
    if (m.find("BuildpackId") != m.end() && !m["BuildpackId"].empty()) {
      buildpackId = make_shared<long>(boost::any_cast<long>(m["BuildpackId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Cmd") != m.end() && !m["Cmd"].empty()) {
      cmd = make_shared<string>(boost::any_cast<string>(m["Cmd"]));
    }
    if (m.find("CmdArgs") != m.end() && !m["CmdArgs"].empty()) {
      if (typeid(map<string, boost::any>) == m["CmdArgs"].type()) {
        GetK8sApplicationResponseBodyApplcationAppCmdArgs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CmdArgs"]));
        cmdArgs = make_shared<GetK8sApplicationResponseBodyApplcationAppCmdArgs>(model1);
      }
    }
    if (m.find("CsClusterId") != m.end() && !m["CsClusterId"].empty()) {
      csClusterId = make_shared<string>(boost::any_cast<string>(m["CsClusterId"]));
    }
    if (m.find("DeployType") != m.end() && !m["DeployType"].empty()) {
      deployType = make_shared<string>(boost::any_cast<string>(m["DeployType"]));
    }
    if (m.find("DevelopType") != m.end() && !m["DevelopType"].empty()) {
      developType = make_shared<string>(boost::any_cast<string>(m["DevelopType"]));
    }
    if (m.find("EdasContainerVersion") != m.end() && !m["EdasContainerVersion"].empty()) {
      edasContainerVersion = make_shared<string>(boost::any_cast<string>(m["EdasContainerVersion"]));
    }
    if (m.find("EnableEmptyPushReject") != m.end() && !m["EnableEmptyPushReject"].empty()) {
      enableEmptyPushReject = make_shared<bool>(boost::any_cast<bool>(m["EnableEmptyPushReject"]));
    }
    if (m.find("EnableLosslessRule") != m.end() && !m["EnableLosslessRule"].empty()) {
      enableLosslessRule = make_shared<bool>(boost::any_cast<bool>(m["EnableLosslessRule"]));
    }
    if (m.find("EnvList") != m.end() && !m["EnvList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EnvList"].type()) {
        GetK8sApplicationResponseBodyApplcationAppEnvList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EnvList"]));
        envList = make_shared<GetK8sApplicationResponseBodyApplcationAppEnvList>(model1);
      }
    }
    if (m.find("FeatureAnnotations") != m.end() && !m["FeatureAnnotations"].empty()) {
      featureAnnotations = make_shared<string>(boost::any_cast<string>(m["FeatureAnnotations"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      instances = make_shared<long>(boost::any_cast<long>(m["Instances"]));
    }
    if (m.find("InstancesBeforeScaling") != m.end() && !m["InstancesBeforeScaling"].empty()) {
      instancesBeforeScaling = make_shared<long>(boost::any_cast<long>(m["InstancesBeforeScaling"]));
    }
    if (m.find("K8sNamespace") != m.end() && !m["K8sNamespace"].empty()) {
      k8sNamespace = make_shared<string>(boost::any_cast<string>(m["K8sNamespace"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("LimitCpuM") != m.end() && !m["LimitCpuM"].empty()) {
      limitCpuM = make_shared<long>(boost::any_cast<long>(m["LimitCpuM"]));
    }
    if (m.find("LimitEphemeralStorage") != m.end() && !m["LimitEphemeralStorage"].empty()) {
      limitEphemeralStorage = make_shared<string>(boost::any_cast<string>(m["LimitEphemeralStorage"]));
    }
    if (m.find("LimitMem") != m.end() && !m["LimitMem"].empty()) {
      limitMem = make_shared<long>(boost::any_cast<long>(m["LimitMem"]));
    }
    if (m.find("LosslessRuleAligned") != m.end() && !m["LosslessRuleAligned"].empty()) {
      losslessRuleAligned = make_shared<bool>(boost::any_cast<bool>(m["LosslessRuleAligned"]));
    }
    if (m.find("LosslessRuleDelayTime") != m.end() && !m["LosslessRuleDelayTime"].empty()) {
      losslessRuleDelayTime = make_shared<long>(boost::any_cast<long>(m["LosslessRuleDelayTime"]));
    }
    if (m.find("LosslessRuleFuncType") != m.end() && !m["LosslessRuleFuncType"].empty()) {
      losslessRuleFuncType = make_shared<long>(boost::any_cast<long>(m["LosslessRuleFuncType"]));
    }
    if (m.find("LosslessRuleRelated") != m.end() && !m["LosslessRuleRelated"].empty()) {
      losslessRuleRelated = make_shared<bool>(boost::any_cast<bool>(m["LosslessRuleRelated"]));
    }
    if (m.find("LosslessRuleWarmupTime") != m.end() && !m["LosslessRuleWarmupTime"].empty()) {
      losslessRuleWarmupTime = make_shared<long>(boost::any_cast<long>(m["LosslessRuleWarmupTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestCpuM") != m.end() && !m["RequestCpuM"].empty()) {
      requestCpuM = make_shared<long>(boost::any_cast<long>(m["RequestCpuM"]));
    }
    if (m.find("RequestEphemeralStorage") != m.end() && !m["RequestEphemeralStorage"].empty()) {
      requestEphemeralStorage = make_shared<string>(boost::any_cast<string>(m["RequestEphemeralStorage"]));
    }
    if (m.find("RequestMem") != m.end() && !m["RequestMem"].empty()) {
      requestMem = make_shared<long>(boost::any_cast<long>(m["RequestMem"]));
    }
    if (m.find("SlbInfo") != m.end() && !m["SlbInfo"].empty()) {
      slbInfo = make_shared<string>(boost::any_cast<string>(m["SlbInfo"]));
    }
    if (m.find("TomcatVersion") != m.end() && !m["TomcatVersion"].empty()) {
      tomcatVersion = make_shared<string>(boost::any_cast<string>(m["TomcatVersion"]));
    }
    if (m.find("WorkloadType") != m.end() && !m["WorkloadType"].empty()) {
      workloadType = make_shared<string>(boost::any_cast<string>(m["WorkloadType"]));
    }
  }


  virtual ~GetK8sApplicationResponseBodyApplcationApp() = default;
};
class GetK8sApplicationResponseBodyApplcationConf : public Darabonba::Model {
public:
  shared_ptr<string> affinity{};
  shared_ptr<bool> ahasEnabled{};
  shared_ptr<string> deployAcrossNodes{};
  shared_ptr<string> deployAcrossZones{};
  shared_ptr<string> jarStartArgs{};
  shared_ptr<string> jarStartOptions{};
  shared_ptr<string> k8sCmd{};
  shared_ptr<string> k8sCmdArgs{};
  shared_ptr<string> k8sLocalvolumeInfo{};
  shared_ptr<string> k8sNasInfo{};
  shared_ptr<string> k8sVolumeInfo{};
  shared_ptr<string> liveness{};
  shared_ptr<string> postStart{};
  shared_ptr<string> preStop{};
  shared_ptr<string> readiness{};
  shared_ptr<string> runtimeClassName{};
  shared_ptr<string> tolerations{};
  shared_ptr<string> userBaseImageUrl{};

  GetK8sApplicationResponseBodyApplcationConf() {}

  explicit GetK8sApplicationResponseBodyApplcationConf(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affinity) {
      res["Affinity"] = boost::any(*affinity);
    }
    if (ahasEnabled) {
      res["AhasEnabled"] = boost::any(*ahasEnabled);
    }
    if (deployAcrossNodes) {
      res["DeployAcrossNodes"] = boost::any(*deployAcrossNodes);
    }
    if (deployAcrossZones) {
      res["DeployAcrossZones"] = boost::any(*deployAcrossZones);
    }
    if (jarStartArgs) {
      res["JarStartArgs"] = boost::any(*jarStartArgs);
    }
    if (jarStartOptions) {
      res["JarStartOptions"] = boost::any(*jarStartOptions);
    }
    if (k8sCmd) {
      res["K8sCmd"] = boost::any(*k8sCmd);
    }
    if (k8sCmdArgs) {
      res["K8sCmdArgs"] = boost::any(*k8sCmdArgs);
    }
    if (k8sLocalvolumeInfo) {
      res["K8sLocalvolumeInfo"] = boost::any(*k8sLocalvolumeInfo);
    }
    if (k8sNasInfo) {
      res["K8sNasInfo"] = boost::any(*k8sNasInfo);
    }
    if (k8sVolumeInfo) {
      res["K8sVolumeInfo"] = boost::any(*k8sVolumeInfo);
    }
    if (liveness) {
      res["Liveness"] = boost::any(*liveness);
    }
    if (postStart) {
      res["PostStart"] = boost::any(*postStart);
    }
    if (preStop) {
      res["PreStop"] = boost::any(*preStop);
    }
    if (readiness) {
      res["Readiness"] = boost::any(*readiness);
    }
    if (runtimeClassName) {
      res["RuntimeClassName"] = boost::any(*runtimeClassName);
    }
    if (tolerations) {
      res["Tolerations"] = boost::any(*tolerations);
    }
    if (userBaseImageUrl) {
      res["UserBaseImageUrl"] = boost::any(*userBaseImageUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Affinity") != m.end() && !m["Affinity"].empty()) {
      affinity = make_shared<string>(boost::any_cast<string>(m["Affinity"]));
    }
    if (m.find("AhasEnabled") != m.end() && !m["AhasEnabled"].empty()) {
      ahasEnabled = make_shared<bool>(boost::any_cast<bool>(m["AhasEnabled"]));
    }
    if (m.find("DeployAcrossNodes") != m.end() && !m["DeployAcrossNodes"].empty()) {
      deployAcrossNodes = make_shared<string>(boost::any_cast<string>(m["DeployAcrossNodes"]));
    }
    if (m.find("DeployAcrossZones") != m.end() && !m["DeployAcrossZones"].empty()) {
      deployAcrossZones = make_shared<string>(boost::any_cast<string>(m["DeployAcrossZones"]));
    }
    if (m.find("JarStartArgs") != m.end() && !m["JarStartArgs"].empty()) {
      jarStartArgs = make_shared<string>(boost::any_cast<string>(m["JarStartArgs"]));
    }
    if (m.find("JarStartOptions") != m.end() && !m["JarStartOptions"].empty()) {
      jarStartOptions = make_shared<string>(boost::any_cast<string>(m["JarStartOptions"]));
    }
    if (m.find("K8sCmd") != m.end() && !m["K8sCmd"].empty()) {
      k8sCmd = make_shared<string>(boost::any_cast<string>(m["K8sCmd"]));
    }
    if (m.find("K8sCmdArgs") != m.end() && !m["K8sCmdArgs"].empty()) {
      k8sCmdArgs = make_shared<string>(boost::any_cast<string>(m["K8sCmdArgs"]));
    }
    if (m.find("K8sLocalvolumeInfo") != m.end() && !m["K8sLocalvolumeInfo"].empty()) {
      k8sLocalvolumeInfo = make_shared<string>(boost::any_cast<string>(m["K8sLocalvolumeInfo"]));
    }
    if (m.find("K8sNasInfo") != m.end() && !m["K8sNasInfo"].empty()) {
      k8sNasInfo = make_shared<string>(boost::any_cast<string>(m["K8sNasInfo"]));
    }
    if (m.find("K8sVolumeInfo") != m.end() && !m["K8sVolumeInfo"].empty()) {
      k8sVolumeInfo = make_shared<string>(boost::any_cast<string>(m["K8sVolumeInfo"]));
    }
    if (m.find("Liveness") != m.end() && !m["Liveness"].empty()) {
      liveness = make_shared<string>(boost::any_cast<string>(m["Liveness"]));
    }
    if (m.find("PostStart") != m.end() && !m["PostStart"].empty()) {
      postStart = make_shared<string>(boost::any_cast<string>(m["PostStart"]));
    }
    if (m.find("PreStop") != m.end() && !m["PreStop"].empty()) {
      preStop = make_shared<string>(boost::any_cast<string>(m["PreStop"]));
    }
    if (m.find("Readiness") != m.end() && !m["Readiness"].empty()) {
      readiness = make_shared<string>(boost::any_cast<string>(m["Readiness"]));
    }
    if (m.find("RuntimeClassName") != m.end() && !m["RuntimeClassName"].empty()) {
      runtimeClassName = make_shared<string>(boost::any_cast<string>(m["RuntimeClassName"]));
    }
    if (m.find("Tolerations") != m.end() && !m["Tolerations"].empty()) {
      tolerations = make_shared<string>(boost::any_cast<string>(m["Tolerations"]));
    }
    if (m.find("UserBaseImageUrl") != m.end() && !m["UserBaseImageUrl"].empty()) {
      userBaseImageUrl = make_shared<string>(boost::any_cast<string>(m["UserBaseImageUrl"]));
    }
  }


  virtual ~GetK8sApplicationResponseBodyApplcationConf() = default;
};
class GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents : public Darabonba::Model {
public:
  shared_ptr<string> componentId{};
  shared_ptr<string> componentKey{};
  shared_ptr<string> type{};

  GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents() {}

  explicit GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (componentKey) {
      res["ComponentKey"] = boost::any(*componentKey);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      componentId = make_shared<string>(boost::any_cast<string>(m["ComponentId"]));
    }
    if (m.find("ComponentKey") != m.end() && !m["ComponentKey"].empty()) {
      componentKey = make_shared<string>(boost::any_cast<string>(m["ComponentKey"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents() = default;
};
class GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponents : public Darabonba::Model {
public:
  shared_ptr<vector<GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents>> components{};

  GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponents() {}

  explicit GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (components) {
      vector<boost::any> temp1;
      for(auto item1:*components){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Components"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Components") != m.end() && !m["Components"].empty()) {
      if (typeid(vector<boost::any>) == m["Components"].type()) {
        vector<GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Components"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        components = make_shared<vector<GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents>>(expect1);
      }
    }
  }


  virtual ~GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponents() = default;
};
class GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup : public Darabonba::Model {
public:
  shared_ptr<GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponents> components{};
  shared_ptr<string> env{};
  shared_ptr<string> envFrom{};

  GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup() {}

  explicit GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (components) {
      res["Components"] = components ? boost::any(components->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (envFrom) {
      res["EnvFrom"] = boost::any(*envFrom);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Components") != m.end() && !m["Components"].empty()) {
      if (typeid(map<string, boost::any>) == m["Components"].type()) {
        GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponents model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Components"]));
        components = make_shared<GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponents>(model1);
      }
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("EnvFrom") != m.end() && !m["EnvFrom"].empty()) {
      envFrom = make_shared<string>(boost::any_cast<string>(m["EnvFrom"]));
    }
  }


  virtual ~GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup() = default;
};
class GetK8sApplicationResponseBodyApplcationDeployGroups : public Darabonba::Model {
public:
  shared_ptr<vector<GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup>> deployGroup{};

  GetK8sApplicationResponseBodyApplcationDeployGroups() {}

  explicit GetK8sApplicationResponseBodyApplcationDeployGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployGroup) {
      vector<boost::any> temp1;
      for(auto item1:*deployGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeployGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployGroup") != m.end() && !m["DeployGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["DeployGroup"].type()) {
        vector<GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeployGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deployGroup = make_shared<vector<GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup>>(expect1);
      }
    }
  }


  virtual ~GetK8sApplicationResponseBodyApplcationDeployGroups() = default;
};
class GetK8sApplicationResponseBodyApplcationImageInfo : public Darabonba::Model {
public:
  shared_ptr<string> imageUrl{};
  shared_ptr<string> regionId{};
  shared_ptr<string> repoId{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<string> repoOriginType{};
  shared_ptr<string> tag{};

  GetK8sApplicationResponseBodyApplcationImageInfo() {}

  explicit GetK8sApplicationResponseBodyApplcationImageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (repoOriginType) {
      res["RepoOriginType"] = boost::any(*repoOriginType);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("RepoOriginType") != m.end() && !m["RepoOriginType"].empty()) {
      repoOriginType = make_shared<string>(boost::any_cast<string>(m["RepoOriginType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~GetK8sApplicationResponseBodyApplcationImageInfo() = default;
};
class GetK8sApplicationResponseBodyApplcationLatestVersion : public Darabonba::Model {
public:
  shared_ptr<string> packageVersion{};
  shared_ptr<string> url{};
  shared_ptr<string> warUrl{};

  GetK8sApplicationResponseBodyApplcationLatestVersion() {}

  explicit GetK8sApplicationResponseBodyApplcationLatestVersion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (warUrl) {
      res["WarUrl"] = boost::any(*warUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("WarUrl") != m.end() && !m["WarUrl"].empty()) {
      warUrl = make_shared<string>(boost::any_cast<string>(m["WarUrl"]));
    }
  }


  virtual ~GetK8sApplicationResponseBodyApplcationLatestVersion() = default;
};
class GetK8sApplicationResponseBodyApplcation : public Darabonba::Model {
public:
  shared_ptr<GetK8sApplicationResponseBodyApplcationApp> app{};
  shared_ptr<string> appId{};
  shared_ptr<GetK8sApplicationResponseBodyApplcationConf> conf{};
  shared_ptr<GetK8sApplicationResponseBodyApplcationDeployGroups> deployGroups{};
  shared_ptr<GetK8sApplicationResponseBodyApplcationImageInfo> imageInfo{};
  shared_ptr<GetK8sApplicationResponseBodyApplcationLatestVersion> latestVersion{};

  GetK8sApplicationResponseBodyApplcation() {}

  explicit GetK8sApplicationResponseBodyApplcation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = app ? boost::any(app->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (conf) {
      res["Conf"] = conf ? boost::any(conf->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deployGroups) {
      res["DeployGroups"] = deployGroups ? boost::any(deployGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageInfo) {
      res["ImageInfo"] = imageInfo ? boost::any(imageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (latestVersion) {
      res["LatestVersion"] = latestVersion ? boost::any(latestVersion->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      if (typeid(map<string, boost::any>) == m["App"].type()) {
        GetK8sApplicationResponseBodyApplcationApp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["App"]));
        app = make_shared<GetK8sApplicationResponseBodyApplcationApp>(model1);
      }
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Conf") != m.end() && !m["Conf"].empty()) {
      if (typeid(map<string, boost::any>) == m["Conf"].type()) {
        GetK8sApplicationResponseBodyApplcationConf model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Conf"]));
        conf = make_shared<GetK8sApplicationResponseBodyApplcationConf>(model1);
      }
    }
    if (m.find("DeployGroups") != m.end() && !m["DeployGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeployGroups"].type()) {
        GetK8sApplicationResponseBodyApplcationDeployGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeployGroups"]));
        deployGroups = make_shared<GetK8sApplicationResponseBodyApplcationDeployGroups>(model1);
      }
    }
    if (m.find("ImageInfo") != m.end() && !m["ImageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageInfo"].type()) {
        GetK8sApplicationResponseBodyApplcationImageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageInfo"]));
        imageInfo = make_shared<GetK8sApplicationResponseBodyApplcationImageInfo>(model1);
      }
    }
    if (m.find("LatestVersion") != m.end() && !m["LatestVersion"].empty()) {
      if (typeid(map<string, boost::any>) == m["LatestVersion"].type()) {
        GetK8sApplicationResponseBodyApplcationLatestVersion model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LatestVersion"]));
        latestVersion = make_shared<GetK8sApplicationResponseBodyApplcationLatestVersion>(model1);
      }
    }
  }


  virtual ~GetK8sApplicationResponseBodyApplcation() = default;
};
class GetK8sApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetK8sApplicationResponseBodyApplcation> applcation{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetK8sApplicationResponseBody() {}

  explicit GetK8sApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applcation) {
      res["Applcation"] = applcation ? boost::any(applcation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Applcation") != m.end() && !m["Applcation"].empty()) {
      if (typeid(map<string, boost::any>) == m["Applcation"].type()) {
        GetK8sApplicationResponseBodyApplcation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Applcation"]));
        applcation = make_shared<GetK8sApplicationResponseBodyApplcation>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetK8sApplicationResponseBody() = default;
};
class GetK8sApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetK8sApplicationResponseBody> body{};

  GetK8sApplicationResponse() {}

  explicit GetK8sApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetK8sApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetK8sApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~GetK8sApplicationResponse() = default;
};
class GetK8sClusterRequest : public Darabonba::Model {
public:
  shared_ptr<long> clusterType{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionTag{};
  shared_ptr<string> subClusterType{};

  GetK8sClusterRequest() {}

  explicit GetK8sClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionTag) {
      res["RegionTag"] = boost::any(*regionTag);
    }
    if (subClusterType) {
      res["SubClusterType"] = boost::any(*subClusterType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<long>(boost::any_cast<long>(m["ClusterType"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionTag") != m.end() && !m["RegionTag"].empty()) {
      regionTag = make_shared<string>(boost::any_cast<string>(m["RegionTag"]));
    }
    if (m.find("SubClusterType") != m.end() && !m["SubClusterType"].empty()) {
      subClusterType = make_shared<string>(boost::any_cast<string>(m["SubClusterType"]));
    }
  }


  virtual ~GetK8sClusterRequest() = default;
};
class GetK8sClusterResponseBodyClusterPageClusterListCluster : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> clusterImportStatus{};
  shared_ptr<string> clusterName{};
  shared_ptr<long> clusterStatus{};
  shared_ptr<long> clusterType{};
  shared_ptr<long> cpu{};
  shared_ptr<string> csClusterId{};
  shared_ptr<string> csClusterStatus{};
  shared_ptr<string> description{};
  shared_ptr<long> mem{};
  shared_ptr<long> networkMode{};
  shared_ptr<long> nodeNum{};
  shared_ptr<string> regionId{};
  shared_ptr<string> subClusterType{};
  shared_ptr<string> subNetCidr{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vswitchId{};

  GetK8sClusterResponseBodyClusterPageClusterListCluster() {}

  explicit GetK8sClusterResponseBodyClusterPageClusterListCluster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterImportStatus) {
      res["ClusterImportStatus"] = boost::any(*clusterImportStatus);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterStatus) {
      res["ClusterStatus"] = boost::any(*clusterStatus);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (csClusterId) {
      res["CsClusterId"] = boost::any(*csClusterId);
    }
    if (csClusterStatus) {
      res["CsClusterStatus"] = boost::any(*csClusterStatus);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (networkMode) {
      res["NetworkMode"] = boost::any(*networkMode);
    }
    if (nodeNum) {
      res["NodeNum"] = boost::any(*nodeNum);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (subClusterType) {
      res["SubClusterType"] = boost::any(*subClusterType);
    }
    if (subNetCidr) {
      res["SubNetCidr"] = boost::any(*subNetCidr);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterImportStatus") != m.end() && !m["ClusterImportStatus"].empty()) {
      clusterImportStatus = make_shared<long>(boost::any_cast<long>(m["ClusterImportStatus"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterStatus") != m.end() && !m["ClusterStatus"].empty()) {
      clusterStatus = make_shared<long>(boost::any_cast<long>(m["ClusterStatus"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<long>(boost::any_cast<long>(m["ClusterType"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CsClusterId") != m.end() && !m["CsClusterId"].empty()) {
      csClusterId = make_shared<string>(boost::any_cast<string>(m["CsClusterId"]));
    }
    if (m.find("CsClusterStatus") != m.end() && !m["CsClusterStatus"].empty()) {
      csClusterStatus = make_shared<string>(boost::any_cast<string>(m["CsClusterStatus"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("NetworkMode") != m.end() && !m["NetworkMode"].empty()) {
      networkMode = make_shared<long>(boost::any_cast<long>(m["NetworkMode"]));
    }
    if (m.find("NodeNum") != m.end() && !m["NodeNum"].empty()) {
      nodeNum = make_shared<long>(boost::any_cast<long>(m["NodeNum"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SubClusterType") != m.end() && !m["SubClusterType"].empty()) {
      subClusterType = make_shared<string>(boost::any_cast<string>(m["SubClusterType"]));
    }
    if (m.find("SubNetCidr") != m.end() && !m["SubNetCidr"].empty()) {
      subNetCidr = make_shared<string>(boost::any_cast<string>(m["SubNetCidr"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~GetK8sClusterResponseBodyClusterPageClusterListCluster() = default;
};
class GetK8sClusterResponseBodyClusterPageClusterList : public Darabonba::Model {
public:
  shared_ptr<vector<GetK8sClusterResponseBodyClusterPageClusterListCluster>> cluster{};

  GetK8sClusterResponseBodyClusterPageClusterList() {}

  explicit GetK8sClusterResponseBodyClusterPageClusterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cluster) {
      vector<boost::any> temp1;
      for(auto item1:*cluster){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Cluster"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cluster") != m.end() && !m["Cluster"].empty()) {
      if (typeid(vector<boost::any>) == m["Cluster"].type()) {
        vector<GetK8sClusterResponseBodyClusterPageClusterListCluster> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Cluster"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetK8sClusterResponseBodyClusterPageClusterListCluster model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cluster = make_shared<vector<GetK8sClusterResponseBodyClusterPageClusterListCluster>>(expect1);
      }
    }
  }


  virtual ~GetK8sClusterResponseBodyClusterPageClusterList() = default;
};
class GetK8sClusterResponseBodyClusterPage : public Darabonba::Model {
public:
  shared_ptr<GetK8sClusterResponseBodyClusterPageClusterList> clusterList{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalSize{};

  GetK8sClusterResponseBodyClusterPage() {}

  explicit GetK8sClusterResponseBodyClusterPage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterList) {
      res["ClusterList"] = clusterList ? boost::any(clusterList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterList") != m.end() && !m["ClusterList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterList"].type()) {
        GetK8sClusterResponseBodyClusterPageClusterList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterList"]));
        clusterList = make_shared<GetK8sClusterResponseBodyClusterPageClusterList>(model1);
      }
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~GetK8sClusterResponseBodyClusterPage() = default;
};
class GetK8sClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetK8sClusterResponseBodyClusterPage> clusterPage{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetK8sClusterResponseBody() {}

  explicit GetK8sClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterPage) {
      res["ClusterPage"] = clusterPage ? boost::any(clusterPage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterPage") != m.end() && !m["ClusterPage"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterPage"].type()) {
        GetK8sClusterResponseBodyClusterPage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterPage"]));
        clusterPage = make_shared<GetK8sClusterResponseBodyClusterPage>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetK8sClusterResponseBody() = default;
};
class GetK8sClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetK8sClusterResponseBody> body{};

  GetK8sClusterResponse() {}

  explicit GetK8sClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetK8sClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetK8sClusterResponseBody>(model1);
      }
    }
  }


  virtual ~GetK8sClusterResponse() = default;
};
class GetK8sServicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  GetK8sServicesRequest() {}

  explicit GetK8sServicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~GetK8sServicesRequest() = default;
};
class GetK8sServicesResponseBodyServicesServicePorts : public Darabonba::Model {
public:
  shared_ptr<long> nodePort{};
  shared_ptr<long> port{};
  shared_ptr<string> protocol{};
  shared_ptr<string> targetPort{};

  GetK8sServicesResponseBodyServicesServicePorts() {}

  explicit GetK8sServicesResponseBodyServicesServicePorts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodePort) {
      res["NodePort"] = boost::any(*nodePort);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (targetPort) {
      res["TargetPort"] = boost::any(*targetPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodePort") != m.end() && !m["NodePort"].empty()) {
      nodePort = make_shared<long>(boost::any_cast<long>(m["NodePort"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("TargetPort") != m.end() && !m["TargetPort"].empty()) {
      targetPort = make_shared<string>(boost::any_cast<string>(m["TargetPort"]));
    }
  }


  virtual ~GetK8sServicesResponseBodyServicesServicePorts() = default;
};
class GetK8sServicesResponseBodyServices : public Darabonba::Model {
public:
  shared_ptr<string> clusterIP{};
  shared_ptr<string> name{};
  shared_ptr<vector<GetK8sServicesResponseBodyServicesServicePorts>> servicePorts{};
  shared_ptr<string> type{};

  GetK8sServicesResponseBodyServices() {}

  explicit GetK8sServicesResponseBodyServices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterIP) {
      res["ClusterIP"] = boost::any(*clusterIP);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (servicePorts) {
      vector<boost::any> temp1;
      for(auto item1:*servicePorts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServicePorts"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterIP") != m.end() && !m["ClusterIP"].empty()) {
      clusterIP = make_shared<string>(boost::any_cast<string>(m["ClusterIP"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ServicePorts") != m.end() && !m["ServicePorts"].empty()) {
      if (typeid(vector<boost::any>) == m["ServicePorts"].type()) {
        vector<GetK8sServicesResponseBodyServicesServicePorts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServicePorts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetK8sServicesResponseBodyServicesServicePorts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        servicePorts = make_shared<vector<GetK8sServicesResponseBodyServicesServicePorts>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetK8sServicesResponseBodyServices() = default;
};
class GetK8sServicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetK8sServicesResponseBodyServices>> services{};

  GetK8sServicesResponseBody() {}

  explicit GetK8sServicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (services) {
      vector<boost::any> temp1;
      for(auto item1:*services){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Services"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Services") != m.end() && !m["Services"].empty()) {
      if (typeid(vector<boost::any>) == m["Services"].type()) {
        vector<GetK8sServicesResponseBodyServices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Services"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetK8sServicesResponseBodyServices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        services = make_shared<vector<GetK8sServicesResponseBodyServices>>(expect1);
      }
    }
  }


  virtual ~GetK8sServicesResponseBody() = default;
};
class GetK8sServicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetK8sServicesResponseBody> body{};

  GetK8sServicesResponse() {}

  explicit GetK8sServicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetK8sServicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetK8sServicesResponseBody>(model1);
      }
    }
  }


  virtual ~GetK8sServicesResponse() = default;
};
class GetPackageStorageCredentialResponseBodyCredential : public Darabonba::Model {
public:
  shared_ptr<string> accessKeyId{};
  shared_ptr<string> accessKeySecret{};
  shared_ptr<string> bucket{};
  shared_ptr<string> expiration{};
  shared_ptr<string> keyPrefix{};
  shared_ptr<string> ossInternalEndpoint{};
  shared_ptr<string> ossPublicEndpoint{};
  shared_ptr<string> ossVpcEndpoint{};
  shared_ptr<string> regionId{};
  shared_ptr<string> securityToken{};

  GetPackageStorageCredentialResponseBodyCredential() {}

  explicit GetPackageStorageCredentialResponseBodyCredential(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKeyId) {
      res["AccessKeyId"] = boost::any(*accessKeyId);
    }
    if (accessKeySecret) {
      res["AccessKeySecret"] = boost::any(*accessKeySecret);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (expiration) {
      res["Expiration"] = boost::any(*expiration);
    }
    if (keyPrefix) {
      res["KeyPrefix"] = boost::any(*keyPrefix);
    }
    if (ossInternalEndpoint) {
      res["OssInternalEndpoint"] = boost::any(*ossInternalEndpoint);
    }
    if (ossPublicEndpoint) {
      res["OssPublicEndpoint"] = boost::any(*ossPublicEndpoint);
    }
    if (ossVpcEndpoint) {
      res["OssVpcEndpoint"] = boost::any(*ossVpcEndpoint);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKeyId") != m.end() && !m["AccessKeyId"].empty()) {
      accessKeyId = make_shared<string>(boost::any_cast<string>(m["AccessKeyId"]));
    }
    if (m.find("AccessKeySecret") != m.end() && !m["AccessKeySecret"].empty()) {
      accessKeySecret = make_shared<string>(boost::any_cast<string>(m["AccessKeySecret"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Expiration") != m.end() && !m["Expiration"].empty()) {
      expiration = make_shared<string>(boost::any_cast<string>(m["Expiration"]));
    }
    if (m.find("KeyPrefix") != m.end() && !m["KeyPrefix"].empty()) {
      keyPrefix = make_shared<string>(boost::any_cast<string>(m["KeyPrefix"]));
    }
    if (m.find("OssInternalEndpoint") != m.end() && !m["OssInternalEndpoint"].empty()) {
      ossInternalEndpoint = make_shared<string>(boost::any_cast<string>(m["OssInternalEndpoint"]));
    }
    if (m.find("OssPublicEndpoint") != m.end() && !m["OssPublicEndpoint"].empty()) {
      ossPublicEndpoint = make_shared<string>(boost::any_cast<string>(m["OssPublicEndpoint"]));
    }
    if (m.find("OssVpcEndpoint") != m.end() && !m["OssVpcEndpoint"].empty()) {
      ossVpcEndpoint = make_shared<string>(boost::any_cast<string>(m["OssVpcEndpoint"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~GetPackageStorageCredentialResponseBodyCredential() = default;
};
class GetPackageStorageCredentialResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetPackageStorageCredentialResponseBodyCredential> credential{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetPackageStorageCredentialResponseBody() {}

  explicit GetPackageStorageCredentialResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (credential) {
      res["Credential"] = credential ? boost::any(credential->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Credential") != m.end() && !m["Credential"].empty()) {
      if (typeid(map<string, boost::any>) == m["Credential"].type()) {
        GetPackageStorageCredentialResponseBodyCredential model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Credential"]));
        credential = make_shared<GetPackageStorageCredentialResponseBodyCredential>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPackageStorageCredentialResponseBody() = default;
};
class GetPackageStorageCredentialResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPackageStorageCredentialResponseBody> body{};

  GetPackageStorageCredentialResponse() {}

  explicit GetPackageStorageCredentialResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPackageStorageCredentialResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPackageStorageCredentialResponseBody>(model1);
      }
    }
  }


  virtual ~GetPackageStorageCredentialResponse() = default;
};
class GetScalingRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> mode{};

  GetScalingRulesRequest() {}

  explicit GetScalingRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
  }


  virtual ~GetScalingRulesRequest() = default;
};
class GetScalingRulesResponseBodyDataRuleListRule : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> cond{};
  shared_ptr<long> cpu{};
  shared_ptr<long> createTime{};
  shared_ptr<long> duration{};
  shared_ptr<bool> enable{};
  shared_ptr<string> groupId{};
  shared_ptr<long> instNum{};
  shared_ptr<long> loadNum{};
  shared_ptr<string> metricType{};
  shared_ptr<string> mode{};
  shared_ptr<string> multiAzPolicy{};
  shared_ptr<string> resourceFrom{};
  shared_ptr<long> rt{};
  shared_ptr<string> specId{};
  shared_ptr<long> step{};
  shared_ptr<string> templateId{};
  shared_ptr<long> templateVersion{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> vSwitchIds{};
  shared_ptr<string> vpcId{};

  GetScalingRulesResponseBodyDataRuleListRule() {}

  explicit GetScalingRulesResponseBodyDataRuleListRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (cond) {
      res["Cond"] = boost::any(*cond);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instNum) {
      res["InstNum"] = boost::any(*instNum);
    }
    if (loadNum) {
      res["LoadNum"] = boost::any(*loadNum);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (multiAzPolicy) {
      res["MultiAzPolicy"] = boost::any(*multiAzPolicy);
    }
    if (resourceFrom) {
      res["ResourceFrom"] = boost::any(*resourceFrom);
    }
    if (rt) {
      res["Rt"] = boost::any(*rt);
    }
    if (specId) {
      res["SpecId"] = boost::any(*specId);
    }
    if (step) {
      res["Step"] = boost::any(*step);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateVersion) {
      res["TemplateVersion"] = boost::any(*templateVersion);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = boost::any(*vSwitchIds);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Cond") != m.end() && !m["Cond"].empty()) {
      cond = make_shared<string>(boost::any_cast<string>(m["Cond"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("InstNum") != m.end() && !m["InstNum"].empty()) {
      instNum = make_shared<long>(boost::any_cast<long>(m["InstNum"]));
    }
    if (m.find("LoadNum") != m.end() && !m["LoadNum"].empty()) {
      loadNum = make_shared<long>(boost::any_cast<long>(m["LoadNum"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("MultiAzPolicy") != m.end() && !m["MultiAzPolicy"].empty()) {
      multiAzPolicy = make_shared<string>(boost::any_cast<string>(m["MultiAzPolicy"]));
    }
    if (m.find("ResourceFrom") != m.end() && !m["ResourceFrom"].empty()) {
      resourceFrom = make_shared<string>(boost::any_cast<string>(m["ResourceFrom"]));
    }
    if (m.find("Rt") != m.end() && !m["Rt"].empty()) {
      rt = make_shared<long>(boost::any_cast<long>(m["Rt"]));
    }
    if (m.find("SpecId") != m.end() && !m["SpecId"].empty()) {
      specId = make_shared<string>(boost::any_cast<string>(m["SpecId"]));
    }
    if (m.find("Step") != m.end() && !m["Step"].empty()) {
      step = make_shared<long>(boost::any_cast<long>(m["Step"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateVersion") != m.end() && !m["TemplateVersion"].empty()) {
      templateVersion = make_shared<long>(boost::any_cast<long>(m["TemplateVersion"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      vSwitchIds = make_shared<string>(boost::any_cast<string>(m["VSwitchIds"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~GetScalingRulesResponseBodyDataRuleListRule() = default;
};
class GetScalingRulesResponseBodyDataRuleList : public Darabonba::Model {
public:
  shared_ptr<vector<GetScalingRulesResponseBodyDataRuleListRule>> rule{};

  GetScalingRulesResponseBodyDataRuleList() {}

  explicit GetScalingRulesResponseBodyDataRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rule) {
      vector<boost::any> temp1;
      for(auto item1:*rule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(vector<boost::any>) == m["Rule"].type()) {
        vector<GetScalingRulesResponseBodyDataRuleListRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetScalingRulesResponseBodyDataRuleListRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rule = make_shared<vector<GetScalingRulesResponseBodyDataRuleListRule>>(expect1);
      }
    }
  }


  virtual ~GetScalingRulesResponseBodyDataRuleList() = default;
};
class GetScalingRulesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> clusterType{};
  shared_ptr<long> oversoldFactor{};
  shared_ptr<GetScalingRulesResponseBodyDataRuleList> ruleList{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> vpcId{};

  GetScalingRulesResponseBodyData() {}

  explicit GetScalingRulesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (oversoldFactor) {
      res["OversoldFactor"] = boost::any(*oversoldFactor);
    }
    if (ruleList) {
      res["RuleList"] = ruleList ? boost::any(ruleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<long>(boost::any_cast<long>(m["ClusterType"]));
    }
    if (m.find("OversoldFactor") != m.end() && !m["OversoldFactor"].empty()) {
      oversoldFactor = make_shared<long>(boost::any_cast<long>(m["OversoldFactor"]));
    }
    if (m.find("RuleList") != m.end() && !m["RuleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleList"].type()) {
        GetScalingRulesResponseBodyDataRuleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleList"]));
        ruleList = make_shared<GetScalingRulesResponseBodyDataRuleList>(model1);
      }
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~GetScalingRulesResponseBodyData() = default;
};
class GetScalingRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetScalingRulesResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> updateTime{};

  GetScalingRulesResponseBody() {}

  explicit GetScalingRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetScalingRulesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetScalingRulesResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~GetScalingRulesResponseBody() = default;
};
class GetScalingRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetScalingRulesResponseBody> body{};

  GetScalingRulesResponse() {}

  explicit GetScalingRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetScalingRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetScalingRulesResponseBody>(model1);
      }
    }
  }


  virtual ~GetScalingRulesResponse() = default;
};
class GetSecureTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};

  GetSecureTokenRequest() {}

  explicit GetSecureTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~GetSecureTokenRequest() = default;
};
class GetSecureTokenResponseBodySecureToken : public Darabonba::Model {
public:
  shared_ptr<string> accessKey{};
  shared_ptr<string> addressServerHost{};
  shared_ptr<string> belongRegion{};
  shared_ptr<string> description{};
  shared_ptr<string> edasId{};
  shared_ptr<long> id{};
  shared_ptr<string> mseInstanceId{};
  shared_ptr<string> mseInternetAddress{};
  shared_ptr<string> mseIntranetAddress{};
  shared_ptr<string> mseRegistryType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> regionName{};
  shared_ptr<string> secretKey{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> userId{};

  GetSecureTokenResponseBodySecureToken() {}

  explicit GetSecureTokenResponseBodySecureToken(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKey) {
      res["AccessKey"] = boost::any(*accessKey);
    }
    if (addressServerHost) {
      res["AddressServerHost"] = boost::any(*addressServerHost);
    }
    if (belongRegion) {
      res["BelongRegion"] = boost::any(*belongRegion);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (edasId) {
      res["EdasId"] = boost::any(*edasId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mseInstanceId) {
      res["MseInstanceId"] = boost::any(*mseInstanceId);
    }
    if (mseInternetAddress) {
      res["MseInternetAddress"] = boost::any(*mseInternetAddress);
    }
    if (mseIntranetAddress) {
      res["MseIntranetAddress"] = boost::any(*mseIntranetAddress);
    }
    if (mseRegistryType) {
      res["MseRegistryType"] = boost::any(*mseRegistryType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (secretKey) {
      res["SecretKey"] = boost::any(*secretKey);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKey") != m.end() && !m["AccessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["AccessKey"]));
    }
    if (m.find("AddressServerHost") != m.end() && !m["AddressServerHost"].empty()) {
      addressServerHost = make_shared<string>(boost::any_cast<string>(m["AddressServerHost"]));
    }
    if (m.find("BelongRegion") != m.end() && !m["BelongRegion"].empty()) {
      belongRegion = make_shared<string>(boost::any_cast<string>(m["BelongRegion"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EdasId") != m.end() && !m["EdasId"].empty()) {
      edasId = make_shared<string>(boost::any_cast<string>(m["EdasId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MseInstanceId") != m.end() && !m["MseInstanceId"].empty()) {
      mseInstanceId = make_shared<string>(boost::any_cast<string>(m["MseInstanceId"]));
    }
    if (m.find("MseInternetAddress") != m.end() && !m["MseInternetAddress"].empty()) {
      mseInternetAddress = make_shared<string>(boost::any_cast<string>(m["MseInternetAddress"]));
    }
    if (m.find("MseIntranetAddress") != m.end() && !m["MseIntranetAddress"].empty()) {
      mseIntranetAddress = make_shared<string>(boost::any_cast<string>(m["MseIntranetAddress"]));
    }
    if (m.find("MseRegistryType") != m.end() && !m["MseRegistryType"].empty()) {
      mseRegistryType = make_shared<string>(boost::any_cast<string>(m["MseRegistryType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("SecretKey") != m.end() && !m["SecretKey"].empty()) {
      secretKey = make_shared<string>(boost::any_cast<string>(m["SecretKey"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetSecureTokenResponseBodySecureToken() = default;
};
class GetSecureTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<GetSecureTokenResponseBodySecureToken> secureToken{};

  GetSecureTokenResponseBody() {}

  explicit GetSecureTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (secureToken) {
      res["SecureToken"] = secureToken ? boost::any(secureToken->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecureToken") != m.end() && !m["SecureToken"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecureToken"].type()) {
        GetSecureTokenResponseBodySecureToken model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecureToken"]));
        secureToken = make_shared<GetSecureTokenResponseBodySecureToken>(model1);
      }
    }
  }


  virtual ~GetSecureTokenResponseBody() = default;
};
class GetSecureTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSecureTokenResponseBody> body{};

  GetSecureTokenResponse() {}

  explicit GetSecureTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSecureTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSecureTokenResponseBody>(model1);
      }
    }
  }


  virtual ~GetSecureTokenResponse() = default;
};
class GetServiceConsumersPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> group{};
  shared_ptr<string> ip{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> origin{};
  shared_ptr<long> page{};
  shared_ptr<string> region{};
  shared_ptr<string> registryType{};
  shared_ptr<string> serviceId{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> serviceVersion{};
  shared_ptr<long> size{};
  shared_ptr<string> source{};

  GetServiceConsumersPageRequest() {}

  explicit GetServiceConsumersPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["appId"] = boost::any(*appId);
    }
    if (group) {
      res["group"] = boost::any(*group);
    }
    if (ip) {
      res["ip"] = boost::any(*ip);
    }
    if (namespace_) {
      res["namespace"] = boost::any(*namespace_);
    }
    if (origin) {
      res["origin"] = boost::any(*origin);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (region) {
      res["region"] = boost::any(*region);
    }
    if (registryType) {
      res["registryType"] = boost::any(*registryType);
    }
    if (serviceId) {
      res["serviceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    if (serviceType) {
      res["serviceType"] = boost::any(*serviceType);
    }
    if (serviceVersion) {
      res["serviceVersion"] = boost::any(*serviceVersion);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("appId") != m.end() && !m["appId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["appId"]));
    }
    if (m.find("group") != m.end() && !m["group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["group"]));
    }
    if (m.find("ip") != m.end() && !m["ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["ip"]));
    }
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["namespace"]));
    }
    if (m.find("origin") != m.end() && !m["origin"].empty()) {
      origin = make_shared<string>(boost::any_cast<string>(m["origin"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("region") != m.end() && !m["region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["region"]));
    }
    if (m.find("registryType") != m.end() && !m["registryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["registryType"]));
    }
    if (m.find("serviceId") != m.end() && !m["serviceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["serviceId"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
    if (m.find("serviceType") != m.end() && !m["serviceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["serviceType"]));
    }
    if (m.find("serviceVersion") != m.end() && !m["serviceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["serviceVersion"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
  }


  virtual ~GetServiceConsumersPageRequest() = default;
};
class GetServiceConsumersPageResponseBodyDataContent : public Darabonba::Model {
public:
  shared_ptr<string> edasAppName{};
  shared_ptr<string> edassAppId{};
  shared_ptr<string> ip{};

  GetServiceConsumersPageResponseBodyDataContent() {}

  explicit GetServiceConsumersPageResponseBodyDataContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edasAppName) {
      res["EdasAppName"] = boost::any(*edasAppName);
    }
    if (edassAppId) {
      res["EdassAppId"] = boost::any(*edassAppId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EdasAppName") != m.end() && !m["EdasAppName"].empty()) {
      edasAppName = make_shared<string>(boost::any_cast<string>(m["EdasAppName"]));
    }
    if (m.find("EdassAppId") != m.end() && !m["EdassAppId"].empty()) {
      edassAppId = make_shared<string>(boost::any_cast<string>(m["EdassAppId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
  }


  virtual ~GetServiceConsumersPageResponseBodyDataContent() = default;
};
class GetServiceConsumersPageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetServiceConsumersPageResponseBodyDataContent>> content{};
  shared_ptr<long> size{};
  shared_ptr<long> totalElements{};
  shared_ptr<long> totalPages{};

  GetServiceConsumersPageResponseBodyData() {}

  explicit GetServiceConsumersPageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      vector<boost::any> temp1;
      for(auto item1:*content){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Content"] = boost::any(temp1);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (totalElements) {
      res["TotalElements"] = boost::any(*totalElements);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(vector<boost::any>) == m["Content"].type()) {
        vector<GetServiceConsumersPageResponseBodyDataContent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Content"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceConsumersPageResponseBodyDataContent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        content = make_shared<vector<GetServiceConsumersPageResponseBodyDataContent>>(expect1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TotalElements") != m.end() && !m["TotalElements"].empty()) {
      totalElements = make_shared<long>(boost::any_cast<long>(m["TotalElements"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~GetServiceConsumersPageResponseBodyData() = default;
};
class GetServiceConsumersPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetServiceConsumersPageResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  GetServiceConsumersPageResponseBody() {}

  explicit GetServiceConsumersPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetServiceConsumersPageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetServiceConsumersPageResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetServiceConsumersPageResponseBody() = default;
};
class GetServiceConsumersPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetServiceConsumersPageResponseBody> body{};

  GetServiceConsumersPageResponse() {}

  explicit GetServiceConsumersPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetServiceConsumersPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetServiceConsumersPageResponseBody>(model1);
      }
    }
  }


  virtual ~GetServiceConsumersPageResponse() = default;
};
class GetServiceDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> group{};
  shared_ptr<string> ip{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> origin{};
  shared_ptr<string> region{};
  shared_ptr<string> registryType{};
  shared_ptr<string> serviceId{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> serviceVersion{};
  shared_ptr<string> source{};

  GetServiceDetailRequest() {}

  explicit GetServiceDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["appId"] = boost::any(*appId);
    }
    if (group) {
      res["group"] = boost::any(*group);
    }
    if (ip) {
      res["ip"] = boost::any(*ip);
    }
    if (namespace_) {
      res["namespace"] = boost::any(*namespace_);
    }
    if (origin) {
      res["origin"] = boost::any(*origin);
    }
    if (region) {
      res["region"] = boost::any(*region);
    }
    if (registryType) {
      res["registryType"] = boost::any(*registryType);
    }
    if (serviceId) {
      res["serviceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    if (serviceType) {
      res["serviceType"] = boost::any(*serviceType);
    }
    if (serviceVersion) {
      res["serviceVersion"] = boost::any(*serviceVersion);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("appId") != m.end() && !m["appId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["appId"]));
    }
    if (m.find("group") != m.end() && !m["group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["group"]));
    }
    if (m.find("ip") != m.end() && !m["ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["ip"]));
    }
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["namespace"]));
    }
    if (m.find("origin") != m.end() && !m["origin"].empty()) {
      origin = make_shared<string>(boost::any_cast<string>(m["origin"]));
    }
    if (m.find("region") != m.end() && !m["region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["region"]));
    }
    if (m.find("registryType") != m.end() && !m["registryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["registryType"]));
    }
    if (m.find("serviceId") != m.end() && !m["serviceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["serviceId"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
    if (m.find("serviceType") != m.end() && !m["serviceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["serviceType"]));
    }
    if (m.find("serviceVersion") != m.end() && !m["serviceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["serviceVersion"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
  }


  virtual ~GetServiceDetailRequest() = default;
};
class GetServiceDetailResponseBodyDataMethodsReturnDefinition : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> type{};

  GetServiceDetailResponseBodyDataMethodsReturnDefinition() {}

  explicit GetServiceDetailResponseBodyDataMethodsReturnDefinition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetServiceDetailResponseBodyDataMethodsReturnDefinition() = default;
};
class GetServiceDetailResponseBodyDataMethods : public Darabonba::Model {
public:
  shared_ptr<string> methodController{};
  shared_ptr<string> name{};
  shared_ptr<string> nameDetail{};
  shared_ptr<string> parameterDefinitions{};
  shared_ptr<string> parameterDetails{};
  shared_ptr<string> parameterNames{};
  shared_ptr<string> parameterTypes{};
  shared_ptr<string> paths{};
  shared_ptr<string> requestMethods{};
  shared_ptr<GetServiceDetailResponseBodyDataMethodsReturnDefinition> returnDefinition{};
  shared_ptr<string> returnDetails{};
  shared_ptr<string> returnType{};

  GetServiceDetailResponseBodyDataMethods() {}

  explicit GetServiceDetailResponseBodyDataMethods(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (methodController) {
      res["MethodController"] = boost::any(*methodController);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nameDetail) {
      res["NameDetail"] = boost::any(*nameDetail);
    }
    if (parameterDefinitions) {
      res["ParameterDefinitions"] = boost::any(*parameterDefinitions);
    }
    if (parameterDetails) {
      res["ParameterDetails"] = boost::any(*parameterDetails);
    }
    if (parameterNames) {
      res["ParameterNames"] = boost::any(*parameterNames);
    }
    if (parameterTypes) {
      res["ParameterTypes"] = boost::any(*parameterTypes);
    }
    if (paths) {
      res["Paths"] = boost::any(*paths);
    }
    if (requestMethods) {
      res["RequestMethods"] = boost::any(*requestMethods);
    }
    if (returnDefinition) {
      res["ReturnDefinition"] = returnDefinition ? boost::any(returnDefinition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (returnDetails) {
      res["ReturnDetails"] = boost::any(*returnDetails);
    }
    if (returnType) {
      res["ReturnType"] = boost::any(*returnType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MethodController") != m.end() && !m["MethodController"].empty()) {
      methodController = make_shared<string>(boost::any_cast<string>(m["MethodController"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NameDetail") != m.end() && !m["NameDetail"].empty()) {
      nameDetail = make_shared<string>(boost::any_cast<string>(m["NameDetail"]));
    }
    if (m.find("ParameterDefinitions") != m.end() && !m["ParameterDefinitions"].empty()) {
      parameterDefinitions = make_shared<string>(boost::any_cast<string>(m["ParameterDefinitions"]));
    }
    if (m.find("ParameterDetails") != m.end() && !m["ParameterDetails"].empty()) {
      parameterDetails = make_shared<string>(boost::any_cast<string>(m["ParameterDetails"]));
    }
    if (m.find("ParameterNames") != m.end() && !m["ParameterNames"].empty()) {
      parameterNames = make_shared<string>(boost::any_cast<string>(m["ParameterNames"]));
    }
    if (m.find("ParameterTypes") != m.end() && !m["ParameterTypes"].empty()) {
      parameterTypes = make_shared<string>(boost::any_cast<string>(m["ParameterTypes"]));
    }
    if (m.find("Paths") != m.end() && !m["Paths"].empty()) {
      paths = make_shared<string>(boost::any_cast<string>(m["Paths"]));
    }
    if (m.find("RequestMethods") != m.end() && !m["RequestMethods"].empty()) {
      requestMethods = make_shared<string>(boost::any_cast<string>(m["RequestMethods"]));
    }
    if (m.find("ReturnDefinition") != m.end() && !m["ReturnDefinition"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReturnDefinition"].type()) {
        GetServiceDetailResponseBodyDataMethodsReturnDefinition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReturnDefinition"]));
        returnDefinition = make_shared<GetServiceDetailResponseBodyDataMethodsReturnDefinition>(model1);
      }
    }
    if (m.find("ReturnDetails") != m.end() && !m["ReturnDetails"].empty()) {
      returnDetails = make_shared<string>(boost::any_cast<string>(m["ReturnDetails"]));
    }
    if (m.find("ReturnType") != m.end() && !m["ReturnType"].empty()) {
      returnType = make_shared<string>(boost::any_cast<string>(m["ReturnType"]));
    }
  }


  virtual ~GetServiceDetailResponseBodyDataMethods() = default;
};
class GetServiceDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> dubboApplicationName{};
  shared_ptr<string> edasAppName{};
  shared_ptr<string> group{};
  shared_ptr<string> metadata{};
  shared_ptr<vector<GetServiceDetailResponseBodyDataMethods>> methods{};
  shared_ptr<string> registryType{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> springApplicationName{};
  shared_ptr<string> version{};

  GetServiceDetailResponseBodyData() {}

  explicit GetServiceDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dubboApplicationName) {
      res["DubboApplicationName"] = boost::any(*dubboApplicationName);
    }
    if (edasAppName) {
      res["EdasAppName"] = boost::any(*edasAppName);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (metadata) {
      res["Metadata"] = boost::any(*metadata);
    }
    if (methods) {
      vector<boost::any> temp1;
      for(auto item1:*methods){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Methods"] = boost::any(temp1);
    }
    if (registryType) {
      res["RegistryType"] = boost::any(*registryType);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (springApplicationName) {
      res["SpringApplicationName"] = boost::any(*springApplicationName);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DubboApplicationName") != m.end() && !m["DubboApplicationName"].empty()) {
      dubboApplicationName = make_shared<string>(boost::any_cast<string>(m["DubboApplicationName"]));
    }
    if (m.find("EdasAppName") != m.end() && !m["EdasAppName"].empty()) {
      edasAppName = make_shared<string>(boost::any_cast<string>(m["EdasAppName"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("Metadata") != m.end() && !m["Metadata"].empty()) {
      metadata = make_shared<string>(boost::any_cast<string>(m["Metadata"]));
    }
    if (m.find("Methods") != m.end() && !m["Methods"].empty()) {
      if (typeid(vector<boost::any>) == m["Methods"].type()) {
        vector<GetServiceDetailResponseBodyDataMethods> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Methods"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceDetailResponseBodyDataMethods model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        methods = make_shared<vector<GetServiceDetailResponseBodyDataMethods>>(expect1);
      }
    }
    if (m.find("RegistryType") != m.end() && !m["RegistryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["RegistryType"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
    if (m.find("SpringApplicationName") != m.end() && !m["SpringApplicationName"].empty()) {
      springApplicationName = make_shared<string>(boost::any_cast<string>(m["SpringApplicationName"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~GetServiceDetailResponseBodyData() = default;
};
class GetServiceDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetServiceDetailResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  GetServiceDetailResponseBody() {}

  explicit GetServiceDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetServiceDetailResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetServiceDetailResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetServiceDetailResponseBody() = default;
};
class GetServiceDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetServiceDetailResponseBody> body{};

  GetServiceDetailResponse() {}

  explicit GetServiceDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetServiceDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetServiceDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetServiceDetailResponse() = default;
};
class GetServiceListPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespace_{};
  shared_ptr<string> origin{};
  shared_ptr<long> page{};
  shared_ptr<string> region{};
  shared_ptr<string> searchType{};
  shared_ptr<string> searchValue{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> side{};
  shared_ptr<long> size{};

  GetServiceListPageRequest() {}

  explicit GetServiceListPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespace_) {
      res["namespace"] = boost::any(*namespace_);
    }
    if (origin) {
      res["origin"] = boost::any(*origin);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (region) {
      res["region"] = boost::any(*region);
    }
    if (searchType) {
      res["searchType"] = boost::any(*searchType);
    }
    if (searchValue) {
      res["searchValue"] = boost::any(*searchValue);
    }
    if (serviceType) {
      res["serviceType"] = boost::any(*serviceType);
    }
    if (side) {
      res["side"] = boost::any(*side);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["namespace"]));
    }
    if (m.find("origin") != m.end() && !m["origin"].empty()) {
      origin = make_shared<string>(boost::any_cast<string>(m["origin"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("region") != m.end() && !m["region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["region"]));
    }
    if (m.find("searchType") != m.end() && !m["searchType"].empty()) {
      searchType = make_shared<string>(boost::any_cast<string>(m["searchType"]));
    }
    if (m.find("searchValue") != m.end() && !m["searchValue"].empty()) {
      searchValue = make_shared<string>(boost::any_cast<string>(m["searchValue"]));
    }
    if (m.find("serviceType") != m.end() && !m["serviceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["serviceType"]));
    }
    if (m.find("side") != m.end() && !m["side"].empty()) {
      side = make_shared<string>(boost::any_cast<string>(m["side"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
  }


  virtual ~GetServiceListPageRequest() = default;
};
class GetServiceListPageResponseBodyDataContent : public Darabonba::Model {
public:
  shared_ptr<string> edasAppId{};
  shared_ptr<string> edasAppName{};
  shared_ptr<string> group{};
  shared_ptr<long> instanceNum{};
  shared_ptr<string> registerType{};
  shared_ptr<string> serviceId{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> version{};

  GetServiceListPageResponseBodyDataContent() {}

  explicit GetServiceListPageResponseBodyDataContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edasAppId) {
      res["EdasAppId"] = boost::any(*edasAppId);
    }
    if (edasAppName) {
      res["EdasAppName"] = boost::any(*edasAppName);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (instanceNum) {
      res["InstanceNum"] = boost::any(*instanceNum);
    }
    if (registerType) {
      res["RegisterType"] = boost::any(*registerType);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EdasAppId") != m.end() && !m["EdasAppId"].empty()) {
      edasAppId = make_shared<string>(boost::any_cast<string>(m["EdasAppId"]));
    }
    if (m.find("EdasAppName") != m.end() && !m["EdasAppName"].empty()) {
      edasAppName = make_shared<string>(boost::any_cast<string>(m["EdasAppName"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("InstanceNum") != m.end() && !m["InstanceNum"].empty()) {
      instanceNum = make_shared<long>(boost::any_cast<long>(m["InstanceNum"]));
    }
    if (m.find("RegisterType") != m.end() && !m["RegisterType"].empty()) {
      registerType = make_shared<string>(boost::any_cast<string>(m["RegisterType"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["ServiceId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~GetServiceListPageResponseBodyDataContent() = default;
};
class GetServiceListPageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetServiceListPageResponseBodyDataContent>> content{};
  shared_ptr<long> size{};
  shared_ptr<long> totalElements{};
  shared_ptr<long> totalPages{};

  GetServiceListPageResponseBodyData() {}

  explicit GetServiceListPageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      vector<boost::any> temp1;
      for(auto item1:*content){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Content"] = boost::any(temp1);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (totalElements) {
      res["TotalElements"] = boost::any(*totalElements);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(vector<boost::any>) == m["Content"].type()) {
        vector<GetServiceListPageResponseBodyDataContent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Content"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceListPageResponseBodyDataContent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        content = make_shared<vector<GetServiceListPageResponseBodyDataContent>>(expect1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TotalElements") != m.end() && !m["TotalElements"].empty()) {
      totalElements = make_shared<long>(boost::any_cast<long>(m["TotalElements"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~GetServiceListPageResponseBodyData() = default;
};
class GetServiceListPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetServiceListPageResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  GetServiceListPageResponseBody() {}

  explicit GetServiceListPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetServiceListPageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetServiceListPageResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetServiceListPageResponseBody() = default;
};
class GetServiceListPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetServiceListPageResponseBody> body{};

  GetServiceListPageResponse() {}

  explicit GetServiceListPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetServiceListPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetServiceListPageResponseBody>(model1);
      }
    }
  }


  virtual ~GetServiceListPageResponse() = default;
};
class GetServiceMethodPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> group{};
  shared_ptr<string> ip{};
  shared_ptr<string> methodController{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> origin{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> path{};
  shared_ptr<string> region{};
  shared_ptr<string> registryType{};
  shared_ptr<string> serviceId{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> serviceVersion{};
  shared_ptr<string> source{};

  GetServiceMethodPageRequest() {}

  explicit GetServiceMethodPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["appId"] = boost::any(*appId);
    }
    if (group) {
      res["group"] = boost::any(*group);
    }
    if (ip) {
      res["ip"] = boost::any(*ip);
    }
    if (methodController) {
      res["methodController"] = boost::any(*methodController);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (namespace_) {
      res["namespace"] = boost::any(*namespace_);
    }
    if (origin) {
      res["origin"] = boost::any(*origin);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (region) {
      res["region"] = boost::any(*region);
    }
    if (registryType) {
      res["registryType"] = boost::any(*registryType);
    }
    if (serviceId) {
      res["serviceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    if (serviceType) {
      res["serviceType"] = boost::any(*serviceType);
    }
    if (serviceVersion) {
      res["serviceVersion"] = boost::any(*serviceVersion);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("appId") != m.end() && !m["appId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["appId"]));
    }
    if (m.find("group") != m.end() && !m["group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["group"]));
    }
    if (m.find("ip") != m.end() && !m["ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["ip"]));
    }
    if (m.find("methodController") != m.end() && !m["methodController"].empty()) {
      methodController = make_shared<string>(boost::any_cast<string>(m["methodController"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["namespace"]));
    }
    if (m.find("origin") != m.end() && !m["origin"].empty()) {
      origin = make_shared<string>(boost::any_cast<string>(m["origin"]));
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("region") != m.end() && !m["region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["region"]));
    }
    if (m.find("registryType") != m.end() && !m["registryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["registryType"]));
    }
    if (m.find("serviceId") != m.end() && !m["serviceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["serviceId"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
    if (m.find("serviceType") != m.end() && !m["serviceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["serviceType"]));
    }
    if (m.find("serviceVersion") != m.end() && !m["serviceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["serviceVersion"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
  }


  virtual ~GetServiceMethodPageRequest() = default;
};
class GetServiceMethodPageResponseBodyDataResultReturnDefinition : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> type{};

  GetServiceMethodPageResponseBodyDataResultReturnDefinition() {}

  explicit GetServiceMethodPageResponseBodyDataResultReturnDefinition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetServiceMethodPageResponseBodyDataResultReturnDefinition() = default;
};
class GetServiceMethodPageResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<string> methodController{};
  shared_ptr<string> name{};
  shared_ptr<string> nameDetail{};
  shared_ptr<string> parameterDefinitions{};
  shared_ptr<string> parameterDetails{};
  shared_ptr<string> parameterNames{};
  shared_ptr<string> parameterTypes{};
  shared_ptr<string> paths{};
  shared_ptr<string> requestMethods{};
  shared_ptr<GetServiceMethodPageResponseBodyDataResultReturnDefinition> returnDefinition{};
  shared_ptr<string> returnDetails{};
  shared_ptr<string> returnType{};

  GetServiceMethodPageResponseBodyDataResult() {}

  explicit GetServiceMethodPageResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (methodController) {
      res["MethodController"] = boost::any(*methodController);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nameDetail) {
      res["NameDetail"] = boost::any(*nameDetail);
    }
    if (parameterDefinitions) {
      res["ParameterDefinitions"] = boost::any(*parameterDefinitions);
    }
    if (parameterDetails) {
      res["ParameterDetails"] = boost::any(*parameterDetails);
    }
    if (parameterNames) {
      res["ParameterNames"] = boost::any(*parameterNames);
    }
    if (parameterTypes) {
      res["ParameterTypes"] = boost::any(*parameterTypes);
    }
    if (paths) {
      res["Paths"] = boost::any(*paths);
    }
    if (requestMethods) {
      res["RequestMethods"] = boost::any(*requestMethods);
    }
    if (returnDefinition) {
      res["ReturnDefinition"] = returnDefinition ? boost::any(returnDefinition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (returnDetails) {
      res["ReturnDetails"] = boost::any(*returnDetails);
    }
    if (returnType) {
      res["ReturnType"] = boost::any(*returnType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MethodController") != m.end() && !m["MethodController"].empty()) {
      methodController = make_shared<string>(boost::any_cast<string>(m["MethodController"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NameDetail") != m.end() && !m["NameDetail"].empty()) {
      nameDetail = make_shared<string>(boost::any_cast<string>(m["NameDetail"]));
    }
    if (m.find("ParameterDefinitions") != m.end() && !m["ParameterDefinitions"].empty()) {
      parameterDefinitions = make_shared<string>(boost::any_cast<string>(m["ParameterDefinitions"]));
    }
    if (m.find("ParameterDetails") != m.end() && !m["ParameterDetails"].empty()) {
      parameterDetails = make_shared<string>(boost::any_cast<string>(m["ParameterDetails"]));
    }
    if (m.find("ParameterNames") != m.end() && !m["ParameterNames"].empty()) {
      parameterNames = make_shared<string>(boost::any_cast<string>(m["ParameterNames"]));
    }
    if (m.find("ParameterTypes") != m.end() && !m["ParameterTypes"].empty()) {
      parameterTypes = make_shared<string>(boost::any_cast<string>(m["ParameterTypes"]));
    }
    if (m.find("Paths") != m.end() && !m["Paths"].empty()) {
      paths = make_shared<string>(boost::any_cast<string>(m["Paths"]));
    }
    if (m.find("RequestMethods") != m.end() && !m["RequestMethods"].empty()) {
      requestMethods = make_shared<string>(boost::any_cast<string>(m["RequestMethods"]));
    }
    if (m.find("ReturnDefinition") != m.end() && !m["ReturnDefinition"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReturnDefinition"].type()) {
        GetServiceMethodPageResponseBodyDataResultReturnDefinition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReturnDefinition"]));
        returnDefinition = make_shared<GetServiceMethodPageResponseBodyDataResultReturnDefinition>(model1);
      }
    }
    if (m.find("ReturnDetails") != m.end() && !m["ReturnDetails"].empty()) {
      returnDetails = make_shared<string>(boost::any_cast<string>(m["ReturnDetails"]));
    }
    if (m.find("ReturnType") != m.end() && !m["ReturnType"].empty()) {
      returnType = make_shared<string>(boost::any_cast<string>(m["ReturnType"]));
    }
  }


  virtual ~GetServiceMethodPageResponseBodyDataResult() = default;
};
class GetServiceMethodPageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<GetServiceMethodPageResponseBodyDataResult>> result{};
  shared_ptr<long> totalSize{};

  GetServiceMethodPageResponseBodyData() {}

  explicit GetServiceMethodPageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<GetServiceMethodPageResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceMethodPageResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<GetServiceMethodPageResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~GetServiceMethodPageResponseBodyData() = default;
};
class GetServiceMethodPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetServiceMethodPageResponseBodyData> data{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetServiceMethodPageResponseBody() {}

  explicit GetServiceMethodPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetServiceMethodPageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetServiceMethodPageResponseBodyData>(model1);
      }
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetServiceMethodPageResponseBody() = default;
};
class GetServiceMethodPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetServiceMethodPageResponseBody> body{};

  GetServiceMethodPageResponse() {}

  explicit GetServiceMethodPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetServiceMethodPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetServiceMethodPageResponseBody>(model1);
      }
    }
  }


  virtual ~GetServiceMethodPageResponse() = default;
};
class GetServiceProvidersPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> group{};
  shared_ptr<string> ip{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> origin{};
  shared_ptr<long> page{};
  shared_ptr<string> region{};
  shared_ptr<string> registryType{};
  shared_ptr<string> serviceId{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> serviceVersion{};
  shared_ptr<long> size{};
  shared_ptr<string> source{};

  GetServiceProvidersPageRequest() {}

  explicit GetServiceProvidersPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["appId"] = boost::any(*appId);
    }
    if (group) {
      res["group"] = boost::any(*group);
    }
    if (ip) {
      res["ip"] = boost::any(*ip);
    }
    if (namespace_) {
      res["namespace"] = boost::any(*namespace_);
    }
    if (origin) {
      res["origin"] = boost::any(*origin);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (region) {
      res["region"] = boost::any(*region);
    }
    if (registryType) {
      res["registryType"] = boost::any(*registryType);
    }
    if (serviceId) {
      res["serviceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    if (serviceType) {
      res["serviceType"] = boost::any(*serviceType);
    }
    if (serviceVersion) {
      res["serviceVersion"] = boost::any(*serviceVersion);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("appId") != m.end() && !m["appId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["appId"]));
    }
    if (m.find("group") != m.end() && !m["group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["group"]));
    }
    if (m.find("ip") != m.end() && !m["ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["ip"]));
    }
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["namespace"]));
    }
    if (m.find("origin") != m.end() && !m["origin"].empty()) {
      origin = make_shared<string>(boost::any_cast<string>(m["origin"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("region") != m.end() && !m["region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["region"]));
    }
    if (m.find("registryType") != m.end() && !m["registryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["registryType"]));
    }
    if (m.find("serviceId") != m.end() && !m["serviceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["serviceId"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
    if (m.find("serviceType") != m.end() && !m["serviceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["serviceType"]));
    }
    if (m.find("serviceVersion") != m.end() && !m["serviceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["serviceVersion"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
  }


  virtual ~GetServiceProvidersPageRequest() = default;
};
class GetServiceProvidersPageResponseBodyDataContent : public Darabonba::Model {
public:
  shared_ptr<string> iannotations{};
  shared_ptr<string> ip{};
  shared_ptr<string> port{};
  shared_ptr<string> serializeType{};
  shared_ptr<string> timeout{};

  GetServiceProvidersPageResponseBodyDataContent() {}

  explicit GetServiceProvidersPageResponseBodyDataContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iannotations) {
      res["Iannotations"] = boost::any(*iannotations);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (serializeType) {
      res["SerializeType"] = boost::any(*serializeType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Iannotations") != m.end() && !m["Iannotations"].empty()) {
      iannotations = make_shared<string>(boost::any_cast<string>(m["Iannotations"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("SerializeType") != m.end() && !m["SerializeType"].empty()) {
      serializeType = make_shared<string>(boost::any_cast<string>(m["SerializeType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<string>(boost::any_cast<string>(m["Timeout"]));
    }
  }


  virtual ~GetServiceProvidersPageResponseBodyDataContent() = default;
};
class GetServiceProvidersPageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetServiceProvidersPageResponseBodyDataContent>> content{};
  shared_ptr<long> size{};
  shared_ptr<long> totalElements{};
  shared_ptr<long> totalPages{};

  GetServiceProvidersPageResponseBodyData() {}

  explicit GetServiceProvidersPageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      vector<boost::any> temp1;
      for(auto item1:*content){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Content"] = boost::any(temp1);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (totalElements) {
      res["TotalElements"] = boost::any(*totalElements);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(vector<boost::any>) == m["Content"].type()) {
        vector<GetServiceProvidersPageResponseBodyDataContent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Content"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceProvidersPageResponseBodyDataContent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        content = make_shared<vector<GetServiceProvidersPageResponseBodyDataContent>>(expect1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TotalElements") != m.end() && !m["TotalElements"].empty()) {
      totalElements = make_shared<long>(boost::any_cast<long>(m["TotalElements"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~GetServiceProvidersPageResponseBodyData() = default;
};
class GetServiceProvidersPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetServiceProvidersPageResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  GetServiceProvidersPageResponseBody() {}

  explicit GetServiceProvidersPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetServiceProvidersPageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetServiceProvidersPageResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetServiceProvidersPageResponseBody() = default;
};
class GetServiceProvidersPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetServiceProvidersPageResponseBody> body{};

  GetServiceProvidersPageResponse() {}

  explicit GetServiceProvidersPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetServiceProvidersPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetServiceProvidersPageResponseBody>(model1);
      }
    }
  }


  virtual ~GetServiceProvidersPageResponse() = default;
};
class GetWebContainerConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  GetWebContainerConfigRequest() {}

  explicit GetWebContainerConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~GetWebContainerConfigRequest() = default;
};
class GetWebContainerConfigResponseBodyWebContainerConfig : public Darabonba::Model {
public:
  shared_ptr<string> contextInputType{};
  shared_ptr<string> contextPath{};
  shared_ptr<long> httpPort{};
  shared_ptr<long> maxThreads{};
  shared_ptr<string> serverXml{};
  shared_ptr<string> uriEncoding{};
  shared_ptr<bool> useAdvancedServerXml{};
  shared_ptr<bool> useBodyEncoding{};
  shared_ptr<bool> useDefaultConfig{};

  GetWebContainerConfigResponseBodyWebContainerConfig() {}

  explicit GetWebContainerConfigResponseBodyWebContainerConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contextInputType) {
      res["ContextInputType"] = boost::any(*contextInputType);
    }
    if (contextPath) {
      res["ContextPath"] = boost::any(*contextPath);
    }
    if (httpPort) {
      res["HttpPort"] = boost::any(*httpPort);
    }
    if (maxThreads) {
      res["MaxThreads"] = boost::any(*maxThreads);
    }
    if (serverXml) {
      res["ServerXml"] = boost::any(*serverXml);
    }
    if (uriEncoding) {
      res["UriEncoding"] = boost::any(*uriEncoding);
    }
    if (useAdvancedServerXml) {
      res["UseAdvancedServerXml"] = boost::any(*useAdvancedServerXml);
    }
    if (useBodyEncoding) {
      res["UseBodyEncoding"] = boost::any(*useBodyEncoding);
    }
    if (useDefaultConfig) {
      res["UseDefaultConfig"] = boost::any(*useDefaultConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContextInputType") != m.end() && !m["ContextInputType"].empty()) {
      contextInputType = make_shared<string>(boost::any_cast<string>(m["ContextInputType"]));
    }
    if (m.find("ContextPath") != m.end() && !m["ContextPath"].empty()) {
      contextPath = make_shared<string>(boost::any_cast<string>(m["ContextPath"]));
    }
    if (m.find("HttpPort") != m.end() && !m["HttpPort"].empty()) {
      httpPort = make_shared<long>(boost::any_cast<long>(m["HttpPort"]));
    }
    if (m.find("MaxThreads") != m.end() && !m["MaxThreads"].empty()) {
      maxThreads = make_shared<long>(boost::any_cast<long>(m["MaxThreads"]));
    }
    if (m.find("ServerXml") != m.end() && !m["ServerXml"].empty()) {
      serverXml = make_shared<string>(boost::any_cast<string>(m["ServerXml"]));
    }
    if (m.find("UriEncoding") != m.end() && !m["UriEncoding"].empty()) {
      uriEncoding = make_shared<string>(boost::any_cast<string>(m["UriEncoding"]));
    }
    if (m.find("UseAdvancedServerXml") != m.end() && !m["UseAdvancedServerXml"].empty()) {
      useAdvancedServerXml = make_shared<bool>(boost::any_cast<bool>(m["UseAdvancedServerXml"]));
    }
    if (m.find("UseBodyEncoding") != m.end() && !m["UseBodyEncoding"].empty()) {
      useBodyEncoding = make_shared<bool>(boost::any_cast<bool>(m["UseBodyEncoding"]));
    }
    if (m.find("UseDefaultConfig") != m.end() && !m["UseDefaultConfig"].empty()) {
      useDefaultConfig = make_shared<bool>(boost::any_cast<bool>(m["UseDefaultConfig"]));
    }
  }


  virtual ~GetWebContainerConfigResponseBodyWebContainerConfig() = default;
};
class GetWebContainerConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<GetWebContainerConfigResponseBodyWebContainerConfig> webContainerConfig{};

  GetWebContainerConfigResponseBody() {}

  explicit GetWebContainerConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (webContainerConfig) {
      res["WebContainerConfig"] = webContainerConfig ? boost::any(webContainerConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WebContainerConfig") != m.end() && !m["WebContainerConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebContainerConfig"].type()) {
        GetWebContainerConfigResponseBodyWebContainerConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebContainerConfig"]));
        webContainerConfig = make_shared<GetWebContainerConfigResponseBodyWebContainerConfig>(model1);
      }
    }
  }


  virtual ~GetWebContainerConfigResponseBody() = default;
};
class GetWebContainerConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWebContainerConfigResponseBody> body{};

  GetWebContainerConfigResponse() {}

  explicit GetWebContainerConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWebContainerConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWebContainerConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GetWebContainerConfigResponse() = default;
};
class ImportK8sClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<bool> enableAsm{};
  shared_ptr<long> mode{};
  shared_ptr<string> namespaceId{};

  ImportK8sClusterRequest() {}

  explicit ImportK8sClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (enableAsm) {
      res["EnableAsm"] = boost::any(*enableAsm);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EnableAsm") != m.end() && !m["EnableAsm"].empty()) {
      enableAsm = make_shared<bool>(boost::any_cast<bool>(m["EnableAsm"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<long>(boost::any_cast<long>(m["Mode"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~ImportK8sClusterRequest() = default;
};
class ImportK8sClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ImportK8sClusterResponseBody() {}

  explicit ImportK8sClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ImportK8sClusterResponseBody() = default;
};
class ImportK8sClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportK8sClusterResponseBody> body{};

  ImportK8sClusterResponse() {}

  explicit ImportK8sClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportK8sClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportK8sClusterResponseBody>(model1);
      }
    }
  }


  virtual ~ImportK8sClusterResponse() = default;
};
class InsertApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationName{};
  shared_ptr<long> buildPackId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> componentIds{};
  shared_ptr<long> cpu{};
  shared_ptr<string> description{};
  shared_ptr<string> ecuInfo{};
  shared_ptr<bool> enablePortCheck{};
  shared_ptr<bool> enableUrlCheck{};
  shared_ptr<string> healthCheckURL{};
  shared_ptr<string> healthCheckUrl{};
  shared_ptr<string> hooks{};
  shared_ptr<string> jdk{};
  shared_ptr<string> jvmOptions{};
  shared_ptr<string> logicalRegionId{};
  shared_ptr<long> maxHeapSize{};
  shared_ptr<long> maxPermSize{};
  shared_ptr<long> mem{};
  shared_ptr<long> minHeapSize{};
  shared_ptr<string> packageType{};
  shared_ptr<string> reservedPortStr{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> webContainer{};

  InsertApplicationRequest() {}

  explicit InsertApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (buildPackId) {
      res["BuildPackId"] = boost::any(*buildPackId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (componentIds) {
      res["ComponentIds"] = boost::any(*componentIds);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ecuInfo) {
      res["EcuInfo"] = boost::any(*ecuInfo);
    }
    if (enablePortCheck) {
      res["EnablePortCheck"] = boost::any(*enablePortCheck);
    }
    if (enableUrlCheck) {
      res["EnableUrlCheck"] = boost::any(*enableUrlCheck);
    }
    if (healthCheckURL) {
      res["HealthCheckURL"] = boost::any(*healthCheckURL);
    }
    if (healthCheckUrl) {
      res["HealthCheckUrl"] = boost::any(*healthCheckUrl);
    }
    if (hooks) {
      res["Hooks"] = boost::any(*hooks);
    }
    if (jdk) {
      res["Jdk"] = boost::any(*jdk);
    }
    if (jvmOptions) {
      res["JvmOptions"] = boost::any(*jvmOptions);
    }
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    if (maxHeapSize) {
      res["MaxHeapSize"] = boost::any(*maxHeapSize);
    }
    if (maxPermSize) {
      res["MaxPermSize"] = boost::any(*maxPermSize);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (minHeapSize) {
      res["MinHeapSize"] = boost::any(*minHeapSize);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (reservedPortStr) {
      res["ReservedPortStr"] = boost::any(*reservedPortStr);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (webContainer) {
      res["WebContainer"] = boost::any(*webContainer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("BuildPackId") != m.end() && !m["BuildPackId"].empty()) {
      buildPackId = make_shared<long>(boost::any_cast<long>(m["BuildPackId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ComponentIds") != m.end() && !m["ComponentIds"].empty()) {
      componentIds = make_shared<string>(boost::any_cast<string>(m["ComponentIds"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EcuInfo") != m.end() && !m["EcuInfo"].empty()) {
      ecuInfo = make_shared<string>(boost::any_cast<string>(m["EcuInfo"]));
    }
    if (m.find("EnablePortCheck") != m.end() && !m["EnablePortCheck"].empty()) {
      enablePortCheck = make_shared<bool>(boost::any_cast<bool>(m["EnablePortCheck"]));
    }
    if (m.find("EnableUrlCheck") != m.end() && !m["EnableUrlCheck"].empty()) {
      enableUrlCheck = make_shared<bool>(boost::any_cast<bool>(m["EnableUrlCheck"]));
    }
    if (m.find("HealthCheckURL") != m.end() && !m["HealthCheckURL"].empty()) {
      healthCheckURL = make_shared<string>(boost::any_cast<string>(m["HealthCheckURL"]));
    }
    if (m.find("HealthCheckUrl") != m.end() && !m["HealthCheckUrl"].empty()) {
      healthCheckUrl = make_shared<string>(boost::any_cast<string>(m["HealthCheckUrl"]));
    }
    if (m.find("Hooks") != m.end() && !m["Hooks"].empty()) {
      hooks = make_shared<string>(boost::any_cast<string>(m["Hooks"]));
    }
    if (m.find("Jdk") != m.end() && !m["Jdk"].empty()) {
      jdk = make_shared<string>(boost::any_cast<string>(m["Jdk"]));
    }
    if (m.find("JvmOptions") != m.end() && !m["JvmOptions"].empty()) {
      jvmOptions = make_shared<string>(boost::any_cast<string>(m["JvmOptions"]));
    }
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
    if (m.find("MaxHeapSize") != m.end() && !m["MaxHeapSize"].empty()) {
      maxHeapSize = make_shared<long>(boost::any_cast<long>(m["MaxHeapSize"]));
    }
    if (m.find("MaxPermSize") != m.end() && !m["MaxPermSize"].empty()) {
      maxPermSize = make_shared<long>(boost::any_cast<long>(m["MaxPermSize"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("MinHeapSize") != m.end() && !m["MinHeapSize"].empty()) {
      minHeapSize = make_shared<long>(boost::any_cast<long>(m["MinHeapSize"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("ReservedPortStr") != m.end() && !m["ReservedPortStr"].empty()) {
      reservedPortStr = make_shared<string>(boost::any_cast<string>(m["ReservedPortStr"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("WebContainer") != m.end() && !m["WebContainer"].empty()) {
      webContainer = make_shared<string>(boost::any_cast<string>(m["WebContainer"]));
    }
  }


  virtual ~InsertApplicationRequest() = default;
};
class InsertApplicationResponseBodyApplicationInfo : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<bool> dockerize{};
  shared_ptr<string> owner{};
  shared_ptr<long> port{};
  shared_ptr<string> regionName{};
  shared_ptr<string> userId{};

  InsertApplicationResponseBodyApplicationInfo() {}

  explicit InsertApplicationResponseBodyApplicationInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (dockerize) {
      res["Dockerize"] = boost::any(*dockerize);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Dockerize") != m.end() && !m["Dockerize"].empty()) {
      dockerize = make_shared<bool>(boost::any_cast<bool>(m["Dockerize"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~InsertApplicationResponseBodyApplicationInfo() = default;
};
class InsertApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<InsertApplicationResponseBodyApplicationInfo> applicationInfo{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  InsertApplicationResponseBody() {}

  explicit InsertApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationInfo) {
      res["ApplicationInfo"] = applicationInfo ? boost::any(applicationInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationInfo") != m.end() && !m["ApplicationInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplicationInfo"].type()) {
        InsertApplicationResponseBodyApplicationInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplicationInfo"]));
        applicationInfo = make_shared<InsertApplicationResponseBodyApplicationInfo>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InsertApplicationResponseBody() = default;
};
class InsertApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsertApplicationResponseBody> body{};

  InsertApplicationResponse() {}

  explicit InsertApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~InsertApplicationResponse() = default;
};
class InsertClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterName{};
  shared_ptr<long> clusterType{};
  shared_ptr<string> iaasProvider{};
  shared_ptr<string> logicalRegionId{};
  shared_ptr<long> networkMode{};
  shared_ptr<long> oversoldFactor{};
  shared_ptr<string> vpcId{};

  InsertClusterRequest() {}

  explicit InsertClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (iaasProvider) {
      res["IaasProvider"] = boost::any(*iaasProvider);
    }
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    if (networkMode) {
      res["NetworkMode"] = boost::any(*networkMode);
    }
    if (oversoldFactor) {
      res["OversoldFactor"] = boost::any(*oversoldFactor);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<long>(boost::any_cast<long>(m["ClusterType"]));
    }
    if (m.find("IaasProvider") != m.end() && !m["IaasProvider"].empty()) {
      iaasProvider = make_shared<string>(boost::any_cast<string>(m["IaasProvider"]));
    }
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
    if (m.find("NetworkMode") != m.end() && !m["NetworkMode"].empty()) {
      networkMode = make_shared<long>(boost::any_cast<long>(m["NetworkMode"]));
    }
    if (m.find("OversoldFactor") != m.end() && !m["OversoldFactor"].empty()) {
      oversoldFactor = make_shared<long>(boost::any_cast<long>(m["OversoldFactor"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~InsertClusterRequest() = default;
};
class InsertClusterResponseBodyCluster : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<long> clusterType{};
  shared_ptr<string> iaasProvider{};
  shared_ptr<long> networkMode{};
  shared_ptr<long> oversoldFactor{};
  shared_ptr<string> regionId{};
  shared_ptr<string> vpcId{};

  InsertClusterResponseBodyCluster() {}

  explicit InsertClusterResponseBodyCluster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (iaasProvider) {
      res["IaasProvider"] = boost::any(*iaasProvider);
    }
    if (networkMode) {
      res["NetworkMode"] = boost::any(*networkMode);
    }
    if (oversoldFactor) {
      res["OversoldFactor"] = boost::any(*oversoldFactor);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<long>(boost::any_cast<long>(m["ClusterType"]));
    }
    if (m.find("IaasProvider") != m.end() && !m["IaasProvider"].empty()) {
      iaasProvider = make_shared<string>(boost::any_cast<string>(m["IaasProvider"]));
    }
    if (m.find("NetworkMode") != m.end() && !m["NetworkMode"].empty()) {
      networkMode = make_shared<long>(boost::any_cast<long>(m["NetworkMode"]));
    }
    if (m.find("OversoldFactor") != m.end() && !m["OversoldFactor"].empty()) {
      oversoldFactor = make_shared<long>(boost::any_cast<long>(m["OversoldFactor"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~InsertClusterResponseBodyCluster() = default;
};
class InsertClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<InsertClusterResponseBodyCluster> cluster{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  InsertClusterResponseBody() {}

  explicit InsertClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cluster) {
      res["Cluster"] = cluster ? boost::any(cluster->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cluster") != m.end() && !m["Cluster"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cluster"].type()) {
        InsertClusterResponseBodyCluster model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cluster"]));
        cluster = make_shared<InsertClusterResponseBodyCluster>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InsertClusterResponseBody() = default;
};
class InsertClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsertClusterResponseBody> body{};

  InsertClusterResponse() {}

  explicit InsertClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertClusterResponseBody>(model1);
      }
    }
  }


  virtual ~InsertClusterResponse() = default;
};
class InsertClusterMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> password{};

  InsertClusterMemberRequest() {}

  explicit InsertClusterMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["clusterId"] = boost::any(*clusterId);
    }
    if (instanceIds) {
      res["instanceIds"] = boost::any(*instanceIds);
    }
    if (password) {
      res["password"] = boost::any(*password);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clusterId") != m.end() && !m["clusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["clusterId"]));
    }
    if (m.find("instanceIds") != m.end() && !m["instanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["instanceIds"]));
    }
    if (m.find("password") != m.end() && !m["password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["password"]));
    }
  }


  virtual ~InsertClusterMemberRequest() = default;
};
class InsertClusterMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  InsertClusterMemberResponseBody() {}

  explicit InsertClusterMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InsertClusterMemberResponseBody() = default;
};
class InsertClusterMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsertClusterMemberResponseBody> body{};

  InsertClusterMemberResponse() {}

  explicit InsertClusterMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertClusterMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertClusterMemberResponseBody>(model1);
      }
    }
  }


  virtual ~InsertClusterMemberResponse() = default;
};
class InsertDeployGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> initPackageVersionId{};

  InsertDeployGroupRequest() {}

  explicit InsertDeployGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (initPackageVersionId) {
      res["InitPackageVersionId"] = boost::any(*initPackageVersionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InitPackageVersionId") != m.end() && !m["InitPackageVersionId"].empty()) {
      initPackageVersionId = make_shared<string>(boost::any_cast<string>(m["InitPackageVersionId"]));
    }
  }


  virtual ~InsertDeployGroupRequest() = default;
};
class InsertDeployGroupResponseBodyDeployGroupEntity : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appVersionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> groupName{};
  shared_ptr<long> groupType{};
  shared_ptr<string> id{};
  shared_ptr<string> packageVersionId{};
  shared_ptr<long> updateTime{};

  InsertDeployGroupResponseBodyDeployGroupEntity() {}

  explicit InsertDeployGroupResponseBodyDeployGroupEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appVersionId) {
      res["AppVersionId"] = boost::any(*appVersionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (packageVersionId) {
      res["PackageVersionId"] = boost::any(*packageVersionId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppVersionId") != m.end() && !m["AppVersionId"].empty()) {
      appVersionId = make_shared<string>(boost::any_cast<string>(m["AppVersionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<long>(boost::any_cast<long>(m["GroupType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("PackageVersionId") != m.end() && !m["PackageVersionId"].empty()) {
      packageVersionId = make_shared<string>(boost::any_cast<string>(m["PackageVersionId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~InsertDeployGroupResponseBodyDeployGroupEntity() = default;
};
class InsertDeployGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<InsertDeployGroupResponseBodyDeployGroupEntity> deployGroupEntity{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  InsertDeployGroupResponseBody() {}

  explicit InsertDeployGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (deployGroupEntity) {
      res["DeployGroupEntity"] = deployGroupEntity ? boost::any(deployGroupEntity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("DeployGroupEntity") != m.end() && !m["DeployGroupEntity"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeployGroupEntity"].type()) {
        InsertDeployGroupResponseBodyDeployGroupEntity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeployGroupEntity"]));
        deployGroupEntity = make_shared<InsertDeployGroupResponseBodyDeployGroupEntity>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InsertDeployGroupResponseBody() = default;
};
class InsertDeployGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsertDeployGroupResponseBody> body{};

  InsertDeployGroupResponse() {}

  explicit InsertDeployGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertDeployGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertDeployGroupResponseBody>(model1);
      }
    }
  }


  virtual ~InsertDeployGroupResponse() = default;
};
class InsertK8sApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> annotations{};
  shared_ptr<string> appConfig{};
  shared_ptr<string> appName{};
  shared_ptr<string> appTemplateName{};
  shared_ptr<string> applicationDescription{};
  shared_ptr<string> buildPackId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> command{};
  shared_ptr<string> commandArgs{};
  shared_ptr<string> configMountDescs{};
  shared_ptr<string> containerRegistryId{};
  shared_ptr<string> csClusterId{};
  shared_ptr<string> customAffinity{};
  shared_ptr<string> customAgentVersion{};
  shared_ptr<string> customTolerations{};
  shared_ptr<string> deployAcrossNodes{};
  shared_ptr<string> deployAcrossZones{};
  shared_ptr<string> edasContainerVersion{};
  shared_ptr<string> emptyDirs{};
  shared_ptr<bool> enableAhas{};
  shared_ptr<bool> enableAsm{};
  shared_ptr<bool> enableEmptyPushReject{};
  shared_ptr<bool> enableLosslessRule{};
  shared_ptr<string> envFroms{};
  shared_ptr<string> envs{};
  shared_ptr<string> featureConfig{};
  shared_ptr<string> imagePlatforms{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> initContainers{};
  shared_ptr<string> internetSlbId{};
  shared_ptr<long> internetSlbPort{};
  shared_ptr<string> internetSlbProtocol{};
  shared_ptr<long> internetTargetPort{};
  shared_ptr<string> intranetSlbId{};
  shared_ptr<long> intranetSlbPort{};
  shared_ptr<string> intranetSlbProtocol{};
  shared_ptr<long> intranetTargetPort{};
  shared_ptr<bool> isMultilingualApp{};
  shared_ptr<string> JDK{};
  shared_ptr<string> javaStartUpConfig{};
  shared_ptr<string> labels{};
  shared_ptr<long> limitCpu{};
  shared_ptr<long> limitEphemeralStorage{};
  shared_ptr<long> limitMem{};
  shared_ptr<long> limitmCpu{};
  shared_ptr<string> liveness{};
  shared_ptr<string> localVolume{};
  shared_ptr<string> logicalRegionId{};
  shared_ptr<bool> losslessRuleAligned{};
  shared_ptr<long> losslessRuleDelayTime{};
  shared_ptr<long> losslessRuleFuncType{};
  shared_ptr<bool> losslessRuleRelated{};
  shared_ptr<long> losslessRuleWarmupTime{};
  shared_ptr<string> mountDescs{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> nasId{};
  shared_ptr<string> packageType{};
  shared_ptr<string> packageUrl{};
  shared_ptr<string> packageVersion{};
  shared_ptr<string> postStart{};
  shared_ptr<string> preStop{};
  shared_ptr<string> pvcMountDescs{};
  shared_ptr<string> readiness{};
  shared_ptr<long> replicas{};
  shared_ptr<string> repoId{};
  shared_ptr<long> requestsCpu{};
  shared_ptr<long> requestsEphemeralStorage{};
  shared_ptr<long> requestsMem{};
  shared_ptr<long> requestsmCpu{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> runtimeClassName{};
  shared_ptr<string> secretName{};
  shared_ptr<string> serviceConfigs{};
  shared_ptr<string> sidecars{};
  shared_ptr<string> slsConfigs{};
  shared_ptr<string> startup{};
  shared_ptr<string> storageType{};
  shared_ptr<long> terminateGracePeriod{};
  shared_ptr<long> timeout{};
  shared_ptr<string> uriEncoding{};
  shared_ptr<bool> useBodyEncoding{};
  shared_ptr<string> userBaseImageUrl{};
  shared_ptr<string> webContainer{};
  shared_ptr<string> webContainerConfig{};
  shared_ptr<string> workloadType{};

  InsertK8sApplicationRequest() {}

  explicit InsertK8sApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotations) {
      res["Annotations"] = boost::any(*annotations);
    }
    if (appConfig) {
      res["AppConfig"] = boost::any(*appConfig);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appTemplateName) {
      res["AppTemplateName"] = boost::any(*appTemplateName);
    }
    if (applicationDescription) {
      res["ApplicationDescription"] = boost::any(*applicationDescription);
    }
    if (buildPackId) {
      res["BuildPackId"] = boost::any(*buildPackId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (commandArgs) {
      res["CommandArgs"] = boost::any(*commandArgs);
    }
    if (configMountDescs) {
      res["ConfigMountDescs"] = boost::any(*configMountDescs);
    }
    if (containerRegistryId) {
      res["ContainerRegistryId"] = boost::any(*containerRegistryId);
    }
    if (csClusterId) {
      res["CsClusterId"] = boost::any(*csClusterId);
    }
    if (customAffinity) {
      res["CustomAffinity"] = boost::any(*customAffinity);
    }
    if (customAgentVersion) {
      res["CustomAgentVersion"] = boost::any(*customAgentVersion);
    }
    if (customTolerations) {
      res["CustomTolerations"] = boost::any(*customTolerations);
    }
    if (deployAcrossNodes) {
      res["DeployAcrossNodes"] = boost::any(*deployAcrossNodes);
    }
    if (deployAcrossZones) {
      res["DeployAcrossZones"] = boost::any(*deployAcrossZones);
    }
    if (edasContainerVersion) {
      res["EdasContainerVersion"] = boost::any(*edasContainerVersion);
    }
    if (emptyDirs) {
      res["EmptyDirs"] = boost::any(*emptyDirs);
    }
    if (enableAhas) {
      res["EnableAhas"] = boost::any(*enableAhas);
    }
    if (enableAsm) {
      res["EnableAsm"] = boost::any(*enableAsm);
    }
    if (enableEmptyPushReject) {
      res["EnableEmptyPushReject"] = boost::any(*enableEmptyPushReject);
    }
    if (enableLosslessRule) {
      res["EnableLosslessRule"] = boost::any(*enableLosslessRule);
    }
    if (envFroms) {
      res["EnvFroms"] = boost::any(*envFroms);
    }
    if (envs) {
      res["Envs"] = boost::any(*envs);
    }
    if (featureConfig) {
      res["FeatureConfig"] = boost::any(*featureConfig);
    }
    if (imagePlatforms) {
      res["ImagePlatforms"] = boost::any(*imagePlatforms);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (initContainers) {
      res["InitContainers"] = boost::any(*initContainers);
    }
    if (internetSlbId) {
      res["InternetSlbId"] = boost::any(*internetSlbId);
    }
    if (internetSlbPort) {
      res["InternetSlbPort"] = boost::any(*internetSlbPort);
    }
    if (internetSlbProtocol) {
      res["InternetSlbProtocol"] = boost::any(*internetSlbProtocol);
    }
    if (internetTargetPort) {
      res["InternetTargetPort"] = boost::any(*internetTargetPort);
    }
    if (intranetSlbId) {
      res["IntranetSlbId"] = boost::any(*intranetSlbId);
    }
    if (intranetSlbPort) {
      res["IntranetSlbPort"] = boost::any(*intranetSlbPort);
    }
    if (intranetSlbProtocol) {
      res["IntranetSlbProtocol"] = boost::any(*intranetSlbProtocol);
    }
    if (intranetTargetPort) {
      res["IntranetTargetPort"] = boost::any(*intranetTargetPort);
    }
    if (isMultilingualApp) {
      res["IsMultilingualApp"] = boost::any(*isMultilingualApp);
    }
    if (JDK) {
      res["JDK"] = boost::any(*JDK);
    }
    if (javaStartUpConfig) {
      res["JavaStartUpConfig"] = boost::any(*javaStartUpConfig);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (limitCpu) {
      res["LimitCpu"] = boost::any(*limitCpu);
    }
    if (limitEphemeralStorage) {
      res["LimitEphemeralStorage"] = boost::any(*limitEphemeralStorage);
    }
    if (limitMem) {
      res["LimitMem"] = boost::any(*limitMem);
    }
    if (limitmCpu) {
      res["LimitmCpu"] = boost::any(*limitmCpu);
    }
    if (liveness) {
      res["Liveness"] = boost::any(*liveness);
    }
    if (localVolume) {
      res["LocalVolume"] = boost::any(*localVolume);
    }
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    if (losslessRuleAligned) {
      res["LosslessRuleAligned"] = boost::any(*losslessRuleAligned);
    }
    if (losslessRuleDelayTime) {
      res["LosslessRuleDelayTime"] = boost::any(*losslessRuleDelayTime);
    }
    if (losslessRuleFuncType) {
      res["LosslessRuleFuncType"] = boost::any(*losslessRuleFuncType);
    }
    if (losslessRuleRelated) {
      res["LosslessRuleRelated"] = boost::any(*losslessRuleRelated);
    }
    if (losslessRuleWarmupTime) {
      res["LosslessRuleWarmupTime"] = boost::any(*losslessRuleWarmupTime);
    }
    if (mountDescs) {
      res["MountDescs"] = boost::any(*mountDescs);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (nasId) {
      res["NasId"] = boost::any(*nasId);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (packageUrl) {
      res["PackageUrl"] = boost::any(*packageUrl);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    if (postStart) {
      res["PostStart"] = boost::any(*postStart);
    }
    if (preStop) {
      res["PreStop"] = boost::any(*preStop);
    }
    if (pvcMountDescs) {
      res["PvcMountDescs"] = boost::any(*pvcMountDescs);
    }
    if (readiness) {
      res["Readiness"] = boost::any(*readiness);
    }
    if (replicas) {
      res["Replicas"] = boost::any(*replicas);
    }
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    if (requestsCpu) {
      res["RequestsCpu"] = boost::any(*requestsCpu);
    }
    if (requestsEphemeralStorage) {
      res["RequestsEphemeralStorage"] = boost::any(*requestsEphemeralStorage);
    }
    if (requestsMem) {
      res["RequestsMem"] = boost::any(*requestsMem);
    }
    if (requestsmCpu) {
      res["RequestsmCpu"] = boost::any(*requestsmCpu);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (runtimeClassName) {
      res["RuntimeClassName"] = boost::any(*runtimeClassName);
    }
    if (secretName) {
      res["SecretName"] = boost::any(*secretName);
    }
    if (serviceConfigs) {
      res["ServiceConfigs"] = boost::any(*serviceConfigs);
    }
    if (sidecars) {
      res["Sidecars"] = boost::any(*sidecars);
    }
    if (slsConfigs) {
      res["SlsConfigs"] = boost::any(*slsConfigs);
    }
    if (startup) {
      res["Startup"] = boost::any(*startup);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    if (terminateGracePeriod) {
      res["TerminateGracePeriod"] = boost::any(*terminateGracePeriod);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (uriEncoding) {
      res["UriEncoding"] = boost::any(*uriEncoding);
    }
    if (useBodyEncoding) {
      res["UseBodyEncoding"] = boost::any(*useBodyEncoding);
    }
    if (userBaseImageUrl) {
      res["UserBaseImageUrl"] = boost::any(*userBaseImageUrl);
    }
    if (webContainer) {
      res["WebContainer"] = boost::any(*webContainer);
    }
    if (webContainerConfig) {
      res["WebContainerConfig"] = boost::any(*webContainerConfig);
    }
    if (workloadType) {
      res["WorkloadType"] = boost::any(*workloadType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      annotations = make_shared<string>(boost::any_cast<string>(m["Annotations"]));
    }
    if (m.find("AppConfig") != m.end() && !m["AppConfig"].empty()) {
      appConfig = make_shared<string>(boost::any_cast<string>(m["AppConfig"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppTemplateName") != m.end() && !m["AppTemplateName"].empty()) {
      appTemplateName = make_shared<string>(boost::any_cast<string>(m["AppTemplateName"]));
    }
    if (m.find("ApplicationDescription") != m.end() && !m["ApplicationDescription"].empty()) {
      applicationDescription = make_shared<string>(boost::any_cast<string>(m["ApplicationDescription"]));
    }
    if (m.find("BuildPackId") != m.end() && !m["BuildPackId"].empty()) {
      buildPackId = make_shared<string>(boost::any_cast<string>(m["BuildPackId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("CommandArgs") != m.end() && !m["CommandArgs"].empty()) {
      commandArgs = make_shared<string>(boost::any_cast<string>(m["CommandArgs"]));
    }
    if (m.find("ConfigMountDescs") != m.end() && !m["ConfigMountDescs"].empty()) {
      configMountDescs = make_shared<string>(boost::any_cast<string>(m["ConfigMountDescs"]));
    }
    if (m.find("ContainerRegistryId") != m.end() && !m["ContainerRegistryId"].empty()) {
      containerRegistryId = make_shared<string>(boost::any_cast<string>(m["ContainerRegistryId"]));
    }
    if (m.find("CsClusterId") != m.end() && !m["CsClusterId"].empty()) {
      csClusterId = make_shared<string>(boost::any_cast<string>(m["CsClusterId"]));
    }
    if (m.find("CustomAffinity") != m.end() && !m["CustomAffinity"].empty()) {
      customAffinity = make_shared<string>(boost::any_cast<string>(m["CustomAffinity"]));
    }
    if (m.find("CustomAgentVersion") != m.end() && !m["CustomAgentVersion"].empty()) {
      customAgentVersion = make_shared<string>(boost::any_cast<string>(m["CustomAgentVersion"]));
    }
    if (m.find("CustomTolerations") != m.end() && !m["CustomTolerations"].empty()) {
      customTolerations = make_shared<string>(boost::any_cast<string>(m["CustomTolerations"]));
    }
    if (m.find("DeployAcrossNodes") != m.end() && !m["DeployAcrossNodes"].empty()) {
      deployAcrossNodes = make_shared<string>(boost::any_cast<string>(m["DeployAcrossNodes"]));
    }
    if (m.find("DeployAcrossZones") != m.end() && !m["DeployAcrossZones"].empty()) {
      deployAcrossZones = make_shared<string>(boost::any_cast<string>(m["DeployAcrossZones"]));
    }
    if (m.find("EdasContainerVersion") != m.end() && !m["EdasContainerVersion"].empty()) {
      edasContainerVersion = make_shared<string>(boost::any_cast<string>(m["EdasContainerVersion"]));
    }
    if (m.find("EmptyDirs") != m.end() && !m["EmptyDirs"].empty()) {
      emptyDirs = make_shared<string>(boost::any_cast<string>(m["EmptyDirs"]));
    }
    if (m.find("EnableAhas") != m.end() && !m["EnableAhas"].empty()) {
      enableAhas = make_shared<bool>(boost::any_cast<bool>(m["EnableAhas"]));
    }
    if (m.find("EnableAsm") != m.end() && !m["EnableAsm"].empty()) {
      enableAsm = make_shared<bool>(boost::any_cast<bool>(m["EnableAsm"]));
    }
    if (m.find("EnableEmptyPushReject") != m.end() && !m["EnableEmptyPushReject"].empty()) {
      enableEmptyPushReject = make_shared<bool>(boost::any_cast<bool>(m["EnableEmptyPushReject"]));
    }
    if (m.find("EnableLosslessRule") != m.end() && !m["EnableLosslessRule"].empty()) {
      enableLosslessRule = make_shared<bool>(boost::any_cast<bool>(m["EnableLosslessRule"]));
    }
    if (m.find("EnvFroms") != m.end() && !m["EnvFroms"].empty()) {
      envFroms = make_shared<string>(boost::any_cast<string>(m["EnvFroms"]));
    }
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      envs = make_shared<string>(boost::any_cast<string>(m["Envs"]));
    }
    if (m.find("FeatureConfig") != m.end() && !m["FeatureConfig"].empty()) {
      featureConfig = make_shared<string>(boost::any_cast<string>(m["FeatureConfig"]));
    }
    if (m.find("ImagePlatforms") != m.end() && !m["ImagePlatforms"].empty()) {
      imagePlatforms = make_shared<string>(boost::any_cast<string>(m["ImagePlatforms"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("InitContainers") != m.end() && !m["InitContainers"].empty()) {
      initContainers = make_shared<string>(boost::any_cast<string>(m["InitContainers"]));
    }
    if (m.find("InternetSlbId") != m.end() && !m["InternetSlbId"].empty()) {
      internetSlbId = make_shared<string>(boost::any_cast<string>(m["InternetSlbId"]));
    }
    if (m.find("InternetSlbPort") != m.end() && !m["InternetSlbPort"].empty()) {
      internetSlbPort = make_shared<long>(boost::any_cast<long>(m["InternetSlbPort"]));
    }
    if (m.find("InternetSlbProtocol") != m.end() && !m["InternetSlbProtocol"].empty()) {
      internetSlbProtocol = make_shared<string>(boost::any_cast<string>(m["InternetSlbProtocol"]));
    }
    if (m.find("InternetTargetPort") != m.end() && !m["InternetTargetPort"].empty()) {
      internetTargetPort = make_shared<long>(boost::any_cast<long>(m["InternetTargetPort"]));
    }
    if (m.find("IntranetSlbId") != m.end() && !m["IntranetSlbId"].empty()) {
      intranetSlbId = make_shared<string>(boost::any_cast<string>(m["IntranetSlbId"]));
    }
    if (m.find("IntranetSlbPort") != m.end() && !m["IntranetSlbPort"].empty()) {
      intranetSlbPort = make_shared<long>(boost::any_cast<long>(m["IntranetSlbPort"]));
    }
    if (m.find("IntranetSlbProtocol") != m.end() && !m["IntranetSlbProtocol"].empty()) {
      intranetSlbProtocol = make_shared<string>(boost::any_cast<string>(m["IntranetSlbProtocol"]));
    }
    if (m.find("IntranetTargetPort") != m.end() && !m["IntranetTargetPort"].empty()) {
      intranetTargetPort = make_shared<long>(boost::any_cast<long>(m["IntranetTargetPort"]));
    }
    if (m.find("IsMultilingualApp") != m.end() && !m["IsMultilingualApp"].empty()) {
      isMultilingualApp = make_shared<bool>(boost::any_cast<bool>(m["IsMultilingualApp"]));
    }
    if (m.find("JDK") != m.end() && !m["JDK"].empty()) {
      JDK = make_shared<string>(boost::any_cast<string>(m["JDK"]));
    }
    if (m.find("JavaStartUpConfig") != m.end() && !m["JavaStartUpConfig"].empty()) {
      javaStartUpConfig = make_shared<string>(boost::any_cast<string>(m["JavaStartUpConfig"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("LimitCpu") != m.end() && !m["LimitCpu"].empty()) {
      limitCpu = make_shared<long>(boost::any_cast<long>(m["LimitCpu"]));
    }
    if (m.find("LimitEphemeralStorage") != m.end() && !m["LimitEphemeralStorage"].empty()) {
      limitEphemeralStorage = make_shared<long>(boost::any_cast<long>(m["LimitEphemeralStorage"]));
    }
    if (m.find("LimitMem") != m.end() && !m["LimitMem"].empty()) {
      limitMem = make_shared<long>(boost::any_cast<long>(m["LimitMem"]));
    }
    if (m.find("LimitmCpu") != m.end() && !m["LimitmCpu"].empty()) {
      limitmCpu = make_shared<long>(boost::any_cast<long>(m["LimitmCpu"]));
    }
    if (m.find("Liveness") != m.end() && !m["Liveness"].empty()) {
      liveness = make_shared<string>(boost::any_cast<string>(m["Liveness"]));
    }
    if (m.find("LocalVolume") != m.end() && !m["LocalVolume"].empty()) {
      localVolume = make_shared<string>(boost::any_cast<string>(m["LocalVolume"]));
    }
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
    if (m.find("LosslessRuleAligned") != m.end() && !m["LosslessRuleAligned"].empty()) {
      losslessRuleAligned = make_shared<bool>(boost::any_cast<bool>(m["LosslessRuleAligned"]));
    }
    if (m.find("LosslessRuleDelayTime") != m.end() && !m["LosslessRuleDelayTime"].empty()) {
      losslessRuleDelayTime = make_shared<long>(boost::any_cast<long>(m["LosslessRuleDelayTime"]));
    }
    if (m.find("LosslessRuleFuncType") != m.end() && !m["LosslessRuleFuncType"].empty()) {
      losslessRuleFuncType = make_shared<long>(boost::any_cast<long>(m["LosslessRuleFuncType"]));
    }
    if (m.find("LosslessRuleRelated") != m.end() && !m["LosslessRuleRelated"].empty()) {
      losslessRuleRelated = make_shared<bool>(boost::any_cast<bool>(m["LosslessRuleRelated"]));
    }
    if (m.find("LosslessRuleWarmupTime") != m.end() && !m["LosslessRuleWarmupTime"].empty()) {
      losslessRuleWarmupTime = make_shared<long>(boost::any_cast<long>(m["LosslessRuleWarmupTime"]));
    }
    if (m.find("MountDescs") != m.end() && !m["MountDescs"].empty()) {
      mountDescs = make_shared<string>(boost::any_cast<string>(m["MountDescs"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NasId") != m.end() && !m["NasId"].empty()) {
      nasId = make_shared<string>(boost::any_cast<string>(m["NasId"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("PackageUrl") != m.end() && !m["PackageUrl"].empty()) {
      packageUrl = make_shared<string>(boost::any_cast<string>(m["PackageUrl"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
    if (m.find("PostStart") != m.end() && !m["PostStart"].empty()) {
      postStart = make_shared<string>(boost::any_cast<string>(m["PostStart"]));
    }
    if (m.find("PreStop") != m.end() && !m["PreStop"].empty()) {
      preStop = make_shared<string>(boost::any_cast<string>(m["PreStop"]));
    }
    if (m.find("PvcMountDescs") != m.end() && !m["PvcMountDescs"].empty()) {
      pvcMountDescs = make_shared<string>(boost::any_cast<string>(m["PvcMountDescs"]));
    }
    if (m.find("Readiness") != m.end() && !m["Readiness"].empty()) {
      readiness = make_shared<string>(boost::any_cast<string>(m["Readiness"]));
    }
    if (m.find("Replicas") != m.end() && !m["Replicas"].empty()) {
      replicas = make_shared<long>(boost::any_cast<long>(m["Replicas"]));
    }
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
    if (m.find("RequestsCpu") != m.end() && !m["RequestsCpu"].empty()) {
      requestsCpu = make_shared<long>(boost::any_cast<long>(m["RequestsCpu"]));
    }
    if (m.find("RequestsEphemeralStorage") != m.end() && !m["RequestsEphemeralStorage"].empty()) {
      requestsEphemeralStorage = make_shared<long>(boost::any_cast<long>(m["RequestsEphemeralStorage"]));
    }
    if (m.find("RequestsMem") != m.end() && !m["RequestsMem"].empty()) {
      requestsMem = make_shared<long>(boost::any_cast<long>(m["RequestsMem"]));
    }
    if (m.find("RequestsmCpu") != m.end() && !m["RequestsmCpu"].empty()) {
      requestsmCpu = make_shared<long>(boost::any_cast<long>(m["RequestsmCpu"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RuntimeClassName") != m.end() && !m["RuntimeClassName"].empty()) {
      runtimeClassName = make_shared<string>(boost::any_cast<string>(m["RuntimeClassName"]));
    }
    if (m.find("SecretName") != m.end() && !m["SecretName"].empty()) {
      secretName = make_shared<string>(boost::any_cast<string>(m["SecretName"]));
    }
    if (m.find("ServiceConfigs") != m.end() && !m["ServiceConfigs"].empty()) {
      serviceConfigs = make_shared<string>(boost::any_cast<string>(m["ServiceConfigs"]));
    }
    if (m.find("Sidecars") != m.end() && !m["Sidecars"].empty()) {
      sidecars = make_shared<string>(boost::any_cast<string>(m["Sidecars"]));
    }
    if (m.find("SlsConfigs") != m.end() && !m["SlsConfigs"].empty()) {
      slsConfigs = make_shared<string>(boost::any_cast<string>(m["SlsConfigs"]));
    }
    if (m.find("Startup") != m.end() && !m["Startup"].empty()) {
      startup = make_shared<string>(boost::any_cast<string>(m["Startup"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
    if (m.find("TerminateGracePeriod") != m.end() && !m["TerminateGracePeriod"].empty()) {
      terminateGracePeriod = make_shared<long>(boost::any_cast<long>(m["TerminateGracePeriod"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("UriEncoding") != m.end() && !m["UriEncoding"].empty()) {
      uriEncoding = make_shared<string>(boost::any_cast<string>(m["UriEncoding"]));
    }
    if (m.find("UseBodyEncoding") != m.end() && !m["UseBodyEncoding"].empty()) {
      useBodyEncoding = make_shared<bool>(boost::any_cast<bool>(m["UseBodyEncoding"]));
    }
    if (m.find("UserBaseImageUrl") != m.end() && !m["UserBaseImageUrl"].empty()) {
      userBaseImageUrl = make_shared<string>(boost::any_cast<string>(m["UserBaseImageUrl"]));
    }
    if (m.find("WebContainer") != m.end() && !m["WebContainer"].empty()) {
      webContainer = make_shared<string>(boost::any_cast<string>(m["WebContainer"]));
    }
    if (m.find("WebContainerConfig") != m.end() && !m["WebContainerConfig"].empty()) {
      webContainerConfig = make_shared<string>(boost::any_cast<string>(m["WebContainerConfig"]));
    }
    if (m.find("WorkloadType") != m.end() && !m["WorkloadType"].empty()) {
      workloadType = make_shared<string>(boost::any_cast<string>(m["WorkloadType"]));
    }
  }


  virtual ~InsertK8sApplicationRequest() = default;
};
class InsertK8sApplicationResponseBodyApplicationInfo : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> clusterType{};
  shared_ptr<bool> dockerize{};
  shared_ptr<string> edasId{};
  shared_ptr<string> owner{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userId{};

  InsertK8sApplicationResponseBodyApplicationInfo() {}

  explicit InsertK8sApplicationResponseBodyApplicationInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (dockerize) {
      res["Dockerize"] = boost::any(*dockerize);
    }
    if (edasId) {
      res["EdasId"] = boost::any(*edasId);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<long>(boost::any_cast<long>(m["ClusterType"]));
    }
    if (m.find("Dockerize") != m.end() && !m["Dockerize"].empty()) {
      dockerize = make_shared<bool>(boost::any_cast<bool>(m["Dockerize"]));
    }
    if (m.find("EdasId") != m.end() && !m["EdasId"].empty()) {
      edasId = make_shared<string>(boost::any_cast<string>(m["EdasId"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~InsertK8sApplicationResponseBodyApplicationInfo() = default;
};
class InsertK8sApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<InsertK8sApplicationResponseBodyApplicationInfo> applicationInfo{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  InsertK8sApplicationResponseBody() {}

  explicit InsertK8sApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationInfo) {
      res["ApplicationInfo"] = applicationInfo ? boost::any(applicationInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationInfo") != m.end() && !m["ApplicationInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplicationInfo"].type()) {
        InsertK8sApplicationResponseBodyApplicationInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplicationInfo"]));
        applicationInfo = make_shared<InsertK8sApplicationResponseBodyApplicationInfo>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InsertK8sApplicationResponseBody() = default;
};
class InsertK8sApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsertK8sApplicationResponseBody> body{};

  InsertK8sApplicationResponse() {}

  explicit InsertK8sApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertK8sApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertK8sApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~InsertK8sApplicationResponse() = default;
};
class InsertOrUpdateRegionRequest : public Darabonba::Model {
public:
  shared_ptr<bool> debugEnable{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> mseInstanceId{};
  shared_ptr<string> regionName{};
  shared_ptr<string> regionTag{};
  shared_ptr<string> registryType{};

  InsertOrUpdateRegionRequest() {}

  explicit InsertOrUpdateRegionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (debugEnable) {
      res["DebugEnable"] = boost::any(*debugEnable);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mseInstanceId) {
      res["MseInstanceId"] = boost::any(*mseInstanceId);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (regionTag) {
      res["RegionTag"] = boost::any(*regionTag);
    }
    if (registryType) {
      res["RegistryType"] = boost::any(*registryType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DebugEnable") != m.end() && !m["DebugEnable"].empty()) {
      debugEnable = make_shared<bool>(boost::any_cast<bool>(m["DebugEnable"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MseInstanceId") != m.end() && !m["MseInstanceId"].empty()) {
      mseInstanceId = make_shared<string>(boost::any_cast<string>(m["MseInstanceId"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("RegionTag") != m.end() && !m["RegionTag"].empty()) {
      regionTag = make_shared<string>(boost::any_cast<string>(m["RegionTag"]));
    }
    if (m.find("RegistryType") != m.end() && !m["RegistryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["RegistryType"]));
    }
  }


  virtual ~InsertOrUpdateRegionRequest() = default;
};
class InsertOrUpdateRegionResponseBodyUserDefineRegionEntity : public Darabonba::Model {
public:
  shared_ptr<string> belongRegion{};
  shared_ptr<bool> debugEnable{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> regionId{};
  shared_ptr<string> regionName{};
  shared_ptr<string> userId{};

  InsertOrUpdateRegionResponseBodyUserDefineRegionEntity() {}

  explicit InsertOrUpdateRegionResponseBodyUserDefineRegionEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (belongRegion) {
      res["BelongRegion"] = boost::any(*belongRegion);
    }
    if (debugEnable) {
      res["DebugEnable"] = boost::any(*debugEnable);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BelongRegion") != m.end() && !m["BelongRegion"].empty()) {
      belongRegion = make_shared<string>(boost::any_cast<string>(m["BelongRegion"]));
    }
    if (m.find("DebugEnable") != m.end() && !m["DebugEnable"].empty()) {
      debugEnable = make_shared<bool>(boost::any_cast<bool>(m["DebugEnable"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~InsertOrUpdateRegionResponseBodyUserDefineRegionEntity() = default;
};
class InsertOrUpdateRegionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<InsertOrUpdateRegionResponseBodyUserDefineRegionEntity> userDefineRegionEntity{};

  InsertOrUpdateRegionResponseBody() {}

  explicit InsertOrUpdateRegionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userDefineRegionEntity) {
      res["UserDefineRegionEntity"] = userDefineRegionEntity ? boost::any(userDefineRegionEntity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserDefineRegionEntity") != m.end() && !m["UserDefineRegionEntity"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserDefineRegionEntity"].type()) {
        InsertOrUpdateRegionResponseBodyUserDefineRegionEntity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserDefineRegionEntity"]));
        userDefineRegionEntity = make_shared<InsertOrUpdateRegionResponseBodyUserDefineRegionEntity>(model1);
      }
    }
  }


  virtual ~InsertOrUpdateRegionResponseBody() = default;
};
class InsertOrUpdateRegionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsertOrUpdateRegionResponseBody> body{};

  InsertOrUpdateRegionResponse() {}

  explicit InsertOrUpdateRegionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertOrUpdateRegionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertOrUpdateRegionResponseBody>(model1);
      }
    }
  }


  virtual ~InsertOrUpdateRegionResponse() = default;
};
class InsertRoleRequest : public Darabonba::Model {
public:
  shared_ptr<string> actionData{};
  shared_ptr<string> roleName{};

  InsertRoleRequest() {}

  explicit InsertRoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionData) {
      res["ActionData"] = boost::any(*actionData);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionData") != m.end() && !m["ActionData"].empty()) {
      actionData = make_shared<string>(boost::any_cast<string>(m["ActionData"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
  }


  virtual ~InsertRoleRequest() = default;
};
class InsertRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> roleId{};

  InsertRoleResponseBody() {}

  explicit InsertRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<long>(boost::any_cast<long>(m["RoleId"]));
    }
  }


  virtual ~InsertRoleResponseBody() = default;
};
class InsertRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsertRoleResponseBody> body{};

  InsertRoleResponse() {}

  explicit InsertRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertRoleResponseBody>(model1);
      }
    }
  }


  virtual ~InsertRoleResponse() = default;
};
class InsertServiceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};

  InsertServiceGroupRequest() {}

  explicit InsertServiceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~InsertServiceGroupRequest() = default;
};
class InsertServiceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  InsertServiceGroupResponseBody() {}

  explicit InsertServiceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InsertServiceGroupResponseBody() = default;
};
class InsertServiceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsertServiceGroupResponseBody> body{};

  InsertServiceGroupResponse() {}

  explicit InsertServiceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertServiceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertServiceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~InsertServiceGroupResponse() = default;
};
class InsertSwimmingLaneRequest : public Darabonba::Model {
public:
  shared_ptr<string> appInfos{};
  shared_ptr<bool> enableRules{};
  shared_ptr<string> entryRules{};
  shared_ptr<long> groupId{};
  shared_ptr<string> logicalRegionId{};
  shared_ptr<string> name{};
  shared_ptr<string> tag{};

  InsertSwimmingLaneRequest() {}

  explicit InsertSwimmingLaneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appInfos) {
      res["AppInfos"] = boost::any(*appInfos);
    }
    if (enableRules) {
      res["EnableRules"] = boost::any(*enableRules);
    }
    if (entryRules) {
      res["EntryRules"] = boost::any(*entryRules);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppInfos") != m.end() && !m["AppInfos"].empty()) {
      appInfos = make_shared<string>(boost::any_cast<string>(m["AppInfos"]));
    }
    if (m.find("EnableRules") != m.end() && !m["EnableRules"].empty()) {
      enableRules = make_shared<bool>(boost::any_cast<bool>(m["EnableRules"]));
    }
    if (m.find("EntryRules") != m.end() && !m["EntryRules"].empty()) {
      entryRules = make_shared<string>(boost::any_cast<string>(m["EntryRules"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~InsertSwimmingLaneRequest() = default;
};
class InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> laneId{};
  shared_ptr<string> rules{};

  InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList() {}

  explicit InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (laneId) {
      res["LaneId"] = boost::any(*laneId);
    }
    if (rules) {
      res["Rules"] = boost::any(*rules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("LaneId") != m.end() && !m["LaneId"].empty()) {
      laneId = make_shared<long>(boost::any_cast<long>(m["LaneId"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rules = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
  }


  virtual ~InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList() = default;
};
class InsertSwimmingLaneResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appInfos{};
  shared_ptr<string> entryRule{};
  shared_ptr<long> groupId{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> namespaceId{};
  shared_ptr<vector<InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList>> swimmingLaneAppRelationShipList{};
  shared_ptr<string> tag{};

  InsertSwimmingLaneResponseBodyData() {}

  explicit InsertSwimmingLaneResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appInfos) {
      res["AppInfos"] = boost::any(*appInfos);
    }
    if (entryRule) {
      res["EntryRule"] = boost::any(*entryRule);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (swimmingLaneAppRelationShipList) {
      vector<boost::any> temp1;
      for(auto item1:*swimmingLaneAppRelationShipList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SwimmingLaneAppRelationShipList"] = boost::any(temp1);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppInfos") != m.end() && !m["AppInfos"].empty()) {
      appInfos = make_shared<string>(boost::any_cast<string>(m["AppInfos"]));
    }
    if (m.find("EntryRule") != m.end() && !m["EntryRule"].empty()) {
      entryRule = make_shared<string>(boost::any_cast<string>(m["EntryRule"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("SwimmingLaneAppRelationShipList") != m.end() && !m["SwimmingLaneAppRelationShipList"].empty()) {
      if (typeid(vector<boost::any>) == m["SwimmingLaneAppRelationShipList"].type()) {
        vector<InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SwimmingLaneAppRelationShipList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        swimmingLaneAppRelationShipList = make_shared<vector<InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList>>(expect1);
      }
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~InsertSwimmingLaneResponseBodyData() = default;
};
class InsertSwimmingLaneResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<InsertSwimmingLaneResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  InsertSwimmingLaneResponseBody() {}

  explicit InsertSwimmingLaneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        InsertSwimmingLaneResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<InsertSwimmingLaneResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InsertSwimmingLaneResponseBody() = default;
};
class InsertSwimmingLaneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsertSwimmingLaneResponseBody> body{};

  InsertSwimmingLaneResponse() {}

  explicit InsertSwimmingLaneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertSwimmingLaneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertSwimmingLaneResponseBody>(model1);
      }
    }
  }


  virtual ~InsertSwimmingLaneResponse() = default;
};
class InsertSwimmingLaneGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appIds{};
  shared_ptr<string> entryApp{};
  shared_ptr<string> logicalRegionId{};
  shared_ptr<string> name{};

  InsertSwimmingLaneGroupRequest() {}

  explicit InsertSwimmingLaneGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (entryApp) {
      res["EntryApp"] = boost::any(*entryApp);
    }
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      appIds = make_shared<string>(boost::any_cast<string>(m["AppIds"]));
    }
    if (m.find("EntryApp") != m.end() && !m["EntryApp"].empty()) {
      entryApp = make_shared<string>(boost::any_cast<string>(m["EntryApp"]));
    }
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~InsertSwimmingLaneGroupRequest() = default;
};
class InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};

  InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication() {}

  explicit InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
  }


  virtual ~InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication() = default;
};
class InsertSwimmingLaneGroupResponseBodyDataApplicationList : public Darabonba::Model {
public:
  shared_ptr<vector<InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication>> application{};

  InsertSwimmingLaneGroupResponseBodyDataApplicationList() {}

  explicit InsertSwimmingLaneGroupResponseBodyDataApplicationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (application) {
      vector<boost::any> temp1;
      for(auto item1:*application){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Application"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Application") != m.end() && !m["Application"].empty()) {
      if (typeid(vector<boost::any>) == m["Application"].type()) {
        vector<InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Application"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        application = make_shared<vector<InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication>>(expect1);
      }
    }
  }


  virtual ~InsertSwimmingLaneGroupResponseBodyDataApplicationList() = default;
};
class InsertSwimmingLaneGroupResponseBodyDataEntryApplication : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};

  InsertSwimmingLaneGroupResponseBodyDataEntryApplication() {}

  explicit InsertSwimmingLaneGroupResponseBodyDataEntryApplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
  }


  virtual ~InsertSwimmingLaneGroupResponseBodyDataEntryApplication() = default;
};
class InsertSwimmingLaneGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<InsertSwimmingLaneGroupResponseBodyDataApplicationList> applicationList{};
  shared_ptr<InsertSwimmingLaneGroupResponseBodyDataEntryApplication> entryApplication{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> namespaceId{};

  InsertSwimmingLaneGroupResponseBodyData() {}

  explicit InsertSwimmingLaneGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationList) {
      res["ApplicationList"] = applicationList ? boost::any(applicationList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (entryApplication) {
      res["EntryApplication"] = entryApplication ? boost::any(entryApplication->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationList") != m.end() && !m["ApplicationList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplicationList"].type()) {
        InsertSwimmingLaneGroupResponseBodyDataApplicationList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplicationList"]));
        applicationList = make_shared<InsertSwimmingLaneGroupResponseBodyDataApplicationList>(model1);
      }
    }
    if (m.find("EntryApplication") != m.end() && !m["EntryApplication"].empty()) {
      if (typeid(map<string, boost::any>) == m["EntryApplication"].type()) {
        InsertSwimmingLaneGroupResponseBodyDataEntryApplication model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EntryApplication"]));
        entryApplication = make_shared<InsertSwimmingLaneGroupResponseBodyDataEntryApplication>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~InsertSwimmingLaneGroupResponseBodyData() = default;
};
class InsertSwimmingLaneGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<InsertSwimmingLaneGroupResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  InsertSwimmingLaneGroupResponseBody() {}

  explicit InsertSwimmingLaneGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        InsertSwimmingLaneGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<InsertSwimmingLaneGroupResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InsertSwimmingLaneGroupResponseBody() = default;
};
class InsertSwimmingLaneGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsertSwimmingLaneGroupResponseBody> body{};

  InsertSwimmingLaneGroupResponse() {}

  explicit InsertSwimmingLaneGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertSwimmingLaneGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertSwimmingLaneGroupResponseBody>(model1);
      }
    }
  }


  virtual ~InsertSwimmingLaneGroupResponse() = default;
};
class InstallAgentRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<bool> doAsync{};
  shared_ptr<string> instanceIds{};

  InstallAgentRequest() {}

  explicit InstallAgentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (doAsync) {
      res["DoAsync"] = boost::any(*doAsync);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DoAsync") != m.end() && !m["DoAsync"].empty()) {
      doAsync = make_shared<bool>(boost::any_cast<bool>(m["DoAsync"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
  }


  virtual ~InstallAgentRequest() = default;
};
class InstallAgentResponseBodyExecutionResultListExecutionResult : public Darabonba::Model {
public:
  shared_ptr<string> finishedTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> invokeRecordStatus{};
  shared_ptr<string> status{};
  shared_ptr<bool> success{};

  InstallAgentResponseBodyExecutionResultListExecutionResult() {}

  explicit InstallAgentResponseBodyExecutionResultListExecutionResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (invokeRecordStatus) {
      res["InvokeRecordStatus"] = boost::any(*invokeRecordStatus);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<string>(boost::any_cast<string>(m["FinishedTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InvokeRecordStatus") != m.end() && !m["InvokeRecordStatus"].empty()) {
      invokeRecordStatus = make_shared<string>(boost::any_cast<string>(m["InvokeRecordStatus"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InstallAgentResponseBodyExecutionResultListExecutionResult() = default;
};
class InstallAgentResponseBodyExecutionResultList : public Darabonba::Model {
public:
  shared_ptr<vector<InstallAgentResponseBodyExecutionResultListExecutionResult>> executionResult{};

  InstallAgentResponseBodyExecutionResultList() {}

  explicit InstallAgentResponseBodyExecutionResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (executionResult) {
      vector<boost::any> temp1;
      for(auto item1:*executionResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExecutionResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExecutionResult") != m.end() && !m["ExecutionResult"].empty()) {
      if (typeid(vector<boost::any>) == m["ExecutionResult"].type()) {
        vector<InstallAgentResponseBodyExecutionResultListExecutionResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExecutionResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InstallAgentResponseBodyExecutionResultListExecutionResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        executionResult = make_shared<vector<InstallAgentResponseBodyExecutionResultListExecutionResult>>(expect1);
      }
    }
  }


  virtual ~InstallAgentResponseBodyExecutionResultList() = default;
};
class InstallAgentResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<InstallAgentResponseBodyExecutionResultList> executionResultList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  InstallAgentResponseBody() {}

  explicit InstallAgentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (executionResultList) {
      res["ExecutionResultList"] = executionResultList ? boost::any(executionResultList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("ExecutionResultList") != m.end() && !m["ExecutionResultList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExecutionResultList"].type()) {
        InstallAgentResponseBodyExecutionResultList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExecutionResultList"]));
        executionResultList = make_shared<InstallAgentResponseBodyExecutionResultList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InstallAgentResponseBody() = default;
};
class InstallAgentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstallAgentResponseBody> body{};

  InstallAgentResponse() {}

  explicit InstallAgentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallAgentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallAgentResponseBody>(model1);
      }
    }
  }


  virtual ~InstallAgentResponse() = default;
};
class ListAliyunRegionResponseBodyRegionEntityListRegionEntity : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  ListAliyunRegionResponseBodyRegionEntityListRegionEntity() {}

  explicit ListAliyunRegionResponseBodyRegionEntityListRegionEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListAliyunRegionResponseBodyRegionEntityListRegionEntity() = default;
};
class ListAliyunRegionResponseBodyRegionEntityList : public Darabonba::Model {
public:
  shared_ptr<vector<ListAliyunRegionResponseBodyRegionEntityListRegionEntity>> regionEntity{};

  ListAliyunRegionResponseBodyRegionEntityList() {}

  explicit ListAliyunRegionResponseBodyRegionEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionEntity) {
      vector<boost::any> temp1;
      for(auto item1:*regionEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegionEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionEntity") != m.end() && !m["RegionEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["RegionEntity"].type()) {
        vector<ListAliyunRegionResponseBodyRegionEntityListRegionEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegionEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAliyunRegionResponseBodyRegionEntityListRegionEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regionEntity = make_shared<vector<ListAliyunRegionResponseBodyRegionEntityListRegionEntity>>(expect1);
      }
    }
  }


  virtual ~ListAliyunRegionResponseBodyRegionEntityList() = default;
};
class ListAliyunRegionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<ListAliyunRegionResponseBodyRegionEntityList> regionEntityList{};
  shared_ptr<string> requestId{};

  ListAliyunRegionResponseBody() {}

  explicit ListAliyunRegionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (regionEntityList) {
      res["RegionEntityList"] = regionEntityList ? boost::any(regionEntityList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RegionEntityList") != m.end() && !m["RegionEntityList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegionEntityList"].type()) {
        ListAliyunRegionResponseBodyRegionEntityList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegionEntityList"]));
        regionEntityList = make_shared<ListAliyunRegionResponseBodyRegionEntityList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAliyunRegionResponseBody() = default;
};
class ListAliyunRegionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAliyunRegionResponseBody> body{};

  ListAliyunRegionResponse() {}

  explicit ListAliyunRegionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAliyunRegionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAliyunRegionResponseBody>(model1);
      }
    }
  }


  virtual ~ListAliyunRegionResponse() = default;
};
class ListApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appIds{};
  shared_ptr<string> appName{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> logicalRegionId{};
  shared_ptr<string> logicalRegionIdFilter{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};

  ListApplicationRequest() {}

  explicit ListApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    if (logicalRegionIdFilter) {
      res["LogicalRegionIdFilter"] = boost::any(*logicalRegionIdFilter);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      appIds = make_shared<string>(boost::any_cast<string>(m["AppIds"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
    if (m.find("LogicalRegionIdFilter") != m.end() && !m["LogicalRegionIdFilter"].empty()) {
      logicalRegionIdFilter = make_shared<string>(boost::any_cast<string>(m["LogicalRegionIdFilter"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListApplicationRequest() = default;
};
class ListApplicationResponseBodyApplicationListApplication : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> applicationType{};
  shared_ptr<long> buildPackageId{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> clusterType{};
  shared_ptr<long> createTime{};
  shared_ptr<string> extSlbIp{};
  shared_ptr<long> extSlbListenerPort{};
  shared_ptr<long> instances{};
  shared_ptr<string> k8sNamespace{};
  shared_ptr<string> name{};
  shared_ptr<string> namespaceId{};
  shared_ptr<long> port{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> runningInstanceCount{};
  shared_ptr<string> slbIp{};
  shared_ptr<long> slbListenerPort{};
  shared_ptr<long> slbPort{};
  shared_ptr<string> state{};

  ListApplicationResponseBodyApplicationListApplication() {}

  explicit ListApplicationResponseBodyApplicationListApplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (applicationType) {
      res["ApplicationType"] = boost::any(*applicationType);
    }
    if (buildPackageId) {
      res["BuildPackageId"] = boost::any(*buildPackageId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (extSlbIp) {
      res["ExtSlbIp"] = boost::any(*extSlbIp);
    }
    if (extSlbListenerPort) {
      res["ExtSlbListenerPort"] = boost::any(*extSlbListenerPort);
    }
    if (instances) {
      res["Instances"] = boost::any(*instances);
    }
    if (k8sNamespace) {
      res["K8sNamespace"] = boost::any(*k8sNamespace);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (runningInstanceCount) {
      res["RunningInstanceCount"] = boost::any(*runningInstanceCount);
    }
    if (slbIp) {
      res["SlbIp"] = boost::any(*slbIp);
    }
    if (slbListenerPort) {
      res["SlbListenerPort"] = boost::any(*slbListenerPort);
    }
    if (slbPort) {
      res["SlbPort"] = boost::any(*slbPort);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ApplicationType") != m.end() && !m["ApplicationType"].empty()) {
      applicationType = make_shared<string>(boost::any_cast<string>(m["ApplicationType"]));
    }
    if (m.find("BuildPackageId") != m.end() && !m["BuildPackageId"].empty()) {
      buildPackageId = make_shared<long>(boost::any_cast<long>(m["BuildPackageId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<long>(boost::any_cast<long>(m["ClusterType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ExtSlbIp") != m.end() && !m["ExtSlbIp"].empty()) {
      extSlbIp = make_shared<string>(boost::any_cast<string>(m["ExtSlbIp"]));
    }
    if (m.find("ExtSlbListenerPort") != m.end() && !m["ExtSlbListenerPort"].empty()) {
      extSlbListenerPort = make_shared<long>(boost::any_cast<long>(m["ExtSlbListenerPort"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      instances = make_shared<long>(boost::any_cast<long>(m["Instances"]));
    }
    if (m.find("K8sNamespace") != m.end() && !m["K8sNamespace"].empty()) {
      k8sNamespace = make_shared<string>(boost::any_cast<string>(m["K8sNamespace"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RunningInstanceCount") != m.end() && !m["RunningInstanceCount"].empty()) {
      runningInstanceCount = make_shared<long>(boost::any_cast<long>(m["RunningInstanceCount"]));
    }
    if (m.find("SlbIp") != m.end() && !m["SlbIp"].empty()) {
      slbIp = make_shared<string>(boost::any_cast<string>(m["SlbIp"]));
    }
    if (m.find("SlbListenerPort") != m.end() && !m["SlbListenerPort"].empty()) {
      slbListenerPort = make_shared<long>(boost::any_cast<long>(m["SlbListenerPort"]));
    }
    if (m.find("SlbPort") != m.end() && !m["SlbPort"].empty()) {
      slbPort = make_shared<long>(boost::any_cast<long>(m["SlbPort"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListApplicationResponseBodyApplicationListApplication() = default;
};
class ListApplicationResponseBodyApplicationList : public Darabonba::Model {
public:
  shared_ptr<vector<ListApplicationResponseBodyApplicationListApplication>> application{};

  ListApplicationResponseBodyApplicationList() {}

  explicit ListApplicationResponseBodyApplicationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (application) {
      vector<boost::any> temp1;
      for(auto item1:*application){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Application"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Application") != m.end() && !m["Application"].empty()) {
      if (typeid(vector<boost::any>) == m["Application"].type()) {
        vector<ListApplicationResponseBodyApplicationListApplication> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Application"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationResponseBodyApplicationListApplication model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        application = make_shared<vector<ListApplicationResponseBodyApplicationListApplication>>(expect1);
      }
    }
  }


  virtual ~ListApplicationResponseBodyApplicationList() = default;
};
class ListApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListApplicationResponseBodyApplicationList> applicationList{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListApplicationResponseBody() {}

  explicit ListApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationList) {
      res["ApplicationList"] = applicationList ? boost::any(applicationList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationList") != m.end() && !m["ApplicationList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplicationList"].type()) {
        ListApplicationResponseBodyApplicationList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplicationList"]));
        applicationList = make_shared<ListApplicationResponseBodyApplicationList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListApplicationResponseBody() = default;
};
class ListApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListApplicationResponseBody> body{};

  ListApplicationResponse() {}

  explicit ListApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~ListApplicationResponse() = default;
};
class ListApplicationEcuRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> logicalRegionId{};

  ListApplicationEcuRequest() {}

  explicit ListApplicationEcuRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
  }


  virtual ~ListApplicationEcuRequest() = default;
};
class ListApplicationEcuResponseBodyEcuInfoListEcuEntity : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> availableCpu{};
  shared_ptr<long> availableMem{};
  shared_ptr<long> cpu{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> dockerEnv{};
  shared_ptr<string> ecuId{};
  shared_ptr<long> heartbeatTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ipAddr{};
  shared_ptr<long> mem{};
  shared_ptr<string> name{};
  shared_ptr<bool> online{};
  shared_ptr<string> regionId{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zoneId{};

  ListApplicationEcuResponseBodyEcuInfoListEcuEntity() {}

  explicit ListApplicationEcuResponseBodyEcuInfoListEcuEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (availableCpu) {
      res["AvailableCpu"] = boost::any(*availableCpu);
    }
    if (availableMem) {
      res["AvailableMem"] = boost::any(*availableMem);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dockerEnv) {
      res["DockerEnv"] = boost::any(*dockerEnv);
    }
    if (ecuId) {
      res["EcuId"] = boost::any(*ecuId);
    }
    if (heartbeatTime) {
      res["HeartbeatTime"] = boost::any(*heartbeatTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ipAddr) {
      res["IpAddr"] = boost::any(*ipAddr);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AvailableCpu") != m.end() && !m["AvailableCpu"].empty()) {
      availableCpu = make_shared<long>(boost::any_cast<long>(m["AvailableCpu"]));
    }
    if (m.find("AvailableMem") != m.end() && !m["AvailableMem"].empty()) {
      availableMem = make_shared<long>(boost::any_cast<long>(m["AvailableMem"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DockerEnv") != m.end() && !m["DockerEnv"].empty()) {
      dockerEnv = make_shared<bool>(boost::any_cast<bool>(m["DockerEnv"]));
    }
    if (m.find("EcuId") != m.end() && !m["EcuId"].empty()) {
      ecuId = make_shared<string>(boost::any_cast<string>(m["EcuId"]));
    }
    if (m.find("HeartbeatTime") != m.end() && !m["HeartbeatTime"].empty()) {
      heartbeatTime = make_shared<long>(boost::any_cast<long>(m["HeartbeatTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IpAddr") != m.end() && !m["IpAddr"].empty()) {
      ipAddr = make_shared<string>(boost::any_cast<string>(m["IpAddr"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<bool>(boost::any_cast<bool>(m["Online"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~ListApplicationEcuResponseBodyEcuInfoListEcuEntity() = default;
};
class ListApplicationEcuResponseBodyEcuInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<ListApplicationEcuResponseBodyEcuInfoListEcuEntity>> ecuEntity{};

  ListApplicationEcuResponseBodyEcuInfoList() {}

  explicit ListApplicationEcuResponseBodyEcuInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecuEntity) {
      vector<boost::any> temp1;
      for(auto item1:*ecuEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EcuEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcuEntity") != m.end() && !m["EcuEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["EcuEntity"].type()) {
        vector<ListApplicationEcuResponseBodyEcuInfoListEcuEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EcuEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationEcuResponseBodyEcuInfoListEcuEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ecuEntity = make_shared<vector<ListApplicationEcuResponseBodyEcuInfoListEcuEntity>>(expect1);
      }
    }
  }


  virtual ~ListApplicationEcuResponseBodyEcuInfoList() = default;
};
class ListApplicationEcuResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListApplicationEcuResponseBodyEcuInfoList> ecuInfoList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListApplicationEcuResponseBody() {}

  explicit ListApplicationEcuResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (ecuInfoList) {
      res["EcuInfoList"] = ecuInfoList ? boost::any(ecuInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("EcuInfoList") != m.end() && !m["EcuInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EcuInfoList"].type()) {
        ListApplicationEcuResponseBodyEcuInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EcuInfoList"]));
        ecuInfoList = make_shared<ListApplicationEcuResponseBodyEcuInfoList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListApplicationEcuResponseBody() = default;
};
class ListApplicationEcuResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListApplicationEcuResponseBody> body{};

  ListApplicationEcuResponse() {}

  explicit ListApplicationEcuResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApplicationEcuResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApplicationEcuResponseBody>(model1);
      }
    }
  }


  virtual ~ListApplicationEcuResponse() = default;
};
class ListAuthorityResponseBodyAuthorityListAuthorityActionListAction : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> name{};

  ListAuthorityResponseBodyAuthorityListAuthorityActionListAction() {}

  explicit ListAuthorityResponseBodyAuthorityListAuthorityActionListAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListAuthorityResponseBodyAuthorityListAuthorityActionListAction() = default;
};
class ListAuthorityResponseBodyAuthorityListAuthorityActionList : public Darabonba::Model {
public:
  shared_ptr<vector<ListAuthorityResponseBodyAuthorityListAuthorityActionListAction>> action{};

  ListAuthorityResponseBodyAuthorityListAuthorityActionList() {}

  explicit ListAuthorityResponseBodyAuthorityListAuthorityActionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      vector<boost::any> temp1;
      for(auto item1:*action){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Action"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      if (typeid(vector<boost::any>) == m["Action"].type()) {
        vector<ListAuthorityResponseBodyAuthorityListAuthorityActionListAction> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Action"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAuthorityResponseBodyAuthorityListAuthorityActionListAction model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        action = make_shared<vector<ListAuthorityResponseBodyAuthorityListAuthorityActionListAction>>(expect1);
      }
    }
  }


  virtual ~ListAuthorityResponseBodyAuthorityListAuthorityActionList() = default;
};
class ListAuthorityResponseBodyAuthorityListAuthority : public Darabonba::Model {
public:
  shared_ptr<ListAuthorityResponseBodyAuthorityListAuthorityActionList> actionList{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> name{};

  ListAuthorityResponseBodyAuthorityListAuthority() {}

  explicit ListAuthorityResponseBodyAuthorityListAuthority(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionList) {
      res["ActionList"] = actionList ? boost::any(actionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionList") != m.end() && !m["ActionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ActionList"].type()) {
        ListAuthorityResponseBodyAuthorityListAuthorityActionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ActionList"]));
        actionList = make_shared<ListAuthorityResponseBodyAuthorityListAuthorityActionList>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListAuthorityResponseBodyAuthorityListAuthority() = default;
};
class ListAuthorityResponseBodyAuthorityList : public Darabonba::Model {
public:
  shared_ptr<vector<ListAuthorityResponseBodyAuthorityListAuthority>> authority{};

  ListAuthorityResponseBodyAuthorityList() {}

  explicit ListAuthorityResponseBodyAuthorityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authority) {
      vector<boost::any> temp1;
      for(auto item1:*authority){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Authority"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Authority") != m.end() && !m["Authority"].empty()) {
      if (typeid(vector<boost::any>) == m["Authority"].type()) {
        vector<ListAuthorityResponseBodyAuthorityListAuthority> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Authority"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAuthorityResponseBodyAuthorityListAuthority model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authority = make_shared<vector<ListAuthorityResponseBodyAuthorityListAuthority>>(expect1);
      }
    }
  }


  virtual ~ListAuthorityResponseBodyAuthorityList() = default;
};
class ListAuthorityResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListAuthorityResponseBodyAuthorityList> authorityList{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListAuthorityResponseBody() {}

  explicit ListAuthorityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorityList) {
      res["AuthorityList"] = authorityList ? boost::any(authorityList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorityList") != m.end() && !m["AuthorityList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthorityList"].type()) {
        ListAuthorityResponseBodyAuthorityList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthorityList"]));
        authorityList = make_shared<ListAuthorityResponseBodyAuthorityList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAuthorityResponseBody() = default;
};
class ListAuthorityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAuthorityResponseBody> body{};

  ListAuthorityResponse() {}

  explicit ListAuthorityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAuthorityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAuthorityResponseBody>(model1);
      }
    }
  }


  virtual ~ListAuthorityResponse() = default;
};
class ListBuildPackResponseBodyBuildPackListBuildPack : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<bool> disabled{};
  shared_ptr<string> feature{};
  shared_ptr<string> imageId{};
  shared_ptr<bool> multipleTenant{};
  shared_ptr<string> packVersion{};
  shared_ptr<string> pandoraDesc{};
  shared_ptr<string> pandoraDownloadUrl{};
  shared_ptr<string> pandoraVersion{};
  shared_ptr<string> pluginInfo{};
  shared_ptr<string> scriptName{};
  shared_ptr<string> scriptVersion{};
  shared_ptr<string> supportFeatures{};
  shared_ptr<string> tengineDownloadUrl{};
  shared_ptr<string> tengineImageId{};
  shared_ptr<string> tomcatDesc{};
  shared_ptr<string> tomcatDownloadUrl{};
  shared_ptr<string> tomcatPath{};
  shared_ptr<string> tomcatVersion{};
  shared_ptr<bool> withTengine{};

  ListBuildPackResponseBodyBuildPackListBuildPack() {}

  explicit ListBuildPackResponseBodyBuildPackListBuildPack(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (disabled) {
      res["Disabled"] = boost::any(*disabled);
    }
    if (feature) {
      res["Feature"] = boost::any(*feature);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (multipleTenant) {
      res["MultipleTenant"] = boost::any(*multipleTenant);
    }
    if (packVersion) {
      res["PackVersion"] = boost::any(*packVersion);
    }
    if (pandoraDesc) {
      res["PandoraDesc"] = boost::any(*pandoraDesc);
    }
    if (pandoraDownloadUrl) {
      res["PandoraDownloadUrl"] = boost::any(*pandoraDownloadUrl);
    }
    if (pandoraVersion) {
      res["PandoraVersion"] = boost::any(*pandoraVersion);
    }
    if (pluginInfo) {
      res["PluginInfo"] = boost::any(*pluginInfo);
    }
    if (scriptName) {
      res["ScriptName"] = boost::any(*scriptName);
    }
    if (scriptVersion) {
      res["ScriptVersion"] = boost::any(*scriptVersion);
    }
    if (supportFeatures) {
      res["SupportFeatures"] = boost::any(*supportFeatures);
    }
    if (tengineDownloadUrl) {
      res["TengineDownloadUrl"] = boost::any(*tengineDownloadUrl);
    }
    if (tengineImageId) {
      res["TengineImageId"] = boost::any(*tengineImageId);
    }
    if (tomcatDesc) {
      res["TomcatDesc"] = boost::any(*tomcatDesc);
    }
    if (tomcatDownloadUrl) {
      res["TomcatDownloadUrl"] = boost::any(*tomcatDownloadUrl);
    }
    if (tomcatPath) {
      res["TomcatPath"] = boost::any(*tomcatPath);
    }
    if (tomcatVersion) {
      res["TomcatVersion"] = boost::any(*tomcatVersion);
    }
    if (withTengine) {
      res["WithTengine"] = boost::any(*withTengine);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Disabled") != m.end() && !m["Disabled"].empty()) {
      disabled = make_shared<bool>(boost::any_cast<bool>(m["Disabled"]));
    }
    if (m.find("Feature") != m.end() && !m["Feature"].empty()) {
      feature = make_shared<string>(boost::any_cast<string>(m["Feature"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("MultipleTenant") != m.end() && !m["MultipleTenant"].empty()) {
      multipleTenant = make_shared<bool>(boost::any_cast<bool>(m["MultipleTenant"]));
    }
    if (m.find("PackVersion") != m.end() && !m["PackVersion"].empty()) {
      packVersion = make_shared<string>(boost::any_cast<string>(m["PackVersion"]));
    }
    if (m.find("PandoraDesc") != m.end() && !m["PandoraDesc"].empty()) {
      pandoraDesc = make_shared<string>(boost::any_cast<string>(m["PandoraDesc"]));
    }
    if (m.find("PandoraDownloadUrl") != m.end() && !m["PandoraDownloadUrl"].empty()) {
      pandoraDownloadUrl = make_shared<string>(boost::any_cast<string>(m["PandoraDownloadUrl"]));
    }
    if (m.find("PandoraVersion") != m.end() && !m["PandoraVersion"].empty()) {
      pandoraVersion = make_shared<string>(boost::any_cast<string>(m["PandoraVersion"]));
    }
    if (m.find("PluginInfo") != m.end() && !m["PluginInfo"].empty()) {
      pluginInfo = make_shared<string>(boost::any_cast<string>(m["PluginInfo"]));
    }
    if (m.find("ScriptName") != m.end() && !m["ScriptName"].empty()) {
      scriptName = make_shared<string>(boost::any_cast<string>(m["ScriptName"]));
    }
    if (m.find("ScriptVersion") != m.end() && !m["ScriptVersion"].empty()) {
      scriptVersion = make_shared<string>(boost::any_cast<string>(m["ScriptVersion"]));
    }
    if (m.find("SupportFeatures") != m.end() && !m["SupportFeatures"].empty()) {
      supportFeatures = make_shared<string>(boost::any_cast<string>(m["SupportFeatures"]));
    }
    if (m.find("TengineDownloadUrl") != m.end() && !m["TengineDownloadUrl"].empty()) {
      tengineDownloadUrl = make_shared<string>(boost::any_cast<string>(m["TengineDownloadUrl"]));
    }
    if (m.find("TengineImageId") != m.end() && !m["TengineImageId"].empty()) {
      tengineImageId = make_shared<string>(boost::any_cast<string>(m["TengineImageId"]));
    }
    if (m.find("TomcatDesc") != m.end() && !m["TomcatDesc"].empty()) {
      tomcatDesc = make_shared<string>(boost::any_cast<string>(m["TomcatDesc"]));
    }
    if (m.find("TomcatDownloadUrl") != m.end() && !m["TomcatDownloadUrl"].empty()) {
      tomcatDownloadUrl = make_shared<string>(boost::any_cast<string>(m["TomcatDownloadUrl"]));
    }
    if (m.find("TomcatPath") != m.end() && !m["TomcatPath"].empty()) {
      tomcatPath = make_shared<string>(boost::any_cast<string>(m["TomcatPath"]));
    }
    if (m.find("TomcatVersion") != m.end() && !m["TomcatVersion"].empty()) {
      tomcatVersion = make_shared<string>(boost::any_cast<string>(m["TomcatVersion"]));
    }
    if (m.find("WithTengine") != m.end() && !m["WithTengine"].empty()) {
      withTengine = make_shared<bool>(boost::any_cast<bool>(m["WithTengine"]));
    }
  }


  virtual ~ListBuildPackResponseBodyBuildPackListBuildPack() = default;
};
class ListBuildPackResponseBodyBuildPackList : public Darabonba::Model {
public:
  shared_ptr<vector<ListBuildPackResponseBodyBuildPackListBuildPack>> buildPack{};

  ListBuildPackResponseBodyBuildPackList() {}

  explicit ListBuildPackResponseBodyBuildPackList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (buildPack) {
      vector<boost::any> temp1;
      for(auto item1:*buildPack){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BuildPack"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BuildPack") != m.end() && !m["BuildPack"].empty()) {
      if (typeid(vector<boost::any>) == m["BuildPack"].type()) {
        vector<ListBuildPackResponseBodyBuildPackListBuildPack> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BuildPack"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBuildPackResponseBodyBuildPackListBuildPack model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        buildPack = make_shared<vector<ListBuildPackResponseBodyBuildPackListBuildPack>>(expect1);
      }
    }
  }


  virtual ~ListBuildPackResponseBodyBuildPackList() = default;
};
class ListBuildPackResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListBuildPackResponseBodyBuildPackList> buildPackList{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListBuildPackResponseBody() {}

  explicit ListBuildPackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (buildPackList) {
      res["BuildPackList"] = buildPackList ? boost::any(buildPackList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BuildPackList") != m.end() && !m["BuildPackList"].empty()) {
      if (typeid(map<string, boost::any>) == m["BuildPackList"].type()) {
        ListBuildPackResponseBodyBuildPackList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BuildPackList"]));
        buildPackList = make_shared<ListBuildPackResponseBodyBuildPackList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListBuildPackResponseBody() = default;
};
class ListBuildPackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListBuildPackResponseBody> body{};

  ListBuildPackResponse() {}

  explicit ListBuildPackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBuildPackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBuildPackResponseBody>(model1);
      }
    }
  }


  virtual ~ListBuildPackResponse() = default;
};
class ListClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> logicalRegionId{};
  shared_ptr<string> resourceGroupId{};

  ListClusterRequest() {}

  explicit ListClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListClusterRequest() = default;
};
class ListClusterResponseBodyClusterListCluster : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<long> clusterType{};
  shared_ptr<long> cpu{};
  shared_ptr<long> cpuUsed{};
  shared_ptr<long> createTime{};
  shared_ptr<string> csClusterId{};
  shared_ptr<string> description{};
  shared_ptr<string> iaasProvider{};
  shared_ptr<long> mem{};
  shared_ptr<long> memUsed{};
  shared_ptr<long> networkMode{};
  shared_ptr<long> nodeNum{};
  shared_ptr<long> oversoldFactor{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> vpcId{};

  ListClusterResponseBodyClusterListCluster() {}

  explicit ListClusterResponseBodyClusterListCluster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (cpuUsed) {
      res["CpuUsed"] = boost::any(*cpuUsed);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (csClusterId) {
      res["CsClusterId"] = boost::any(*csClusterId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (iaasProvider) {
      res["IaasProvider"] = boost::any(*iaasProvider);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (memUsed) {
      res["MemUsed"] = boost::any(*memUsed);
    }
    if (networkMode) {
      res["NetworkMode"] = boost::any(*networkMode);
    }
    if (nodeNum) {
      res["NodeNum"] = boost::any(*nodeNum);
    }
    if (oversoldFactor) {
      res["OversoldFactor"] = boost::any(*oversoldFactor);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<long>(boost::any_cast<long>(m["ClusterType"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CpuUsed") != m.end() && !m["CpuUsed"].empty()) {
      cpuUsed = make_shared<long>(boost::any_cast<long>(m["CpuUsed"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CsClusterId") != m.end() && !m["CsClusterId"].empty()) {
      csClusterId = make_shared<string>(boost::any_cast<string>(m["CsClusterId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IaasProvider") != m.end() && !m["IaasProvider"].empty()) {
      iaasProvider = make_shared<string>(boost::any_cast<string>(m["IaasProvider"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("MemUsed") != m.end() && !m["MemUsed"].empty()) {
      memUsed = make_shared<long>(boost::any_cast<long>(m["MemUsed"]));
    }
    if (m.find("NetworkMode") != m.end() && !m["NetworkMode"].empty()) {
      networkMode = make_shared<long>(boost::any_cast<long>(m["NetworkMode"]));
    }
    if (m.find("NodeNum") != m.end() && !m["NodeNum"].empty()) {
      nodeNum = make_shared<long>(boost::any_cast<long>(m["NodeNum"]));
    }
    if (m.find("OversoldFactor") != m.end() && !m["OversoldFactor"].empty()) {
      oversoldFactor = make_shared<long>(boost::any_cast<long>(m["OversoldFactor"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ListClusterResponseBodyClusterListCluster() = default;
};
class ListClusterResponseBodyClusterList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterResponseBodyClusterListCluster>> cluster{};

  ListClusterResponseBodyClusterList() {}

  explicit ListClusterResponseBodyClusterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cluster) {
      vector<boost::any> temp1;
      for(auto item1:*cluster){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Cluster"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cluster") != m.end() && !m["Cluster"].empty()) {
      if (typeid(vector<boost::any>) == m["Cluster"].type()) {
        vector<ListClusterResponseBodyClusterListCluster> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Cluster"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterResponseBodyClusterListCluster model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cluster = make_shared<vector<ListClusterResponseBodyClusterListCluster>>(expect1);
      }
    }
  }


  virtual ~ListClusterResponseBodyClusterList() = default;
};
class ListClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListClusterResponseBodyClusterList> clusterList{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListClusterResponseBody() {}

  explicit ListClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterList) {
      res["ClusterList"] = clusterList ? boost::any(clusterList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterList") != m.end() && !m["ClusterList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterList"].type()) {
        ListClusterResponseBodyClusterList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterList"]));
        clusterList = make_shared<ListClusterResponseBodyClusterList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListClusterResponseBody() = default;
};
class ListClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterResponseBody> body{};

  ListClusterResponse() {}

  explicit ListClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterResponse() = default;
};
class ListClusterMembersRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> ecsList{};
  shared_ptr<long> pageSize{};

  ListClusterMembersRequest() {}

  explicit ListClusterMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (ecsList) {
      res["EcsList"] = boost::any(*ecsList);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("EcsList") != m.end() && !m["EcsList"].empty()) {
      ecsList = make_shared<string>(boost::any_cast<string>(m["EcsList"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListClusterMembersRequest() = default;
};
class ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterMemberId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> ecsId{};
  shared_ptr<string> ecuId{};
  shared_ptr<string> privateIp{};
  shared_ptr<long> status{};
  shared_ptr<long> updateTime{};

  ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember() {}

  explicit ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterMemberId) {
      res["ClusterMemberId"] = boost::any(*clusterMemberId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (ecsId) {
      res["EcsId"] = boost::any(*ecsId);
    }
    if (ecuId) {
      res["EcuId"] = boost::any(*ecuId);
    }
    if (privateIp) {
      res["PrivateIp"] = boost::any(*privateIp);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterMemberId") != m.end() && !m["ClusterMemberId"].empty()) {
      clusterMemberId = make_shared<string>(boost::any_cast<string>(m["ClusterMemberId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("EcsId") != m.end() && !m["EcsId"].empty()) {
      ecsId = make_shared<string>(boost::any_cast<string>(m["EcsId"]));
    }
    if (m.find("EcuId") != m.end() && !m["EcuId"].empty()) {
      ecuId = make_shared<string>(boost::any_cast<string>(m["EcuId"]));
    }
    if (m.find("PrivateIp") != m.end() && !m["PrivateIp"].empty()) {
      privateIp = make_shared<string>(boost::any_cast<string>(m["PrivateIp"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember() = default;
};
class ListClusterMembersResponseBodyClusterMemberPageClusterMemberList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember>> clusterMember{};

  ListClusterMembersResponseBodyClusterMemberPageClusterMemberList() {}

  explicit ListClusterMembersResponseBodyClusterMemberPageClusterMemberList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterMember) {
      vector<boost::any> temp1;
      for(auto item1:*clusterMember){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterMember"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterMember") != m.end() && !m["ClusterMember"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterMember"].type()) {
        vector<ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterMember"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterMember = make_shared<vector<ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember>>(expect1);
      }
    }
  }


  virtual ~ListClusterMembersResponseBodyClusterMemberPageClusterMemberList() = default;
};
class ListClusterMembersResponseBodyClusterMemberPage : public Darabonba::Model {
public:
  shared_ptr<ListClusterMembersResponseBodyClusterMemberPageClusterMemberList> clusterMemberList{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalSize{};

  ListClusterMembersResponseBodyClusterMemberPage() {}

  explicit ListClusterMembersResponseBodyClusterMemberPage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterMemberList) {
      res["ClusterMemberList"] = clusterMemberList ? boost::any(clusterMemberList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterMemberList") != m.end() && !m["ClusterMemberList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterMemberList"].type()) {
        ListClusterMembersResponseBodyClusterMemberPageClusterMemberList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterMemberList"]));
        clusterMemberList = make_shared<ListClusterMembersResponseBodyClusterMemberPageClusterMemberList>(model1);
      }
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ListClusterMembersResponseBodyClusterMemberPage() = default;
};
class ListClusterMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListClusterMembersResponseBodyClusterMemberPage> clusterMemberPage{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListClusterMembersResponseBody() {}

  explicit ListClusterMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterMemberPage) {
      res["ClusterMemberPage"] = clusterMemberPage ? boost::any(clusterMemberPage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterMemberPage") != m.end() && !m["ClusterMemberPage"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterMemberPage"].type()) {
        ListClusterMembersResponseBodyClusterMemberPage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterMemberPage"]));
        clusterMemberPage = make_shared<ListClusterMembersResponseBodyClusterMemberPage>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListClusterMembersResponseBody() = default;
};
class ListClusterMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterMembersResponseBody> body{};

  ListClusterMembersResponse() {}

  explicit ListClusterMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterMembersResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterMembersResponse() = default;
};
class ListComponentsResponseBodyComponentListComponent : public Darabonba::Model {
public:
  shared_ptr<string> componentId{};
  shared_ptr<string> componentKey{};
  shared_ptr<string> desc{};
  shared_ptr<bool> expired{};
  shared_ptr<string> type{};
  shared_ptr<string> version{};

  ListComponentsResponseBodyComponentListComponent() {}

  explicit ListComponentsResponseBodyComponentListComponent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (componentKey) {
      res["ComponentKey"] = boost::any(*componentKey);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (expired) {
      res["Expired"] = boost::any(*expired);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      componentId = make_shared<string>(boost::any_cast<string>(m["ComponentId"]));
    }
    if (m.find("ComponentKey") != m.end() && !m["ComponentKey"].empty()) {
      componentKey = make_shared<string>(boost::any_cast<string>(m["ComponentKey"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Expired") != m.end() && !m["Expired"].empty()) {
      expired = make_shared<bool>(boost::any_cast<bool>(m["Expired"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ListComponentsResponseBodyComponentListComponent() = default;
};
class ListComponentsResponseBodyComponentList : public Darabonba::Model {
public:
  shared_ptr<vector<ListComponentsResponseBodyComponentListComponent>> component{};

  ListComponentsResponseBodyComponentList() {}

  explicit ListComponentsResponseBodyComponentList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (component) {
      vector<boost::any> temp1;
      for(auto item1:*component){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Component"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Component") != m.end() && !m["Component"].empty()) {
      if (typeid(vector<boost::any>) == m["Component"].type()) {
        vector<ListComponentsResponseBodyComponentListComponent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Component"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListComponentsResponseBodyComponentListComponent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        component = make_shared<vector<ListComponentsResponseBodyComponentListComponent>>(expect1);
      }
    }
  }


  virtual ~ListComponentsResponseBodyComponentList() = default;
};
class ListComponentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListComponentsResponseBodyComponentList> componentList{};
  shared_ptr<string> message{};

  ListComponentsResponseBody() {}

  explicit ListComponentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (componentList) {
      res["ComponentList"] = componentList ? boost::any(componentList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("ComponentList") != m.end() && !m["ComponentList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComponentList"].type()) {
        ListComponentsResponseBodyComponentList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComponentList"]));
        componentList = make_shared<ListComponentsResponseBodyComponentList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~ListComponentsResponseBody() = default;
};
class ListComponentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListComponentsResponseBody> body{};

  ListComponentsResponse() {}

  explicit ListComponentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListComponentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListComponentsResponseBody>(model1);
      }
    }
  }


  virtual ~ListComponentsResponse() = default;
};
class ListConfigTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> pageSize{};

  ListConfigTemplatesRequest() {}

  explicit ListConfigTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListConfigTemplatesRequest() = default;
};
class ListConfigTemplatesResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> description{};
  shared_ptr<string> format{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  ListConfigTemplatesResponseBodyDataResult() {}

  explicit ListConfigTemplatesResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListConfigTemplatesResponseBodyDataResult() = default;
};
class ListConfigTemplatesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListConfigTemplatesResponseBodyDataResult>> result{};
  shared_ptr<long> totalSize{};

  ListConfigTemplatesResponseBodyData() {}

  explicit ListConfigTemplatesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListConfigTemplatesResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConfigTemplatesResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListConfigTemplatesResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ListConfigTemplatesResponseBodyData() = default;
};
class ListConfigTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListConfigTemplatesResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListConfigTemplatesResponseBody() {}

  explicit ListConfigTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListConfigTemplatesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListConfigTemplatesResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListConfigTemplatesResponseBody() = default;
};
class ListConfigTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListConfigTemplatesResponseBody> body{};

  ListConfigTemplatesResponse() {}

  explicit ListConfigTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListConfigTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListConfigTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListConfigTemplatesResponse() = default;
};
class ListConsumedServicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  ListConsumedServicesRequest() {}

  explicit ListConsumedServicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~ListConsumedServicesRequest() = default;
};
class ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesGroups : public Darabonba::Model {
public:
  shared_ptr<vector<string>> group{};

  ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesGroups() {}

  explicit ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (group) {
      res["group"] = boost::any(*group);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("group") != m.end() && !m["group"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["group"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["group"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      group = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesGroups() = default;
};
class ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesIps : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ip{};

  ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesIps() {}

  explicit ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesIps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["ip"] = boost::any(*ip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ip") != m.end() && !m["ip"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ip"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ip"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ip = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesIps() = default;
};
class ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> dockerApplication{};
  shared_ptr<string> group2Ip{};
  shared_ptr<ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesGroups> groups{};
  shared_ptr<ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesIps> ips{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> version{};

  ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices() {}

  explicit ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dockerApplication) {
      res["DockerApplication"] = boost::any(*dockerApplication);
    }
    if (group2Ip) {
      res["Group2Ip"] = boost::any(*group2Ip);
    }
    if (groups) {
      res["Groups"] = groups ? boost::any(groups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ips) {
      res["Ips"] = ips ? boost::any(ips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DockerApplication") != m.end() && !m["DockerApplication"].empty()) {
      dockerApplication = make_shared<bool>(boost::any_cast<bool>(m["DockerApplication"]));
    }
    if (m.find("Group2Ip") != m.end() && !m["Group2Ip"].empty()) {
      group2Ip = make_shared<string>(boost::any_cast<string>(m["Group2Ip"]));
    }
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      if (typeid(map<string, boost::any>) == m["Groups"].type()) {
        ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Groups"]));
        groups = make_shared<ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesGroups>(model1);
      }
    }
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ips"].type()) {
        ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesIps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ips"]));
        ips = make_shared<ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesIps>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices() = default;
};
class ListConsumedServicesResponseBodyConsumedServicesList : public Darabonba::Model {
public:
  shared_ptr<vector<ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices>> listConsumedServices{};

  ListConsumedServicesResponseBodyConsumedServicesList() {}

  explicit ListConsumedServicesResponseBodyConsumedServicesList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listConsumedServices) {
      vector<boost::any> temp1;
      for(auto item1:*listConsumedServices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ListConsumedServices"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListConsumedServices") != m.end() && !m["ListConsumedServices"].empty()) {
      if (typeid(vector<boost::any>) == m["ListConsumedServices"].type()) {
        vector<ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ListConsumedServices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        listConsumedServices = make_shared<vector<ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices>>(expect1);
      }
    }
  }


  virtual ~ListConsumedServicesResponseBodyConsumedServicesList() = default;
};
class ListConsumedServicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListConsumedServicesResponseBodyConsumedServicesList> consumedServicesList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListConsumedServicesResponseBody() {}

  explicit ListConsumedServicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (consumedServicesList) {
      res["ConsumedServicesList"] = consumedServicesList ? boost::any(consumedServicesList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("ConsumedServicesList") != m.end() && !m["ConsumedServicesList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConsumedServicesList"].type()) {
        ListConsumedServicesResponseBodyConsumedServicesList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConsumedServicesList"]));
        consumedServicesList = make_shared<ListConsumedServicesResponseBodyConsumedServicesList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListConsumedServicesResponseBody() = default;
};
class ListConsumedServicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListConsumedServicesResponseBody> body{};

  ListConsumedServicesResponse() {}

  explicit ListConsumedServicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListConsumedServicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListConsumedServicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListConsumedServicesResponse() = default;
};
class ListConvertableEcuRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};

  ListConvertableEcuRequest() {}

  explicit ListConvertableEcuRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["clusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clusterId") != m.end() && !m["clusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["clusterId"]));
    }
  }


  virtual ~ListConvertableEcuRequest() = default;
};
class ListConvertableEcuResponseBodyInstanceListInstance : public Darabonba::Model {
public:
  shared_ptr<long> cpu{};
  shared_ptr<string> ecuId{};
  shared_ptr<string> eip{};
  shared_ptr<bool> expired{};
  shared_ptr<string> innerIp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> mem{};
  shared_ptr<string> privateIp{};
  shared_ptr<string> publicIp{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcName{};

  ListConvertableEcuResponseBodyInstanceListInstance() {}

  explicit ListConvertableEcuResponseBodyInstanceListInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (ecuId) {
      res["EcuId"] = boost::any(*ecuId);
    }
    if (eip) {
      res["Eip"] = boost::any(*eip);
    }
    if (expired) {
      res["Expired"] = boost::any(*expired);
    }
    if (innerIp) {
      res["InnerIp"] = boost::any(*innerIp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (privateIp) {
      res["PrivateIp"] = boost::any(*privateIp);
    }
    if (publicIp) {
      res["PublicIp"] = boost::any(*publicIp);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("EcuId") != m.end() && !m["EcuId"].empty()) {
      ecuId = make_shared<string>(boost::any_cast<string>(m["EcuId"]));
    }
    if (m.find("Eip") != m.end() && !m["Eip"].empty()) {
      eip = make_shared<string>(boost::any_cast<string>(m["Eip"]));
    }
    if (m.find("Expired") != m.end() && !m["Expired"].empty()) {
      expired = make_shared<bool>(boost::any_cast<bool>(m["Expired"]));
    }
    if (m.find("InnerIp") != m.end() && !m["InnerIp"].empty()) {
      innerIp = make_shared<string>(boost::any_cast<string>(m["InnerIp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("PrivateIp") != m.end() && !m["PrivateIp"].empty()) {
      privateIp = make_shared<string>(boost::any_cast<string>(m["PrivateIp"]));
    }
    if (m.find("PublicIp") != m.end() && !m["PublicIp"].empty()) {
      publicIp = make_shared<string>(boost::any_cast<string>(m["PublicIp"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
  }


  virtual ~ListConvertableEcuResponseBodyInstanceListInstance() = default;
};
class ListConvertableEcuResponseBodyInstanceList : public Darabonba::Model {
public:
  shared_ptr<vector<ListConvertableEcuResponseBodyInstanceListInstance>> instance{};

  ListConvertableEcuResponseBodyInstanceList() {}

  explicit ListConvertableEcuResponseBodyInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      vector<boost::any> temp1;
      for(auto item1:*instance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(vector<boost::any>) == m["Instance"].type()) {
        vector<ListConvertableEcuResponseBodyInstanceListInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConvertableEcuResponseBodyInstanceListInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instance = make_shared<vector<ListConvertableEcuResponseBodyInstanceListInstance>>(expect1);
      }
    }
  }


  virtual ~ListConvertableEcuResponseBodyInstanceList() = default;
};
class ListConvertableEcuResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListConvertableEcuResponseBodyInstanceList> instanceList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListConvertableEcuResponseBody() {}

  explicit ListConvertableEcuResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (instanceList) {
      res["InstanceList"] = instanceList ? boost::any(instanceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("InstanceList") != m.end() && !m["InstanceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceList"].type()) {
        ListConvertableEcuResponseBodyInstanceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceList"]));
        instanceList = make_shared<ListConvertableEcuResponseBodyInstanceList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListConvertableEcuResponseBody() = default;
};
class ListConvertableEcuResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListConvertableEcuResponseBody> body{};

  ListConvertableEcuResponse() {}

  explicit ListConvertableEcuResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListConvertableEcuResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListConvertableEcuResponseBody>(model1);
      }
    }
  }


  virtual ~ListConvertableEcuResponse() = default;
};
class ListDeployGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  ListDeployGroupRequest() {}

  explicit ListDeployGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~ListDeployGroupRequest() = default;
};
class ListDeployGroupResponseBodyDeployGroupListDeployGroup : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appVersionId{};
  shared_ptr<string> baseComponentMetaName{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> cpuLimit{};
  shared_ptr<string> cpuRequest{};
  shared_ptr<long> createTime{};
  shared_ptr<string> csClusterId{};
  shared_ptr<string> deploymentName{};
  shared_ptr<string> env{};
  shared_ptr<string> ephemeralStorageLimit{};
  shared_ptr<string> ephemeralStorageRequest{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<long> groupType{};
  shared_ptr<string> labels{};
  shared_ptr<long> lastUpdateTime{};
  shared_ptr<string> memoryLimit{};
  shared_ptr<string> memoryRequest{};
  shared_ptr<string> nameSpace_{};
  shared_ptr<string> packagePublicUrl{};
  shared_ptr<string> packageUrl{};
  shared_ptr<string> packageVersion{};
  shared_ptr<string> packageVersionId{};
  shared_ptr<string> postStart{};
  shared_ptr<string> preStop{};
  shared_ptr<string> reversion{};
  shared_ptr<string> selector{};
  shared_ptr<string> status{};
  shared_ptr<string> strategy{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> VExtServerGroupId{};
  shared_ptr<string> VServerGroupId{};

  ListDeployGroupResponseBodyDeployGroupListDeployGroup() {}

  explicit ListDeployGroupResponseBodyDeployGroupListDeployGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appVersionId) {
      res["AppVersionId"] = boost::any(*appVersionId);
    }
    if (baseComponentMetaName) {
      res["BaseComponentMetaName"] = boost::any(*baseComponentMetaName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (cpuLimit) {
      res["CpuLimit"] = boost::any(*cpuLimit);
    }
    if (cpuRequest) {
      res["CpuRequest"] = boost::any(*cpuRequest);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (csClusterId) {
      res["CsClusterId"] = boost::any(*csClusterId);
    }
    if (deploymentName) {
      res["DeploymentName"] = boost::any(*deploymentName);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (ephemeralStorageLimit) {
      res["EphemeralStorageLimit"] = boost::any(*ephemeralStorageLimit);
    }
    if (ephemeralStorageRequest) {
      res["EphemeralStorageRequest"] = boost::any(*ephemeralStorageRequest);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (lastUpdateTime) {
      res["LastUpdateTime"] = boost::any(*lastUpdateTime);
    }
    if (memoryLimit) {
      res["MemoryLimit"] = boost::any(*memoryLimit);
    }
    if (memoryRequest) {
      res["MemoryRequest"] = boost::any(*memoryRequest);
    }
    if (nameSpace_) {
      res["NameSpace"] = boost::any(*nameSpace_);
    }
    if (packagePublicUrl) {
      res["PackagePublicUrl"] = boost::any(*packagePublicUrl);
    }
    if (packageUrl) {
      res["PackageUrl"] = boost::any(*packageUrl);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    if (packageVersionId) {
      res["PackageVersionId"] = boost::any(*packageVersionId);
    }
    if (postStart) {
      res["PostStart"] = boost::any(*postStart);
    }
    if (preStop) {
      res["PreStop"] = boost::any(*preStop);
    }
    if (reversion) {
      res["Reversion"] = boost::any(*reversion);
    }
    if (selector) {
      res["Selector"] = boost::any(*selector);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (strategy) {
      res["Strategy"] = boost::any(*strategy);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (VExtServerGroupId) {
      res["VExtServerGroupId"] = boost::any(*VExtServerGroupId);
    }
    if (VServerGroupId) {
      res["VServerGroupId"] = boost::any(*VServerGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppVersionId") != m.end() && !m["AppVersionId"].empty()) {
      appVersionId = make_shared<string>(boost::any_cast<string>(m["AppVersionId"]));
    }
    if (m.find("BaseComponentMetaName") != m.end() && !m["BaseComponentMetaName"].empty()) {
      baseComponentMetaName = make_shared<string>(boost::any_cast<string>(m["BaseComponentMetaName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("CpuLimit") != m.end() && !m["CpuLimit"].empty()) {
      cpuLimit = make_shared<string>(boost::any_cast<string>(m["CpuLimit"]));
    }
    if (m.find("CpuRequest") != m.end() && !m["CpuRequest"].empty()) {
      cpuRequest = make_shared<string>(boost::any_cast<string>(m["CpuRequest"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CsClusterId") != m.end() && !m["CsClusterId"].empty()) {
      csClusterId = make_shared<string>(boost::any_cast<string>(m["CsClusterId"]));
    }
    if (m.find("DeploymentName") != m.end() && !m["DeploymentName"].empty()) {
      deploymentName = make_shared<string>(boost::any_cast<string>(m["DeploymentName"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("EphemeralStorageLimit") != m.end() && !m["EphemeralStorageLimit"].empty()) {
      ephemeralStorageLimit = make_shared<string>(boost::any_cast<string>(m["EphemeralStorageLimit"]));
    }
    if (m.find("EphemeralStorageRequest") != m.end() && !m["EphemeralStorageRequest"].empty()) {
      ephemeralStorageRequest = make_shared<string>(boost::any_cast<string>(m["EphemeralStorageRequest"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<long>(boost::any_cast<long>(m["GroupType"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("LastUpdateTime") != m.end() && !m["LastUpdateTime"].empty()) {
      lastUpdateTime = make_shared<long>(boost::any_cast<long>(m["LastUpdateTime"]));
    }
    if (m.find("MemoryLimit") != m.end() && !m["MemoryLimit"].empty()) {
      memoryLimit = make_shared<string>(boost::any_cast<string>(m["MemoryLimit"]));
    }
    if (m.find("MemoryRequest") != m.end() && !m["MemoryRequest"].empty()) {
      memoryRequest = make_shared<string>(boost::any_cast<string>(m["MemoryRequest"]));
    }
    if (m.find("NameSpace") != m.end() && !m["NameSpace"].empty()) {
      nameSpace_ = make_shared<string>(boost::any_cast<string>(m["NameSpace"]));
    }
    if (m.find("PackagePublicUrl") != m.end() && !m["PackagePublicUrl"].empty()) {
      packagePublicUrl = make_shared<string>(boost::any_cast<string>(m["PackagePublicUrl"]));
    }
    if (m.find("PackageUrl") != m.end() && !m["PackageUrl"].empty()) {
      packageUrl = make_shared<string>(boost::any_cast<string>(m["PackageUrl"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
    if (m.find("PackageVersionId") != m.end() && !m["PackageVersionId"].empty()) {
      packageVersionId = make_shared<string>(boost::any_cast<string>(m["PackageVersionId"]));
    }
    if (m.find("PostStart") != m.end() && !m["PostStart"].empty()) {
      postStart = make_shared<string>(boost::any_cast<string>(m["PostStart"]));
    }
    if (m.find("PreStop") != m.end() && !m["PreStop"].empty()) {
      preStop = make_shared<string>(boost::any_cast<string>(m["PreStop"]));
    }
    if (m.find("Reversion") != m.end() && !m["Reversion"].empty()) {
      reversion = make_shared<string>(boost::any_cast<string>(m["Reversion"]));
    }
    if (m.find("Selector") != m.end() && !m["Selector"].empty()) {
      selector = make_shared<string>(boost::any_cast<string>(m["Selector"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      strategy = make_shared<string>(boost::any_cast<string>(m["Strategy"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("VExtServerGroupId") != m.end() && !m["VExtServerGroupId"].empty()) {
      VExtServerGroupId = make_shared<string>(boost::any_cast<string>(m["VExtServerGroupId"]));
    }
    if (m.find("VServerGroupId") != m.end() && !m["VServerGroupId"].empty()) {
      VServerGroupId = make_shared<string>(boost::any_cast<string>(m["VServerGroupId"]));
    }
  }


  virtual ~ListDeployGroupResponseBodyDeployGroupListDeployGroup() = default;
};
class ListDeployGroupResponseBodyDeployGroupList : public Darabonba::Model {
public:
  shared_ptr<vector<ListDeployGroupResponseBodyDeployGroupListDeployGroup>> deployGroup{};

  ListDeployGroupResponseBodyDeployGroupList() {}

  explicit ListDeployGroupResponseBodyDeployGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployGroup) {
      vector<boost::any> temp1;
      for(auto item1:*deployGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeployGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployGroup") != m.end() && !m["DeployGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["DeployGroup"].type()) {
        vector<ListDeployGroupResponseBodyDeployGroupListDeployGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeployGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDeployGroupResponseBodyDeployGroupListDeployGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deployGroup = make_shared<vector<ListDeployGroupResponseBodyDeployGroupListDeployGroup>>(expect1);
      }
    }
  }


  virtual ~ListDeployGroupResponseBodyDeployGroupList() = default;
};
class ListDeployGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListDeployGroupResponseBodyDeployGroupList> deployGroupList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListDeployGroupResponseBody() {}

  explicit ListDeployGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (deployGroupList) {
      res["DeployGroupList"] = deployGroupList ? boost::any(deployGroupList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("DeployGroupList") != m.end() && !m["DeployGroupList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeployGroupList"].type()) {
        ListDeployGroupResponseBodyDeployGroupList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeployGroupList"]));
        deployGroupList = make_shared<ListDeployGroupResponseBodyDeployGroupList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDeployGroupResponseBody() = default;
};
class ListDeployGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDeployGroupResponseBody> body{};

  ListDeployGroupResponse() {}

  explicit ListDeployGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDeployGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDeployGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListDeployGroupResponse() = default;
};
class ListEcsNotInClusterRequest : public Darabonba::Model {
public:
  shared_ptr<long> networkMode{};
  shared_ptr<string> vpcId{};

  ListEcsNotInClusterRequest() {}

  explicit ListEcsNotInClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkMode) {
      res["NetworkMode"] = boost::any(*networkMode);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkMode") != m.end() && !m["NetworkMode"].empty()) {
      networkMode = make_shared<long>(boost::any_cast<long>(m["NetworkMode"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ListEcsNotInClusterRequest() = default;
};
class ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity : public Darabonba::Model {
public:
  shared_ptr<long> cpu{};
  shared_ptr<string> eip{};
  shared_ptr<bool> expired{};
  shared_ptr<string> innerIp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> mem{};
  shared_ptr<string> privateIp{};
  shared_ptr<string> publicIp{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcName{};

  ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity() {}

  explicit ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (eip) {
      res["Eip"] = boost::any(*eip);
    }
    if (expired) {
      res["Expired"] = boost::any(*expired);
    }
    if (innerIp) {
      res["InnerIp"] = boost::any(*innerIp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (privateIp) {
      res["PrivateIp"] = boost::any(*privateIp);
    }
    if (publicIp) {
      res["PublicIp"] = boost::any(*publicIp);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("Eip") != m.end() && !m["Eip"].empty()) {
      eip = make_shared<string>(boost::any_cast<string>(m["Eip"]));
    }
    if (m.find("Expired") != m.end() && !m["Expired"].empty()) {
      expired = make_shared<bool>(boost::any_cast<bool>(m["Expired"]));
    }
    if (m.find("InnerIp") != m.end() && !m["InnerIp"].empty()) {
      innerIp = make_shared<string>(boost::any_cast<string>(m["InnerIp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("PrivateIp") != m.end() && !m["PrivateIp"].empty()) {
      privateIp = make_shared<string>(boost::any_cast<string>(m["PrivateIp"]));
    }
    if (m.find("PublicIp") != m.end() && !m["PublicIp"].empty()) {
      publicIp = make_shared<string>(boost::any_cast<string>(m["PublicIp"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
  }


  virtual ~ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity() = default;
};
class ListEcsNotInClusterResponseBodyEcsEntityList : public Darabonba::Model {
public:
  shared_ptr<vector<ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity>> ecsEntity{};

  ListEcsNotInClusterResponseBodyEcsEntityList() {}

  explicit ListEcsNotInClusterResponseBodyEcsEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecsEntity) {
      vector<boost::any> temp1;
      for(auto item1:*ecsEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EcsEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcsEntity") != m.end() && !m["EcsEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["EcsEntity"].type()) {
        vector<ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EcsEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ecsEntity = make_shared<vector<ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity>>(expect1);
      }
    }
  }


  virtual ~ListEcsNotInClusterResponseBodyEcsEntityList() = default;
};
class ListEcsNotInClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListEcsNotInClusterResponseBodyEcsEntityList> ecsEntityList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListEcsNotInClusterResponseBody() {}

  explicit ListEcsNotInClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (ecsEntityList) {
      res["EcsEntityList"] = ecsEntityList ? boost::any(ecsEntityList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("EcsEntityList") != m.end() && !m["EcsEntityList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EcsEntityList"].type()) {
        ListEcsNotInClusterResponseBodyEcsEntityList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EcsEntityList"]));
        ecsEntityList = make_shared<ListEcsNotInClusterResponseBodyEcsEntityList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListEcsNotInClusterResponseBody() = default;
};
class ListEcsNotInClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEcsNotInClusterResponseBody> body{};

  ListEcsNotInClusterResponse() {}

  explicit ListEcsNotInClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEcsNotInClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEcsNotInClusterResponseBody>(model1);
      }
    }
  }


  virtual ~ListEcsNotInClusterResponse() = default;
};
class ListEcuByRegionRequest : public Darabonba::Model {
public:
  shared_ptr<string> act{};
  shared_ptr<string> logicalRegionId{};

  ListEcuByRegionRequest() {}

  explicit ListEcuByRegionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (act) {
      res["Act"] = boost::any(*act);
    }
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Act") != m.end() && !m["Act"].empty()) {
      act = make_shared<string>(boost::any_cast<string>(m["Act"]));
    }
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
  }


  virtual ~ListEcuByRegionRequest() = default;
};
class ListEcuByRegionResponseBodyEcuEntityListEcuEntity : public Darabonba::Model {
public:
  shared_ptr<long> availableCpu{};
  shared_ptr<long> availableMem{};
  shared_ptr<long> cpu{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> dockerEnv{};
  shared_ptr<string> ecuId{};
  shared_ptr<long> heartbeatTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ipAddr{};
  shared_ptr<long> mem{};
  shared_ptr<string> name{};
  shared_ptr<bool> online{};
  shared_ptr<string> regionId{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zoneId{};

  ListEcuByRegionResponseBodyEcuEntityListEcuEntity() {}

  explicit ListEcuByRegionResponseBodyEcuEntityListEcuEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableCpu) {
      res["AvailableCpu"] = boost::any(*availableCpu);
    }
    if (availableMem) {
      res["AvailableMem"] = boost::any(*availableMem);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dockerEnv) {
      res["DockerEnv"] = boost::any(*dockerEnv);
    }
    if (ecuId) {
      res["EcuId"] = boost::any(*ecuId);
    }
    if (heartbeatTime) {
      res["HeartbeatTime"] = boost::any(*heartbeatTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ipAddr) {
      res["IpAddr"] = boost::any(*ipAddr);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableCpu") != m.end() && !m["AvailableCpu"].empty()) {
      availableCpu = make_shared<long>(boost::any_cast<long>(m["AvailableCpu"]));
    }
    if (m.find("AvailableMem") != m.end() && !m["AvailableMem"].empty()) {
      availableMem = make_shared<long>(boost::any_cast<long>(m["AvailableMem"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DockerEnv") != m.end() && !m["DockerEnv"].empty()) {
      dockerEnv = make_shared<bool>(boost::any_cast<bool>(m["DockerEnv"]));
    }
    if (m.find("EcuId") != m.end() && !m["EcuId"].empty()) {
      ecuId = make_shared<string>(boost::any_cast<string>(m["EcuId"]));
    }
    if (m.find("HeartbeatTime") != m.end() && !m["HeartbeatTime"].empty()) {
      heartbeatTime = make_shared<long>(boost::any_cast<long>(m["HeartbeatTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IpAddr") != m.end() && !m["IpAddr"].empty()) {
      ipAddr = make_shared<string>(boost::any_cast<string>(m["IpAddr"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<bool>(boost::any_cast<bool>(m["Online"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~ListEcuByRegionResponseBodyEcuEntityListEcuEntity() = default;
};
class ListEcuByRegionResponseBodyEcuEntityList : public Darabonba::Model {
public:
  shared_ptr<vector<ListEcuByRegionResponseBodyEcuEntityListEcuEntity>> ecuEntity{};

  ListEcuByRegionResponseBodyEcuEntityList() {}

  explicit ListEcuByRegionResponseBodyEcuEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecuEntity) {
      vector<boost::any> temp1;
      for(auto item1:*ecuEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EcuEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcuEntity") != m.end() && !m["EcuEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["EcuEntity"].type()) {
        vector<ListEcuByRegionResponseBodyEcuEntityListEcuEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EcuEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEcuByRegionResponseBodyEcuEntityListEcuEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ecuEntity = make_shared<vector<ListEcuByRegionResponseBodyEcuEntityListEcuEntity>>(expect1);
      }
    }
  }


  virtual ~ListEcuByRegionResponseBodyEcuEntityList() = default;
};
class ListEcuByRegionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListEcuByRegionResponseBodyEcuEntityList> ecuEntityList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListEcuByRegionResponseBody() {}

  explicit ListEcuByRegionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (ecuEntityList) {
      res["EcuEntityList"] = ecuEntityList ? boost::any(ecuEntityList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("EcuEntityList") != m.end() && !m["EcuEntityList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EcuEntityList"].type()) {
        ListEcuByRegionResponseBodyEcuEntityList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EcuEntityList"]));
        ecuEntityList = make_shared<ListEcuByRegionResponseBodyEcuEntityList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListEcuByRegionResponseBody() = default;
};
class ListEcuByRegionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEcuByRegionResponseBody> body{};

  ListEcuByRegionResponse() {}

  explicit ListEcuByRegionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEcuByRegionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEcuByRegionResponseBody>(model1);
      }
    }
  }


  virtual ~ListEcuByRegionResponse() = default;
};
class ListHistoryDeployVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  ListHistoryDeployVersionRequest() {}

  explicit ListHistoryDeployVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~ListHistoryDeployVersionRequest() = default;
};
class ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> packageVersion{};
  shared_ptr<string> publicUrl{};
  shared_ptr<string> type{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> warUrl{};

  ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion() {}

  explicit ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    if (publicUrl) {
      res["PublicUrl"] = boost::any(*publicUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (warUrl) {
      res["WarUrl"] = boost::any(*warUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
    if (m.find("PublicUrl") != m.end() && !m["PublicUrl"].empty()) {
      publicUrl = make_shared<string>(boost::any_cast<string>(m["PublicUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("WarUrl") != m.end() && !m["WarUrl"].empty()) {
      warUrl = make_shared<string>(boost::any_cast<string>(m["WarUrl"]));
    }
  }


  virtual ~ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion() = default;
};
class ListHistoryDeployVersionResponseBodyPackageVersionList : public Darabonba::Model {
public:
  shared_ptr<vector<ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion>> packageVersion{};

  ListHistoryDeployVersionResponseBodyPackageVersionList() {}

  explicit ListHistoryDeployVersionResponseBodyPackageVersionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (packageVersion) {
      vector<boost::any> temp1;
      for(auto item1:*packageVersion){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PackageVersion"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      if (typeid(vector<boost::any>) == m["PackageVersion"].type()) {
        vector<ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PackageVersion"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        packageVersion = make_shared<vector<ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion>>(expect1);
      }
    }
  }


  virtual ~ListHistoryDeployVersionResponseBodyPackageVersionList() = default;
};
class ListHistoryDeployVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<ListHistoryDeployVersionResponseBodyPackageVersionList> packageVersionList{};
  shared_ptr<string> requestId{};

  ListHistoryDeployVersionResponseBody() {}

  explicit ListHistoryDeployVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (packageVersionList) {
      res["PackageVersionList"] = packageVersionList ? boost::any(packageVersionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PackageVersionList") != m.end() && !m["PackageVersionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PackageVersionList"].type()) {
        ListHistoryDeployVersionResponseBodyPackageVersionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PackageVersionList"]));
        packageVersionList = make_shared<ListHistoryDeployVersionResponseBodyPackageVersionList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListHistoryDeployVersionResponseBody() = default;
};
class ListHistoryDeployVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHistoryDeployVersionResponseBody> body{};

  ListHistoryDeployVersionResponse() {}

  explicit ListHistoryDeployVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHistoryDeployVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHistoryDeployVersionResponseBody>(model1);
      }
    }
  }


  virtual ~ListHistoryDeployVersionResponse() = default;
};
class ListK8sConfigMapsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<map<string, boost::any>> condition{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> showRelatedApps{};

  ListK8sConfigMapsRequest() {}

  explicit ListK8sConfigMapsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (showRelatedApps) {
      res["ShowRelatedApps"] = boost::any(*showRelatedApps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Condition"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      condition = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ShowRelatedApps") != m.end() && !m["ShowRelatedApps"].empty()) {
      showRelatedApps = make_shared<bool>(boost::any_cast<bool>(m["ShowRelatedApps"]));
    }
  }


  virtual ~ListK8sConfigMapsRequest() = default;
};
class ListK8sConfigMapsResponseBodyResultConfigMapsData : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListK8sConfigMapsResponseBodyResultConfigMapsData() {}

  explicit ListK8sConfigMapsResponseBodyResultConfigMapsData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListK8sConfigMapsResponseBodyResultConfigMapsData() = default;
};
class ListK8sConfigMapsResponseBodyResultConfigMapsRelatedApps : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};

  ListK8sConfigMapsResponseBodyResultConfigMapsRelatedApps() {}

  explicit ListK8sConfigMapsResponseBodyResultConfigMapsRelatedApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
  }


  virtual ~ListK8sConfigMapsResponseBodyResultConfigMapsRelatedApps() = default;
};
class ListK8sConfigMapsResponseBodyResultConfigMaps : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> creationTime{};
  shared_ptr<vector<ListK8sConfigMapsResponseBodyResultConfigMapsData>> data{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<vector<ListK8sConfigMapsResponseBodyResultConfigMapsRelatedApps>> relatedApps{};

  ListK8sConfigMapsResponseBodyResultConfigMaps() {}

  explicit ListK8sConfigMapsResponseBodyResultConfigMaps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (relatedApps) {
      vector<boost::any> temp1;
      for(auto item1:*relatedApps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RelatedApps"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListK8sConfigMapsResponseBodyResultConfigMapsData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListK8sConfigMapsResponseBodyResultConfigMapsData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListK8sConfigMapsResponseBodyResultConfigMapsData>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RelatedApps") != m.end() && !m["RelatedApps"].empty()) {
      if (typeid(vector<boost::any>) == m["RelatedApps"].type()) {
        vector<ListK8sConfigMapsResponseBodyResultConfigMapsRelatedApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RelatedApps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListK8sConfigMapsResponseBodyResultConfigMapsRelatedApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relatedApps = make_shared<vector<ListK8sConfigMapsResponseBodyResultConfigMapsRelatedApps>>(expect1);
      }
    }
  }


  virtual ~ListK8sConfigMapsResponseBodyResultConfigMaps() = default;
};
class ListK8sConfigMapsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListK8sConfigMapsResponseBodyResultConfigMaps>> configMaps{};
  shared_ptr<long> total{};

  ListK8sConfigMapsResponseBodyResult() {}

  explicit ListK8sConfigMapsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configMaps) {
      vector<boost::any> temp1;
      for(auto item1:*configMaps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigMaps"] = boost::any(temp1);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigMaps") != m.end() && !m["ConfigMaps"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigMaps"].type()) {
        vector<ListK8sConfigMapsResponseBodyResultConfigMaps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigMaps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListK8sConfigMapsResponseBodyResultConfigMaps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configMaps = make_shared<vector<ListK8sConfigMapsResponseBodyResultConfigMaps>>(expect1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListK8sConfigMapsResponseBodyResult() = default;
};
class ListK8sConfigMapsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListK8sConfigMapsResponseBodyResult> result{};

  ListK8sConfigMapsResponseBody() {}

  explicit ListK8sConfigMapsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ListK8sConfigMapsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ListK8sConfigMapsResponseBodyResult>(model1);
      }
    }
  }


  virtual ~ListK8sConfigMapsResponseBody() = default;
};
class ListK8sConfigMapsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListK8sConfigMapsResponseBody> body{};

  ListK8sConfigMapsResponse() {}

  explicit ListK8sConfigMapsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListK8sConfigMapsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListK8sConfigMapsResponseBody>(model1);
      }
    }
  }


  virtual ~ListK8sConfigMapsResponse() = default;
};
class ListK8sIngressRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> condition{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};

  ListK8sIngressRulesRequest() {}

  explicit ListK8sIngressRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListK8sIngressRulesRequest() = default;
};
class ListK8sIngressRulesResponseBodyDataIngressConfsRulesPathsBackend : public Darabonba::Model {
public:
  shared_ptr<string> serviceName{};
  shared_ptr<string> servicePort{};

  ListK8sIngressRulesResponseBodyDataIngressConfsRulesPathsBackend() {}

  explicit ListK8sIngressRulesResponseBodyDataIngressConfsRulesPathsBackend(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (servicePort) {
      res["ServicePort"] = boost::any(*servicePort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServicePort") != m.end() && !m["ServicePort"].empty()) {
      servicePort = make_shared<string>(boost::any_cast<string>(m["ServicePort"]));
    }
  }


  virtual ~ListK8sIngressRulesResponseBodyDataIngressConfsRulesPathsBackend() = default;
};
class ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<ListK8sIngressRulesResponseBodyDataIngressConfsRulesPathsBackend> backend{};
  shared_ptr<long> collectRate{};
  shared_ptr<string> path{};
  shared_ptr<string> pathType{};
  shared_ptr<string> status{};

  ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths() {}

  explicit ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (backend) {
      res["Backend"] = backend ? boost::any(backend->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (collectRate) {
      res["CollectRate"] = boost::any(*collectRate);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (pathType) {
      res["PathType"] = boost::any(*pathType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Backend") != m.end() && !m["Backend"].empty()) {
      if (typeid(map<string, boost::any>) == m["Backend"].type()) {
        ListK8sIngressRulesResponseBodyDataIngressConfsRulesPathsBackend model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Backend"]));
        backend = make_shared<ListK8sIngressRulesResponseBodyDataIngressConfsRulesPathsBackend>(model1);
      }
    }
    if (m.find("CollectRate") != m.end() && !m["CollectRate"].empty()) {
      collectRate = make_shared<long>(boost::any_cast<long>(m["CollectRate"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("PathType") != m.end() && !m["PathType"].empty()) {
      pathType = make_shared<string>(boost::any_cast<string>(m["PathType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths() = default;
};
class ListK8sIngressRulesResponseBodyDataIngressConfsRules : public Darabonba::Model {
public:
  shared_ptr<bool> enableTls{};
  shared_ptr<string> host{};
  shared_ptr<vector<ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths>> paths{};
  shared_ptr<string> secretName{};

  ListK8sIngressRulesResponseBodyDataIngressConfsRules() {}

  explicit ListK8sIngressRulesResponseBodyDataIngressConfsRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableTls) {
      res["EnableTls"] = boost::any(*enableTls);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (paths) {
      vector<boost::any> temp1;
      for(auto item1:*paths){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Paths"] = boost::any(temp1);
    }
    if (secretName) {
      res["SecretName"] = boost::any(*secretName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableTls") != m.end() && !m["EnableTls"].empty()) {
      enableTls = make_shared<bool>(boost::any_cast<bool>(m["EnableTls"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Paths") != m.end() && !m["Paths"].empty()) {
      if (typeid(vector<boost::any>) == m["Paths"].type()) {
        vector<ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Paths"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        paths = make_shared<vector<ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths>>(expect1);
      }
    }
    if (m.find("SecretName") != m.end() && !m["SecretName"].empty()) {
      secretName = make_shared<string>(boost::any_cast<string>(m["SecretName"]));
    }
  }


  virtual ~ListK8sIngressRulesResponseBodyDataIngressConfsRules() = default;
};
class ListK8sIngressRulesResponseBodyDataIngressConfs : public Darabonba::Model {
public:
  shared_ptr<string> albId{};
  shared_ptr<string> annotations{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> dashboardUrl{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> ingressType{};
  shared_ptr<string> labels{};
  shared_ptr<string> mseGatewayId{};
  shared_ptr<string> mseGatewayName{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> officalBasicUrl{};
  shared_ptr<string> officalRequestUrl{};
  shared_ptr<vector<ListK8sIngressRulesResponseBodyDataIngressConfsRules>> rules{};
  shared_ptr<bool> sslRedirect{};

  ListK8sIngressRulesResponseBodyDataIngressConfs() {}

  explicit ListK8sIngressRulesResponseBodyDataIngressConfs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (albId) {
      res["AlbId"] = boost::any(*albId);
    }
    if (annotations) {
      res["Annotations"] = boost::any(*annotations);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (dashboardUrl) {
      res["DashboardUrl"] = boost::any(*dashboardUrl);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (ingressType) {
      res["IngressType"] = boost::any(*ingressType);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (mseGatewayId) {
      res["MseGatewayId"] = boost::any(*mseGatewayId);
    }
    if (mseGatewayName) {
      res["MseGatewayName"] = boost::any(*mseGatewayName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (officalBasicUrl) {
      res["OfficalBasicUrl"] = boost::any(*officalBasicUrl);
    }
    if (officalRequestUrl) {
      res["OfficalRequestUrl"] = boost::any(*officalRequestUrl);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    if (sslRedirect) {
      res["SslRedirect"] = boost::any(*sslRedirect);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlbId") != m.end() && !m["AlbId"].empty()) {
      albId = make_shared<string>(boost::any_cast<string>(m["AlbId"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      annotations = make_shared<string>(boost::any_cast<string>(m["Annotations"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DashboardUrl") != m.end() && !m["DashboardUrl"].empty()) {
      dashboardUrl = make_shared<string>(boost::any_cast<string>(m["DashboardUrl"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("IngressType") != m.end() && !m["IngressType"].empty()) {
      ingressType = make_shared<string>(boost::any_cast<string>(m["IngressType"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("MseGatewayId") != m.end() && !m["MseGatewayId"].empty()) {
      mseGatewayId = make_shared<string>(boost::any_cast<string>(m["MseGatewayId"]));
    }
    if (m.find("MseGatewayName") != m.end() && !m["MseGatewayName"].empty()) {
      mseGatewayName = make_shared<string>(boost::any_cast<string>(m["MseGatewayName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("OfficalBasicUrl") != m.end() && !m["OfficalBasicUrl"].empty()) {
      officalBasicUrl = make_shared<string>(boost::any_cast<string>(m["OfficalBasicUrl"]));
    }
    if (m.find("OfficalRequestUrl") != m.end() && !m["OfficalRequestUrl"].empty()) {
      officalRequestUrl = make_shared<string>(boost::any_cast<string>(m["OfficalRequestUrl"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<ListK8sIngressRulesResponseBodyDataIngressConfsRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListK8sIngressRulesResponseBodyDataIngressConfsRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<ListK8sIngressRulesResponseBodyDataIngressConfsRules>>(expect1);
      }
    }
    if (m.find("SslRedirect") != m.end() && !m["SslRedirect"].empty()) {
      sslRedirect = make_shared<bool>(boost::any_cast<bool>(m["SslRedirect"]));
    }
  }


  virtual ~ListK8sIngressRulesResponseBodyDataIngressConfs() = default;
};
class ListK8sIngressRulesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<vector<ListK8sIngressRulesResponseBodyDataIngressConfs>> ingressConfs{};
  shared_ptr<string> regionId{};

  ListK8sIngressRulesResponseBodyData() {}

  explicit ListK8sIngressRulesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (ingressConfs) {
      vector<boost::any> temp1;
      for(auto item1:*ingressConfs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IngressConfs"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("IngressConfs") != m.end() && !m["IngressConfs"].empty()) {
      if (typeid(vector<boost::any>) == m["IngressConfs"].type()) {
        vector<ListK8sIngressRulesResponseBodyDataIngressConfs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IngressConfs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListK8sIngressRulesResponseBodyDataIngressConfs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ingressConfs = make_shared<vector<ListK8sIngressRulesResponseBodyDataIngressConfs>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListK8sIngressRulesResponseBodyData() = default;
};
class ListK8sIngressRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListK8sIngressRulesResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListK8sIngressRulesResponseBody() {}

  explicit ListK8sIngressRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListK8sIngressRulesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListK8sIngressRulesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListK8sIngressRulesResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListK8sIngressRulesResponseBody() = default;
};
class ListK8sIngressRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListK8sIngressRulesResponseBody> body{};

  ListK8sIngressRulesResponse() {}

  explicit ListK8sIngressRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListK8sIngressRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListK8sIngressRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListK8sIngressRulesResponse() = default;
};
class ListK8sNamespacesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};

  ListK8sNamespacesRequest() {}

  explicit ListK8sNamespacesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~ListK8sNamespacesRequest() = default;
};
class ListK8sNamespacesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> namespace_{};

  ListK8sNamespacesResponseBodyData() {}

  explicit ListK8sNamespacesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~ListK8sNamespacesResponseBodyData() = default;
};
class ListK8sNamespacesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListK8sNamespacesResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListK8sNamespacesResponseBody() {}

  explicit ListK8sNamespacesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListK8sNamespacesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListK8sNamespacesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListK8sNamespacesResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListK8sNamespacesResponseBody() = default;
};
class ListK8sNamespacesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListK8sNamespacesResponseBody> body{};

  ListK8sNamespacesResponse() {}

  explicit ListK8sNamespacesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListK8sNamespacesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListK8sNamespacesResponseBody>(model1);
      }
    }
  }


  virtual ~ListK8sNamespacesResponse() = default;
};
class ListK8sSecretsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> condition{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> showRelatedApps{};

  ListK8sSecretsRequest() {}

  explicit ListK8sSecretsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (showRelatedApps) {
      res["ShowRelatedApps"] = boost::any(*showRelatedApps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ShowRelatedApps") != m.end() && !m["ShowRelatedApps"].empty()) {
      showRelatedApps = make_shared<bool>(boost::any_cast<bool>(m["ShowRelatedApps"]));
    }
  }


  virtual ~ListK8sSecretsRequest() = default;
};
class ListK8sSecretsResponseBodyResultSecretsCertDetail : public Darabonba::Model {
public:
  shared_ptr<vector<string>> domainNames{};
  shared_ptr<string> endTime{};
  shared_ptr<string> issuer{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  ListK8sSecretsResponseBodyResultSecretsCertDetail() {}

  explicit ListK8sSecretsResponseBodyResultSecretsCertDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DomainNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DomainNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domainNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListK8sSecretsResponseBodyResultSecretsCertDetail() = default;
};
class ListK8sSecretsResponseBodyResultSecretsData : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListK8sSecretsResponseBodyResultSecretsData() {}

  explicit ListK8sSecretsResponseBodyResultSecretsData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListK8sSecretsResponseBodyResultSecretsData() = default;
};
class ListK8sSecretsResponseBodyResultSecretsRelatedApps : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};

  ListK8sSecretsResponseBodyResultSecretsRelatedApps() {}

  explicit ListK8sSecretsResponseBodyResultSecretsRelatedApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
  }


  virtual ~ListK8sSecretsResponseBodyResultSecretsRelatedApps() = default;
};
class ListK8sSecretsResponseBodyResultSecretsRelatedIngressRulesRelatedApps : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};

  ListK8sSecretsResponseBodyResultSecretsRelatedIngressRulesRelatedApps() {}

  explicit ListK8sSecretsResponseBodyResultSecretsRelatedIngressRulesRelatedApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
  }


  virtual ~ListK8sSecretsResponseBodyResultSecretsRelatedIngressRulesRelatedApps() = default;
};
class ListK8sSecretsResponseBodyResultSecretsRelatedIngressRules : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<vector<ListK8sSecretsResponseBodyResultSecretsRelatedIngressRulesRelatedApps>> relatedApps{};

  ListK8sSecretsResponseBodyResultSecretsRelatedIngressRules() {}

  explicit ListK8sSecretsResponseBodyResultSecretsRelatedIngressRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (relatedApps) {
      vector<boost::any> temp1;
      for(auto item1:*relatedApps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RelatedApps"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RelatedApps") != m.end() && !m["RelatedApps"].empty()) {
      if (typeid(vector<boost::any>) == m["RelatedApps"].type()) {
        vector<ListK8sSecretsResponseBodyResultSecretsRelatedIngressRulesRelatedApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RelatedApps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListK8sSecretsResponseBodyResultSecretsRelatedIngressRulesRelatedApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relatedApps = make_shared<vector<ListK8sSecretsResponseBodyResultSecretsRelatedIngressRulesRelatedApps>>(expect1);
      }
    }
  }


  virtual ~ListK8sSecretsResponseBodyResultSecretsRelatedIngressRules() = default;
};
class ListK8sSecretsResponseBodyResultSecrets : public Darabonba::Model {
public:
  shared_ptr<bool> base64Encoded{};
  shared_ptr<ListK8sSecretsResponseBodyResultSecretsCertDetail> certDetail{};
  shared_ptr<string> certId{};
  shared_ptr<string> certRegionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> creationTime{};
  shared_ptr<vector<ListK8sSecretsResponseBodyResultSecretsData>> data{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<vector<ListK8sSecretsResponseBodyResultSecretsRelatedApps>> relatedApps{};
  shared_ptr<vector<ListK8sSecretsResponseBodyResultSecretsRelatedIngressRules>> relatedIngressRules{};
  shared_ptr<string> type{};

  ListK8sSecretsResponseBodyResultSecrets() {}

  explicit ListK8sSecretsResponseBodyResultSecrets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (base64Encoded) {
      res["Base64Encoded"] = boost::any(*base64Encoded);
    }
    if (certDetail) {
      res["CertDetail"] = certDetail ? boost::any(certDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certRegionId) {
      res["CertRegionId"] = boost::any(*certRegionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (relatedApps) {
      vector<boost::any> temp1;
      for(auto item1:*relatedApps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RelatedApps"] = boost::any(temp1);
    }
    if (relatedIngressRules) {
      vector<boost::any> temp1;
      for(auto item1:*relatedIngressRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RelatedIngressRules"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Base64Encoded") != m.end() && !m["Base64Encoded"].empty()) {
      base64Encoded = make_shared<bool>(boost::any_cast<bool>(m["Base64Encoded"]));
    }
    if (m.find("CertDetail") != m.end() && !m["CertDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertDetail"].type()) {
        ListK8sSecretsResponseBodyResultSecretsCertDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertDetail"]));
        certDetail = make_shared<ListK8sSecretsResponseBodyResultSecretsCertDetail>(model1);
      }
    }
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<string>(boost::any_cast<string>(m["CertId"]));
    }
    if (m.find("CertRegionId") != m.end() && !m["CertRegionId"].empty()) {
      certRegionId = make_shared<string>(boost::any_cast<string>(m["CertRegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListK8sSecretsResponseBodyResultSecretsData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListK8sSecretsResponseBodyResultSecretsData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListK8sSecretsResponseBodyResultSecretsData>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RelatedApps") != m.end() && !m["RelatedApps"].empty()) {
      if (typeid(vector<boost::any>) == m["RelatedApps"].type()) {
        vector<ListK8sSecretsResponseBodyResultSecretsRelatedApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RelatedApps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListK8sSecretsResponseBodyResultSecretsRelatedApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relatedApps = make_shared<vector<ListK8sSecretsResponseBodyResultSecretsRelatedApps>>(expect1);
      }
    }
    if (m.find("RelatedIngressRules") != m.end() && !m["RelatedIngressRules"].empty()) {
      if (typeid(vector<boost::any>) == m["RelatedIngressRules"].type()) {
        vector<ListK8sSecretsResponseBodyResultSecretsRelatedIngressRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RelatedIngressRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListK8sSecretsResponseBodyResultSecretsRelatedIngressRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relatedIngressRules = make_shared<vector<ListK8sSecretsResponseBodyResultSecretsRelatedIngressRules>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListK8sSecretsResponseBodyResultSecrets() = default;
};
class ListK8sSecretsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListK8sSecretsResponseBodyResultSecrets>> secrets{};
  shared_ptr<long> total{};

  ListK8sSecretsResponseBodyResult() {}

  explicit ListK8sSecretsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (secrets) {
      vector<boost::any> temp1;
      for(auto item1:*secrets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Secrets"] = boost::any(temp1);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Secrets") != m.end() && !m["Secrets"].empty()) {
      if (typeid(vector<boost::any>) == m["Secrets"].type()) {
        vector<ListK8sSecretsResponseBodyResultSecrets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Secrets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListK8sSecretsResponseBodyResultSecrets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        secrets = make_shared<vector<ListK8sSecretsResponseBodyResultSecrets>>(expect1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListK8sSecretsResponseBodyResult() = default;
};
class ListK8sSecretsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListK8sSecretsResponseBodyResult> result{};

  ListK8sSecretsResponseBody() {}

  explicit ListK8sSecretsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ListK8sSecretsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ListK8sSecretsResponseBodyResult>(model1);
      }
    }
  }


  virtual ~ListK8sSecretsResponseBody() = default;
};
class ListK8sSecretsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListK8sSecretsResponseBody> body{};

  ListK8sSecretsResponse() {}

  explicit ListK8sSecretsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListK8sSecretsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListK8sSecretsResponseBody>(model1);
      }
    }
  }


  virtual ~ListK8sSecretsResponse() = default;
};
class ListMethodsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> serviceName{};

  ListMethodsRequest() {}

  explicit ListMethodsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~ListMethodsRequest() = default;
};
class ListMethodsResponseBodyServiceMethodListServiceMethodInputParams : public Darabonba::Model {
public:
  shared_ptr<vector<string>> inputParam{};

  ListMethodsResponseBodyServiceMethodListServiceMethodInputParams() {}

  explicit ListMethodsResponseBodyServiceMethodListServiceMethodInputParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputParam) {
      res["InputParam"] = boost::any(*inputParam);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputParam") != m.end() && !m["InputParam"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InputParam"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InputParam"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      inputParam = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListMethodsResponseBodyServiceMethodListServiceMethodInputParams() = default;
};
class ListMethodsResponseBodyServiceMethodListServiceMethodParamTypes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> paramType{};

  ListMethodsResponseBodyServiceMethodListServiceMethodParamTypes() {}

  explicit ListMethodsResponseBodyServiceMethodListServiceMethodParamTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (paramType) {
      res["ParamType"] = boost::any(*paramType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParamType") != m.end() && !m["ParamType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ParamType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ParamType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      paramType = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListMethodsResponseBodyServiceMethodListServiceMethodParamTypes() = default;
};
class ListMethodsResponseBodyServiceMethodListServiceMethod : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<ListMethodsResponseBodyServiceMethodListServiceMethodInputParams> inputParams{};
  shared_ptr<string> methodName{};
  shared_ptr<string> output{};
  shared_ptr<ListMethodsResponseBodyServiceMethodListServiceMethodParamTypes> paramTypes{};
  shared_ptr<string> serviceName{};

  ListMethodsResponseBodyServiceMethodListServiceMethod() {}

  explicit ListMethodsResponseBodyServiceMethodListServiceMethod(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (inputParams) {
      res["InputParams"] = inputParams ? boost::any(inputParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (paramTypes) {
      res["ParamTypes"] = paramTypes ? boost::any(paramTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("InputParams") != m.end() && !m["InputParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputParams"].type()) {
        ListMethodsResponseBodyServiceMethodListServiceMethodInputParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputParams"]));
        inputParams = make_shared<ListMethodsResponseBodyServiceMethodListServiceMethodInputParams>(model1);
      }
    }
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("ParamTypes") != m.end() && !m["ParamTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["ParamTypes"].type()) {
        ListMethodsResponseBodyServiceMethodListServiceMethodParamTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ParamTypes"]));
        paramTypes = make_shared<ListMethodsResponseBodyServiceMethodListServiceMethodParamTypes>(model1);
      }
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~ListMethodsResponseBodyServiceMethodListServiceMethod() = default;
};
class ListMethodsResponseBodyServiceMethodList : public Darabonba::Model {
public:
  shared_ptr<vector<ListMethodsResponseBodyServiceMethodListServiceMethod>> serviceMethod{};

  ListMethodsResponseBodyServiceMethodList() {}

  explicit ListMethodsResponseBodyServiceMethodList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceMethod) {
      vector<boost::any> temp1;
      for(auto item1:*serviceMethod){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceMethod"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceMethod") != m.end() && !m["ServiceMethod"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceMethod"].type()) {
        vector<ListMethodsResponseBodyServiceMethodListServiceMethod> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceMethod"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMethodsResponseBodyServiceMethodListServiceMethod model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceMethod = make_shared<vector<ListMethodsResponseBodyServiceMethodListServiceMethod>>(expect1);
      }
    }
  }


  virtual ~ListMethodsResponseBodyServiceMethodList() = default;
};
class ListMethodsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListMethodsResponseBodyServiceMethodList> serviceMethodList{};

  ListMethodsResponseBody() {}

  explicit ListMethodsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (serviceMethodList) {
      res["ServiceMethodList"] = serviceMethodList ? boost::any(serviceMethodList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ServiceMethodList") != m.end() && !m["ServiceMethodList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceMethodList"].type()) {
        ListMethodsResponseBodyServiceMethodList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceMethodList"]));
        serviceMethodList = make_shared<ListMethodsResponseBodyServiceMethodList>(model1);
      }
    }
  }


  virtual ~ListMethodsResponseBody() = default;
};
class ListMethodsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMethodsResponseBody> body{};

  ListMethodsResponse() {}

  explicit ListMethodsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMethodsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMethodsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMethodsResponse() = default;
};
class ListPublishedServicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  ListPublishedServicesRequest() {}

  explicit ListPublishedServicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~ListPublishedServicesRequest() = default;
};
class ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesGroups : public Darabonba::Model {
public:
  shared_ptr<vector<string>> group{};

  ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesGroups() {}

  explicit ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (group) {
      res["group"] = boost::any(*group);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("group") != m.end() && !m["group"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["group"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["group"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      group = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesGroups() = default;
};
class ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesIps : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ip{};

  ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesIps() {}

  explicit ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesIps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["ip"] = boost::any(*ip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ip") != m.end() && !m["ip"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ip"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ip"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ip = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesIps() = default;
};
class ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> dockerApplication{};
  shared_ptr<string> group2Ip{};
  shared_ptr<ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesGroups> groups{};
  shared_ptr<ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesIps> ips{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> version{};

  ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices() {}

  explicit ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dockerApplication) {
      res["DockerApplication"] = boost::any(*dockerApplication);
    }
    if (group2Ip) {
      res["Group2Ip"] = boost::any(*group2Ip);
    }
    if (groups) {
      res["Groups"] = groups ? boost::any(groups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ips) {
      res["Ips"] = ips ? boost::any(ips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DockerApplication") != m.end() && !m["DockerApplication"].empty()) {
      dockerApplication = make_shared<bool>(boost::any_cast<bool>(m["DockerApplication"]));
    }
    if (m.find("Group2Ip") != m.end() && !m["Group2Ip"].empty()) {
      group2Ip = make_shared<string>(boost::any_cast<string>(m["Group2Ip"]));
    }
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      if (typeid(map<string, boost::any>) == m["Groups"].type()) {
        ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Groups"]));
        groups = make_shared<ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesGroups>(model1);
      }
    }
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ips"].type()) {
        ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesIps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ips"]));
        ips = make_shared<ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesIps>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices() = default;
};
class ListPublishedServicesResponseBodyPublishedServicesList : public Darabonba::Model {
public:
  shared_ptr<vector<ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices>> listPublishedServices{};

  ListPublishedServicesResponseBodyPublishedServicesList() {}

  explicit ListPublishedServicesResponseBodyPublishedServicesList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listPublishedServices) {
      vector<boost::any> temp1;
      for(auto item1:*listPublishedServices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ListPublishedServices"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListPublishedServices") != m.end() && !m["ListPublishedServices"].empty()) {
      if (typeid(vector<boost::any>) == m["ListPublishedServices"].type()) {
        vector<ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ListPublishedServices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        listPublishedServices = make_shared<vector<ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices>>(expect1);
      }
    }
  }


  virtual ~ListPublishedServicesResponseBodyPublishedServicesList() = default;
};
class ListPublishedServicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<ListPublishedServicesResponseBodyPublishedServicesList> publishedServicesList{};
  shared_ptr<string> requestId{};

  ListPublishedServicesResponseBody() {}

  explicit ListPublishedServicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (publishedServicesList) {
      res["PublishedServicesList"] = publishedServicesList ? boost::any(publishedServicesList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PublishedServicesList") != m.end() && !m["PublishedServicesList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PublishedServicesList"].type()) {
        ListPublishedServicesResponseBodyPublishedServicesList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PublishedServicesList"]));
        publishedServicesList = make_shared<ListPublishedServicesResponseBodyPublishedServicesList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPublishedServicesResponseBody() = default;
};
class ListPublishedServicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPublishedServicesResponseBody> body{};

  ListPublishedServicesResponse() {}

  explicit ListPublishedServicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPublishedServicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPublishedServicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListPublishedServicesResponse() = default;
};
class ListRecentChangeOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  ListRecentChangeOrderRequest() {}

  explicit ListRecentChangeOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~ListRecentChangeOrderRequest() = default;
};
class ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> batchCount{};
  shared_ptr<string> batchType{};
  shared_ptr<string> changeOrderDescription{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<string> coType{};
  shared_ptr<string> coTypeCode{};
  shared_ptr<string> createTime{};
  shared_ptr<string> createUserId{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> source{};
  shared_ptr<long> status{};
  shared_ptr<string> userId{};

  ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder() {}

  explicit ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (batchCount) {
      res["BatchCount"] = boost::any(*batchCount);
    }
    if (batchType) {
      res["BatchType"] = boost::any(*batchType);
    }
    if (changeOrderDescription) {
      res["ChangeOrderDescription"] = boost::any(*changeOrderDescription);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (coType) {
      res["CoType"] = boost::any(*coType);
    }
    if (coTypeCode) {
      res["CoTypeCode"] = boost::any(*coTypeCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUserId) {
      res["CreateUserId"] = boost::any(*createUserId);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BatchCount") != m.end() && !m["BatchCount"].empty()) {
      batchCount = make_shared<long>(boost::any_cast<long>(m["BatchCount"]));
    }
    if (m.find("BatchType") != m.end() && !m["BatchType"].empty()) {
      batchType = make_shared<string>(boost::any_cast<string>(m["BatchType"]));
    }
    if (m.find("ChangeOrderDescription") != m.end() && !m["ChangeOrderDescription"].empty()) {
      changeOrderDescription = make_shared<string>(boost::any_cast<string>(m["ChangeOrderDescription"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("CoType") != m.end() && !m["CoType"].empty()) {
      coType = make_shared<string>(boost::any_cast<string>(m["CoType"]));
    }
    if (m.find("CoTypeCode") != m.end() && !m["CoTypeCode"].empty()) {
      coTypeCode = make_shared<string>(boost::any_cast<string>(m["CoTypeCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateUserId") != m.end() && !m["CreateUserId"].empty()) {
      createUserId = make_shared<string>(boost::any_cast<string>(m["CreateUserId"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder() = default;
};
class ListRecentChangeOrderResponseBodyChangeOrderList : public Darabonba::Model {
public:
  shared_ptr<vector<ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder>> changeOrder{};

  ListRecentChangeOrderResponseBodyChangeOrderList() {}

  explicit ListRecentChangeOrderResponseBodyChangeOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrder) {
      vector<boost::any> temp1;
      for(auto item1:*changeOrder){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChangeOrder"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrder") != m.end() && !m["ChangeOrder"].empty()) {
      if (typeid(vector<boost::any>) == m["ChangeOrder"].type()) {
        vector<ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChangeOrder"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        changeOrder = make_shared<vector<ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder>>(expect1);
      }
    }
  }


  virtual ~ListRecentChangeOrderResponseBodyChangeOrderList() = default;
};
class ListRecentChangeOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListRecentChangeOrderResponseBodyChangeOrderList> changeOrderList{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListRecentChangeOrderResponseBody() {}

  explicit ListRecentChangeOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderList) {
      res["ChangeOrderList"] = changeOrderList ? boost::any(changeOrderList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderList") != m.end() && !m["ChangeOrderList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ChangeOrderList"].type()) {
        ListRecentChangeOrderResponseBodyChangeOrderList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ChangeOrderList"]));
        changeOrderList = make_shared<ListRecentChangeOrderResponseBodyChangeOrderList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListRecentChangeOrderResponseBody() = default;
};
class ListRecentChangeOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRecentChangeOrderResponseBody> body{};

  ListRecentChangeOrderResponse() {}

  explicit ListRecentChangeOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRecentChangeOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRecentChangeOrderResponseBody>(model1);
      }
    }
  }


  virtual ~ListRecentChangeOrderResponse() = default;
};
class ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> addressType{};
  shared_ptr<bool> expired{};
  shared_ptr<long> groupId{};
  shared_ptr<string> networkType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> slbId{};
  shared_ptr<string> slbName{};
  shared_ptr<string> slbStatus{};
  shared_ptr<string> userId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vswitchId{};

  ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity() {}

  explicit ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (addressType) {
      res["AddressType"] = boost::any(*addressType);
    }
    if (expired) {
      res["Expired"] = boost::any(*expired);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (slbName) {
      res["SlbName"] = boost::any(*slbName);
    }
    if (slbStatus) {
      res["SlbStatus"] = boost::any(*slbStatus);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("AddressType") != m.end() && !m["AddressType"].empty()) {
      addressType = make_shared<string>(boost::any_cast<string>(m["AddressType"]));
    }
    if (m.find("Expired") != m.end() && !m["Expired"].empty()) {
      expired = make_shared<bool>(boost::any_cast<bool>(m["Expired"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("SlbName") != m.end() && !m["SlbName"].empty()) {
      slbName = make_shared<string>(boost::any_cast<string>(m["SlbName"]));
    }
    if (m.find("SlbStatus") != m.end() && !m["SlbStatus"].empty()) {
      slbStatus = make_shared<string>(boost::any_cast<string>(m["SlbStatus"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity() = default;
};
class ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbList : public Darabonba::Model {
public:
  shared_ptr<vector<ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity>> slbEntity{};

  ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbList() {}

  explicit ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (slbEntity) {
      vector<boost::any> temp1;
      for(auto item1:*slbEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SlbEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SlbEntity") != m.end() && !m["SlbEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["SlbEntity"].type()) {
        vector<ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SlbEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        slbEntity = make_shared<vector<ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity>>(expect1);
      }
    }
  }


  virtual ~ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbList() = default;
};
class ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity : public Darabonba::Model {
public:
  shared_ptr<long> availableCpu{};
  shared_ptr<long> availableMem{};
  shared_ptr<long> cpu{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> dockerEnv{};
  shared_ptr<string> ecuId{};
  shared_ptr<long> heartbeatTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ipAddr{};
  shared_ptr<long> mem{};
  shared_ptr<string> name{};
  shared_ptr<bool> online{};
  shared_ptr<string> regionId{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zoneId{};

  ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity() {}

  explicit ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableCpu) {
      res["AvailableCpu"] = boost::any(*availableCpu);
    }
    if (availableMem) {
      res["AvailableMem"] = boost::any(*availableMem);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dockerEnv) {
      res["DockerEnv"] = boost::any(*dockerEnv);
    }
    if (ecuId) {
      res["EcuId"] = boost::any(*ecuId);
    }
    if (heartbeatTime) {
      res["HeartbeatTime"] = boost::any(*heartbeatTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ipAddr) {
      res["IpAddr"] = boost::any(*ipAddr);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableCpu") != m.end() && !m["AvailableCpu"].empty()) {
      availableCpu = make_shared<long>(boost::any_cast<long>(m["AvailableCpu"]));
    }
    if (m.find("AvailableMem") != m.end() && !m["AvailableMem"].empty()) {
      availableMem = make_shared<long>(boost::any_cast<long>(m["AvailableMem"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DockerEnv") != m.end() && !m["DockerEnv"].empty()) {
      dockerEnv = make_shared<bool>(boost::any_cast<bool>(m["DockerEnv"]));
    }
    if (m.find("EcuId") != m.end() && !m["EcuId"].empty()) {
      ecuId = make_shared<string>(boost::any_cast<string>(m["EcuId"]));
    }
    if (m.find("HeartbeatTime") != m.end() && !m["HeartbeatTime"].empty()) {
      heartbeatTime = make_shared<long>(boost::any_cast<long>(m["HeartbeatTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IpAddr") != m.end() && !m["IpAddr"].empty()) {
      ipAddr = make_shared<string>(boost::any_cast<string>(m["IpAddr"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<bool>(boost::any_cast<bool>(m["Online"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity() = default;
};
class ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity : public Darabonba::Model {
public:
  shared_ptr<string> cidrblock{};
  shared_ptr<string> description{};
  shared_ptr<long> ecsNum{};
  shared_ptr<bool> expired{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};
  shared_ptr<string> userId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcName{};

  ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity() {}

  explicit ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrblock) {
      res["Cidrblock"] = boost::any(*cidrblock);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ecsNum) {
      res["EcsNum"] = boost::any(*ecsNum);
    }
    if (expired) {
      res["Expired"] = boost::any(*expired);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cidrblock") != m.end() && !m["Cidrblock"].empty()) {
      cidrblock = make_shared<string>(boost::any_cast<string>(m["Cidrblock"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EcsNum") != m.end() && !m["EcsNum"].empty()) {
      ecsNum = make_shared<long>(boost::any_cast<long>(m["EcsNum"]));
    }
    if (m.find("Expired") != m.end() && !m["Expired"].empty()) {
      expired = make_shared<bool>(boost::any_cast<bool>(m["Expired"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
  }


  virtual ~ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity() = default;
};
class ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity : public Darabonba::Model {
public:
  shared_ptr<long> cpu{};
  shared_ptr<string> description{};
  shared_ptr<ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity> ecuEntity{};
  shared_ptr<string> eip{};
  shared_ptr<bool> expired{};
  shared_ptr<string> groupId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> innerIp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> mem{};
  shared_ptr<string> privateIp{};
  shared_ptr<string> publicIp{};
  shared_ptr<string> regionId{};
  shared_ptr<string> serialNum{};
  shared_ptr<string> sgId{};
  shared_ptr<string> status{};
  shared_ptr<string> userId{};
  shared_ptr<ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity> vpcEntity{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zoneId{};

  ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity() {}

  explicit ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ecuEntity) {
      res["EcuEntity"] = ecuEntity ? boost::any(ecuEntity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (eip) {
      res["Eip"] = boost::any(*eip);
    }
    if (expired) {
      res["Expired"] = boost::any(*expired);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (innerIp) {
      res["InnerIp"] = boost::any(*innerIp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (privateIp) {
      res["PrivateIp"] = boost::any(*privateIp);
    }
    if (publicIp) {
      res["PublicIp"] = boost::any(*publicIp);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (serialNum) {
      res["SerialNum"] = boost::any(*serialNum);
    }
    if (sgId) {
      res["SgId"] = boost::any(*sgId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (vpcEntity) {
      res["VpcEntity"] = vpcEntity ? boost::any(vpcEntity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EcuEntity") != m.end() && !m["EcuEntity"].empty()) {
      if (typeid(map<string, boost::any>) == m["EcuEntity"].type()) {
        ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EcuEntity"]));
        ecuEntity = make_shared<ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity>(model1);
      }
    }
    if (m.find("Eip") != m.end() && !m["Eip"].empty()) {
      eip = make_shared<string>(boost::any_cast<string>(m["Eip"]));
    }
    if (m.find("Expired") != m.end() && !m["Expired"].empty()) {
      expired = make_shared<bool>(boost::any_cast<bool>(m["Expired"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InnerIp") != m.end() && !m["InnerIp"].empty()) {
      innerIp = make_shared<string>(boost::any_cast<string>(m["InnerIp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("PrivateIp") != m.end() && !m["PrivateIp"].empty()) {
      privateIp = make_shared<string>(boost::any_cast<string>(m["PrivateIp"]));
    }
    if (m.find("PublicIp") != m.end() && !m["PublicIp"].empty()) {
      publicIp = make_shared<string>(boost::any_cast<string>(m["PublicIp"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SerialNum") != m.end() && !m["SerialNum"].empty()) {
      serialNum = make_shared<string>(boost::any_cast<string>(m["SerialNum"]));
    }
    if (m.find("SgId") != m.end() && !m["SgId"].empty()) {
      sgId = make_shared<string>(boost::any_cast<string>(m["SgId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("VpcEntity") != m.end() && !m["VpcEntity"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpcEntity"].type()) {
        ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpcEntity"]));
        vpcEntity = make_shared<ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity>(model1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity() = default;
};
class ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsList : public Darabonba::Model {
public:
  shared_ptr<vector<ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity>> ecsEntity{};

  ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsList() {}

  explicit ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecsEntity) {
      vector<boost::any> temp1;
      for(auto item1:*ecsEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EcsEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcsEntity") != m.end() && !m["EcsEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["EcsEntity"].type()) {
        vector<ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EcsEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ecsEntity = make_shared<vector<ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity>>(expect1);
      }
    }
  }


  virtual ~ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsList() = default;
};
class ListResourceGroupResponseBodyResourceGroupListResGroupEntity : public Darabonba::Model {
public:
  shared_ptr<string> adminUserId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbList> slbList{};
  shared_ptr<long> updateTime{};
  shared_ptr<ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsList> ecsList{};

  ListResourceGroupResponseBodyResourceGroupListResGroupEntity() {}

  explicit ListResourceGroupResponseBodyResourceGroupListResGroupEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminUserId) {
      res["AdminUserId"] = boost::any(*adminUserId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (slbList) {
      res["SlbList"] = slbList ? boost::any(slbList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (ecsList) {
      res["ecsList"] = ecsList ? boost::any(ecsList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminUserId") != m.end() && !m["AdminUserId"].empty()) {
      adminUserId = make_shared<string>(boost::any_cast<string>(m["AdminUserId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SlbList") != m.end() && !m["SlbList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SlbList"].type()) {
        ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SlbList"]));
        slbList = make_shared<ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbList>(model1);
      }
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("ecsList") != m.end() && !m["ecsList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ecsList"].type()) {
        ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ecsList"]));
        ecsList = make_shared<ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsList>(model1);
      }
    }
  }


  virtual ~ListResourceGroupResponseBodyResourceGroupListResGroupEntity() = default;
};
class ListResourceGroupResponseBodyResourceGroupList : public Darabonba::Model {
public:
  shared_ptr<vector<ListResourceGroupResponseBodyResourceGroupListResGroupEntity>> resGroupEntity{};

  ListResourceGroupResponseBodyResourceGroupList() {}

  explicit ListResourceGroupResponseBodyResourceGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resGroupEntity) {
      vector<boost::any> temp1;
      for(auto item1:*resGroupEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResGroupEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResGroupEntity") != m.end() && !m["ResGroupEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["ResGroupEntity"].type()) {
        vector<ListResourceGroupResponseBodyResourceGroupListResGroupEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResGroupEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourceGroupResponseBodyResourceGroupListResGroupEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resGroupEntity = make_shared<vector<ListResourceGroupResponseBodyResourceGroupListResGroupEntity>>(expect1);
      }
    }
  }


  virtual ~ListResourceGroupResponseBodyResourceGroupList() = default;
};
class ListResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListResourceGroupResponseBodyResourceGroupList> resourceGroupList{};

  ListResourceGroupResponseBody() {}

  explicit ListResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupList) {
      res["ResourceGroupList"] = resourceGroupList ? boost::any(resourceGroupList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupList") != m.end() && !m["ResourceGroupList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceGroupList"].type()) {
        ListResourceGroupResponseBodyResourceGroupList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceGroupList"]));
        resourceGroupList = make_shared<ListResourceGroupResponseBodyResourceGroupList>(model1);
      }
    }
  }


  virtual ~ListResourceGroupResponseBody() = default;
};
class ListResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListResourceGroupResponseBody> body{};

  ListResourceGroupResponse() {}

  explicit ListResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListResourceGroupResponse() = default;
};
class ListRoleResponseBodyRoleListRoleItemActionListAction : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> name{};

  ListRoleResponseBodyRoleListRoleItemActionListAction() {}

  explicit ListRoleResponseBodyRoleListRoleItemActionListAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListRoleResponseBodyRoleListRoleItemActionListAction() = default;
};
class ListRoleResponseBodyRoleListRoleItemActionList : public Darabonba::Model {
public:
  shared_ptr<vector<ListRoleResponseBodyRoleListRoleItemActionListAction>> action{};

  ListRoleResponseBodyRoleListRoleItemActionList() {}

  explicit ListRoleResponseBodyRoleListRoleItemActionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      vector<boost::any> temp1;
      for(auto item1:*action){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Action"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      if (typeid(vector<boost::any>) == m["Action"].type()) {
        vector<ListRoleResponseBodyRoleListRoleItemActionListAction> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Action"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRoleResponseBodyRoleListRoleItemActionListAction model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        action = make_shared<vector<ListRoleResponseBodyRoleListRoleItemActionListAction>>(expect1);
      }
    }
  }


  virtual ~ListRoleResponseBodyRoleListRoleItemActionList() = default;
};
class ListRoleResponseBodyRoleListRoleItemRole : public Darabonba::Model {
public:
  shared_ptr<string> adminUserId{};
  shared_ptr<long> createTime{};
  shared_ptr<long> id{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> name{};
  shared_ptr<long> updateTime{};

  ListRoleResponseBodyRoleListRoleItemRole() {}

  explicit ListRoleResponseBodyRoleListRoleItemRole(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminUserId) {
      res["AdminUserId"] = boost::any(*adminUserId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminUserId") != m.end() && !m["AdminUserId"].empty()) {
      adminUserId = make_shared<string>(boost::any_cast<string>(m["AdminUserId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~ListRoleResponseBodyRoleListRoleItemRole() = default;
};
class ListRoleResponseBodyRoleListRoleItem : public Darabonba::Model {
public:
  shared_ptr<ListRoleResponseBodyRoleListRoleItemActionList> actionList{};
  shared_ptr<ListRoleResponseBodyRoleListRoleItemRole> role{};

  ListRoleResponseBodyRoleListRoleItem() {}

  explicit ListRoleResponseBodyRoleListRoleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionList) {
      res["ActionList"] = actionList ? boost::any(actionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (role) {
      res["Role"] = role ? boost::any(role->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionList") != m.end() && !m["ActionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ActionList"].type()) {
        ListRoleResponseBodyRoleListRoleItemActionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ActionList"]));
        actionList = make_shared<ListRoleResponseBodyRoleListRoleItemActionList>(model1);
      }
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      if (typeid(map<string, boost::any>) == m["Role"].type()) {
        ListRoleResponseBodyRoleListRoleItemRole model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Role"]));
        role = make_shared<ListRoleResponseBodyRoleListRoleItemRole>(model1);
      }
    }
  }


  virtual ~ListRoleResponseBodyRoleListRoleItem() = default;
};
class ListRoleResponseBodyRoleList : public Darabonba::Model {
public:
  shared_ptr<vector<ListRoleResponseBodyRoleListRoleItem>> roleItem{};

  ListRoleResponseBodyRoleList() {}

  explicit ListRoleResponseBodyRoleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleItem) {
      vector<boost::any> temp1;
      for(auto item1:*roleItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RoleItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleItem") != m.end() && !m["RoleItem"].empty()) {
      if (typeid(vector<boost::any>) == m["RoleItem"].type()) {
        vector<ListRoleResponseBodyRoleListRoleItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RoleItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRoleResponseBodyRoleListRoleItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roleItem = make_shared<vector<ListRoleResponseBodyRoleListRoleItem>>(expect1);
      }
    }
  }


  virtual ~ListRoleResponseBodyRoleList() = default;
};
class ListRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListRoleResponseBodyRoleList> roleList{};

  ListRoleResponseBody() {}

  explicit ListRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (roleList) {
      res["RoleList"] = roleList ? boost::any(roleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RoleList") != m.end() && !m["RoleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoleList"].type()) {
        ListRoleResponseBodyRoleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoleList"]));
        roleList = make_shared<ListRoleResponseBodyRoleList>(model1);
      }
    }
  }


  virtual ~ListRoleResponseBody() = default;
};
class ListRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRoleResponseBody> body{};

  ListRoleResponse() {}

  explicit ListRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRoleResponseBody>(model1);
      }
    }
  }


  virtual ~ListRoleResponse() = default;
};
class ListScaleOutEcuRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> cpu{};
  shared_ptr<string> groupId{};
  shared_ptr<long> instanceNum{};
  shared_ptr<string> logicalRegionId{};
  shared_ptr<long> mem{};

  ListScaleOutEcuRequest() {}

  explicit ListScaleOutEcuRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceNum) {
      res["InstanceNum"] = boost::any(*instanceNum);
    }
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("InstanceNum") != m.end() && !m["InstanceNum"].empty()) {
      instanceNum = make_shared<long>(boost::any_cast<long>(m["InstanceNum"]));
    }
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
  }


  virtual ~ListScaleOutEcuRequest() = default;
};
class ListScaleOutEcuResponseBodyEcuInfoListEcuInfo : public Darabonba::Model {
public:
  shared_ptr<long> availableCpu{};
  shared_ptr<long> availableMem{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> dockerEnv{};
  shared_ptr<string> ecuId{};
  shared_ptr<long> heartbeatTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ipAddr{};
  shared_ptr<string> name{};
  shared_ptr<bool> online{};
  shared_ptr<string> regionId{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zoneId{};

  ListScaleOutEcuResponseBodyEcuInfoListEcuInfo() {}

  explicit ListScaleOutEcuResponseBodyEcuInfoListEcuInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableCpu) {
      res["AvailableCpu"] = boost::any(*availableCpu);
    }
    if (availableMem) {
      res["AvailableMem"] = boost::any(*availableMem);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dockerEnv) {
      res["DockerEnv"] = boost::any(*dockerEnv);
    }
    if (ecuId) {
      res["EcuId"] = boost::any(*ecuId);
    }
    if (heartbeatTime) {
      res["HeartbeatTime"] = boost::any(*heartbeatTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ipAddr) {
      res["IpAddr"] = boost::any(*ipAddr);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableCpu") != m.end() && !m["AvailableCpu"].empty()) {
      availableCpu = make_shared<long>(boost::any_cast<long>(m["AvailableCpu"]));
    }
    if (m.find("AvailableMem") != m.end() && !m["AvailableMem"].empty()) {
      availableMem = make_shared<long>(boost::any_cast<long>(m["AvailableMem"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DockerEnv") != m.end() && !m["DockerEnv"].empty()) {
      dockerEnv = make_shared<bool>(boost::any_cast<bool>(m["DockerEnv"]));
    }
    if (m.find("EcuId") != m.end() && !m["EcuId"].empty()) {
      ecuId = make_shared<string>(boost::any_cast<string>(m["EcuId"]));
    }
    if (m.find("HeartbeatTime") != m.end() && !m["HeartbeatTime"].empty()) {
      heartbeatTime = make_shared<long>(boost::any_cast<long>(m["HeartbeatTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IpAddr") != m.end() && !m["IpAddr"].empty()) {
      ipAddr = make_shared<string>(boost::any_cast<string>(m["IpAddr"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<bool>(boost::any_cast<bool>(m["Online"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~ListScaleOutEcuResponseBodyEcuInfoListEcuInfo() = default;
};
class ListScaleOutEcuResponseBodyEcuInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<ListScaleOutEcuResponseBodyEcuInfoListEcuInfo>> ecuInfo{};

  ListScaleOutEcuResponseBodyEcuInfoList() {}

  explicit ListScaleOutEcuResponseBodyEcuInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecuInfo) {
      vector<boost::any> temp1;
      for(auto item1:*ecuInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EcuInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcuInfo") != m.end() && !m["EcuInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["EcuInfo"].type()) {
        vector<ListScaleOutEcuResponseBodyEcuInfoListEcuInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EcuInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScaleOutEcuResponseBodyEcuInfoListEcuInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ecuInfo = make_shared<vector<ListScaleOutEcuResponseBodyEcuInfoListEcuInfo>>(expect1);
      }
    }
  }


  virtual ~ListScaleOutEcuResponseBodyEcuInfoList() = default;
};
class ListScaleOutEcuResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListScaleOutEcuResponseBodyEcuInfoList> ecuInfoList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListScaleOutEcuResponseBody() {}

  explicit ListScaleOutEcuResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (ecuInfoList) {
      res["EcuInfoList"] = ecuInfoList ? boost::any(ecuInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("EcuInfoList") != m.end() && !m["EcuInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EcuInfoList"].type()) {
        ListScaleOutEcuResponseBodyEcuInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EcuInfoList"]));
        ecuInfoList = make_shared<ListScaleOutEcuResponseBodyEcuInfoList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListScaleOutEcuResponseBody() = default;
};
class ListScaleOutEcuResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListScaleOutEcuResponseBody> body{};

  ListScaleOutEcuResponse() {}

  explicit ListScaleOutEcuResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListScaleOutEcuResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListScaleOutEcuResponseBody>(model1);
      }
    }
  }


  virtual ~ListScaleOutEcuResponse() = default;
};
class ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};

  ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups() {}

  explicit ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups() = default;
};
class ListServiceGroupsResponseBodyServiceGroupsList : public Darabonba::Model {
public:
  shared_ptr<vector<ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups>> listServiceGroups{};

  ListServiceGroupsResponseBodyServiceGroupsList() {}

  explicit ListServiceGroupsResponseBodyServiceGroupsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listServiceGroups) {
      vector<boost::any> temp1;
      for(auto item1:*listServiceGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ListServiceGroups"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListServiceGroups") != m.end() && !m["ListServiceGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["ListServiceGroups"].type()) {
        vector<ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ListServiceGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        listServiceGroups = make_shared<vector<ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups>>(expect1);
      }
    }
  }


  virtual ~ListServiceGroupsResponseBodyServiceGroupsList() = default;
};
class ListServiceGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListServiceGroupsResponseBodyServiceGroupsList> serviceGroupsList{};

  ListServiceGroupsResponseBody() {}

  explicit ListServiceGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (serviceGroupsList) {
      res["ServiceGroupsList"] = serviceGroupsList ? boost::any(serviceGroupsList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ServiceGroupsList") != m.end() && !m["ServiceGroupsList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceGroupsList"].type()) {
        ListServiceGroupsResponseBodyServiceGroupsList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceGroupsList"]));
        serviceGroupsList = make_shared<ListServiceGroupsResponseBodyServiceGroupsList>(model1);
      }
    }
  }


  virtual ~ListServiceGroupsResponseBody() = default;
};
class ListServiceGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListServiceGroupsResponseBody> body{};

  ListServiceGroupsResponse() {}

  explicit ListServiceGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListServiceGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListServiceGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListServiceGroupsResponse() = default;
};
class ListSlbRequest : public Darabonba::Model {
public:
  shared_ptr<string> addressType{};
  shared_ptr<string> slbType{};
  shared_ptr<string> vpcId{};

  ListSlbRequest() {}

  explicit ListSlbRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressType) {
      res["AddressType"] = boost::any(*addressType);
    }
    if (slbType) {
      res["SlbType"] = boost::any(*slbType);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressType") != m.end() && !m["AddressType"].empty()) {
      addressType = make_shared<string>(boost::any_cast<string>(m["AddressType"]));
    }
    if (m.find("SlbType") != m.end() && !m["SlbType"].empty()) {
      slbType = make_shared<string>(boost::any_cast<string>(m["SlbType"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ListSlbRequest() = default;
};
class ListSlbResponseBodySlbListSlbEntity : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> addressType{};
  shared_ptr<bool> expired{};
  shared_ptr<long> groupId{};
  shared_ptr<string> networkType{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> reusable{};
  shared_ptr<string> slbId{};
  shared_ptr<string> slbName{};
  shared_ptr<string> slbStatus{};
  shared_ptr<string> tags{};
  shared_ptr<string> userId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vswitchId{};

  ListSlbResponseBodySlbListSlbEntity() {}

  explicit ListSlbResponseBodySlbListSlbEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (addressType) {
      res["AddressType"] = boost::any(*addressType);
    }
    if (expired) {
      res["Expired"] = boost::any(*expired);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reusable) {
      res["Reusable"] = boost::any(*reusable);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (slbName) {
      res["SlbName"] = boost::any(*slbName);
    }
    if (slbStatus) {
      res["SlbStatus"] = boost::any(*slbStatus);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("AddressType") != m.end() && !m["AddressType"].empty()) {
      addressType = make_shared<string>(boost::any_cast<string>(m["AddressType"]));
    }
    if (m.find("Expired") != m.end() && !m["Expired"].empty()) {
      expired = make_shared<bool>(boost::any_cast<bool>(m["Expired"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Reusable") != m.end() && !m["Reusable"].empty()) {
      reusable = make_shared<bool>(boost::any_cast<bool>(m["Reusable"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("SlbName") != m.end() && !m["SlbName"].empty()) {
      slbName = make_shared<string>(boost::any_cast<string>(m["SlbName"]));
    }
    if (m.find("SlbStatus") != m.end() && !m["SlbStatus"].empty()) {
      slbStatus = make_shared<string>(boost::any_cast<string>(m["SlbStatus"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~ListSlbResponseBodySlbListSlbEntity() = default;
};
class ListSlbResponseBodySlbList : public Darabonba::Model {
public:
  shared_ptr<vector<ListSlbResponseBodySlbListSlbEntity>> slbEntity{};

  ListSlbResponseBodySlbList() {}

  explicit ListSlbResponseBodySlbList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (slbEntity) {
      vector<boost::any> temp1;
      for(auto item1:*slbEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SlbEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SlbEntity") != m.end() && !m["SlbEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["SlbEntity"].type()) {
        vector<ListSlbResponseBodySlbListSlbEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SlbEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSlbResponseBodySlbListSlbEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        slbEntity = make_shared<vector<ListSlbResponseBodySlbListSlbEntity>>(expect1);
      }
    }
  }


  virtual ~ListSlbResponseBodySlbList() = default;
};
class ListSlbResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListSlbResponseBodySlbList> slbList{};

  ListSlbResponseBody() {}

  explicit ListSlbResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (slbList) {
      res["SlbList"] = slbList ? boost::any(slbList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SlbList") != m.end() && !m["SlbList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SlbList"].type()) {
        ListSlbResponseBodySlbList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SlbList"]));
        slbList = make_shared<ListSlbResponseBodySlbList>(model1);
      }
    }
  }


  virtual ~ListSlbResponseBody() = default;
};
class ListSlbResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSlbResponseBody> body{};

  ListSlbResponse() {}

  explicit ListSlbResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSlbResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSlbResponseBody>(model1);
      }
    }
  }


  virtual ~ListSlbResponse() = default;
};
class ListSubAccountResponseBodySubAccountListSubAccount : public Darabonba::Model {
public:
  shared_ptr<string> adminEdasId{};
  shared_ptr<string> adminUserId{};
  shared_ptr<string> adminUserKp{};
  shared_ptr<string> email{};
  shared_ptr<string> phone{};
  shared_ptr<string> subEdasId{};
  shared_ptr<string> subUserId{};
  shared_ptr<string> subUserKp{};

  ListSubAccountResponseBodySubAccountListSubAccount() {}

  explicit ListSubAccountResponseBodySubAccountListSubAccount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminEdasId) {
      res["AdminEdasId"] = boost::any(*adminEdasId);
    }
    if (adminUserId) {
      res["AdminUserId"] = boost::any(*adminUserId);
    }
    if (adminUserKp) {
      res["AdminUserKp"] = boost::any(*adminUserKp);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (subEdasId) {
      res["SubEdasId"] = boost::any(*subEdasId);
    }
    if (subUserId) {
      res["SubUserId"] = boost::any(*subUserId);
    }
    if (subUserKp) {
      res["SubUserKp"] = boost::any(*subUserKp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminEdasId") != m.end() && !m["AdminEdasId"].empty()) {
      adminEdasId = make_shared<string>(boost::any_cast<string>(m["AdminEdasId"]));
    }
    if (m.find("AdminUserId") != m.end() && !m["AdminUserId"].empty()) {
      adminUserId = make_shared<string>(boost::any_cast<string>(m["AdminUserId"]));
    }
    if (m.find("AdminUserKp") != m.end() && !m["AdminUserKp"].empty()) {
      adminUserKp = make_shared<string>(boost::any_cast<string>(m["AdminUserKp"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("SubEdasId") != m.end() && !m["SubEdasId"].empty()) {
      subEdasId = make_shared<string>(boost::any_cast<string>(m["SubEdasId"]));
    }
    if (m.find("SubUserId") != m.end() && !m["SubUserId"].empty()) {
      subUserId = make_shared<string>(boost::any_cast<string>(m["SubUserId"]));
    }
    if (m.find("SubUserKp") != m.end() && !m["SubUserKp"].empty()) {
      subUserKp = make_shared<string>(boost::any_cast<string>(m["SubUserKp"]));
    }
  }


  virtual ~ListSubAccountResponseBodySubAccountListSubAccount() = default;
};
class ListSubAccountResponseBodySubAccountList : public Darabonba::Model {
public:
  shared_ptr<vector<ListSubAccountResponseBodySubAccountListSubAccount>> subAccount{};

  ListSubAccountResponseBodySubAccountList() {}

  explicit ListSubAccountResponseBodySubAccountList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subAccount) {
      vector<boost::any> temp1;
      for(auto item1:*subAccount){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubAccount"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubAccount") != m.end() && !m["SubAccount"].empty()) {
      if (typeid(vector<boost::any>) == m["SubAccount"].type()) {
        vector<ListSubAccountResponseBodySubAccountListSubAccount> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubAccount"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSubAccountResponseBodySubAccountListSubAccount model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subAccount = make_shared<vector<ListSubAccountResponseBodySubAccountListSubAccount>>(expect1);
      }
    }
  }


  virtual ~ListSubAccountResponseBodySubAccountList() = default;
};
class ListSubAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListSubAccountResponseBodySubAccountList> subAccountList{};

  ListSubAccountResponseBody() {}

  explicit ListSubAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subAccountList) {
      res["SubAccountList"] = subAccountList ? boost::any(subAccountList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubAccountList") != m.end() && !m["SubAccountList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubAccountList"].type()) {
        ListSubAccountResponseBodySubAccountList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubAccountList"]));
        subAccountList = make_shared<ListSubAccountResponseBodySubAccountList>(model1);
      }
    }
  }


  virtual ~ListSubAccountResponseBody() = default;
};
class ListSubAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSubAccountResponseBody> body{};

  ListSubAccountResponse() {}

  explicit ListSubAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSubAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSubAccountResponseBody>(model1);
      }
    }
  }


  virtual ~ListSubAccountResponse() = default;
};
class ListSwimmingLaneRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};

  ListSwimmingLaneRequest() {}

  explicit ListSwimmingLaneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
  }


  virtual ~ListSwimmingLaneRequest() = default;
};
class ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> extra{};
  shared_ptr<long> laneId{};
  shared_ptr<string> rules{};

  ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList() {}

  explicit ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (laneId) {
      res["LaneId"] = boost::any(*laneId);
    }
    if (rules) {
      res["Rules"] = boost::any(*rules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["Extra"]));
    }
    if (m.find("LaneId") != m.end() && !m["LaneId"].empty()) {
      laneId = make_shared<long>(boost::any_cast<long>(m["LaneId"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rules = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
  }


  virtual ~ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList() = default;
};
class ListSwimmingLaneResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> enableRules{};
  shared_ptr<string> entryRule{};
  shared_ptr<long> groupId{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> scenarioSign{};
  shared_ptr<vector<ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList>> swimmingLaneAppRelationShipList{};
  shared_ptr<string> tag{};

  ListSwimmingLaneResponseBodyData() {}

  explicit ListSwimmingLaneResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableRules) {
      res["EnableRules"] = boost::any(*enableRules);
    }
    if (entryRule) {
      res["EntryRule"] = boost::any(*entryRule);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (scenarioSign) {
      res["ScenarioSign"] = boost::any(*scenarioSign);
    }
    if (swimmingLaneAppRelationShipList) {
      vector<boost::any> temp1;
      for(auto item1:*swimmingLaneAppRelationShipList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SwimmingLaneAppRelationShipList"] = boost::any(temp1);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableRules") != m.end() && !m["EnableRules"].empty()) {
      enableRules = make_shared<bool>(boost::any_cast<bool>(m["EnableRules"]));
    }
    if (m.find("EntryRule") != m.end() && !m["EntryRule"].empty()) {
      entryRule = make_shared<string>(boost::any_cast<string>(m["EntryRule"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("ScenarioSign") != m.end() && !m["ScenarioSign"].empty()) {
      scenarioSign = make_shared<string>(boost::any_cast<string>(m["ScenarioSign"]));
    }
    if (m.find("SwimmingLaneAppRelationShipList") != m.end() && !m["SwimmingLaneAppRelationShipList"].empty()) {
      if (typeid(vector<boost::any>) == m["SwimmingLaneAppRelationShipList"].type()) {
        vector<ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SwimmingLaneAppRelationShipList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        swimmingLaneAppRelationShipList = make_shared<vector<ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList>>(expect1);
      }
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~ListSwimmingLaneResponseBodyData() = default;
};
class ListSwimmingLaneResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListSwimmingLaneResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListSwimmingLaneResponseBody() {}

  explicit ListSwimmingLaneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListSwimmingLaneResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSwimmingLaneResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListSwimmingLaneResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListSwimmingLaneResponseBody() = default;
};
class ListSwimmingLaneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSwimmingLaneResponseBody> body{};

  ListSwimmingLaneResponse() {}

  explicit ListSwimmingLaneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSwimmingLaneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSwimmingLaneResponseBody>(model1);
      }
    }
  }


  virtual ~ListSwimmingLaneResponse() = default;
};
class ListSwimmingLaneGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> logicalRegionId{};

  ListSwimmingLaneGroupRequest() {}

  explicit ListSwimmingLaneGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
  }


  virtual ~ListSwimmingLaneGroupRequest() = default;
};
class ListSwimmingLaneGroupResponseBodyDataApplicationList : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};

  ListSwimmingLaneGroupResponseBodyDataApplicationList() {}

  explicit ListSwimmingLaneGroupResponseBodyDataApplicationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
  }


  virtual ~ListSwimmingLaneGroupResponseBodyDataApplicationList() = default;
};
class ListSwimmingLaneGroupResponseBodyDataEntryApplication : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> source{};

  ListSwimmingLaneGroupResponseBodyDataEntryApplication() {}

  explicit ListSwimmingLaneGroupResponseBodyDataEntryApplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~ListSwimmingLaneGroupResponseBodyDataEntryApplication() = default;
};
class ListSwimmingLaneGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListSwimmingLaneGroupResponseBodyDataApplicationList>> applicationList{};
  shared_ptr<ListSwimmingLaneGroupResponseBodyDataEntryApplication> entryApplication{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> namespaceId{};

  ListSwimmingLaneGroupResponseBodyData() {}

  explicit ListSwimmingLaneGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationList) {
      vector<boost::any> temp1;
      for(auto item1:*applicationList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApplicationList"] = boost::any(temp1);
    }
    if (entryApplication) {
      res["EntryApplication"] = entryApplication ? boost::any(entryApplication->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationList") != m.end() && !m["ApplicationList"].empty()) {
      if (typeid(vector<boost::any>) == m["ApplicationList"].type()) {
        vector<ListSwimmingLaneGroupResponseBodyDataApplicationList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApplicationList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSwimmingLaneGroupResponseBodyDataApplicationList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applicationList = make_shared<vector<ListSwimmingLaneGroupResponseBodyDataApplicationList>>(expect1);
      }
    }
    if (m.find("EntryApplication") != m.end() && !m["EntryApplication"].empty()) {
      if (typeid(map<string, boost::any>) == m["EntryApplication"].type()) {
        ListSwimmingLaneGroupResponseBodyDataEntryApplication model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EntryApplication"]));
        entryApplication = make_shared<ListSwimmingLaneGroupResponseBodyDataEntryApplication>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~ListSwimmingLaneGroupResponseBodyData() = default;
};
class ListSwimmingLaneGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListSwimmingLaneGroupResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListSwimmingLaneGroupResponseBody() {}

  explicit ListSwimmingLaneGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListSwimmingLaneGroupResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSwimmingLaneGroupResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListSwimmingLaneGroupResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListSwimmingLaneGroupResponseBody() = default;
};
class ListSwimmingLaneGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSwimmingLaneGroupResponseBody> body{};

  ListSwimmingLaneGroupResponse() {}

  explicit ListSwimmingLaneGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSwimmingLaneGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSwimmingLaneGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListSwimmingLaneGroupResponse() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> resourceIds{};
  shared_ptr<string> resourceRegionId{};
  shared_ptr<string> resourceType{};
  shared_ptr<map<string, boost::any>> tags{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (resourceRegionId) {
      res["ResourceRegionId"] = boost::any(*resourceRegionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ResourceIds"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      resourceIds = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ResourceRegionId") != m.end() && !m["ResourceRegionId"].empty()) {
      resourceRegionId = make_shared<string>(boost::any_cast<string>(m["ResourceRegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyTagResourcesTagResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyTagResourcesTagResource() {}

  explicit ListTagResourcesResponseBodyTagResourcesTagResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResourcesTagResource() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<vector<ListTagResourcesResponseBodyTagResourcesTagResource>> tagResource{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagResource) {
      vector<boost::any> temp1;
      for(auto item1:*tagResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagResource") != m.end() && !m["TagResource"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResource"].type()) {
        vector<ListTagResourcesResponseBodyTagResourcesTagResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResourcesTagResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResource = make_shared<vector<ListTagResourcesResponseBodyTagResourcesTagResource>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListTagResourcesResponseBodyTagResources> tagResources{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      res["TagResources"] = tagResources ? boost::any(tagResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagResources"].type()) {
        ListTagResourcesResponseBodyTagResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagResources"]));
        tagResources = make_shared<ListTagResourcesResponseBodyTagResources>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ListUserDefineRegionRequest : public Darabonba::Model {
public:
  shared_ptr<bool> debugEnable{};

  ListUserDefineRegionRequest() {}

  explicit ListUserDefineRegionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (debugEnable) {
      res["DebugEnable"] = boost::any(*debugEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DebugEnable") != m.end() && !m["DebugEnable"].empty()) {
      debugEnable = make_shared<bool>(boost::any_cast<bool>(m["DebugEnable"]));
    }
  }


  virtual ~ListUserDefineRegionRequest() = default;
};
class ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity : public Darabonba::Model {
public:
  shared_ptr<string> belongRegion{};
  shared_ptr<bool> debugEnable{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> mseInstanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> regionName{};
  shared_ptr<string> registryType{};
  shared_ptr<string> userId{};

  ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity() {}

  explicit ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (belongRegion) {
      res["BelongRegion"] = boost::any(*belongRegion);
    }
    if (debugEnable) {
      res["DebugEnable"] = boost::any(*debugEnable);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mseInstanceId) {
      res["MseInstanceId"] = boost::any(*mseInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (registryType) {
      res["RegistryType"] = boost::any(*registryType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BelongRegion") != m.end() && !m["BelongRegion"].empty()) {
      belongRegion = make_shared<string>(boost::any_cast<string>(m["BelongRegion"]));
    }
    if (m.find("DebugEnable") != m.end() && !m["DebugEnable"].empty()) {
      debugEnable = make_shared<bool>(boost::any_cast<bool>(m["DebugEnable"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MseInstanceId") != m.end() && !m["MseInstanceId"].empty()) {
      mseInstanceId = make_shared<string>(boost::any_cast<string>(m["MseInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("RegistryType") != m.end() && !m["RegistryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["RegistryType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity() = default;
};
class ListUserDefineRegionResponseBodyUserDefineRegionList : public Darabonba::Model {
public:
  shared_ptr<vector<ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity>> userDefineRegionEntity{};

  ListUserDefineRegionResponseBodyUserDefineRegionList() {}

  explicit ListUserDefineRegionResponseBodyUserDefineRegionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userDefineRegionEntity) {
      vector<boost::any> temp1;
      for(auto item1:*userDefineRegionEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserDefineRegionEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserDefineRegionEntity") != m.end() && !m["UserDefineRegionEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["UserDefineRegionEntity"].type()) {
        vector<ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserDefineRegionEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userDefineRegionEntity = make_shared<vector<ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity>>(expect1);
      }
    }
  }


  virtual ~ListUserDefineRegionResponseBodyUserDefineRegionList() = default;
};
class ListUserDefineRegionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListUserDefineRegionResponseBodyUserDefineRegionList> userDefineRegionList{};

  ListUserDefineRegionResponseBody() {}

  explicit ListUserDefineRegionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userDefineRegionList) {
      res["UserDefineRegionList"] = userDefineRegionList ? boost::any(userDefineRegionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserDefineRegionList") != m.end() && !m["UserDefineRegionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserDefineRegionList"].type()) {
        ListUserDefineRegionResponseBodyUserDefineRegionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserDefineRegionList"]));
        userDefineRegionList = make_shared<ListUserDefineRegionResponseBodyUserDefineRegionList>(model1);
      }
    }
  }


  virtual ~ListUserDefineRegionResponseBody() = default;
};
class ListUserDefineRegionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUserDefineRegionResponseBody> body{};

  ListUserDefineRegionResponse() {}

  explicit ListUserDefineRegionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUserDefineRegionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUserDefineRegionResponseBody>(model1);
      }
    }
  }


  virtual ~ListUserDefineRegionResponse() = default;
};
class ListVpcResponseBodyVpcListVpcEntity : public Darabonba::Model {
public:
  shared_ptr<long> ecsNum{};
  shared_ptr<bool> expired{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcName{};

  ListVpcResponseBodyVpcListVpcEntity() {}

  explicit ListVpcResponseBodyVpcListVpcEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecsNum) {
      res["EcsNum"] = boost::any(*ecsNum);
    }
    if (expired) {
      res["Expired"] = boost::any(*expired);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcsNum") != m.end() && !m["EcsNum"].empty()) {
      ecsNum = make_shared<long>(boost::any_cast<long>(m["EcsNum"]));
    }
    if (m.find("Expired") != m.end() && !m["Expired"].empty()) {
      expired = make_shared<bool>(boost::any_cast<bool>(m["Expired"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
  }


  virtual ~ListVpcResponseBodyVpcListVpcEntity() = default;
};
class ListVpcResponseBodyVpcList : public Darabonba::Model {
public:
  shared_ptr<vector<ListVpcResponseBodyVpcListVpcEntity>> vpcEntity{};

  ListVpcResponseBodyVpcList() {}

  explicit ListVpcResponseBodyVpcList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcEntity) {
      vector<boost::any> temp1;
      for(auto item1:*vpcEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VpcEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcEntity") != m.end() && !m["VpcEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["VpcEntity"].type()) {
        vector<ListVpcResponseBodyVpcListVpcEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VpcEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVpcResponseBodyVpcListVpcEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vpcEntity = make_shared<vector<ListVpcResponseBodyVpcListVpcEntity>>(expect1);
      }
    }
  }


  virtual ~ListVpcResponseBodyVpcList() = default;
};
class ListVpcResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListVpcResponseBodyVpcList> vpcList{};

  ListVpcResponseBody() {}

  explicit ListVpcResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vpcList) {
      res["VpcList"] = vpcList ? boost::any(vpcList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VpcList") != m.end() && !m["VpcList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpcList"].type()) {
        ListVpcResponseBodyVpcList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpcList"]));
        vpcList = make_shared<ListVpcResponseBodyVpcList>(model1);
      }
    }
  }


  virtual ~ListVpcResponseBody() = default;
};
class ListVpcResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListVpcResponseBody> body{};

  ListVpcResponse() {}

  explicit ListVpcResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListVpcResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListVpcResponseBody>(model1);
      }
    }
  }


  virtual ~ListVpcResponse() = default;
};
class MigrateEcuRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceIds{};
  shared_ptr<string> logicalRegionId{};

  MigrateEcuRequest() {}

  explicit MigrateEcuRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
  }


  virtual ~MigrateEcuRequest() = default;
};
class MigrateEcuResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  MigrateEcuResponseBody() {}

  explicit MigrateEcuResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~MigrateEcuResponseBody() = default;
};
class MigrateEcuResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MigrateEcuResponseBody> body{};

  MigrateEcuResponse() {}

  explicit MigrateEcuResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MigrateEcuResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MigrateEcuResponseBody>(model1);
      }
    }
  }


  virtual ~MigrateEcuResponse() = default;
};
class ModifyScalingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<bool> acceptEULA{};
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> inCondition{};
  shared_ptr<long> inCpu{};
  shared_ptr<long> inDuration{};
  shared_ptr<bool> inEnable{};
  shared_ptr<long> inInstanceNum{};
  shared_ptr<long> inLoad{};
  shared_ptr<long> inRT{};
  shared_ptr<long> inStep{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> multiAzPolicy{};
  shared_ptr<long> outCPU{};
  shared_ptr<string> outCondition{};
  shared_ptr<long> outDuration{};
  shared_ptr<bool> outEnable{};
  shared_ptr<long> outInstanceNum{};
  shared_ptr<long> outLoad{};
  shared_ptr<long> outRT{};
  shared_ptr<long> outStep{};
  shared_ptr<string> password{};
  shared_ptr<string> resourceFrom{};
  shared_ptr<string> scalingPolicy{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateInstanceId{};
  shared_ptr<string> templateInstanceName{};
  shared_ptr<long> templateVersion{};
  shared_ptr<string> vSwitchIds{};
  shared_ptr<string> vpcId{};

  ModifyScalingRuleRequest() {}

  explicit ModifyScalingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptEULA) {
      res["AcceptEULA"] = boost::any(*acceptEULA);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (inCondition) {
      res["InCondition"] = boost::any(*inCondition);
    }
    if (inCpu) {
      res["InCpu"] = boost::any(*inCpu);
    }
    if (inDuration) {
      res["InDuration"] = boost::any(*inDuration);
    }
    if (inEnable) {
      res["InEnable"] = boost::any(*inEnable);
    }
    if (inInstanceNum) {
      res["InInstanceNum"] = boost::any(*inInstanceNum);
    }
    if (inLoad) {
      res["InLoad"] = boost::any(*inLoad);
    }
    if (inRT) {
      res["InRT"] = boost::any(*inRT);
    }
    if (inStep) {
      res["InStep"] = boost::any(*inStep);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (multiAzPolicy) {
      res["MultiAzPolicy"] = boost::any(*multiAzPolicy);
    }
    if (outCPU) {
      res["OutCPU"] = boost::any(*outCPU);
    }
    if (outCondition) {
      res["OutCondition"] = boost::any(*outCondition);
    }
    if (outDuration) {
      res["OutDuration"] = boost::any(*outDuration);
    }
    if (outEnable) {
      res["OutEnable"] = boost::any(*outEnable);
    }
    if (outInstanceNum) {
      res["OutInstanceNum"] = boost::any(*outInstanceNum);
    }
    if (outLoad) {
      res["OutLoad"] = boost::any(*outLoad);
    }
    if (outRT) {
      res["OutRT"] = boost::any(*outRT);
    }
    if (outStep) {
      res["OutStep"] = boost::any(*outStep);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (resourceFrom) {
      res["ResourceFrom"] = boost::any(*resourceFrom);
    }
    if (scalingPolicy) {
      res["ScalingPolicy"] = boost::any(*scalingPolicy);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateInstanceId) {
      res["TemplateInstanceId"] = boost::any(*templateInstanceId);
    }
    if (templateInstanceName) {
      res["TemplateInstanceName"] = boost::any(*templateInstanceName);
    }
    if (templateVersion) {
      res["TemplateVersion"] = boost::any(*templateVersion);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = boost::any(*vSwitchIds);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptEULA") != m.end() && !m["AcceptEULA"].empty()) {
      acceptEULA = make_shared<bool>(boost::any_cast<bool>(m["AcceptEULA"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("InCondition") != m.end() && !m["InCondition"].empty()) {
      inCondition = make_shared<string>(boost::any_cast<string>(m["InCondition"]));
    }
    if (m.find("InCpu") != m.end() && !m["InCpu"].empty()) {
      inCpu = make_shared<long>(boost::any_cast<long>(m["InCpu"]));
    }
    if (m.find("InDuration") != m.end() && !m["InDuration"].empty()) {
      inDuration = make_shared<long>(boost::any_cast<long>(m["InDuration"]));
    }
    if (m.find("InEnable") != m.end() && !m["InEnable"].empty()) {
      inEnable = make_shared<bool>(boost::any_cast<bool>(m["InEnable"]));
    }
    if (m.find("InInstanceNum") != m.end() && !m["InInstanceNum"].empty()) {
      inInstanceNum = make_shared<long>(boost::any_cast<long>(m["InInstanceNum"]));
    }
    if (m.find("InLoad") != m.end() && !m["InLoad"].empty()) {
      inLoad = make_shared<long>(boost::any_cast<long>(m["InLoad"]));
    }
    if (m.find("InRT") != m.end() && !m["InRT"].empty()) {
      inRT = make_shared<long>(boost::any_cast<long>(m["InRT"]));
    }
    if (m.find("InStep") != m.end() && !m["InStep"].empty()) {
      inStep = make_shared<long>(boost::any_cast<long>(m["InStep"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("MultiAzPolicy") != m.end() && !m["MultiAzPolicy"].empty()) {
      multiAzPolicy = make_shared<string>(boost::any_cast<string>(m["MultiAzPolicy"]));
    }
    if (m.find("OutCPU") != m.end() && !m["OutCPU"].empty()) {
      outCPU = make_shared<long>(boost::any_cast<long>(m["OutCPU"]));
    }
    if (m.find("OutCondition") != m.end() && !m["OutCondition"].empty()) {
      outCondition = make_shared<string>(boost::any_cast<string>(m["OutCondition"]));
    }
    if (m.find("OutDuration") != m.end() && !m["OutDuration"].empty()) {
      outDuration = make_shared<long>(boost::any_cast<long>(m["OutDuration"]));
    }
    if (m.find("OutEnable") != m.end() && !m["OutEnable"].empty()) {
      outEnable = make_shared<bool>(boost::any_cast<bool>(m["OutEnable"]));
    }
    if (m.find("OutInstanceNum") != m.end() && !m["OutInstanceNum"].empty()) {
      outInstanceNum = make_shared<long>(boost::any_cast<long>(m["OutInstanceNum"]));
    }
    if (m.find("OutLoad") != m.end() && !m["OutLoad"].empty()) {
      outLoad = make_shared<long>(boost::any_cast<long>(m["OutLoad"]));
    }
    if (m.find("OutRT") != m.end() && !m["OutRT"].empty()) {
      outRT = make_shared<long>(boost::any_cast<long>(m["OutRT"]));
    }
    if (m.find("OutStep") != m.end() && !m["OutStep"].empty()) {
      outStep = make_shared<long>(boost::any_cast<long>(m["OutStep"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("ResourceFrom") != m.end() && !m["ResourceFrom"].empty()) {
      resourceFrom = make_shared<string>(boost::any_cast<string>(m["ResourceFrom"]));
    }
    if (m.find("ScalingPolicy") != m.end() && !m["ScalingPolicy"].empty()) {
      scalingPolicy = make_shared<string>(boost::any_cast<string>(m["ScalingPolicy"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateInstanceId") != m.end() && !m["TemplateInstanceId"].empty()) {
      templateInstanceId = make_shared<string>(boost::any_cast<string>(m["TemplateInstanceId"]));
    }
    if (m.find("TemplateInstanceName") != m.end() && !m["TemplateInstanceName"].empty()) {
      templateInstanceName = make_shared<string>(boost::any_cast<string>(m["TemplateInstanceName"]));
    }
    if (m.find("TemplateVersion") != m.end() && !m["TemplateVersion"].empty()) {
      templateVersion = make_shared<long>(boost::any_cast<long>(m["TemplateVersion"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      vSwitchIds = make_shared<string>(boost::any_cast<string>(m["VSwitchIds"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ModifyScalingRuleRequest() = default;
};
class ModifyScalingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ModifyScalingRuleResponseBody() {}

  explicit ModifyScalingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyScalingRuleResponseBody() = default;
};
class ModifyScalingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyScalingRuleResponseBody> body{};

  ModifyScalingRuleResponse() {}

  explicit ModifyScalingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyScalingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyScalingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyScalingRuleResponse() = default;
};
class QueryApplicationStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  QueryApplicationStatusRequest() {}

  explicit QueryApplicationStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~QueryApplicationStatusRequest() = default;
};
class QueryApplicationStatusResponseBodyAppInfoApplication : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<long> buildPackageId{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> cpu{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> dockerize{};
  shared_ptr<string> email{};
  shared_ptr<string> healthCheckUrl{};
  shared_ptr<long> instanceCount{};
  shared_ptr<long> launchTime{};
  shared_ptr<long> memory{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<string> phone{};
  shared_ptr<long> port{};
  shared_ptr<string> regionId{};
  shared_ptr<long> runningInstanceCount{};
  shared_ptr<string> userId{};

  QueryApplicationStatusResponseBodyAppInfoApplication() {}

  explicit QueryApplicationStatusResponseBodyAppInfoApplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (buildPackageId) {
      res["BuildPackageId"] = boost::any(*buildPackageId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dockerize) {
      res["Dockerize"] = boost::any(*dockerize);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (healthCheckUrl) {
      res["HealthCheckUrl"] = boost::any(*healthCheckUrl);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (launchTime) {
      res["LaunchTime"] = boost::any(*launchTime);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (runningInstanceCount) {
      res["RunningInstanceCount"] = boost::any(*runningInstanceCount);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("BuildPackageId") != m.end() && !m["BuildPackageId"].empty()) {
      buildPackageId = make_shared<long>(boost::any_cast<long>(m["BuildPackageId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Dockerize") != m.end() && !m["Dockerize"].empty()) {
      dockerize = make_shared<bool>(boost::any_cast<bool>(m["Dockerize"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("HealthCheckUrl") != m.end() && !m["HealthCheckUrl"].empty()) {
      healthCheckUrl = make_shared<string>(boost::any_cast<string>(m["HealthCheckUrl"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("LaunchTime") != m.end() && !m["LaunchTime"].empty()) {
      launchTime = make_shared<long>(boost::any_cast<long>(m["LaunchTime"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RunningInstanceCount") != m.end() && !m["RunningInstanceCount"].empty()) {
      runningInstanceCount = make_shared<long>(boost::any_cast<long>(m["RunningInstanceCount"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryApplicationStatusResponseBodyAppInfoApplication() = default;
};
class QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> deployRecordId{};
  shared_ptr<string> eccId{};
  shared_ptr<string> ecuId{};
  shared_ptr<string> packageMd5{};
  shared_ptr<string> packageVersionId{};

  QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord() {}

  explicit QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deployRecordId) {
      res["DeployRecordId"] = boost::any(*deployRecordId);
    }
    if (eccId) {
      res["EccId"] = boost::any(*eccId);
    }
    if (ecuId) {
      res["EcuId"] = boost::any(*ecuId);
    }
    if (packageMd5) {
      res["PackageMd5"] = boost::any(*packageMd5);
    }
    if (packageVersionId) {
      res["PackageVersionId"] = boost::any(*packageVersionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DeployRecordId") != m.end() && !m["DeployRecordId"].empty()) {
      deployRecordId = make_shared<string>(boost::any_cast<string>(m["DeployRecordId"]));
    }
    if (m.find("EccId") != m.end() && !m["EccId"].empty()) {
      eccId = make_shared<string>(boost::any_cast<string>(m["EccId"]));
    }
    if (m.find("EcuId") != m.end() && !m["EcuId"].empty()) {
      ecuId = make_shared<string>(boost::any_cast<string>(m["EcuId"]));
    }
    if (m.find("PackageMd5") != m.end() && !m["PackageMd5"].empty()) {
      packageMd5 = make_shared<string>(boost::any_cast<string>(m["PackageMd5"]));
    }
    if (m.find("PackageVersionId") != m.end() && !m["PackageVersionId"].empty()) {
      packageVersionId = make_shared<string>(boost::any_cast<string>(m["PackageVersionId"]));
    }
  }


  virtual ~QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord() = default;
};
class QueryApplicationStatusResponseBodyAppInfoDeployRecordList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord>> deployRecord{};

  QueryApplicationStatusResponseBodyAppInfoDeployRecordList() {}

  explicit QueryApplicationStatusResponseBodyAppInfoDeployRecordList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployRecord) {
      vector<boost::any> temp1;
      for(auto item1:*deployRecord){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeployRecord"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployRecord") != m.end() && !m["DeployRecord"].empty()) {
      if (typeid(vector<boost::any>) == m["DeployRecord"].type()) {
        vector<QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeployRecord"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deployRecord = make_shared<vector<QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord>>(expect1);
      }
    }
  }


  virtual ~QueryApplicationStatusResponseBodyAppInfoDeployRecordList() = default;
};
class QueryApplicationStatusResponseBodyAppInfoEccListEcc : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> appState{};
  shared_ptr<string> containerStatus{};
  shared_ptr<long> createTime{};
  shared_ptr<string> eccId{};
  shared_ptr<string> ecuId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> ip{};
  shared_ptr<long> taskState{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> vpcId{};

  QueryApplicationStatusResponseBodyAppInfoEccListEcc() {}

  explicit QueryApplicationStatusResponseBodyAppInfoEccListEcc(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appState) {
      res["AppState"] = boost::any(*appState);
    }
    if (containerStatus) {
      res["ContainerStatus"] = boost::any(*containerStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (eccId) {
      res["EccId"] = boost::any(*eccId);
    }
    if (ecuId) {
      res["EcuId"] = boost::any(*ecuId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (taskState) {
      res["TaskState"] = boost::any(*taskState);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppState") != m.end() && !m["AppState"].empty()) {
      appState = make_shared<long>(boost::any_cast<long>(m["AppState"]));
    }
    if (m.find("ContainerStatus") != m.end() && !m["ContainerStatus"].empty()) {
      containerStatus = make_shared<string>(boost::any_cast<string>(m["ContainerStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("EccId") != m.end() && !m["EccId"].empty()) {
      eccId = make_shared<string>(boost::any_cast<string>(m["EccId"]));
    }
    if (m.find("EcuId") != m.end() && !m["EcuId"].empty()) {
      ecuId = make_shared<string>(boost::any_cast<string>(m["EcuId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("TaskState") != m.end() && !m["TaskState"].empty()) {
      taskState = make_shared<long>(boost::any_cast<long>(m["TaskState"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~QueryApplicationStatusResponseBodyAppInfoEccListEcc() = default;
};
class QueryApplicationStatusResponseBodyAppInfoEccList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryApplicationStatusResponseBodyAppInfoEccListEcc>> ecc{};

  QueryApplicationStatusResponseBodyAppInfoEccList() {}

  explicit QueryApplicationStatusResponseBodyAppInfoEccList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecc) {
      vector<boost::any> temp1;
      for(auto item1:*ecc){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ecc"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ecc") != m.end() && !m["Ecc"].empty()) {
      if (typeid(vector<boost::any>) == m["Ecc"].type()) {
        vector<QueryApplicationStatusResponseBodyAppInfoEccListEcc> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ecc"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryApplicationStatusResponseBodyAppInfoEccListEcc model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ecc = make_shared<vector<QueryApplicationStatusResponseBodyAppInfoEccListEcc>>(expect1);
      }
    }
  }


  virtual ~QueryApplicationStatusResponseBodyAppInfoEccList() = default;
};
class QueryApplicationStatusResponseBodyAppInfoEcuListEcu : public Darabonba::Model {
public:
  shared_ptr<long> availableCpu{};
  shared_ptr<long> availableMem{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> dockerEnv{};
  shared_ptr<string> ecuId{};
  shared_ptr<string> groupId{};
  shared_ptr<long> heartbeatTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ipAddr{};
  shared_ptr<string> name{};
  shared_ptr<bool> online{};
  shared_ptr<string> regionId{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zoneId{};

  QueryApplicationStatusResponseBodyAppInfoEcuListEcu() {}

  explicit QueryApplicationStatusResponseBodyAppInfoEcuListEcu(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableCpu) {
      res["AvailableCpu"] = boost::any(*availableCpu);
    }
    if (availableMem) {
      res["AvailableMem"] = boost::any(*availableMem);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dockerEnv) {
      res["DockerEnv"] = boost::any(*dockerEnv);
    }
    if (ecuId) {
      res["EcuId"] = boost::any(*ecuId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (heartbeatTime) {
      res["HeartbeatTime"] = boost::any(*heartbeatTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ipAddr) {
      res["IpAddr"] = boost::any(*ipAddr);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableCpu") != m.end() && !m["AvailableCpu"].empty()) {
      availableCpu = make_shared<long>(boost::any_cast<long>(m["AvailableCpu"]));
    }
    if (m.find("AvailableMem") != m.end() && !m["AvailableMem"].empty()) {
      availableMem = make_shared<long>(boost::any_cast<long>(m["AvailableMem"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DockerEnv") != m.end() && !m["DockerEnv"].empty()) {
      dockerEnv = make_shared<bool>(boost::any_cast<bool>(m["DockerEnv"]));
    }
    if (m.find("EcuId") != m.end() && !m["EcuId"].empty()) {
      ecuId = make_shared<string>(boost::any_cast<string>(m["EcuId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HeartbeatTime") != m.end() && !m["HeartbeatTime"].empty()) {
      heartbeatTime = make_shared<long>(boost::any_cast<long>(m["HeartbeatTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IpAddr") != m.end() && !m["IpAddr"].empty()) {
      ipAddr = make_shared<string>(boost::any_cast<string>(m["IpAddr"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<bool>(boost::any_cast<bool>(m["Online"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~QueryApplicationStatusResponseBodyAppInfoEcuListEcu() = default;
};
class QueryApplicationStatusResponseBodyAppInfoEcuList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryApplicationStatusResponseBodyAppInfoEcuListEcu>> ecu{};

  QueryApplicationStatusResponseBodyAppInfoEcuList() {}

  explicit QueryApplicationStatusResponseBodyAppInfoEcuList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecu) {
      vector<boost::any> temp1;
      for(auto item1:*ecu){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ecu"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ecu") != m.end() && !m["Ecu"].empty()) {
      if (typeid(vector<boost::any>) == m["Ecu"].type()) {
        vector<QueryApplicationStatusResponseBodyAppInfoEcuListEcu> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ecu"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryApplicationStatusResponseBodyAppInfoEcuListEcu model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ecu = make_shared<vector<QueryApplicationStatusResponseBodyAppInfoEcuListEcu>>(expect1);
      }
    }
  }


  virtual ~QueryApplicationStatusResponseBodyAppInfoEcuList() = default;
};
class QueryApplicationStatusResponseBodyAppInfoGroupListGroup : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appVersionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<long> groupType{};
  shared_ptr<string> packageVersionId{};
  shared_ptr<long> updateTime{};

  QueryApplicationStatusResponseBodyAppInfoGroupListGroup() {}

  explicit QueryApplicationStatusResponseBodyAppInfoGroupListGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appVersionId) {
      res["AppVersionId"] = boost::any(*appVersionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (packageVersionId) {
      res["PackageVersionId"] = boost::any(*packageVersionId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppVersionId") != m.end() && !m["AppVersionId"].empty()) {
      appVersionId = make_shared<string>(boost::any_cast<string>(m["AppVersionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<long>(boost::any_cast<long>(m["GroupType"]));
    }
    if (m.find("PackageVersionId") != m.end() && !m["PackageVersionId"].empty()) {
      packageVersionId = make_shared<string>(boost::any_cast<string>(m["PackageVersionId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~QueryApplicationStatusResponseBodyAppInfoGroupListGroup() = default;
};
class QueryApplicationStatusResponseBodyAppInfoGroupList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryApplicationStatusResponseBodyAppInfoGroupListGroup>> group{};

  QueryApplicationStatusResponseBodyAppInfoGroupList() {}

  explicit QueryApplicationStatusResponseBodyAppInfoGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (group) {
      vector<boost::any> temp1;
      for(auto item1:*group){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Group"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      if (typeid(vector<boost::any>) == m["Group"].type()) {
        vector<QueryApplicationStatusResponseBodyAppInfoGroupListGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Group"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryApplicationStatusResponseBodyAppInfoGroupListGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        group = make_shared<vector<QueryApplicationStatusResponseBodyAppInfoGroupListGroup>>(expect1);
      }
    }
  }


  virtual ~QueryApplicationStatusResponseBodyAppInfoGroupList() = default;
};
class QueryApplicationStatusResponseBodyAppInfo : public Darabonba::Model {
public:
  shared_ptr<QueryApplicationStatusResponseBodyAppInfoApplication> application{};
  shared_ptr<QueryApplicationStatusResponseBodyAppInfoDeployRecordList> deployRecordList{};
  shared_ptr<QueryApplicationStatusResponseBodyAppInfoEccList> eccList{};
  shared_ptr<QueryApplicationStatusResponseBodyAppInfoEcuList> ecuList{};
  shared_ptr<QueryApplicationStatusResponseBodyAppInfoGroupList> groupList{};

  QueryApplicationStatusResponseBodyAppInfo() {}

  explicit QueryApplicationStatusResponseBodyAppInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (application) {
      res["Application"] = application ? boost::any(application->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deployRecordList) {
      res["DeployRecordList"] = deployRecordList ? boost::any(deployRecordList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (eccList) {
      res["EccList"] = eccList ? boost::any(eccList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ecuList) {
      res["EcuList"] = ecuList ? boost::any(ecuList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupList) {
      res["GroupList"] = groupList ? boost::any(groupList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Application") != m.end() && !m["Application"].empty()) {
      if (typeid(map<string, boost::any>) == m["Application"].type()) {
        QueryApplicationStatusResponseBodyAppInfoApplication model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Application"]));
        application = make_shared<QueryApplicationStatusResponseBodyAppInfoApplication>(model1);
      }
    }
    if (m.find("DeployRecordList") != m.end() && !m["DeployRecordList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeployRecordList"].type()) {
        QueryApplicationStatusResponseBodyAppInfoDeployRecordList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeployRecordList"]));
        deployRecordList = make_shared<QueryApplicationStatusResponseBodyAppInfoDeployRecordList>(model1);
      }
    }
    if (m.find("EccList") != m.end() && !m["EccList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EccList"].type()) {
        QueryApplicationStatusResponseBodyAppInfoEccList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EccList"]));
        eccList = make_shared<QueryApplicationStatusResponseBodyAppInfoEccList>(model1);
      }
    }
    if (m.find("EcuList") != m.end() && !m["EcuList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EcuList"].type()) {
        QueryApplicationStatusResponseBodyAppInfoEcuList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EcuList"]));
        ecuList = make_shared<QueryApplicationStatusResponseBodyAppInfoEcuList>(model1);
      }
    }
    if (m.find("GroupList") != m.end() && !m["GroupList"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupList"].type()) {
        QueryApplicationStatusResponseBodyAppInfoGroupList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupList"]));
        groupList = make_shared<QueryApplicationStatusResponseBodyAppInfoGroupList>(model1);
      }
    }
  }


  virtual ~QueryApplicationStatusResponseBodyAppInfo() = default;
};
class QueryApplicationStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryApplicationStatusResponseBodyAppInfo> appInfo{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  QueryApplicationStatusResponseBody() {}

  explicit QueryApplicationStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appInfo) {
      res["AppInfo"] = appInfo ? boost::any(appInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppInfo") != m.end() && !m["AppInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppInfo"].type()) {
        QueryApplicationStatusResponseBodyAppInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppInfo"]));
        appInfo = make_shared<QueryApplicationStatusResponseBodyAppInfo>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryApplicationStatusResponseBody() = default;
};
class QueryApplicationStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryApplicationStatusResponseBody> body{};

  QueryApplicationStatusResponse() {}

  explicit QueryApplicationStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryApplicationStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryApplicationStatusResponseBody>(model1);
      }
    }
  }


  virtual ~QueryApplicationStatusResponse() = default;
};
class QueryEccInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> eccId{};

  QueryEccInfoRequest() {}

  explicit QueryEccInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eccId) {
      res["EccId"] = boost::any(*eccId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EccId") != m.end() && !m["EccId"].empty()) {
      eccId = make_shared<string>(boost::any_cast<string>(m["EccId"]));
    }
  }


  virtual ~QueryEccInfoRequest() = default;
};
class QueryEccInfoResponseBodyEccInfo : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> eccId{};
  shared_ptr<string> ecuId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> packageMd5{};
  shared_ptr<string> packageVersion{};
  shared_ptr<string> vpcId{};

  QueryEccInfoResponseBodyEccInfo() {}

  explicit QueryEccInfoResponseBodyEccInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (eccId) {
      res["EccId"] = boost::any(*eccId);
    }
    if (ecuId) {
      res["EcuId"] = boost::any(*ecuId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (packageMd5) {
      res["PackageMd5"] = boost::any(*packageMd5);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EccId") != m.end() && !m["EccId"].empty()) {
      eccId = make_shared<string>(boost::any_cast<string>(m["EccId"]));
    }
    if (m.find("EcuId") != m.end() && !m["EcuId"].empty()) {
      ecuId = make_shared<string>(boost::any_cast<string>(m["EcuId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("PackageMd5") != m.end() && !m["PackageMd5"].empty()) {
      packageMd5 = make_shared<string>(boost::any_cast<string>(m["PackageMd5"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~QueryEccInfoResponseBodyEccInfo() = default;
};
class QueryEccInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<QueryEccInfoResponseBodyEccInfo> eccInfo{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  QueryEccInfoResponseBody() {}

  explicit QueryEccInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (eccInfo) {
      res["EccInfo"] = eccInfo ? boost::any(eccInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("EccInfo") != m.end() && !m["EccInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["EccInfo"].type()) {
        QueryEccInfoResponseBodyEccInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EccInfo"]));
        eccInfo = make_shared<QueryEccInfoResponseBodyEccInfo>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryEccInfoResponseBody() = default;
};
class QueryEccInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryEccInfoResponseBody> body{};

  QueryEccInfoResponse() {}

  explicit QueryEccInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEccInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEccInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEccInfoResponse() = default;
};
class QueryMigrateEcuListRequest : public Darabonba::Model {
public:
  shared_ptr<string> logicalRegionId{};

  QueryMigrateEcuListRequest() {}

  explicit QueryMigrateEcuListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
  }


  virtual ~QueryMigrateEcuListRequest() = default;
};
class QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity : public Darabonba::Model {
public:
  shared_ptr<long> availableCpu{};
  shared_ptr<long> availableMem{};
  shared_ptr<long> cpu{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> dockerEnv{};
  shared_ptr<string> ecuId{};
  shared_ptr<long> heartbeatTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ipAddr{};
  shared_ptr<long> mem{};
  shared_ptr<string> name{};
  shared_ptr<bool> online{};
  shared_ptr<string> regionId{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zoneId{};

  QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity() {}

  explicit QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableCpu) {
      res["AvailableCpu"] = boost::any(*availableCpu);
    }
    if (availableMem) {
      res["AvailableMem"] = boost::any(*availableMem);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dockerEnv) {
      res["DockerEnv"] = boost::any(*dockerEnv);
    }
    if (ecuId) {
      res["EcuId"] = boost::any(*ecuId);
    }
    if (heartbeatTime) {
      res["HeartbeatTime"] = boost::any(*heartbeatTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ipAddr) {
      res["IpAddr"] = boost::any(*ipAddr);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableCpu") != m.end() && !m["AvailableCpu"].empty()) {
      availableCpu = make_shared<long>(boost::any_cast<long>(m["AvailableCpu"]));
    }
    if (m.find("AvailableMem") != m.end() && !m["AvailableMem"].empty()) {
      availableMem = make_shared<long>(boost::any_cast<long>(m["AvailableMem"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DockerEnv") != m.end() && !m["DockerEnv"].empty()) {
      dockerEnv = make_shared<bool>(boost::any_cast<bool>(m["DockerEnv"]));
    }
    if (m.find("EcuId") != m.end() && !m["EcuId"].empty()) {
      ecuId = make_shared<string>(boost::any_cast<string>(m["EcuId"]));
    }
    if (m.find("HeartbeatTime") != m.end() && !m["HeartbeatTime"].empty()) {
      heartbeatTime = make_shared<long>(boost::any_cast<long>(m["HeartbeatTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IpAddr") != m.end() && !m["IpAddr"].empty()) {
      ipAddr = make_shared<string>(boost::any_cast<string>(m["IpAddr"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<bool>(boost::any_cast<bool>(m["Online"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity() = default;
};
class QueryMigrateEcuListResponseBodyEcuEntityList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity>> ecuEntity{};

  QueryMigrateEcuListResponseBodyEcuEntityList() {}

  explicit QueryMigrateEcuListResponseBodyEcuEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecuEntity) {
      vector<boost::any> temp1;
      for(auto item1:*ecuEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EcuEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcuEntity") != m.end() && !m["EcuEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["EcuEntity"].type()) {
        vector<QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EcuEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ecuEntity = make_shared<vector<QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity>>(expect1);
      }
    }
  }


  virtual ~QueryMigrateEcuListResponseBodyEcuEntityList() = default;
};
class QueryMigrateEcuListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<QueryMigrateEcuListResponseBodyEcuEntityList> ecuEntityList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  QueryMigrateEcuListResponseBody() {}

  explicit QueryMigrateEcuListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (ecuEntityList) {
      res["EcuEntityList"] = ecuEntityList ? boost::any(ecuEntityList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("EcuEntityList") != m.end() && !m["EcuEntityList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EcuEntityList"].type()) {
        QueryMigrateEcuListResponseBodyEcuEntityList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EcuEntityList"]));
        ecuEntityList = make_shared<QueryMigrateEcuListResponseBodyEcuEntityList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMigrateEcuListResponseBody() = default;
};
class QueryMigrateEcuListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMigrateEcuListResponseBody> body{};

  QueryMigrateEcuListResponse() {}

  explicit QueryMigrateEcuListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMigrateEcuListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMigrateEcuListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMigrateEcuListResponse() = default;
};
class QueryMigrateRegionListRequest : public Darabonba::Model {
public:
  shared_ptr<string> logicalRegionId{};

  QueryMigrateRegionListRequest() {}

  explicit QueryMigrateRegionListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
  }


  virtual ~QueryMigrateRegionListRequest() = default;
};
class QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity : public Darabonba::Model {
public:
  shared_ptr<string> regionName{};
  shared_ptr<string> regionNo{};

  QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity() {}

  explicit QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (regionNo) {
      res["RegionNo"] = boost::any(*regionNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("RegionNo") != m.end() && !m["RegionNo"].empty()) {
      regionNo = make_shared<string>(boost::any_cast<string>(m["RegionNo"]));
    }
  }


  virtual ~QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity() = default;
};
class QueryMigrateRegionListResponseBodyRegionEntityList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity>> regionEntity{};

  QueryMigrateRegionListResponseBodyRegionEntityList() {}

  explicit QueryMigrateRegionListResponseBodyRegionEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionEntity) {
      vector<boost::any> temp1;
      for(auto item1:*regionEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegionEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionEntity") != m.end() && !m["RegionEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["RegionEntity"].type()) {
        vector<QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegionEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regionEntity = make_shared<vector<QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity>>(expect1);
      }
    }
  }


  virtual ~QueryMigrateRegionListResponseBodyRegionEntityList() = default;
};
class QueryMigrateRegionListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<QueryMigrateRegionListResponseBodyRegionEntityList> regionEntityList{};
  shared_ptr<string> requestId{};

  QueryMigrateRegionListResponseBody() {}

  explicit QueryMigrateRegionListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (regionEntityList) {
      res["RegionEntityList"] = regionEntityList ? boost::any(regionEntityList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RegionEntityList") != m.end() && !m["RegionEntityList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegionEntityList"].type()) {
        QueryMigrateRegionListResponseBodyRegionEntityList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegionEntityList"]));
        regionEntityList = make_shared<QueryMigrateRegionListResponseBodyRegionEntityList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMigrateRegionListResponseBody() = default;
};
class QueryMigrateRegionListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMigrateRegionListResponseBody> body{};

  QueryMigrateRegionListResponse() {}

  explicit QueryMigrateRegionListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMigrateRegionListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMigrateRegionListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMigrateRegionListResponse() = default;
};
class QueryRegionConfigResponseBodyRegionConfigFileServerConfig : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> internalUrl{};
  shared_ptr<string> publicUrl{};
  shared_ptr<string> vpcUrl{};

  QueryRegionConfigResponseBodyRegionConfigFileServerConfig() {}

  explicit QueryRegionConfigResponseBodyRegionConfigFileServerConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (internalUrl) {
      res["InternalUrl"] = boost::any(*internalUrl);
    }
    if (publicUrl) {
      res["PublicUrl"] = boost::any(*publicUrl);
    }
    if (vpcUrl) {
      res["VpcUrl"] = boost::any(*vpcUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("InternalUrl") != m.end() && !m["InternalUrl"].empty()) {
      internalUrl = make_shared<string>(boost::any_cast<string>(m["InternalUrl"]));
    }
    if (m.find("PublicUrl") != m.end() && !m["PublicUrl"].empty()) {
      publicUrl = make_shared<string>(boost::any_cast<string>(m["PublicUrl"]));
    }
    if (m.find("VpcUrl") != m.end() && !m["VpcUrl"].empty()) {
      vpcUrl = make_shared<string>(boost::any_cast<string>(m["VpcUrl"]));
    }
  }


  virtual ~QueryRegionConfigResponseBodyRegionConfigFileServerConfig() = default;
};
class QueryRegionConfigResponseBodyRegionConfig : public Darabonba::Model {
public:
  shared_ptr<string> addressServerHost{};
  shared_ptr<string> agentInstallScript{};
  shared_ptr<QueryRegionConfigResponseBodyRegionConfigFileServerConfig> fileServerConfig{};
  shared_ptr<string> fileServerType{};
  shared_ptr<string> id{};
  shared_ptr<string> imageId{};
  shared_ptr<string> name{};
  shared_ptr<long> no{};
  shared_ptr<string> tag{};

  QueryRegionConfigResponseBodyRegionConfig() {}

  explicit QueryRegionConfigResponseBodyRegionConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressServerHost) {
      res["AddressServerHost"] = boost::any(*addressServerHost);
    }
    if (agentInstallScript) {
      res["AgentInstallScript"] = boost::any(*agentInstallScript);
    }
    if (fileServerConfig) {
      res["FileServerConfig"] = fileServerConfig ? boost::any(fileServerConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileServerType) {
      res["FileServerType"] = boost::any(*fileServerType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (no) {
      res["No"] = boost::any(*no);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressServerHost") != m.end() && !m["AddressServerHost"].empty()) {
      addressServerHost = make_shared<string>(boost::any_cast<string>(m["AddressServerHost"]));
    }
    if (m.find("AgentInstallScript") != m.end() && !m["AgentInstallScript"].empty()) {
      agentInstallScript = make_shared<string>(boost::any_cast<string>(m["AgentInstallScript"]));
    }
    if (m.find("FileServerConfig") != m.end() && !m["FileServerConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileServerConfig"].type()) {
        QueryRegionConfigResponseBodyRegionConfigFileServerConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileServerConfig"]));
        fileServerConfig = make_shared<QueryRegionConfigResponseBodyRegionConfigFileServerConfig>(model1);
      }
    }
    if (m.find("FileServerType") != m.end() && !m["FileServerType"].empty()) {
      fileServerType = make_shared<string>(boost::any_cast<string>(m["FileServerType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("No") != m.end() && !m["No"].empty()) {
      no = make_shared<long>(boost::any_cast<long>(m["No"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~QueryRegionConfigResponseBodyRegionConfig() = default;
};
class QueryRegionConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<QueryRegionConfigResponseBodyRegionConfig> regionConfig{};
  shared_ptr<string> requestId{};

  QueryRegionConfigResponseBody() {}

  explicit QueryRegionConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (regionConfig) {
      res["RegionConfig"] = regionConfig ? boost::any(regionConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RegionConfig") != m.end() && !m["RegionConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegionConfig"].type()) {
        QueryRegionConfigResponseBodyRegionConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegionConfig"]));
        regionConfig = make_shared<QueryRegionConfigResponseBodyRegionConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryRegionConfigResponseBody() = default;
};
class QueryRegionConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryRegionConfigResponseBody> body{};

  QueryRegionConfigResponse() {}

  explicit QueryRegionConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryRegionConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryRegionConfigResponseBody>(model1);
      }
    }
  }


  virtual ~QueryRegionConfigResponse() = default;
};
class QuerySlsLogStoreListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> type{};

  QuerySlsLogStoreListRequest() {}

  explicit QuerySlsLogStoreListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QuerySlsLogStoreListRequest() = default;
};
class QuerySlsLogStoreListResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> consumerSide{};
  shared_ptr<string> createTime{};
  shared_ptr<string> link{};
  shared_ptr<string> logstore{};
  shared_ptr<string> project{};
  shared_ptr<string> source{};

  QuerySlsLogStoreListResponseBodyResult() {}

  explicit QuerySlsLogStoreListResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerSide) {
      res["ConsumerSide"] = boost::any(*consumerSide);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (link) {
      res["Link"] = boost::any(*link);
    }
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerSide") != m.end() && !m["ConsumerSide"].empty()) {
      consumerSide = make_shared<string>(boost::any_cast<string>(m["ConsumerSide"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Link") != m.end() && !m["Link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["Link"]));
    }
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~QuerySlsLogStoreListResponseBodyResult() = default;
};
class QuerySlsLogStoreListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<QuerySlsLogStoreListResponseBodyResult>> result{};
  shared_ptr<long> totalSize{};

  QuerySlsLogStoreListResponseBody() {}

  explicit QuerySlsLogStoreListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<QuerySlsLogStoreListResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySlsLogStoreListResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<QuerySlsLogStoreListResponseBodyResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~QuerySlsLogStoreListResponseBody() = default;
};
class QuerySlsLogStoreListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySlsLogStoreListResponseBody> body{};

  QuerySlsLogStoreListResponse() {}

  explicit QuerySlsLogStoreListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySlsLogStoreListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySlsLogStoreListResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySlsLogStoreListResponse() = default;
};
class ResetApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> eccInfo{};

  ResetApplicationRequest() {}

  explicit ResetApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (eccInfo) {
      res["EccInfo"] = boost::any(*eccInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EccInfo") != m.end() && !m["EccInfo"].empty()) {
      eccInfo = make_shared<string>(boost::any_cast<string>(m["EccInfo"]));
    }
  }


  virtual ~ResetApplicationRequest() = default;
};
class ResetApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ResetApplicationResponseBody() {}

  explicit ResetApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResetApplicationResponseBody() = default;
};
class ResetApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetApplicationResponseBody> body{};

  ResetApplicationResponse() {}

  explicit ResetApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~ResetApplicationResponse() = default;
};
class RestartApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> eccInfo{};

  RestartApplicationRequest() {}

  explicit RestartApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (eccInfo) {
      res["EccInfo"] = boost::any(*eccInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EccInfo") != m.end() && !m["EccInfo"].empty()) {
      eccInfo = make_shared<string>(boost::any_cast<string>(m["EccInfo"]));
    }
  }


  virtual ~RestartApplicationRequest() = default;
};
class RestartApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RestartApplicationResponseBody() {}

  explicit RestartApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RestartApplicationResponseBody() = default;
};
class RestartApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RestartApplicationResponseBody> body{};

  RestartApplicationResponse() {}

  explicit RestartApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestartApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestartApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~RestartApplicationResponse() = default;
};
class RestartK8sApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> timeout{};

  RestartK8sApplicationRequest() {}

  explicit RestartK8sApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~RestartK8sApplicationRequest() = default;
};
class RestartK8sApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RestartK8sApplicationResponseBody() {}

  explicit RestartK8sApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RestartK8sApplicationResponseBody() = default;
};
class RestartK8sApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RestartK8sApplicationResponseBody> body{};

  RestartK8sApplicationResponse() {}

  explicit RestartK8sApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestartK8sApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestartK8sApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~RestartK8sApplicationResponse() = default;
};
class RetryChangeOrderTaskRequest : public Darabonba::Model {
public:
  shared_ptr<bool> retryStatus{};
  shared_ptr<string> taskId{};

  RetryChangeOrderTaskRequest() {}

  explicit RetryChangeOrderTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (retryStatus) {
      res["RetryStatus"] = boost::any(*retryStatus);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RetryStatus") != m.end() && !m["RetryStatus"].empty()) {
      retryStatus = make_shared<bool>(boost::any_cast<bool>(m["RetryStatus"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~RetryChangeOrderTaskRequest() = default;
};
class RetryChangeOrderTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RetryChangeOrderTaskResponseBody() {}

  explicit RetryChangeOrderTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RetryChangeOrderTaskResponseBody() = default;
};
class RetryChangeOrderTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RetryChangeOrderTaskResponseBody> body{};

  RetryChangeOrderTaskResponse() {}

  explicit RetryChangeOrderTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RetryChangeOrderTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RetryChangeOrderTaskResponseBody>(model1);
      }
    }
  }


  virtual ~RetryChangeOrderTaskResponse() = default;
};
class RollbackApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> batch{};
  shared_ptr<long> batchWaitTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> historyVersion{};

  RollbackApplicationRequest() {}

  explicit RollbackApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (batch) {
      res["Batch"] = boost::any(*batch);
    }
    if (batchWaitTime) {
      res["BatchWaitTime"] = boost::any(*batchWaitTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (historyVersion) {
      res["HistoryVersion"] = boost::any(*historyVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Batch") != m.end() && !m["Batch"].empty()) {
      batch = make_shared<long>(boost::any_cast<long>(m["Batch"]));
    }
    if (m.find("BatchWaitTime") != m.end() && !m["BatchWaitTime"].empty()) {
      batchWaitTime = make_shared<long>(boost::any_cast<long>(m["BatchWaitTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HistoryVersion") != m.end() && !m["HistoryVersion"].empty()) {
      historyVersion = make_shared<string>(boost::any_cast<string>(m["HistoryVersion"]));
    }
  }


  virtual ~RollbackApplicationRequest() = default;
};
class RollbackApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RollbackApplicationResponseBody() {}

  explicit RollbackApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RollbackApplicationResponseBody() = default;
};
class RollbackApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RollbackApplicationResponseBody> body{};

  RollbackApplicationResponse() {}

  explicit RollbackApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RollbackApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RollbackApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~RollbackApplicationResponse() = default;
};
class RollbackChangeOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  RollbackChangeOrderRequest() {}

  explicit RollbackChangeOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~RollbackChangeOrderRequest() = default;
};
class RollbackChangeOrderResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  RollbackChangeOrderResponseBodyData() {}

  explicit RollbackChangeOrderResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~RollbackChangeOrderResponseBodyData() = default;
};
class RollbackChangeOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<RollbackChangeOrderResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> traceId{};

  RollbackChangeOrderResponseBody() {}

  explicit RollbackChangeOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        RollbackChangeOrderResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<RollbackChangeOrderResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RollbackChangeOrderResponseBody() = default;
};
class RollbackChangeOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RollbackChangeOrderResponseBody> body{};

  RollbackChangeOrderResponse() {}

  explicit RollbackChangeOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RollbackChangeOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RollbackChangeOrderResponseBody>(model1);
      }
    }
  }


  virtual ~RollbackChangeOrderResponse() = default;
};
class ScaleInApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> eccInfo{};
  shared_ptr<bool> forceStatus{};

  ScaleInApplicationRequest() {}

  explicit ScaleInApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (eccInfo) {
      res["EccInfo"] = boost::any(*eccInfo);
    }
    if (forceStatus) {
      res["ForceStatus"] = boost::any(*forceStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EccInfo") != m.end() && !m["EccInfo"].empty()) {
      eccInfo = make_shared<string>(boost::any_cast<string>(m["EccInfo"]));
    }
    if (m.find("ForceStatus") != m.end() && !m["ForceStatus"].empty()) {
      forceStatus = make_shared<bool>(boost::any_cast<bool>(m["ForceStatus"]));
    }
  }


  virtual ~ScaleInApplicationRequest() = default;
};
class ScaleInApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};

  ScaleInApplicationResponseBody() {}

  explicit ScaleInApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~ScaleInApplicationResponseBody() = default;
};
class ScaleInApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ScaleInApplicationResponseBody> body{};

  ScaleInApplicationResponse() {}

  explicit ScaleInApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ScaleInApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ScaleInApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~ScaleInApplicationResponse() = default;
};
class ScaleK8sApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> replicas{};
  shared_ptr<long> timeout{};

  ScaleK8sApplicationRequest() {}

  explicit ScaleK8sApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (replicas) {
      res["Replicas"] = boost::any(*replicas);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Replicas") != m.end() && !m["Replicas"].empty()) {
      replicas = make_shared<long>(boost::any_cast<long>(m["Replicas"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~ScaleK8sApplicationRequest() = default;
};
class ScaleK8sApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ScaleK8sApplicationResponseBody() {}

  explicit ScaleK8sApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ScaleK8sApplicationResponseBody() = default;
};
class ScaleK8sApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ScaleK8sApplicationResponseBody> body{};

  ScaleK8sApplicationResponse() {}

  explicit ScaleK8sApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ScaleK8sApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ScaleK8sApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~ScaleK8sApplicationResponse() = default;
};
class ScaleOutApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> deployGroup{};
  shared_ptr<string> ecuInfo{};

  ScaleOutApplicationRequest() {}

  explicit ScaleOutApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (deployGroup) {
      res["DeployGroup"] = boost::any(*deployGroup);
    }
    if (ecuInfo) {
      res["EcuInfo"] = boost::any(*ecuInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DeployGroup") != m.end() && !m["DeployGroup"].empty()) {
      deployGroup = make_shared<string>(boost::any_cast<string>(m["DeployGroup"]));
    }
    if (m.find("EcuInfo") != m.end() && !m["EcuInfo"].empty()) {
      ecuInfo = make_shared<string>(boost::any_cast<string>(m["EcuInfo"]));
    }
  }


  virtual ~ScaleOutApplicationRequest() = default;
};
class ScaleOutApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ScaleOutApplicationResponseBody() {}

  explicit ScaleOutApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ScaleOutApplicationResponseBody() = default;
};
class ScaleOutApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ScaleOutApplicationResponseBody> body{};

  ScaleOutApplicationResponse() {}

  explicit ScaleOutApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ScaleOutApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ScaleOutApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~ScaleOutApplicationResponse() = default;
};
class ScaleoutApplicationWithNewInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewPeriod{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> groupId{};
  shared_ptr<long> instanceChargePeriod{};
  shared_ptr<string> instanceChargePeriodUnit{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<long> scalingNum{};
  shared_ptr<string> scalingPolicy{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateInstanceId{};
  shared_ptr<string> templateVersion{};

  ScaleoutApplicationWithNewInstancesRequest() {}

  explicit ScaleoutApplicationWithNewInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoRenewPeriod) {
      res["AutoRenewPeriod"] = boost::any(*autoRenewPeriod);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceChargePeriod) {
      res["InstanceChargePeriod"] = boost::any(*instanceChargePeriod);
    }
    if (instanceChargePeriodUnit) {
      res["InstanceChargePeriodUnit"] = boost::any(*instanceChargePeriodUnit);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (scalingNum) {
      res["ScalingNum"] = boost::any(*scalingNum);
    }
    if (scalingPolicy) {
      res["ScalingPolicy"] = boost::any(*scalingPolicy);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateInstanceId) {
      res["TemplateInstanceId"] = boost::any(*templateInstanceId);
    }
    if (templateVersion) {
      res["TemplateVersion"] = boost::any(*templateVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("AutoRenewPeriod") != m.end() && !m["AutoRenewPeriod"].empty()) {
      autoRenewPeriod = make_shared<long>(boost::any_cast<long>(m["AutoRenewPeriod"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("InstanceChargePeriod") != m.end() && !m["InstanceChargePeriod"].empty()) {
      instanceChargePeriod = make_shared<long>(boost::any_cast<long>(m["InstanceChargePeriod"]));
    }
    if (m.find("InstanceChargePeriodUnit") != m.end() && !m["InstanceChargePeriodUnit"].empty()) {
      instanceChargePeriodUnit = make_shared<string>(boost::any_cast<string>(m["InstanceChargePeriodUnit"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("ScalingNum") != m.end() && !m["ScalingNum"].empty()) {
      scalingNum = make_shared<long>(boost::any_cast<long>(m["ScalingNum"]));
    }
    if (m.find("ScalingPolicy") != m.end() && !m["ScalingPolicy"].empty()) {
      scalingPolicy = make_shared<string>(boost::any_cast<string>(m["ScalingPolicy"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateInstanceId") != m.end() && !m["TemplateInstanceId"].empty()) {
      templateInstanceId = make_shared<string>(boost::any_cast<string>(m["TemplateInstanceId"]));
    }
    if (m.find("TemplateVersion") != m.end() && !m["TemplateVersion"].empty()) {
      templateVersion = make_shared<string>(boost::any_cast<string>(m["TemplateVersion"]));
    }
  }


  virtual ~ScaleoutApplicationWithNewInstancesRequest() = default;
};
class ScaleoutApplicationWithNewInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ScaleoutApplicationWithNewInstancesResponseBody() {}

  explicit ScaleoutApplicationWithNewInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ScaleoutApplicationWithNewInstancesResponseBody() = default;
};
class ScaleoutApplicationWithNewInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ScaleoutApplicationWithNewInstancesResponseBody> body{};

  ScaleoutApplicationWithNewInstancesResponse() {}

  explicit ScaleoutApplicationWithNewInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ScaleoutApplicationWithNewInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ScaleoutApplicationWithNewInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ScaleoutApplicationWithNewInstancesResponse() = default;
};
class StartApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> eccInfo{};

  StartApplicationRequest() {}

  explicit StartApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (eccInfo) {
      res["EccInfo"] = boost::any(*eccInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EccInfo") != m.end() && !m["EccInfo"].empty()) {
      eccInfo = make_shared<string>(boost::any_cast<string>(m["EccInfo"]));
    }
  }


  virtual ~StartApplicationRequest() = default;
};
class StartApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  StartApplicationResponseBody() {}

  explicit StartApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartApplicationResponseBody() = default;
};
class StartApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartApplicationResponseBody> body{};

  StartApplicationResponse() {}

  explicit StartApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~StartApplicationResponse() = default;
};
class StartK8sAppPrecheckRequest : public Darabonba::Model {
public:
  shared_ptr<string> annotations{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> componentIds{};
  shared_ptr<string> configMountDescs{};
  shared_ptr<string> emptyDirs{};
  shared_ptr<string> envFroms{};
  shared_ptr<string> envs{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> javaStartUpConfig{};
  shared_ptr<string> labels{};
  shared_ptr<long> limitEphemeralStorage{};
  shared_ptr<long> limitMem{};
  shared_ptr<long> limitmCpu{};
  shared_ptr<string> localVolume{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> packageUrl{};
  shared_ptr<string> pvcMountDescs{};
  shared_ptr<string> regionId{};
  shared_ptr<long> replicas{};
  shared_ptr<long> requestsEphemeralStorage{};
  shared_ptr<long> requestsMem{};
  shared_ptr<long> requestsmCpu{};

  StartK8sAppPrecheckRequest() {}

  explicit StartK8sAppPrecheckRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotations) {
      res["Annotations"] = boost::any(*annotations);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (componentIds) {
      res["ComponentIds"] = boost::any(*componentIds);
    }
    if (configMountDescs) {
      res["ConfigMountDescs"] = boost::any(*configMountDescs);
    }
    if (emptyDirs) {
      res["EmptyDirs"] = boost::any(*emptyDirs);
    }
    if (envFroms) {
      res["EnvFroms"] = boost::any(*envFroms);
    }
    if (envs) {
      res["Envs"] = boost::any(*envs);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (javaStartUpConfig) {
      res["JavaStartUpConfig"] = boost::any(*javaStartUpConfig);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (limitEphemeralStorage) {
      res["LimitEphemeralStorage"] = boost::any(*limitEphemeralStorage);
    }
    if (limitMem) {
      res["LimitMem"] = boost::any(*limitMem);
    }
    if (limitmCpu) {
      res["LimitmCpu"] = boost::any(*limitmCpu);
    }
    if (localVolume) {
      res["LocalVolume"] = boost::any(*localVolume);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (packageUrl) {
      res["PackageUrl"] = boost::any(*packageUrl);
    }
    if (pvcMountDescs) {
      res["PvcMountDescs"] = boost::any(*pvcMountDescs);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (replicas) {
      res["Replicas"] = boost::any(*replicas);
    }
    if (requestsEphemeralStorage) {
      res["RequestsEphemeralStorage"] = boost::any(*requestsEphemeralStorage);
    }
    if (requestsMem) {
      res["RequestsMem"] = boost::any(*requestsMem);
    }
    if (requestsmCpu) {
      res["RequestsmCpu"] = boost::any(*requestsmCpu);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      annotations = make_shared<string>(boost::any_cast<string>(m["Annotations"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ComponentIds") != m.end() && !m["ComponentIds"].empty()) {
      componentIds = make_shared<string>(boost::any_cast<string>(m["ComponentIds"]));
    }
    if (m.find("ConfigMountDescs") != m.end() && !m["ConfigMountDescs"].empty()) {
      configMountDescs = make_shared<string>(boost::any_cast<string>(m["ConfigMountDescs"]));
    }
    if (m.find("EmptyDirs") != m.end() && !m["EmptyDirs"].empty()) {
      emptyDirs = make_shared<string>(boost::any_cast<string>(m["EmptyDirs"]));
    }
    if (m.find("EnvFroms") != m.end() && !m["EnvFroms"].empty()) {
      envFroms = make_shared<string>(boost::any_cast<string>(m["EnvFroms"]));
    }
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      envs = make_shared<string>(boost::any_cast<string>(m["Envs"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("JavaStartUpConfig") != m.end() && !m["JavaStartUpConfig"].empty()) {
      javaStartUpConfig = make_shared<string>(boost::any_cast<string>(m["JavaStartUpConfig"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("LimitEphemeralStorage") != m.end() && !m["LimitEphemeralStorage"].empty()) {
      limitEphemeralStorage = make_shared<long>(boost::any_cast<long>(m["LimitEphemeralStorage"]));
    }
    if (m.find("LimitMem") != m.end() && !m["LimitMem"].empty()) {
      limitMem = make_shared<long>(boost::any_cast<long>(m["LimitMem"]));
    }
    if (m.find("LimitmCpu") != m.end() && !m["LimitmCpu"].empty()) {
      limitmCpu = make_shared<long>(boost::any_cast<long>(m["LimitmCpu"]));
    }
    if (m.find("LocalVolume") != m.end() && !m["LocalVolume"].empty()) {
      localVolume = make_shared<string>(boost::any_cast<string>(m["LocalVolume"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PackageUrl") != m.end() && !m["PackageUrl"].empty()) {
      packageUrl = make_shared<string>(boost::any_cast<string>(m["PackageUrl"]));
    }
    if (m.find("PvcMountDescs") != m.end() && !m["PvcMountDescs"].empty()) {
      pvcMountDescs = make_shared<string>(boost::any_cast<string>(m["PvcMountDescs"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Replicas") != m.end() && !m["Replicas"].empty()) {
      replicas = make_shared<long>(boost::any_cast<long>(m["Replicas"]));
    }
    if (m.find("RequestsEphemeralStorage") != m.end() && !m["RequestsEphemeralStorage"].empty()) {
      requestsEphemeralStorage = make_shared<long>(boost::any_cast<long>(m["RequestsEphemeralStorage"]));
    }
    if (m.find("RequestsMem") != m.end() && !m["RequestsMem"].empty()) {
      requestsMem = make_shared<long>(boost::any_cast<long>(m["RequestsMem"]));
    }
    if (m.find("RequestsmCpu") != m.end() && !m["RequestsmCpu"].empty()) {
      requestsmCpu = make_shared<long>(boost::any_cast<long>(m["RequestsmCpu"]));
    }
  }


  virtual ~StartK8sAppPrecheckRequest() = default;
};
class StartK8sAppPrecheckResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> jobs{};

  StartK8sAppPrecheckResponseBodyData() {}

  explicit StartK8sAppPrecheckResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobs) {
      res["Jobs"] = boost::any(*jobs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Jobs") != m.end() && !m["Jobs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Jobs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Jobs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      jobs = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~StartK8sAppPrecheckResponseBodyData() = default;
};
class StartK8sAppPrecheckResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<StartK8sAppPrecheckResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  StartK8sAppPrecheckResponseBody() {}

  explicit StartK8sAppPrecheckResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        StartK8sAppPrecheckResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<StartK8sAppPrecheckResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartK8sAppPrecheckResponseBody() = default;
};
class StartK8sAppPrecheckResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartK8sAppPrecheckResponseBody> body{};

  StartK8sAppPrecheckResponse() {}

  explicit StartK8sAppPrecheckResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartK8sAppPrecheckResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartK8sAppPrecheckResponseBody>(model1);
      }
    }
  }


  virtual ~StartK8sAppPrecheckResponse() = default;
};
class StartK8sApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> replicas{};
  shared_ptr<long> timeout{};

  StartK8sApplicationRequest() {}

  explicit StartK8sApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (replicas) {
      res["Replicas"] = boost::any(*replicas);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Replicas") != m.end() && !m["Replicas"].empty()) {
      replicas = make_shared<long>(boost::any_cast<long>(m["Replicas"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~StartK8sApplicationRequest() = default;
};
class StartK8sApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  StartK8sApplicationResponseBody() {}

  explicit StartK8sApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartK8sApplicationResponseBody() = default;
};
class StartK8sApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartK8sApplicationResponseBody> body{};

  StartK8sApplicationResponse() {}

  explicit StartK8sApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartK8sApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartK8sApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~StartK8sApplicationResponse() = default;
};
class StopApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> eccInfo{};

  StopApplicationRequest() {}

  explicit StopApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (eccInfo) {
      res["EccInfo"] = boost::any(*eccInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EccInfo") != m.end() && !m["EccInfo"].empty()) {
      eccInfo = make_shared<string>(boost::any_cast<string>(m["EccInfo"]));
    }
  }


  virtual ~StopApplicationRequest() = default;
};
class StopApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  StopApplicationResponseBody() {}

  explicit StopApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopApplicationResponseBody() = default;
};
class StopApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopApplicationResponseBody> body{};

  StopApplicationResponse() {}

  explicit StopApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~StopApplicationResponse() = default;
};
class StopK8sApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> timeout{};

  StopK8sApplicationRequest() {}

  explicit StopK8sApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~StopK8sApplicationRequest() = default;
};
class StopK8sApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  StopK8sApplicationResponseBody() {}

  explicit StopK8sApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopK8sApplicationResponseBody() = default;
};
class StopK8sApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopK8sApplicationResponseBody> body{};

  StopK8sApplicationResponse() {}

  explicit StopK8sApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopK8sApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopK8sApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~StopK8sApplicationResponse() = default;
};
class SwitchAdvancedMonitoringRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> enableAdvancedMonitoring{};

  SwitchAdvancedMonitoringRequest() {}

  explicit SwitchAdvancedMonitoringRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (enableAdvancedMonitoring) {
      res["EnableAdvancedMonitoring"] = boost::any(*enableAdvancedMonitoring);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EnableAdvancedMonitoring") != m.end() && !m["EnableAdvancedMonitoring"].empty()) {
      enableAdvancedMonitoring = make_shared<bool>(boost::any_cast<bool>(m["EnableAdvancedMonitoring"]));
    }
  }


  virtual ~SwitchAdvancedMonitoringRequest() = default;
};
class SwitchAdvancedMonitoringResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> advancedMonitoringEnabled{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  SwitchAdvancedMonitoringResponseBody() {}

  explicit SwitchAdvancedMonitoringResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advancedMonitoringEnabled) {
      res["AdvancedMonitoringEnabled"] = boost::any(*advancedMonitoringEnabled);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdvancedMonitoringEnabled") != m.end() && !m["AdvancedMonitoringEnabled"].empty()) {
      advancedMonitoringEnabled = make_shared<bool>(boost::any_cast<bool>(m["AdvancedMonitoringEnabled"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SwitchAdvancedMonitoringResponseBody() = default;
};
class SwitchAdvancedMonitoringResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SwitchAdvancedMonitoringResponseBody> body{};

  SwitchAdvancedMonitoringResponse() {}

  explicit SwitchAdvancedMonitoringResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SwitchAdvancedMonitoringResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SwitchAdvancedMonitoringResponseBody>(model1);
      }
    }
  }


  virtual ~SwitchAdvancedMonitoringResponse() = default;
};
class SynchronizeResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceIds{};
  shared_ptr<string> type{};

  SynchronizeResourceRequest() {}

  explicit SynchronizeResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      resourceIds = make_shared<string>(boost::any_cast<string>(m["ResourceIds"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SynchronizeResourceRequest() = default;
};
class SynchronizeResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SynchronizeResourceResponseBody() {}

  explicit SynchronizeResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SynchronizeResourceResponseBody() = default;
};
class SynchronizeResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SynchronizeResourceResponseBody> body{};

  SynchronizeResourceResponse() {}

  explicit SynchronizeResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SynchronizeResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SynchronizeResourceResponseBody>(model1);
      }
    }
  }


  virtual ~SynchronizeResourceResponse() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceIds{};
  shared_ptr<string> resourceRegionId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tags{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (resourceRegionId) {
      res["ResourceRegionId"] = boost::any(*resourceRegionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      resourceIds = make_shared<string>(boost::any_cast<string>(m["ResourceIds"]));
    }
    if (m.find("ResourceRegionId") != m.end() && !m["ResourceRegionId"].empty()) {
      resourceRegionId = make_shared<string>(boost::any_cast<string>(m["ResourceRegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class TransformClusterMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceIds{};
  shared_ptr<string> password{};
  shared_ptr<string> targetClusterId{};

  TransformClusterMemberRequest() {}

  explicit TransformClusterMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (targetClusterId) {
      res["TargetClusterId"] = boost::any(*targetClusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("TargetClusterId") != m.end() && !m["TargetClusterId"].empty()) {
      targetClusterId = make_shared<string>(boost::any_cast<string>(m["TargetClusterId"]));
    }
  }


  virtual ~TransformClusterMemberRequest() = default;
};
class TransformClusterMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  TransformClusterMemberResponseBody() {}

  explicit TransformClusterMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TransformClusterMemberResponseBody() = default;
};
class TransformClusterMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TransformClusterMemberResponseBody> body{};

  TransformClusterMemberResponse() {}

  explicit TransformClusterMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TransformClusterMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TransformClusterMemberResponseBody>(model1);
      }
    }
  }


  virtual ~TransformClusterMemberResponse() = default;
};
class UnbindK8sSlbRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> slbName{};
  shared_ptr<string> type{};

  UnbindK8sSlbRequest() {}

  explicit UnbindK8sSlbRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (slbName) {
      res["SlbName"] = boost::any(*slbName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("SlbName") != m.end() && !m["SlbName"].empty()) {
      slbName = make_shared<string>(boost::any_cast<string>(m["SlbName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UnbindK8sSlbRequest() = default;
};
class UnbindK8sSlbResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UnbindK8sSlbResponseBody() {}

  explicit UnbindK8sSlbResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnbindK8sSlbResponseBody() = default;
};
class UnbindK8sSlbResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnbindK8sSlbResponseBody> body{};

  UnbindK8sSlbResponse() {}

  explicit UnbindK8sSlbResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindK8sSlbResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindK8sSlbResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindK8sSlbResponse() = default;
};
class UnbindSlbRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> deleteListener{};
  shared_ptr<string> slbId{};
  shared_ptr<string> type{};

  UnbindSlbRequest() {}

  explicit UnbindSlbRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (deleteListener) {
      res["DeleteListener"] = boost::any(*deleteListener);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DeleteListener") != m.end() && !m["DeleteListener"].empty()) {
      deleteListener = make_shared<string>(boost::any_cast<string>(m["DeleteListener"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UnbindSlbRequest() = default;
};
class UnbindSlbResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UnbindSlbResponseBody() {}

  explicit UnbindSlbResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnbindSlbResponseBody() = default;
};
class UnbindSlbResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnbindSlbResponseBody> body{};

  UnbindSlbResponse() {}

  explicit UnbindSlbResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindSlbResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindSlbResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindSlbResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> deleteAll{};
  shared_ptr<string> resourceIds{};
  shared_ptr<string> resourceRegionId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKeys{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteAll) {
      res["DeleteAll"] = boost::any(*deleteAll);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (resourceRegionId) {
      res["ResourceRegionId"] = boost::any(*resourceRegionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKeys) {
      res["TagKeys"] = boost::any(*tagKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteAll") != m.end() && !m["DeleteAll"].empty()) {
      deleteAll = make_shared<bool>(boost::any_cast<bool>(m["DeleteAll"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      resourceIds = make_shared<string>(boost::any_cast<string>(m["ResourceIds"]));
    }
    if (m.find("ResourceRegionId") != m.end() && !m["ResourceRegionId"].empty()) {
      resourceRegionId = make_shared<string>(boost::any_cast<string>(m["ResourceRegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKeys") != m.end() && !m["TagKeys"].empty()) {
      tagKeys = make_shared<string>(boost::any_cast<string>(m["TagKeys"]));
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class UpdateAccountInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> email{};
  shared_ptr<string> name{};
  shared_ptr<string> telephone{};

  UpdateAccountInfoRequest() {}

  explicit UpdateAccountInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (telephone) {
      res["Telephone"] = boost::any(*telephone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Telephone") != m.end() && !m["Telephone"].empty()) {
      telephone = make_shared<string>(boost::any_cast<string>(m["Telephone"]));
    }
  }


  virtual ~UpdateAccountInfoRequest() = default;
};
class UpdateAccountInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateAccountInfoResponseBody() {}

  explicit UpdateAccountInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAccountInfoResponseBody() = default;
};
class UpdateAccountInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAccountInfoResponseBody> body{};

  UpdateAccountInfoResponse() {}

  explicit UpdateAccountInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAccountInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAccountInfoResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAccountInfoResponse() = default;
};
class UpdateApplicationBaseInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> desc{};
  shared_ptr<string> owner{};

  UpdateApplicationBaseInfoRequest() {}

  explicit UpdateApplicationBaseInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
  }


  virtual ~UpdateApplicationBaseInfoRequest() = default;
};
class UpdateApplicationBaseInfoResponseBodyApplcation : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> applicationType{};
  shared_ptr<long> buildPackageId{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> clusterType{};
  shared_ptr<long> cpu{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<bool> dockerize{};
  shared_ptr<string> extSlbId{};
  shared_ptr<string> extSlbIp{};
  shared_ptr<string> extSlbName{};
  shared_ptr<string> healthCheckUrl{};
  shared_ptr<long> instanceCount{};
  shared_ptr<long> memory{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> port{};
  shared_ptr<string> regionId{};
  shared_ptr<long> runningInstanceCount{};
  shared_ptr<string> slbId{};
  shared_ptr<string> slbIp{};
  shared_ptr<string> slbName{};
  shared_ptr<long> slbPort{};
  shared_ptr<string> userId{};

  UpdateApplicationBaseInfoResponseBodyApplcation() {}

  explicit UpdateApplicationBaseInfoResponseBodyApplcation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (applicationType) {
      res["ApplicationType"] = boost::any(*applicationType);
    }
    if (buildPackageId) {
      res["BuildPackageId"] = boost::any(*buildPackageId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dockerize) {
      res["Dockerize"] = boost::any(*dockerize);
    }
    if (extSlbId) {
      res["ExtSlbId"] = boost::any(*extSlbId);
    }
    if (extSlbIp) {
      res["ExtSlbIp"] = boost::any(*extSlbIp);
    }
    if (extSlbName) {
      res["ExtSlbName"] = boost::any(*extSlbName);
    }
    if (healthCheckUrl) {
      res["HealthCheckUrl"] = boost::any(*healthCheckUrl);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (runningInstanceCount) {
      res["RunningInstanceCount"] = boost::any(*runningInstanceCount);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (slbIp) {
      res["SlbIp"] = boost::any(*slbIp);
    }
    if (slbName) {
      res["SlbName"] = boost::any(*slbName);
    }
    if (slbPort) {
      res["SlbPort"] = boost::any(*slbPort);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ApplicationType") != m.end() && !m["ApplicationType"].empty()) {
      applicationType = make_shared<string>(boost::any_cast<string>(m["ApplicationType"]));
    }
    if (m.find("BuildPackageId") != m.end() && !m["BuildPackageId"].empty()) {
      buildPackageId = make_shared<long>(boost::any_cast<long>(m["BuildPackageId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<long>(boost::any_cast<long>(m["ClusterType"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Dockerize") != m.end() && !m["Dockerize"].empty()) {
      dockerize = make_shared<bool>(boost::any_cast<bool>(m["Dockerize"]));
    }
    if (m.find("ExtSlbId") != m.end() && !m["ExtSlbId"].empty()) {
      extSlbId = make_shared<string>(boost::any_cast<string>(m["ExtSlbId"]));
    }
    if (m.find("ExtSlbIp") != m.end() && !m["ExtSlbIp"].empty()) {
      extSlbIp = make_shared<string>(boost::any_cast<string>(m["ExtSlbIp"]));
    }
    if (m.find("ExtSlbName") != m.end() && !m["ExtSlbName"].empty()) {
      extSlbName = make_shared<string>(boost::any_cast<string>(m["ExtSlbName"]));
    }
    if (m.find("HealthCheckUrl") != m.end() && !m["HealthCheckUrl"].empty()) {
      healthCheckUrl = make_shared<string>(boost::any_cast<string>(m["HealthCheckUrl"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RunningInstanceCount") != m.end() && !m["RunningInstanceCount"].empty()) {
      runningInstanceCount = make_shared<long>(boost::any_cast<long>(m["RunningInstanceCount"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("SlbIp") != m.end() && !m["SlbIp"].empty()) {
      slbIp = make_shared<string>(boost::any_cast<string>(m["SlbIp"]));
    }
    if (m.find("SlbName") != m.end() && !m["SlbName"].empty()) {
      slbName = make_shared<string>(boost::any_cast<string>(m["SlbName"]));
    }
    if (m.find("SlbPort") != m.end() && !m["SlbPort"].empty()) {
      slbPort = make_shared<long>(boost::any_cast<long>(m["SlbPort"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~UpdateApplicationBaseInfoResponseBodyApplcation() = default;
};
class UpdateApplicationBaseInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateApplicationBaseInfoResponseBodyApplcation> applcation{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateApplicationBaseInfoResponseBody() {}

  explicit UpdateApplicationBaseInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applcation) {
      res["Applcation"] = applcation ? boost::any(applcation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Applcation") != m.end() && !m["Applcation"].empty()) {
      if (typeid(map<string, boost::any>) == m["Applcation"].type()) {
        UpdateApplicationBaseInfoResponseBodyApplcation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Applcation"]));
        applcation = make_shared<UpdateApplicationBaseInfoResponseBodyApplcation>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateApplicationBaseInfoResponseBody() = default;
};
class UpdateApplicationBaseInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateApplicationBaseInfoResponseBody> body{};

  UpdateApplicationBaseInfoResponse() {}

  explicit UpdateApplicationBaseInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateApplicationBaseInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateApplicationBaseInfoResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateApplicationBaseInfoResponse() = default;
};
class UpdateApplicationScalingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> scalingBehaviour{};
  shared_ptr<bool> scalingRuleEnable{};
  shared_ptr<string> scalingRuleMetric{};
  shared_ptr<string> scalingRuleName{};
  shared_ptr<string> scalingRuleTimer{};
  shared_ptr<string> scalingRuleTrigger{};
  shared_ptr<string> scalingRuleType{};

  UpdateApplicationScalingRuleRequest() {}

  explicit UpdateApplicationScalingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (scalingBehaviour) {
      res["ScalingBehaviour"] = boost::any(*scalingBehaviour);
    }
    if (scalingRuleEnable) {
      res["ScalingRuleEnable"] = boost::any(*scalingRuleEnable);
    }
    if (scalingRuleMetric) {
      res["ScalingRuleMetric"] = boost::any(*scalingRuleMetric);
    }
    if (scalingRuleName) {
      res["ScalingRuleName"] = boost::any(*scalingRuleName);
    }
    if (scalingRuleTimer) {
      res["ScalingRuleTimer"] = boost::any(*scalingRuleTimer);
    }
    if (scalingRuleTrigger) {
      res["ScalingRuleTrigger"] = boost::any(*scalingRuleTrigger);
    }
    if (scalingRuleType) {
      res["ScalingRuleType"] = boost::any(*scalingRuleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ScalingBehaviour") != m.end() && !m["ScalingBehaviour"].empty()) {
      scalingBehaviour = make_shared<string>(boost::any_cast<string>(m["ScalingBehaviour"]));
    }
    if (m.find("ScalingRuleEnable") != m.end() && !m["ScalingRuleEnable"].empty()) {
      scalingRuleEnable = make_shared<bool>(boost::any_cast<bool>(m["ScalingRuleEnable"]));
    }
    if (m.find("ScalingRuleMetric") != m.end() && !m["ScalingRuleMetric"].empty()) {
      scalingRuleMetric = make_shared<string>(boost::any_cast<string>(m["ScalingRuleMetric"]));
    }
    if (m.find("ScalingRuleName") != m.end() && !m["ScalingRuleName"].empty()) {
      scalingRuleName = make_shared<string>(boost::any_cast<string>(m["ScalingRuleName"]));
    }
    if (m.find("ScalingRuleTimer") != m.end() && !m["ScalingRuleTimer"].empty()) {
      scalingRuleTimer = make_shared<string>(boost::any_cast<string>(m["ScalingRuleTimer"]));
    }
    if (m.find("ScalingRuleTrigger") != m.end() && !m["ScalingRuleTrigger"].empty()) {
      scalingRuleTrigger = make_shared<string>(boost::any_cast<string>(m["ScalingRuleTrigger"]));
    }
    if (m.find("ScalingRuleType") != m.end() && !m["ScalingRuleType"].empty()) {
      scalingRuleType = make_shared<string>(boost::any_cast<string>(m["ScalingRuleType"]));
    }
  }


  virtual ~UpdateApplicationScalingRuleRequest() = default;
};
class UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies : public Darabonba::Model {
public:
  shared_ptr<long> periodSeconds{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies() {}

  explicit UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (periodSeconds) {
      res["PeriodSeconds"] = boost::any(*periodSeconds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PeriodSeconds") != m.end() && !m["PeriodSeconds"].empty()) {
      periodSeconds = make_shared<long>(boost::any_cast<long>(m["PeriodSeconds"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies() = default;
};
class UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies>> policies{};
  shared_ptr<string> selectPolicy{};
  shared_ptr<long> stabilizationWindowSeconds{};

  UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown() {}

  explicit UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policies) {
      vector<boost::any> temp1;
      for(auto item1:*policies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Policies"] = boost::any(temp1);
    }
    if (selectPolicy) {
      res["SelectPolicy"] = boost::any(*selectPolicy);
    }
    if (stabilizationWindowSeconds) {
      res["StabilizationWindowSeconds"] = boost::any(*stabilizationWindowSeconds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Policies") != m.end() && !m["Policies"].empty()) {
      if (typeid(vector<boost::any>) == m["Policies"].type()) {
        vector<UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Policies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        policies = make_shared<vector<UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies>>(expect1);
      }
    }
    if (m.find("SelectPolicy") != m.end() && !m["SelectPolicy"].empty()) {
      selectPolicy = make_shared<string>(boost::any_cast<string>(m["SelectPolicy"]));
    }
    if (m.find("StabilizationWindowSeconds") != m.end() && !m["StabilizationWindowSeconds"].empty()) {
      stabilizationWindowSeconds = make_shared<long>(boost::any_cast<long>(m["StabilizationWindowSeconds"]));
    }
  }


  virtual ~UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown() = default;
};
class UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies : public Darabonba::Model {
public:
  shared_ptr<long> periodSeconds{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies() {}

  explicit UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (periodSeconds) {
      res["PeriodSeconds"] = boost::any(*periodSeconds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PeriodSeconds") != m.end() && !m["PeriodSeconds"].empty()) {
      periodSeconds = make_shared<long>(boost::any_cast<long>(m["PeriodSeconds"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies() = default;
};
class UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies>> policies{};
  shared_ptr<string> selectPolicy{};
  shared_ptr<long> stabilizationWindowSeconds{};

  UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp() {}

  explicit UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policies) {
      vector<boost::any> temp1;
      for(auto item1:*policies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Policies"] = boost::any(temp1);
    }
    if (selectPolicy) {
      res["SelectPolicy"] = boost::any(*selectPolicy);
    }
    if (stabilizationWindowSeconds) {
      res["StabilizationWindowSeconds"] = boost::any(*stabilizationWindowSeconds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Policies") != m.end() && !m["Policies"].empty()) {
      if (typeid(vector<boost::any>) == m["Policies"].type()) {
        vector<UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Policies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        policies = make_shared<vector<UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies>>(expect1);
      }
    }
    if (m.find("SelectPolicy") != m.end() && !m["SelectPolicy"].empty()) {
      selectPolicy = make_shared<string>(boost::any_cast<string>(m["SelectPolicy"]));
    }
    if (m.find("StabilizationWindowSeconds") != m.end() && !m["StabilizationWindowSeconds"].empty()) {
      stabilizationWindowSeconds = make_shared<long>(boost::any_cast<long>(m["StabilizationWindowSeconds"]));
    }
  }


  virtual ~UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp() = default;
};
class UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour : public Darabonba::Model {
public:
  shared_ptr<UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown> scaleDown{};
  shared_ptr<UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp> scaleUp{};

  UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour() {}

  explicit UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scaleDown) {
      res["ScaleDown"] = scaleDown ? boost::any(scaleDown->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scaleUp) {
      res["ScaleUp"] = scaleUp ? boost::any(scaleUp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScaleDown") != m.end() && !m["ScaleDown"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScaleDown"].type()) {
        UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScaleDown"]));
        scaleDown = make_shared<UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown>(model1);
      }
    }
    if (m.find("ScaleUp") != m.end() && !m["ScaleUp"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScaleUp"].type()) {
        UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScaleUp"]));
        scaleUp = make_shared<UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp>(model1);
      }
    }
  }


  virtual ~UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour() = default;
};
class UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics : public Darabonba::Model {
public:
  shared_ptr<long> metricTargetAverageUtilization{};
  shared_ptr<string> metricType{};

  UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics() {}

  explicit UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricTargetAverageUtilization) {
      res["MetricTargetAverageUtilization"] = boost::any(*metricTargetAverageUtilization);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricTargetAverageUtilization") != m.end() && !m["MetricTargetAverageUtilization"].empty()) {
      metricTargetAverageUtilization = make_shared<long>(boost::any_cast<long>(m["MetricTargetAverageUtilization"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
  }


  virtual ~UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics() = default;
};
class UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetric : public Darabonba::Model {
public:
  shared_ptr<long> maxReplicas{};
  shared_ptr<vector<UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics>> metrics{};
  shared_ptr<long> minReplicas{};

  UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetric() {}

  explicit UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetric(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (metrics) {
      vector<boost::any> temp1;
      for(auto item1:*metrics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Metrics"] = boost::any(temp1);
    }
    if (minReplicas) {
      res["MinReplicas"] = boost::any(*minReplicas);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(vector<boost::any>) == m["Metrics"].type()) {
        vector<UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Metrics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        metrics = make_shared<vector<UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics>>(expect1);
      }
    }
    if (m.find("MinReplicas") != m.end() && !m["MinReplicas"].empty()) {
      minReplicas = make_shared<long>(boost::any_cast<long>(m["MinReplicas"]));
    }
  }


  virtual ~UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetric() = default;
};
class UpdateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers : public Darabonba::Model {
public:
  shared_ptr<string> metaData{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  UpdateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers() {}

  explicit UpdateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metaData) {
      res["MetaData"] = boost::any(*metaData);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetaData") != m.end() && !m["MetaData"].empty()) {
      metaData = make_shared<string>(boost::any_cast<string>(m["MetaData"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers() = default;
};
class UpdateApplicationScalingRuleResponseBodyAppScalingRuleTrigger : public Darabonba::Model {
public:
  shared_ptr<long> maxReplicas{};
  shared_ptr<long> minReplicas{};
  shared_ptr<vector<UpdateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers>> triggers{};

  UpdateApplicationScalingRuleResponseBodyAppScalingRuleTrigger() {}

  explicit UpdateApplicationScalingRuleResponseBodyAppScalingRuleTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (minReplicas) {
      res["MinReplicas"] = boost::any(*minReplicas);
    }
    if (triggers) {
      vector<boost::any> temp1;
      for(auto item1:*triggers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Triggers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("MinReplicas") != m.end() && !m["MinReplicas"].empty()) {
      minReplicas = make_shared<long>(boost::any_cast<long>(m["MinReplicas"]));
    }
    if (m.find("Triggers") != m.end() && !m["Triggers"].empty()) {
      if (typeid(vector<boost::any>) == m["Triggers"].type()) {
        vector<UpdateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Triggers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        triggers = make_shared<vector<UpdateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers>>(expect1);
      }
    }
  }


  virtual ~UpdateApplicationScalingRuleResponseBodyAppScalingRuleTrigger() = default;
};
class UpdateApplicationScalingRuleResponseBodyAppScalingRule : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour> behaviour{};
  shared_ptr<long> createTime{};
  shared_ptr<long> lastDisableTime{};
  shared_ptr<long> maxReplicas{};
  shared_ptr<UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetric> metric{};
  shared_ptr<long> minReplicas{};
  shared_ptr<bool> scaleRuleEnabled{};
  shared_ptr<string> scaleRuleName{};
  shared_ptr<string> scaleRuleType{};
  shared_ptr<UpdateApplicationScalingRuleResponseBodyAppScalingRuleTrigger> trigger{};
  shared_ptr<long> updateTime{};

  UpdateApplicationScalingRuleResponseBodyAppScalingRule() {}

  explicit UpdateApplicationScalingRuleResponseBodyAppScalingRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (behaviour) {
      res["Behaviour"] = behaviour ? boost::any(behaviour->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastDisableTime) {
      res["LastDisableTime"] = boost::any(*lastDisableTime);
    }
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (metric) {
      res["Metric"] = metric ? boost::any(metric->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (minReplicas) {
      res["MinReplicas"] = boost::any(*minReplicas);
    }
    if (scaleRuleEnabled) {
      res["ScaleRuleEnabled"] = boost::any(*scaleRuleEnabled);
    }
    if (scaleRuleName) {
      res["ScaleRuleName"] = boost::any(*scaleRuleName);
    }
    if (scaleRuleType) {
      res["ScaleRuleType"] = boost::any(*scaleRuleType);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Behaviour") != m.end() && !m["Behaviour"].empty()) {
      if (typeid(map<string, boost::any>) == m["Behaviour"].type()) {
        UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Behaviour"]));
        behaviour = make_shared<UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("LastDisableTime") != m.end() && !m["LastDisableTime"].empty()) {
      lastDisableTime = make_shared<long>(boost::any_cast<long>(m["LastDisableTime"]));
    }
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metric"].type()) {
        UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetric model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metric"]));
        metric = make_shared<UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetric>(model1);
      }
    }
    if (m.find("MinReplicas") != m.end() && !m["MinReplicas"].empty()) {
      minReplicas = make_shared<long>(boost::any_cast<long>(m["MinReplicas"]));
    }
    if (m.find("ScaleRuleEnabled") != m.end() && !m["ScaleRuleEnabled"].empty()) {
      scaleRuleEnabled = make_shared<bool>(boost::any_cast<bool>(m["ScaleRuleEnabled"]));
    }
    if (m.find("ScaleRuleName") != m.end() && !m["ScaleRuleName"].empty()) {
      scaleRuleName = make_shared<string>(boost::any_cast<string>(m["ScaleRuleName"]));
    }
    if (m.find("ScaleRuleType") != m.end() && !m["ScaleRuleType"].empty()) {
      scaleRuleType = make_shared<string>(boost::any_cast<string>(m["ScaleRuleType"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        UpdateApplicationScalingRuleResponseBodyAppScalingRuleTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<UpdateApplicationScalingRuleResponseBodyAppScalingRuleTrigger>(model1);
      }
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~UpdateApplicationScalingRuleResponseBodyAppScalingRule() = default;
};
class UpdateApplicationScalingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateApplicationScalingRuleResponseBodyAppScalingRule> appScalingRule{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateApplicationScalingRuleResponseBody() {}

  explicit UpdateApplicationScalingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appScalingRule) {
      res["AppScalingRule"] = appScalingRule ? boost::any(appScalingRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppScalingRule") != m.end() && !m["AppScalingRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppScalingRule"].type()) {
        UpdateApplicationScalingRuleResponseBodyAppScalingRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppScalingRule"]));
        appScalingRule = make_shared<UpdateApplicationScalingRuleResponseBodyAppScalingRule>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateApplicationScalingRuleResponseBody() = default;
};
class UpdateApplicationScalingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateApplicationScalingRuleResponseBody> body{};

  UpdateApplicationScalingRuleResponse() {}

  explicit UpdateApplicationScalingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateApplicationScalingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateApplicationScalingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateApplicationScalingRuleResponse() = default;
};
class UpdateConfigTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> description{};
  shared_ptr<string> format{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  UpdateConfigTemplateRequest() {}

  explicit UpdateConfigTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateConfigTemplateRequest() = default;
};
class UpdateConfigTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateConfigTemplateResponseBody() {}

  explicit UpdateConfigTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateConfigTemplateResponseBody() = default;
};
class UpdateConfigTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateConfigTemplateResponseBody> body{};

  UpdateConfigTemplateResponse() {}

  explicit UpdateConfigTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateConfigTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateConfigTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateConfigTemplateResponse() = default;
};
class UpdateContainerRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> buildPackId{};

  UpdateContainerRequest() {}

  explicit UpdateContainerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (buildPackId) {
      res["BuildPackId"] = boost::any(*buildPackId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BuildPackId") != m.end() && !m["BuildPackId"].empty()) {
      buildPackId = make_shared<long>(boost::any_cast<long>(m["BuildPackId"]));
    }
  }


  virtual ~UpdateContainerRequest() = default;
};
class UpdateContainerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateContainerResponseBody() {}

  explicit UpdateContainerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateContainerResponseBody() = default;
};
class UpdateContainerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateContainerResponseBody> body{};

  UpdateContainerResponse() {}

  explicit UpdateContainerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateContainerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateContainerResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateContainerResponse() = default;
};
class UpdateContainerConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> contextPath{};
  shared_ptr<string> groupId{};
  shared_ptr<long> httpPort{};
  shared_ptr<long> maxThreads{};
  shared_ptr<string> URIEncoding{};
  shared_ptr<bool> useBodyEncoding{};

  UpdateContainerConfigurationRequest() {}

  explicit UpdateContainerConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (contextPath) {
      res["ContextPath"] = boost::any(*contextPath);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (httpPort) {
      res["HttpPort"] = boost::any(*httpPort);
    }
    if (maxThreads) {
      res["MaxThreads"] = boost::any(*maxThreads);
    }
    if (URIEncoding) {
      res["URIEncoding"] = boost::any(*URIEncoding);
    }
    if (useBodyEncoding) {
      res["UseBodyEncoding"] = boost::any(*useBodyEncoding);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ContextPath") != m.end() && !m["ContextPath"].empty()) {
      contextPath = make_shared<string>(boost::any_cast<string>(m["ContextPath"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HttpPort") != m.end() && !m["HttpPort"].empty()) {
      httpPort = make_shared<long>(boost::any_cast<long>(m["HttpPort"]));
    }
    if (m.find("MaxThreads") != m.end() && !m["MaxThreads"].empty()) {
      maxThreads = make_shared<long>(boost::any_cast<long>(m["MaxThreads"]));
    }
    if (m.find("URIEncoding") != m.end() && !m["URIEncoding"].empty()) {
      URIEncoding = make_shared<string>(boost::any_cast<string>(m["URIEncoding"]));
    }
    if (m.find("UseBodyEncoding") != m.end() && !m["UseBodyEncoding"].empty()) {
      useBodyEncoding = make_shared<bool>(boost::any_cast<bool>(m["UseBodyEncoding"]));
    }
  }


  virtual ~UpdateContainerConfigurationRequest() = default;
};
class UpdateContainerConfigurationResponseBodyContainerConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> contextPath{};
  shared_ptr<long> httpPort{};
  shared_ptr<long> maxThreads{};
  shared_ptr<string> URIEncoding{};
  shared_ptr<bool> useBodyEncoding{};

  UpdateContainerConfigurationResponseBodyContainerConfiguration() {}

  explicit UpdateContainerConfigurationResponseBodyContainerConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contextPath) {
      res["ContextPath"] = boost::any(*contextPath);
    }
    if (httpPort) {
      res["HttpPort"] = boost::any(*httpPort);
    }
    if (maxThreads) {
      res["MaxThreads"] = boost::any(*maxThreads);
    }
    if (URIEncoding) {
      res["URIEncoding"] = boost::any(*URIEncoding);
    }
    if (useBodyEncoding) {
      res["UseBodyEncoding"] = boost::any(*useBodyEncoding);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContextPath") != m.end() && !m["ContextPath"].empty()) {
      contextPath = make_shared<string>(boost::any_cast<string>(m["ContextPath"]));
    }
    if (m.find("HttpPort") != m.end() && !m["HttpPort"].empty()) {
      httpPort = make_shared<long>(boost::any_cast<long>(m["HttpPort"]));
    }
    if (m.find("MaxThreads") != m.end() && !m["MaxThreads"].empty()) {
      maxThreads = make_shared<long>(boost::any_cast<long>(m["MaxThreads"]));
    }
    if (m.find("URIEncoding") != m.end() && !m["URIEncoding"].empty()) {
      URIEncoding = make_shared<string>(boost::any_cast<string>(m["URIEncoding"]));
    }
    if (m.find("UseBodyEncoding") != m.end() && !m["UseBodyEncoding"].empty()) {
      useBodyEncoding = make_shared<bool>(boost::any_cast<bool>(m["UseBodyEncoding"]));
    }
  }


  virtual ~UpdateContainerConfigurationResponseBodyContainerConfiguration() = default;
};
class UpdateContainerConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<UpdateContainerConfigurationResponseBodyContainerConfiguration> containerConfiguration{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateContainerConfigurationResponseBody() {}

  explicit UpdateContainerConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (containerConfiguration) {
      res["ContainerConfiguration"] = containerConfiguration ? boost::any(containerConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("ContainerConfiguration") != m.end() && !m["ContainerConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContainerConfiguration"].type()) {
        UpdateContainerConfigurationResponseBodyContainerConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContainerConfiguration"]));
        containerConfiguration = make_shared<UpdateContainerConfigurationResponseBodyContainerConfiguration>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateContainerConfigurationResponseBody() = default;
};
class UpdateContainerConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateContainerConfigurationResponseBody> body{};

  UpdateContainerConfigurationResponse() {}

  explicit UpdateContainerConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateContainerConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateContainerConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateContainerConfigurationResponse() = default;
};
class UpdateHealthCheckUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> hcURL{};

  UpdateHealthCheckUrlRequest() {}

  explicit UpdateHealthCheckUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (hcURL) {
      res["hcURL"] = boost::any(*hcURL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("hcURL") != m.end() && !m["hcURL"].empty()) {
      hcURL = make_shared<string>(boost::any_cast<string>(m["hcURL"]));
    }
  }


  virtual ~UpdateHealthCheckUrlRequest() = default;
};
class UpdateHealthCheckUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> healthCheckURL{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateHealthCheckUrlResponseBody() {}

  explicit UpdateHealthCheckUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (healthCheckURL) {
      res["HealthCheckURL"] = boost::any(*healthCheckURL);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("HealthCheckURL") != m.end() && !m["HealthCheckURL"].empty()) {
      healthCheckURL = make_shared<string>(boost::any_cast<string>(m["HealthCheckURL"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateHealthCheckUrlResponseBody() = default;
};
class UpdateHealthCheckUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateHealthCheckUrlResponseBody> body{};

  UpdateHealthCheckUrlResponse() {}

  explicit UpdateHealthCheckUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateHealthCheckUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateHealthCheckUrlResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateHealthCheckUrlResponse() = default;
};
class UpdateHookConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> hooks{};

  UpdateHookConfigurationRequest() {}

  explicit UpdateHookConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (hooks) {
      res["Hooks"] = boost::any(*hooks);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Hooks") != m.end() && !m["Hooks"].empty()) {
      hooks = make_shared<string>(boost::any_cast<string>(m["Hooks"]));
    }
  }


  virtual ~UpdateHookConfigurationRequest() = default;
};
class UpdateHookConfigurationResponseBodyHooksConfiguration : public Darabonba::Model {
public:
  shared_ptr<bool> ignoreFail{};
  shared_ptr<string> name{};
  shared_ptr<string> script{};

  UpdateHookConfigurationResponseBodyHooksConfiguration() {}

  explicit UpdateHookConfigurationResponseBodyHooksConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ignoreFail) {
      res["IgnoreFail"] = boost::any(*ignoreFail);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (script) {
      res["Script"] = boost::any(*script);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IgnoreFail") != m.end() && !m["IgnoreFail"].empty()) {
      ignoreFail = make_shared<bool>(boost::any_cast<bool>(m["IgnoreFail"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
  }


  virtual ~UpdateHookConfigurationResponseBodyHooksConfiguration() = default;
};
class UpdateHookConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<UpdateHookConfigurationResponseBodyHooksConfiguration>> hooksConfiguration{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateHookConfigurationResponseBody() {}

  explicit UpdateHookConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hooksConfiguration) {
      vector<boost::any> temp1;
      for(auto item1:*hooksConfiguration){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HooksConfiguration"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("HooksConfiguration") != m.end() && !m["HooksConfiguration"].empty()) {
      if (typeid(vector<boost::any>) == m["HooksConfiguration"].type()) {
        vector<UpdateHookConfigurationResponseBodyHooksConfiguration> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HooksConfiguration"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateHookConfigurationResponseBodyHooksConfiguration model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hooksConfiguration = make_shared<vector<UpdateHookConfigurationResponseBodyHooksConfiguration>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateHookConfigurationResponseBody() = default;
};
class UpdateHookConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateHookConfigurationResponseBody> body{};

  UpdateHookConfigurationResponse() {}

  explicit UpdateHookConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateHookConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateHookConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateHookConfigurationResponse() = default;
};
class UpdateJvmConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};
  shared_ptr<long> maxHeapSize{};
  shared_ptr<long> maxPermSize{};
  shared_ptr<long> minHeapSize{};
  shared_ptr<string> options{};

  UpdateJvmConfigurationRequest() {}

  explicit UpdateJvmConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (maxHeapSize) {
      res["MaxHeapSize"] = boost::any(*maxHeapSize);
    }
    if (maxPermSize) {
      res["MaxPermSize"] = boost::any(*maxPermSize);
    }
    if (minHeapSize) {
      res["MinHeapSize"] = boost::any(*minHeapSize);
    }
    if (options) {
      res["Options"] = boost::any(*options);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("MaxHeapSize") != m.end() && !m["MaxHeapSize"].empty()) {
      maxHeapSize = make_shared<long>(boost::any_cast<long>(m["MaxHeapSize"]));
    }
    if (m.find("MaxPermSize") != m.end() && !m["MaxPermSize"].empty()) {
      maxPermSize = make_shared<long>(boost::any_cast<long>(m["MaxPermSize"]));
    }
    if (m.find("MinHeapSize") != m.end() && !m["MinHeapSize"].empty()) {
      minHeapSize = make_shared<long>(boost::any_cast<long>(m["MinHeapSize"]));
    }
    if (m.find("Options") != m.end() && !m["Options"].empty()) {
      options = make_shared<string>(boost::any_cast<string>(m["Options"]));
    }
  }


  virtual ~UpdateJvmConfigurationRequest() = default;
};
class UpdateJvmConfigurationResponseBodyJvmConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> maxHeapSize{};
  shared_ptr<long> maxPermSize{};
  shared_ptr<long> minHeapSize{};
  shared_ptr<string> options{};

  UpdateJvmConfigurationResponseBodyJvmConfiguration() {}

  explicit UpdateJvmConfigurationResponseBodyJvmConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxHeapSize) {
      res["MaxHeapSize"] = boost::any(*maxHeapSize);
    }
    if (maxPermSize) {
      res["MaxPermSize"] = boost::any(*maxPermSize);
    }
    if (minHeapSize) {
      res["MinHeapSize"] = boost::any(*minHeapSize);
    }
    if (options) {
      res["Options"] = boost::any(*options);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxHeapSize") != m.end() && !m["MaxHeapSize"].empty()) {
      maxHeapSize = make_shared<long>(boost::any_cast<long>(m["MaxHeapSize"]));
    }
    if (m.find("MaxPermSize") != m.end() && !m["MaxPermSize"].empty()) {
      maxPermSize = make_shared<long>(boost::any_cast<long>(m["MaxPermSize"]));
    }
    if (m.find("MinHeapSize") != m.end() && !m["MinHeapSize"].empty()) {
      minHeapSize = make_shared<long>(boost::any_cast<long>(m["MinHeapSize"]));
    }
    if (m.find("Options") != m.end() && !m["Options"].empty()) {
      options = make_shared<string>(boost::any_cast<string>(m["Options"]));
    }
  }


  virtual ~UpdateJvmConfigurationResponseBodyJvmConfiguration() = default;
};
class UpdateJvmConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<UpdateJvmConfigurationResponseBodyJvmConfiguration> jvmConfiguration{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateJvmConfigurationResponseBody() {}

  explicit UpdateJvmConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (jvmConfiguration) {
      res["JvmConfiguration"] = jvmConfiguration ? boost::any(jvmConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("JvmConfiguration") != m.end() && !m["JvmConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["JvmConfiguration"].type()) {
        UpdateJvmConfigurationResponseBodyJvmConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JvmConfiguration"]));
        jvmConfiguration = make_shared<UpdateJvmConfigurationResponseBodyJvmConfiguration>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateJvmConfigurationResponseBody() = default;
};
class UpdateJvmConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateJvmConfigurationResponseBody> body{};

  UpdateJvmConfigurationResponse() {}

  explicit UpdateJvmConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateJvmConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateJvmConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateJvmConfigurationResponse() = default;
};
class UpdateK8sApplicationBaseInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> description{};
  shared_ptr<string> email{};
  shared_ptr<string> owner{};
  shared_ptr<string> phoneNumber{};

  UpdateK8sApplicationBaseInfoRequest() {}

  explicit UpdateK8sApplicationBaseInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
  }


  virtual ~UpdateK8sApplicationBaseInfoRequest() = default;
};
class UpdateK8sApplicationBaseInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  UpdateK8sApplicationBaseInfoResponseBody() {}

  explicit UpdateK8sApplicationBaseInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~UpdateK8sApplicationBaseInfoResponseBody() = default;
};
class UpdateK8sApplicationBaseInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateK8sApplicationBaseInfoResponseBody> body{};

  UpdateK8sApplicationBaseInfoResponse() {}

  explicit UpdateK8sApplicationBaseInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateK8sApplicationBaseInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateK8sApplicationBaseInfoResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateK8sApplicationBaseInfoResponse() = default;
};
class UpdateK8sApplicationConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> cpuLimit{};
  shared_ptr<string> cpuRequest{};
  shared_ptr<string> ephemeralStorageLimit{};
  shared_ptr<string> ephemeralStorageRequest{};
  shared_ptr<string> mcpuLimit{};
  shared_ptr<string> mcpuRequest{};
  shared_ptr<string> memoryLimit{};
  shared_ptr<string> memoryRequest{};
  shared_ptr<long> timeout{};

  UpdateK8sApplicationConfigRequest() {}

  explicit UpdateK8sApplicationConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (cpuLimit) {
      res["CpuLimit"] = boost::any(*cpuLimit);
    }
    if (cpuRequest) {
      res["CpuRequest"] = boost::any(*cpuRequest);
    }
    if (ephemeralStorageLimit) {
      res["EphemeralStorageLimit"] = boost::any(*ephemeralStorageLimit);
    }
    if (ephemeralStorageRequest) {
      res["EphemeralStorageRequest"] = boost::any(*ephemeralStorageRequest);
    }
    if (mcpuLimit) {
      res["McpuLimit"] = boost::any(*mcpuLimit);
    }
    if (mcpuRequest) {
      res["McpuRequest"] = boost::any(*mcpuRequest);
    }
    if (memoryLimit) {
      res["MemoryLimit"] = boost::any(*memoryLimit);
    }
    if (memoryRequest) {
      res["MemoryRequest"] = boost::any(*memoryRequest);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CpuLimit") != m.end() && !m["CpuLimit"].empty()) {
      cpuLimit = make_shared<string>(boost::any_cast<string>(m["CpuLimit"]));
    }
    if (m.find("CpuRequest") != m.end() && !m["CpuRequest"].empty()) {
      cpuRequest = make_shared<string>(boost::any_cast<string>(m["CpuRequest"]));
    }
    if (m.find("EphemeralStorageLimit") != m.end() && !m["EphemeralStorageLimit"].empty()) {
      ephemeralStorageLimit = make_shared<string>(boost::any_cast<string>(m["EphemeralStorageLimit"]));
    }
    if (m.find("EphemeralStorageRequest") != m.end() && !m["EphemeralStorageRequest"].empty()) {
      ephemeralStorageRequest = make_shared<string>(boost::any_cast<string>(m["EphemeralStorageRequest"]));
    }
    if (m.find("McpuLimit") != m.end() && !m["McpuLimit"].empty()) {
      mcpuLimit = make_shared<string>(boost::any_cast<string>(m["McpuLimit"]));
    }
    if (m.find("McpuRequest") != m.end() && !m["McpuRequest"].empty()) {
      mcpuRequest = make_shared<string>(boost::any_cast<string>(m["McpuRequest"]));
    }
    if (m.find("MemoryLimit") != m.end() && !m["MemoryLimit"].empty()) {
      memoryLimit = make_shared<string>(boost::any_cast<string>(m["MemoryLimit"]));
    }
    if (m.find("MemoryRequest") != m.end() && !m["MemoryRequest"].empty()) {
      memoryRequest = make_shared<string>(boost::any_cast<string>(m["MemoryRequest"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~UpdateK8sApplicationConfigRequest() = default;
};
class UpdateK8sApplicationConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateK8sApplicationConfigResponseBody() {}

  explicit UpdateK8sApplicationConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateK8sApplicationConfigResponseBody() = default;
};
class UpdateK8sApplicationConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateK8sApplicationConfigResponseBody> body{};

  UpdateK8sApplicationConfigResponse() {}

  explicit UpdateK8sApplicationConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateK8sApplicationConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateK8sApplicationConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateK8sApplicationConfigResponse() = default;
};
class UpdateK8sConfigMapRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<map<string, boost::any>> data{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};

  UpdateK8sConfigMapRequest() {}

  explicit UpdateK8sConfigMapRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Data"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      data = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~UpdateK8sConfigMapRequest() = default;
};
class UpdateK8sConfigMapResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateK8sConfigMapResponseBody() {}

  explicit UpdateK8sConfigMapResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateK8sConfigMapResponseBody() = default;
};
class UpdateK8sConfigMapResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateK8sConfigMapResponseBody> body{};

  UpdateK8sConfigMapResponse() {}

  explicit UpdateK8sConfigMapResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateK8sConfigMapResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateK8sConfigMapResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateK8sConfigMapResponse() = default;
};
class UpdateK8sIngressRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> annotations{};
  shared_ptr<string> clusterId{};
  shared_ptr<map<string, boost::any>> ingressConf{};
  shared_ptr<string> labels{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};

  UpdateK8sIngressRuleRequest() {}

  explicit UpdateK8sIngressRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotations) {
      res["Annotations"] = boost::any(*annotations);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (ingressConf) {
      res["IngressConf"] = boost::any(*ingressConf);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      annotations = make_shared<string>(boost::any_cast<string>(m["Annotations"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("IngressConf") != m.end() && !m["IngressConf"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["IngressConf"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      ingressConf = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~UpdateK8sIngressRuleRequest() = default;
};
class UpdateK8sIngressRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};

  UpdateK8sIngressRuleResponseBody() {}

  explicit UpdateK8sIngressRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~UpdateK8sIngressRuleResponseBody() = default;
};
class UpdateK8sIngressRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateK8sIngressRuleResponseBody> body{};

  UpdateK8sIngressRuleResponse() {}

  explicit UpdateK8sIngressRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateK8sIngressRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateK8sIngressRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateK8sIngressRuleResponse() = default;
};
class UpdateK8sResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> resourceContent{};

  UpdateK8sResourceRequest() {}

  explicit UpdateK8sResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (resourceContent) {
      res["ResourceContent"] = boost::any(*resourceContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("ResourceContent") != m.end() && !m["ResourceContent"].empty()) {
      resourceContent = make_shared<string>(boost::any_cast<string>(m["ResourceContent"]));
    }
  }


  virtual ~UpdateK8sResourceRequest() = default;
};
class UpdateK8sResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateK8sResourceResponseBody() {}

  explicit UpdateK8sResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateK8sResourceResponseBody() = default;
};
class UpdateK8sResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateK8sResourceResponseBody> body{};

  UpdateK8sResourceResponse() {}

  explicit UpdateK8sResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateK8sResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateK8sResourceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateK8sResourceResponse() = default;
};
class UpdateK8sSecretRequest : public Darabonba::Model {
public:
  shared_ptr<bool> base64Encoded{};
  shared_ptr<string> certId{};
  shared_ptr<string> certRegionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> data{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> type{};

  UpdateK8sSecretRequest() {}

  explicit UpdateK8sSecretRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (base64Encoded) {
      res["Base64Encoded"] = boost::any(*base64Encoded);
    }
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certRegionId) {
      res["CertRegionId"] = boost::any(*certRegionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Base64Encoded") != m.end() && !m["Base64Encoded"].empty()) {
      base64Encoded = make_shared<bool>(boost::any_cast<bool>(m["Base64Encoded"]));
    }
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<string>(boost::any_cast<string>(m["CertId"]));
    }
    if (m.find("CertRegionId") != m.end() && !m["CertRegionId"].empty()) {
      certRegionId = make_shared<string>(boost::any_cast<string>(m["CertRegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateK8sSecretRequest() = default;
};
class UpdateK8sSecretResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateK8sSecretResponseBody() {}

  explicit UpdateK8sSecretResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateK8sSecretResponseBody() = default;
};
class UpdateK8sSecretResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateK8sSecretResponseBody> body{};

  UpdateK8sSecretResponse() {}

  explicit UpdateK8sSecretResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateK8sSecretResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateK8sSecretResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateK8sSecretResponse() = default;
};
class UpdateK8sServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> externalTrafficPolicy{};
  shared_ptr<string> name{};
  shared_ptr<map<string, boost::any>> servicePorts{};
  shared_ptr<string> type{};

  UpdateK8sServiceRequest() {}

  explicit UpdateK8sServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (externalTrafficPolicy) {
      res["ExternalTrafficPolicy"] = boost::any(*externalTrafficPolicy);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (servicePorts) {
      res["ServicePorts"] = boost::any(*servicePorts);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ExternalTrafficPolicy") != m.end() && !m["ExternalTrafficPolicy"].empty()) {
      externalTrafficPolicy = make_shared<string>(boost::any_cast<string>(m["ExternalTrafficPolicy"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ServicePorts") != m.end() && !m["ServicePorts"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ServicePorts"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      servicePorts = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateK8sServiceRequest() = default;
};
class UpdateK8sServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateK8sServiceResponseBody() {}

  explicit UpdateK8sServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateK8sServiceResponseBody() = default;
};
class UpdateK8sServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateK8sServiceResponseBody> body{};

  UpdateK8sServiceResponse() {}

  explicit UpdateK8sServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateK8sServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateK8sServiceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateK8sServiceResponse() = default;
};
class UpdateK8sSlbRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> clusterId{};
  shared_ptr<bool> disableForceOverride{};
  shared_ptr<string> port{};
  shared_ptr<string> scheduler{};
  shared_ptr<string> servicePortInfos{};
  shared_ptr<string> slbName{};
  shared_ptr<string> slbProtocol{};
  shared_ptr<string> specification{};
  shared_ptr<string> targetPort{};
  shared_ptr<string> type{};

  UpdateK8sSlbRequest() {}

  explicit UpdateK8sSlbRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (disableForceOverride) {
      res["DisableForceOverride"] = boost::any(*disableForceOverride);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (servicePortInfos) {
      res["ServicePortInfos"] = boost::any(*servicePortInfos);
    }
    if (slbName) {
      res["SlbName"] = boost::any(*slbName);
    }
    if (slbProtocol) {
      res["SlbProtocol"] = boost::any(*slbProtocol);
    }
    if (specification) {
      res["Specification"] = boost::any(*specification);
    }
    if (targetPort) {
      res["TargetPort"] = boost::any(*targetPort);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DisableForceOverride") != m.end() && !m["DisableForceOverride"].empty()) {
      disableForceOverride = make_shared<bool>(boost::any_cast<bool>(m["DisableForceOverride"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("ServicePortInfos") != m.end() && !m["ServicePortInfos"].empty()) {
      servicePortInfos = make_shared<string>(boost::any_cast<string>(m["ServicePortInfos"]));
    }
    if (m.find("SlbName") != m.end() && !m["SlbName"].empty()) {
      slbName = make_shared<string>(boost::any_cast<string>(m["SlbName"]));
    }
    if (m.find("SlbProtocol") != m.end() && !m["SlbProtocol"].empty()) {
      slbProtocol = make_shared<string>(boost::any_cast<string>(m["SlbProtocol"]));
    }
    if (m.find("Specification") != m.end() && !m["Specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["Specification"]));
    }
    if (m.find("TargetPort") != m.end() && !m["TargetPort"].empty()) {
      targetPort = make_shared<string>(boost::any_cast<string>(m["TargetPort"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateK8sSlbRequest() = default;
};
class UpdateK8sSlbResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateK8sSlbResponseBody() {}

  explicit UpdateK8sSlbResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateK8sSlbResponseBody() = default;
};
class UpdateK8sSlbResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateK8sSlbResponseBody> body{};

  UpdateK8sSlbResponse() {}

  explicit UpdateK8sSlbResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateK8sSlbResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateK8sSlbResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateK8sSlbResponse() = default;
};
class UpdateRoleRequest : public Darabonba::Model {
public:
  shared_ptr<string> actionData{};
  shared_ptr<long> roleId{};

  UpdateRoleRequest() {}

  explicit UpdateRoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionData) {
      res["ActionData"] = boost::any(*actionData);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionData") != m.end() && !m["ActionData"].empty()) {
      actionData = make_shared<string>(boost::any_cast<string>(m["ActionData"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<long>(boost::any_cast<long>(m["RoleId"]));
    }
  }


  virtual ~UpdateRoleRequest() = default;
};
class UpdateRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateRoleResponseBody() {}

  explicit UpdateRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateRoleResponseBody() = default;
};
class UpdateRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateRoleResponseBody> body{};

  UpdateRoleResponse() {}

  explicit UpdateRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRoleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRoleResponse() = default;
};
class UpdateSlsLogStoreRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> configs{};

  UpdateSlsLogStoreRequest() {}

  explicit UpdateSlsLogStoreRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (configs) {
      res["Configs"] = boost::any(*configs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      configs = make_shared<string>(boost::any_cast<string>(m["Configs"]));
    }
  }


  virtual ~UpdateSlsLogStoreRequest() = default;
};
class UpdateSlsLogStoreResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateSlsLogStoreResponseBody() {}

  explicit UpdateSlsLogStoreResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateSlsLogStoreResponseBody() = default;
};
class UpdateSlsLogStoreResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSlsLogStoreResponseBody> body{};

  UpdateSlsLogStoreResponse() {}

  explicit UpdateSlsLogStoreResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSlsLogStoreResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSlsLogStoreResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSlsLogStoreResponse() = default;
};
class UpdateSwimmingLaneRequest : public Darabonba::Model {
public:
  shared_ptr<string> appInfos{};
  shared_ptr<bool> enableRules{};
  shared_ptr<string> entryRules{};
  shared_ptr<long> laneId{};
  shared_ptr<string> name{};

  UpdateSwimmingLaneRequest() {}

  explicit UpdateSwimmingLaneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appInfos) {
      res["AppInfos"] = boost::any(*appInfos);
    }
    if (enableRules) {
      res["EnableRules"] = boost::any(*enableRules);
    }
    if (entryRules) {
      res["EntryRules"] = boost::any(*entryRules);
    }
    if (laneId) {
      res["LaneId"] = boost::any(*laneId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppInfos") != m.end() && !m["AppInfos"].empty()) {
      appInfos = make_shared<string>(boost::any_cast<string>(m["AppInfos"]));
    }
    if (m.find("EnableRules") != m.end() && !m["EnableRules"].empty()) {
      enableRules = make_shared<bool>(boost::any_cast<bool>(m["EnableRules"]));
    }
    if (m.find("EntryRules") != m.end() && !m["EntryRules"].empty()) {
      entryRules = make_shared<string>(boost::any_cast<string>(m["EntryRules"]));
    }
    if (m.find("LaneId") != m.end() && !m["LaneId"].empty()) {
      laneId = make_shared<long>(boost::any_cast<long>(m["LaneId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateSwimmingLaneRequest() = default;
};
class UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> laneId{};
  shared_ptr<string> rules{};

  UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList() {}

  explicit UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (laneId) {
      res["LaneId"] = boost::any(*laneId);
    }
    if (rules) {
      res["Rules"] = boost::any(*rules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("LaneId") != m.end() && !m["LaneId"].empty()) {
      laneId = make_shared<long>(boost::any_cast<long>(m["LaneId"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rules = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
  }


  virtual ~UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList() = default;
};
class UpdateSwimmingLaneResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> entryRule{};
  shared_ptr<long> groupId{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> namespaceId{};
  shared_ptr<vector<UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList>> swimmingLaneAppRelationShipList{};
  shared_ptr<string> tag{};

  UpdateSwimmingLaneResponseBodyData() {}

  explicit UpdateSwimmingLaneResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entryRule) {
      res["EntryRule"] = boost::any(*entryRule);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (swimmingLaneAppRelationShipList) {
      vector<boost::any> temp1;
      for(auto item1:*swimmingLaneAppRelationShipList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SwimmingLaneAppRelationShipList"] = boost::any(temp1);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntryRule") != m.end() && !m["EntryRule"].empty()) {
      entryRule = make_shared<string>(boost::any_cast<string>(m["EntryRule"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("SwimmingLaneAppRelationShipList") != m.end() && !m["SwimmingLaneAppRelationShipList"].empty()) {
      if (typeid(vector<boost::any>) == m["SwimmingLaneAppRelationShipList"].type()) {
        vector<UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SwimmingLaneAppRelationShipList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        swimmingLaneAppRelationShipList = make_shared<vector<UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList>>(expect1);
      }
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~UpdateSwimmingLaneResponseBodyData() = default;
};
class UpdateSwimmingLaneResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<UpdateSwimmingLaneResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateSwimmingLaneResponseBody() {}

  explicit UpdateSwimmingLaneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateSwimmingLaneResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateSwimmingLaneResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateSwimmingLaneResponseBody() = default;
};
class UpdateSwimmingLaneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSwimmingLaneResponseBody> body{};

  UpdateSwimmingLaneResponse() {}

  explicit UpdateSwimmingLaneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSwimmingLaneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSwimmingLaneResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSwimmingLaneResponse() = default;
};
class UpdateSwimmingLaneGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appIds{};
  shared_ptr<string> entryApp{};
  shared_ptr<long> groupId{};
  shared_ptr<string> name{};

  UpdateSwimmingLaneGroupRequest() {}

  explicit UpdateSwimmingLaneGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (entryApp) {
      res["EntryApp"] = boost::any(*entryApp);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      appIds = make_shared<string>(boost::any_cast<string>(m["AppIds"]));
    }
    if (m.find("EntryApp") != m.end() && !m["EntryApp"].empty()) {
      entryApp = make_shared<string>(boost::any_cast<string>(m["EntryApp"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateSwimmingLaneGroupRequest() = default;
};
class UpdateSwimmingLaneGroupResponseBodyDataApplicationList : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};

  UpdateSwimmingLaneGroupResponseBodyDataApplicationList() {}

  explicit UpdateSwimmingLaneGroupResponseBodyDataApplicationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
  }


  virtual ~UpdateSwimmingLaneGroupResponseBodyDataApplicationList() = default;
};
class UpdateSwimmingLaneGroupResponseBodyDataEntryApplication : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};

  UpdateSwimmingLaneGroupResponseBodyDataEntryApplication() {}

  explicit UpdateSwimmingLaneGroupResponseBodyDataEntryApplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
  }


  virtual ~UpdateSwimmingLaneGroupResponseBodyDataEntryApplication() = default;
};
class UpdateSwimmingLaneGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateSwimmingLaneGroupResponseBodyDataApplicationList>> applicationList{};
  shared_ptr<UpdateSwimmingLaneGroupResponseBodyDataEntryApplication> entryApplication{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> namespaceId{};

  UpdateSwimmingLaneGroupResponseBodyData() {}

  explicit UpdateSwimmingLaneGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationList) {
      vector<boost::any> temp1;
      for(auto item1:*applicationList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApplicationList"] = boost::any(temp1);
    }
    if (entryApplication) {
      res["EntryApplication"] = entryApplication ? boost::any(entryApplication->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationList") != m.end() && !m["ApplicationList"].empty()) {
      if (typeid(vector<boost::any>) == m["ApplicationList"].type()) {
        vector<UpdateSwimmingLaneGroupResponseBodyDataApplicationList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApplicationList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSwimmingLaneGroupResponseBodyDataApplicationList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applicationList = make_shared<vector<UpdateSwimmingLaneGroupResponseBodyDataApplicationList>>(expect1);
      }
    }
    if (m.find("EntryApplication") != m.end() && !m["EntryApplication"].empty()) {
      if (typeid(map<string, boost::any>) == m["EntryApplication"].type()) {
        UpdateSwimmingLaneGroupResponseBodyDataEntryApplication model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EntryApplication"]));
        entryApplication = make_shared<UpdateSwimmingLaneGroupResponseBodyDataEntryApplication>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~UpdateSwimmingLaneGroupResponseBodyData() = default;
};
class UpdateSwimmingLaneGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<UpdateSwimmingLaneGroupResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateSwimmingLaneGroupResponseBody() {}

  explicit UpdateSwimmingLaneGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateSwimmingLaneGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateSwimmingLaneGroupResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateSwimmingLaneGroupResponseBody() = default;
};
class UpdateSwimmingLaneGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSwimmingLaneGroupResponseBody> body{};

  UpdateSwimmingLaneGroupResponse() {}

  explicit UpdateSwimmingLaneGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSwimmingLaneGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSwimmingLaneGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSwimmingLaneGroupResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AbortAndRollbackChangeOrderResponse abortAndRollbackChangeOrderWithOptions(shared_ptr<AbortAndRollbackChangeOrderRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AbortAndRollbackChangeOrderResponse abortAndRollbackChangeOrder(shared_ptr<AbortAndRollbackChangeOrderRequest> request);
  AbortChangeOrderResponse abortChangeOrderWithOptions(shared_ptr<AbortChangeOrderRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AbortChangeOrderResponse abortChangeOrder(shared_ptr<AbortChangeOrderRequest> request);
  AddLogPathResponse addLogPathWithOptions(shared_ptr<AddLogPathRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLogPathResponse addLogPath(shared_ptr<AddLogPathRequest> request);
  AuthorizeApplicationResponse authorizeApplicationWithOptions(shared_ptr<AuthorizeApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AuthorizeApplicationResponse authorizeApplication(shared_ptr<AuthorizeApplicationRequest> request);
  AuthorizeResourceGroupResponse authorizeResourceGroupWithOptions(shared_ptr<AuthorizeResourceGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AuthorizeResourceGroupResponse authorizeResourceGroup(shared_ptr<AuthorizeResourceGroupRequest> request);
  AuthorizeRoleResponse authorizeRoleWithOptions(shared_ptr<AuthorizeRoleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AuthorizeRoleResponse authorizeRole(shared_ptr<AuthorizeRoleRequest> request);
  BindEcsSlbResponse bindEcsSlbWithOptions(shared_ptr<BindEcsSlbRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindEcsSlbResponse bindEcsSlb(shared_ptr<BindEcsSlbRequest> request);
  BindK8sSlbResponse bindK8sSlbWithOptions(shared_ptr<BindK8sSlbRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindK8sSlbResponse bindK8sSlb(shared_ptr<BindK8sSlbRequest> request);
  BindSlbResponse bindSlbWithOptions(shared_ptr<BindSlbRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindSlbResponse bindSlb(shared_ptr<BindSlbRequest> request);
  ChangeDeployGroupResponse changeDeployGroupWithOptions(shared_ptr<ChangeDeployGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeDeployGroupResponse changeDeployGroup(shared_ptr<ChangeDeployGroupRequest> request);
  ContinuePipelineResponse continuePipelineWithOptions(shared_ptr<ContinuePipelineRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ContinuePipelineResponse continuePipeline(shared_ptr<ContinuePipelineRequest> request);
  ConvertK8sResourceResponse convertK8sResourceWithOptions(shared_ptr<ConvertK8sResourceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConvertK8sResourceResponse convertK8sResource(shared_ptr<ConvertK8sResourceRequest> request);
  CreateApplicationScalingRuleResponse createApplicationScalingRuleWithOptions(shared_ptr<CreateApplicationScalingRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateApplicationScalingRuleResponse createApplicationScalingRule(shared_ptr<CreateApplicationScalingRuleRequest> request);
  CreateConfigTemplateResponse createConfigTemplateWithOptions(shared_ptr<CreateConfigTemplateRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateConfigTemplateResponse createConfigTemplate(shared_ptr<CreateConfigTemplateRequest> request);
  CreateIDCImportCommandResponse createIDCImportCommandWithOptions(shared_ptr<CreateIDCImportCommandRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIDCImportCommandResponse createIDCImportCommand(shared_ptr<CreateIDCImportCommandRequest> request);
  CreateK8sConfigMapResponse createK8sConfigMapWithOptions(shared_ptr<CreateK8sConfigMapRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateK8sConfigMapResponse createK8sConfigMap(shared_ptr<CreateK8sConfigMapRequest> request);
  CreateK8sIngressRuleResponse createK8sIngressRuleWithOptions(shared_ptr<CreateK8sIngressRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateK8sIngressRuleResponse createK8sIngressRule(shared_ptr<CreateK8sIngressRuleRequest> request);
  CreateK8sSecretResponse createK8sSecretWithOptions(shared_ptr<CreateK8sSecretRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateK8sSecretResponse createK8sSecret(shared_ptr<CreateK8sSecretRequest> request);
  CreateK8sServiceResponse createK8sServiceWithOptions(shared_ptr<CreateK8sServiceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateK8sServiceResponse createK8sService(shared_ptr<CreateK8sServiceRequest> request);
  DeleteApplicationResponse deleteApplicationWithOptions(shared_ptr<DeleteApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteApplicationResponse deleteApplication(shared_ptr<DeleteApplicationRequest> request);
  DeleteApplicationScalingRuleResponse deleteApplicationScalingRuleWithOptions(shared_ptr<DeleteApplicationScalingRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteApplicationScalingRuleResponse deleteApplicationScalingRule(shared_ptr<DeleteApplicationScalingRuleRequest> request);
  DeleteClusterResponse deleteClusterWithOptions(shared_ptr<DeleteClusterRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteClusterResponse deleteCluster(shared_ptr<DeleteClusterRequest> request);
  DeleteClusterMemberResponse deleteClusterMemberWithOptions(shared_ptr<DeleteClusterMemberRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteClusterMemberResponse deleteClusterMember(shared_ptr<DeleteClusterMemberRequest> request);
  DeleteConfigTemplateResponse deleteConfigTemplateWithOptions(shared_ptr<DeleteConfigTemplateRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteConfigTemplateResponse deleteConfigTemplate(shared_ptr<DeleteConfigTemplateRequest> request);
  DeleteDeployGroupResponse deleteDeployGroupWithOptions(shared_ptr<DeleteDeployGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeployGroupResponse deleteDeployGroup(shared_ptr<DeleteDeployGroupRequest> request);
  DeleteEcuResponse deleteEcuWithOptions(shared_ptr<DeleteEcuRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEcuResponse deleteEcu(shared_ptr<DeleteEcuRequest> request);
  DeleteK8sApplicationResponse deleteK8sApplicationWithOptions(shared_ptr<DeleteK8sApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteK8sApplicationResponse deleteK8sApplication(shared_ptr<DeleteK8sApplicationRequest> request);
  DeleteK8sConfigMapResponse deleteK8sConfigMapWithOptions(shared_ptr<DeleteK8sConfigMapRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteK8sConfigMapResponse deleteK8sConfigMap(shared_ptr<DeleteK8sConfigMapRequest> request);
  DeleteK8sIngressRuleResponse deleteK8sIngressRuleWithOptions(shared_ptr<DeleteK8sIngressRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteK8sIngressRuleResponse deleteK8sIngressRule(shared_ptr<DeleteK8sIngressRuleRequest> request);
  DeleteK8sSecretResponse deleteK8sSecretWithOptions(shared_ptr<DeleteK8sSecretRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteK8sSecretResponse deleteK8sSecret(shared_ptr<DeleteK8sSecretRequest> request);
  DeleteK8sServiceResponse deleteK8sServiceWithOptions(shared_ptr<DeleteK8sServiceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteK8sServiceResponse deleteK8sService(shared_ptr<DeleteK8sServiceRequest> request);
  DeleteLogPathResponse deleteLogPathWithOptions(shared_ptr<DeleteLogPathRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLogPathResponse deleteLogPath(shared_ptr<DeleteLogPathRequest> request);
  DeleteRoleResponse deleteRoleWithOptions(shared_ptr<DeleteRoleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRoleResponse deleteRole(shared_ptr<DeleteRoleRequest> request);
  DeleteServiceGroupResponse deleteServiceGroupWithOptions(shared_ptr<DeleteServiceGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteServiceGroupResponse deleteServiceGroup(shared_ptr<DeleteServiceGroupRequest> request);
  DeleteSwimmingLaneResponse deleteSwimmingLaneWithOptions(shared_ptr<DeleteSwimmingLaneRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSwimmingLaneResponse deleteSwimmingLane(shared_ptr<DeleteSwimmingLaneRequest> request);
  DeleteUserDefineRegionResponse deleteUserDefineRegionWithOptions(shared_ptr<DeleteUserDefineRegionRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteUserDefineRegionResponse deleteUserDefineRegion(shared_ptr<DeleteUserDefineRegionRequest> request);
  DeployApplicationResponse deployApplicationWithOptions(shared_ptr<DeployApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeployApplicationResponse deployApplication(shared_ptr<DeployApplicationRequest> request);
  DeployK8sApplicationResponse deployK8sApplicationWithOptions(shared_ptr<DeployK8sApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeployK8sApplicationResponse deployK8sApplication(shared_ptr<DeployK8sApplicationRequest> request);
  DescribeAppInstanceListResponse describeAppInstanceListWithOptions(shared_ptr<DescribeAppInstanceListRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAppInstanceListResponse describeAppInstanceList(shared_ptr<DescribeAppInstanceListRequest> request);
  DescribeApplicationScalingRulesResponse describeApplicationScalingRulesWithOptions(shared_ptr<DescribeApplicationScalingRulesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApplicationScalingRulesResponse describeApplicationScalingRules(shared_ptr<DescribeApplicationScalingRulesRequest> request);
  DisableApplicationScalingRuleResponse disableApplicationScalingRuleWithOptions(shared_ptr<DisableApplicationScalingRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableApplicationScalingRuleResponse disableApplicationScalingRule(shared_ptr<DisableApplicationScalingRuleRequest> request);
  EnableApplicationScalingRuleResponse enableApplicationScalingRuleWithOptions(shared_ptr<EnableApplicationScalingRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableApplicationScalingRuleResponse enableApplicationScalingRule(shared_ptr<EnableApplicationScalingRuleRequest> request);
  GetAppDeploymentResponse getAppDeploymentWithOptions(shared_ptr<GetAppDeploymentRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAppDeploymentResponse getAppDeployment(shared_ptr<GetAppDeploymentRequest> request);
  GetApplicationResponse getApplicationWithOptions(shared_ptr<GetApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetApplicationResponse getApplication(shared_ptr<GetApplicationRequest> request);
  GetChangeOrderInfoResponse getChangeOrderInfoWithOptions(shared_ptr<GetChangeOrderInfoRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetChangeOrderInfoResponse getChangeOrderInfo(shared_ptr<GetChangeOrderInfoRequest> request);
  GetClusterResponse getClusterWithOptions(shared_ptr<GetClusterRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetClusterResponse getCluster(shared_ptr<GetClusterRequest> request);
  GetContainerConfigurationResponse getContainerConfigurationWithOptions(shared_ptr<GetContainerConfigurationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetContainerConfigurationResponse getContainerConfiguration(shared_ptr<GetContainerConfigurationRequest> request);
  GetJavaStartUpConfigResponse getJavaStartUpConfigWithOptions(shared_ptr<GetJavaStartUpConfigRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetJavaStartUpConfigResponse getJavaStartUpConfig(shared_ptr<GetJavaStartUpConfigRequest> request);
  GetJvmConfigurationResponse getJvmConfigurationWithOptions(shared_ptr<GetJvmConfigurationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetJvmConfigurationResponse getJvmConfiguration(shared_ptr<GetJvmConfigurationRequest> request);
  GetK8sAppPrecheckResultResponse getK8sAppPrecheckResultWithOptions(shared_ptr<GetK8sAppPrecheckResultRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetK8sAppPrecheckResultResponse getK8sAppPrecheckResult(shared_ptr<GetK8sAppPrecheckResultRequest> request);
  GetK8sApplicationResponse getK8sApplicationWithOptions(shared_ptr<GetK8sApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetK8sApplicationResponse getK8sApplication(shared_ptr<GetK8sApplicationRequest> request);
  GetK8sClusterResponse getK8sClusterWithOptions(shared_ptr<GetK8sClusterRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetK8sClusterResponse getK8sCluster(shared_ptr<GetK8sClusterRequest> request);
  GetK8sServicesResponse getK8sServicesWithOptions(shared_ptr<GetK8sServicesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetK8sServicesResponse getK8sServices(shared_ptr<GetK8sServicesRequest> request);
  GetPackageStorageCredentialResponse getPackageStorageCredentialWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPackageStorageCredentialResponse getPackageStorageCredential();
  GetScalingRulesResponse getScalingRulesWithOptions(shared_ptr<GetScalingRulesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetScalingRulesResponse getScalingRules(shared_ptr<GetScalingRulesRequest> request);
  GetSecureTokenResponse getSecureTokenWithOptions(shared_ptr<GetSecureTokenRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSecureTokenResponse getSecureToken(shared_ptr<GetSecureTokenRequest> request);
  GetServiceConsumersPageResponse getServiceConsumersPageWithOptions(shared_ptr<GetServiceConsumersPageRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetServiceConsumersPageResponse getServiceConsumersPage(shared_ptr<GetServiceConsumersPageRequest> request);
  GetServiceDetailResponse getServiceDetailWithOptions(shared_ptr<GetServiceDetailRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetServiceDetailResponse getServiceDetail(shared_ptr<GetServiceDetailRequest> request);
  GetServiceListPageResponse getServiceListPageWithOptions(shared_ptr<GetServiceListPageRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetServiceListPageResponse getServiceListPage(shared_ptr<GetServiceListPageRequest> request);
  GetServiceMethodPageResponse getServiceMethodPageWithOptions(shared_ptr<GetServiceMethodPageRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetServiceMethodPageResponse getServiceMethodPage(shared_ptr<GetServiceMethodPageRequest> request);
  GetServiceProvidersPageResponse getServiceProvidersPageWithOptions(shared_ptr<GetServiceProvidersPageRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetServiceProvidersPageResponse getServiceProvidersPage(shared_ptr<GetServiceProvidersPageRequest> request);
  GetWebContainerConfigResponse getWebContainerConfigWithOptions(shared_ptr<GetWebContainerConfigRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWebContainerConfigResponse getWebContainerConfig(shared_ptr<GetWebContainerConfigRequest> request);
  ImportK8sClusterResponse importK8sClusterWithOptions(shared_ptr<ImportK8sClusterRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportK8sClusterResponse importK8sCluster(shared_ptr<ImportK8sClusterRequest> request);
  InsertApplicationResponse insertApplicationWithOptions(shared_ptr<InsertApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertApplicationResponse insertApplication(shared_ptr<InsertApplicationRequest> request);
  InsertClusterResponse insertClusterWithOptions(shared_ptr<InsertClusterRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertClusterResponse insertCluster(shared_ptr<InsertClusterRequest> request);
  InsertClusterMemberResponse insertClusterMemberWithOptions(shared_ptr<InsertClusterMemberRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertClusterMemberResponse insertClusterMember(shared_ptr<InsertClusterMemberRequest> request);
  InsertDeployGroupResponse insertDeployGroupWithOptions(shared_ptr<InsertDeployGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertDeployGroupResponse insertDeployGroup(shared_ptr<InsertDeployGroupRequest> request);
  InsertK8sApplicationResponse insertK8sApplicationWithOptions(shared_ptr<InsertK8sApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertK8sApplicationResponse insertK8sApplication(shared_ptr<InsertK8sApplicationRequest> request);
  InsertOrUpdateRegionResponse insertOrUpdateRegionWithOptions(shared_ptr<InsertOrUpdateRegionRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertOrUpdateRegionResponse insertOrUpdateRegion(shared_ptr<InsertOrUpdateRegionRequest> request);
  InsertRoleResponse insertRoleWithOptions(shared_ptr<InsertRoleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertRoleResponse insertRole(shared_ptr<InsertRoleRequest> request);
  InsertServiceGroupResponse insertServiceGroupWithOptions(shared_ptr<InsertServiceGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertServiceGroupResponse insertServiceGroup(shared_ptr<InsertServiceGroupRequest> request);
  InsertSwimmingLaneResponse insertSwimmingLaneWithOptions(shared_ptr<InsertSwimmingLaneRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertSwimmingLaneResponse insertSwimmingLane(shared_ptr<InsertSwimmingLaneRequest> request);
  InsertSwimmingLaneGroupResponse insertSwimmingLaneGroupWithOptions(shared_ptr<InsertSwimmingLaneGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertSwimmingLaneGroupResponse insertSwimmingLaneGroup(shared_ptr<InsertSwimmingLaneGroupRequest> request);
  InstallAgentResponse installAgentWithOptions(shared_ptr<InstallAgentRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallAgentResponse installAgent(shared_ptr<InstallAgentRequest> request);
  ListAliyunRegionResponse listAliyunRegionWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAliyunRegionResponse listAliyunRegion();
  ListApplicationResponse listApplicationWithOptions(shared_ptr<ListApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApplicationResponse listApplication(shared_ptr<ListApplicationRequest> request);
  ListApplicationEcuResponse listApplicationEcuWithOptions(shared_ptr<ListApplicationEcuRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApplicationEcuResponse listApplicationEcu(shared_ptr<ListApplicationEcuRequest> request);
  ListAuthorityResponse listAuthorityWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAuthorityResponse listAuthority();
  ListBuildPackResponse listBuildPackWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBuildPackResponse listBuildPack();
  ListClusterResponse listClusterWithOptions(shared_ptr<ListClusterRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterResponse listCluster(shared_ptr<ListClusterRequest> request);
  ListClusterMembersResponse listClusterMembersWithOptions(shared_ptr<ListClusterMembersRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterMembersResponse listClusterMembers(shared_ptr<ListClusterMembersRequest> request);
  ListComponentsResponse listComponentsWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListComponentsResponse listComponents();
  ListConfigTemplatesResponse listConfigTemplatesWithOptions(shared_ptr<ListConfigTemplatesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConfigTemplatesResponse listConfigTemplates(shared_ptr<ListConfigTemplatesRequest> request);
  ListConsumedServicesResponse listConsumedServicesWithOptions(shared_ptr<ListConsumedServicesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConsumedServicesResponse listConsumedServices(shared_ptr<ListConsumedServicesRequest> request);
  ListConvertableEcuResponse listConvertableEcuWithOptions(shared_ptr<ListConvertableEcuRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConvertableEcuResponse listConvertableEcu(shared_ptr<ListConvertableEcuRequest> request);
  ListDeployGroupResponse listDeployGroupWithOptions(shared_ptr<ListDeployGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDeployGroupResponse listDeployGroup(shared_ptr<ListDeployGroupRequest> request);
  ListEcsNotInClusterResponse listEcsNotInClusterWithOptions(shared_ptr<ListEcsNotInClusterRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEcsNotInClusterResponse listEcsNotInCluster(shared_ptr<ListEcsNotInClusterRequest> request);
  ListEcuByRegionResponse listEcuByRegionWithOptions(shared_ptr<ListEcuByRegionRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEcuByRegionResponse listEcuByRegion(shared_ptr<ListEcuByRegionRequest> request);
  ListHistoryDeployVersionResponse listHistoryDeployVersionWithOptions(shared_ptr<ListHistoryDeployVersionRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHistoryDeployVersionResponse listHistoryDeployVersion(shared_ptr<ListHistoryDeployVersionRequest> request);
  ListK8sConfigMapsResponse listK8sConfigMapsWithOptions(shared_ptr<ListK8sConfigMapsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListK8sConfigMapsResponse listK8sConfigMaps(shared_ptr<ListK8sConfigMapsRequest> request);
  ListK8sIngressRulesResponse listK8sIngressRulesWithOptions(shared_ptr<ListK8sIngressRulesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListK8sIngressRulesResponse listK8sIngressRules(shared_ptr<ListK8sIngressRulesRequest> request);
  ListK8sNamespacesResponse listK8sNamespacesWithOptions(shared_ptr<ListK8sNamespacesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListK8sNamespacesResponse listK8sNamespaces(shared_ptr<ListK8sNamespacesRequest> request);
  ListK8sSecretsResponse listK8sSecretsWithOptions(shared_ptr<ListK8sSecretsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListK8sSecretsResponse listK8sSecrets(shared_ptr<ListK8sSecretsRequest> request);
  ListMethodsResponse listMethodsWithOptions(shared_ptr<ListMethodsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMethodsResponse listMethods(shared_ptr<ListMethodsRequest> request);
  ListPublishedServicesResponse listPublishedServicesWithOptions(shared_ptr<ListPublishedServicesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPublishedServicesResponse listPublishedServices(shared_ptr<ListPublishedServicesRequest> request);
  ListRecentChangeOrderResponse listRecentChangeOrderWithOptions(shared_ptr<ListRecentChangeOrderRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRecentChangeOrderResponse listRecentChangeOrder(shared_ptr<ListRecentChangeOrderRequest> request);
  ListResourceGroupResponse listResourceGroupWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListResourceGroupResponse listResourceGroup();
  ListRoleResponse listRoleWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRoleResponse listRole();
  ListScaleOutEcuResponse listScaleOutEcuWithOptions(shared_ptr<ListScaleOutEcuRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListScaleOutEcuResponse listScaleOutEcu(shared_ptr<ListScaleOutEcuRequest> request);
  ListServiceGroupsResponse listServiceGroupsWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListServiceGroupsResponse listServiceGroups();
  ListSlbResponse listSlbWithOptions(shared_ptr<ListSlbRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSlbResponse listSlb(shared_ptr<ListSlbRequest> request);
  ListSubAccountResponse listSubAccountWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSubAccountResponse listSubAccount();
  ListSwimmingLaneResponse listSwimmingLaneWithOptions(shared_ptr<ListSwimmingLaneRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSwimmingLaneResponse listSwimmingLane(shared_ptr<ListSwimmingLaneRequest> request);
  ListSwimmingLaneGroupResponse listSwimmingLaneGroupWithOptions(shared_ptr<ListSwimmingLaneGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSwimmingLaneGroupResponse listSwimmingLaneGroup(shared_ptr<ListSwimmingLaneGroupRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ListUserDefineRegionResponse listUserDefineRegionWithOptions(shared_ptr<ListUserDefineRegionRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUserDefineRegionResponse listUserDefineRegion(shared_ptr<ListUserDefineRegionRequest> request);
  ListVpcResponse listVpcWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListVpcResponse listVpc();
  MigrateEcuResponse migrateEcuWithOptions(shared_ptr<MigrateEcuRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MigrateEcuResponse migrateEcu(shared_ptr<MigrateEcuRequest> request);
  ModifyScalingRuleResponse modifyScalingRuleWithOptions(shared_ptr<ModifyScalingRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyScalingRuleResponse modifyScalingRule(shared_ptr<ModifyScalingRuleRequest> request);
  QueryApplicationStatusResponse queryApplicationStatusWithOptions(shared_ptr<QueryApplicationStatusRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryApplicationStatusResponse queryApplicationStatus(shared_ptr<QueryApplicationStatusRequest> request);
  QueryEccInfoResponse queryEccInfoWithOptions(shared_ptr<QueryEccInfoRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEccInfoResponse queryEccInfo(shared_ptr<QueryEccInfoRequest> request);
  QueryMigrateEcuListResponse queryMigrateEcuListWithOptions(shared_ptr<QueryMigrateEcuListRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMigrateEcuListResponse queryMigrateEcuList(shared_ptr<QueryMigrateEcuListRequest> request);
  QueryMigrateRegionListResponse queryMigrateRegionListWithOptions(shared_ptr<QueryMigrateRegionListRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMigrateRegionListResponse queryMigrateRegionList(shared_ptr<QueryMigrateRegionListRequest> request);
  QueryRegionConfigResponse queryRegionConfigWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryRegionConfigResponse queryRegionConfig();
  QuerySlsLogStoreListResponse querySlsLogStoreListWithOptions(shared_ptr<QuerySlsLogStoreListRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySlsLogStoreListResponse querySlsLogStoreList(shared_ptr<QuerySlsLogStoreListRequest> request);
  ResetApplicationResponse resetApplicationWithOptions(shared_ptr<ResetApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetApplicationResponse resetApplication(shared_ptr<ResetApplicationRequest> request);
  RestartApplicationResponse restartApplicationWithOptions(shared_ptr<RestartApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestartApplicationResponse restartApplication(shared_ptr<RestartApplicationRequest> request);
  RestartK8sApplicationResponse restartK8sApplicationWithOptions(shared_ptr<RestartK8sApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestartK8sApplicationResponse restartK8sApplication(shared_ptr<RestartK8sApplicationRequest> request);
  RetryChangeOrderTaskResponse retryChangeOrderTaskWithOptions(shared_ptr<RetryChangeOrderTaskRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RetryChangeOrderTaskResponse retryChangeOrderTask(shared_ptr<RetryChangeOrderTaskRequest> request);
  RollbackApplicationResponse rollbackApplicationWithOptions(shared_ptr<RollbackApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RollbackApplicationResponse rollbackApplication(shared_ptr<RollbackApplicationRequest> request);
  RollbackChangeOrderResponse rollbackChangeOrderWithOptions(shared_ptr<RollbackChangeOrderRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RollbackChangeOrderResponse rollbackChangeOrder(shared_ptr<RollbackChangeOrderRequest> request);
  ScaleInApplicationResponse scaleInApplicationWithOptions(shared_ptr<ScaleInApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ScaleInApplicationResponse scaleInApplication(shared_ptr<ScaleInApplicationRequest> request);
  ScaleK8sApplicationResponse scaleK8sApplicationWithOptions(shared_ptr<ScaleK8sApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ScaleK8sApplicationResponse scaleK8sApplication(shared_ptr<ScaleK8sApplicationRequest> request);
  ScaleOutApplicationResponse scaleOutApplicationWithOptions(shared_ptr<ScaleOutApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ScaleOutApplicationResponse scaleOutApplication(shared_ptr<ScaleOutApplicationRequest> request);
  ScaleoutApplicationWithNewInstancesResponse scaleoutApplicationWithNewInstancesWithOptions(shared_ptr<ScaleoutApplicationWithNewInstancesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ScaleoutApplicationWithNewInstancesResponse scaleoutApplicationWithNewInstances(shared_ptr<ScaleoutApplicationWithNewInstancesRequest> request);
  StartApplicationResponse startApplicationWithOptions(shared_ptr<StartApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartApplicationResponse startApplication(shared_ptr<StartApplicationRequest> request);
  StartK8sAppPrecheckResponse startK8sAppPrecheckWithOptions(shared_ptr<StartK8sAppPrecheckRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartK8sAppPrecheckResponse startK8sAppPrecheck(shared_ptr<StartK8sAppPrecheckRequest> request);
  StartK8sApplicationResponse startK8sApplicationWithOptions(shared_ptr<StartK8sApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartK8sApplicationResponse startK8sApplication(shared_ptr<StartK8sApplicationRequest> request);
  StopApplicationResponse stopApplicationWithOptions(shared_ptr<StopApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopApplicationResponse stopApplication(shared_ptr<StopApplicationRequest> request);
  StopK8sApplicationResponse stopK8sApplicationWithOptions(shared_ptr<StopK8sApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopK8sApplicationResponse stopK8sApplication(shared_ptr<StopK8sApplicationRequest> request);
  SwitchAdvancedMonitoringResponse switchAdvancedMonitoringWithOptions(shared_ptr<SwitchAdvancedMonitoringRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SwitchAdvancedMonitoringResponse switchAdvancedMonitoring(shared_ptr<SwitchAdvancedMonitoringRequest> request);
  SynchronizeResourceResponse synchronizeResourceWithOptions(shared_ptr<SynchronizeResourceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SynchronizeResourceResponse synchronizeResource(shared_ptr<SynchronizeResourceRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  TransformClusterMemberResponse transformClusterMemberWithOptions(shared_ptr<TransformClusterMemberRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TransformClusterMemberResponse transformClusterMember(shared_ptr<TransformClusterMemberRequest> request);
  UnbindK8sSlbResponse unbindK8sSlbWithOptions(shared_ptr<UnbindK8sSlbRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindK8sSlbResponse unbindK8sSlb(shared_ptr<UnbindK8sSlbRequest> request);
  UnbindSlbResponse unbindSlbWithOptions(shared_ptr<UnbindSlbRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindSlbResponse unbindSlb(shared_ptr<UnbindSlbRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  UpdateAccountInfoResponse updateAccountInfoWithOptions(shared_ptr<UpdateAccountInfoRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAccountInfoResponse updateAccountInfo(shared_ptr<UpdateAccountInfoRequest> request);
  UpdateApplicationBaseInfoResponse updateApplicationBaseInfoWithOptions(shared_ptr<UpdateApplicationBaseInfoRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateApplicationBaseInfoResponse updateApplicationBaseInfo(shared_ptr<UpdateApplicationBaseInfoRequest> request);
  UpdateApplicationScalingRuleResponse updateApplicationScalingRuleWithOptions(shared_ptr<UpdateApplicationScalingRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateApplicationScalingRuleResponse updateApplicationScalingRule(shared_ptr<UpdateApplicationScalingRuleRequest> request);
  UpdateConfigTemplateResponse updateConfigTemplateWithOptions(shared_ptr<UpdateConfigTemplateRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateConfigTemplateResponse updateConfigTemplate(shared_ptr<UpdateConfigTemplateRequest> request);
  UpdateContainerResponse updateContainerWithOptions(shared_ptr<UpdateContainerRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateContainerResponse updateContainer(shared_ptr<UpdateContainerRequest> request);
  UpdateContainerConfigurationResponse updateContainerConfigurationWithOptions(shared_ptr<UpdateContainerConfigurationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateContainerConfigurationResponse updateContainerConfiguration(shared_ptr<UpdateContainerConfigurationRequest> request);
  UpdateHealthCheckUrlResponse updateHealthCheckUrlWithOptions(shared_ptr<UpdateHealthCheckUrlRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateHealthCheckUrlResponse updateHealthCheckUrl(shared_ptr<UpdateHealthCheckUrlRequest> request);
  UpdateHookConfigurationResponse updateHookConfigurationWithOptions(shared_ptr<UpdateHookConfigurationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateHookConfigurationResponse updateHookConfiguration(shared_ptr<UpdateHookConfigurationRequest> request);
  UpdateJvmConfigurationResponse updateJvmConfigurationWithOptions(shared_ptr<UpdateJvmConfigurationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateJvmConfigurationResponse updateJvmConfiguration(shared_ptr<UpdateJvmConfigurationRequest> request);
  UpdateK8sApplicationBaseInfoResponse updateK8sApplicationBaseInfoWithOptions(shared_ptr<UpdateK8sApplicationBaseInfoRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateK8sApplicationBaseInfoResponse updateK8sApplicationBaseInfo(shared_ptr<UpdateK8sApplicationBaseInfoRequest> request);
  UpdateK8sApplicationConfigResponse updateK8sApplicationConfigWithOptions(shared_ptr<UpdateK8sApplicationConfigRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateK8sApplicationConfigResponse updateK8sApplicationConfig(shared_ptr<UpdateK8sApplicationConfigRequest> request);
  UpdateK8sConfigMapResponse updateK8sConfigMapWithOptions(shared_ptr<UpdateK8sConfigMapRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateK8sConfigMapResponse updateK8sConfigMap(shared_ptr<UpdateK8sConfigMapRequest> request);
  UpdateK8sIngressRuleResponse updateK8sIngressRuleWithOptions(shared_ptr<UpdateK8sIngressRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateK8sIngressRuleResponse updateK8sIngressRule(shared_ptr<UpdateK8sIngressRuleRequest> request);
  UpdateK8sResourceResponse updateK8sResourceWithOptions(shared_ptr<UpdateK8sResourceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateK8sResourceResponse updateK8sResource(shared_ptr<UpdateK8sResourceRequest> request);
  UpdateK8sSecretResponse updateK8sSecretWithOptions(shared_ptr<UpdateK8sSecretRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateK8sSecretResponse updateK8sSecret(shared_ptr<UpdateK8sSecretRequest> request);
  UpdateK8sServiceResponse updateK8sServiceWithOptions(shared_ptr<UpdateK8sServiceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateK8sServiceResponse updateK8sService(shared_ptr<UpdateK8sServiceRequest> request);
  UpdateK8sSlbResponse updateK8sSlbWithOptions(shared_ptr<UpdateK8sSlbRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateK8sSlbResponse updateK8sSlb(shared_ptr<UpdateK8sSlbRequest> request);
  UpdateRoleResponse updateRoleWithOptions(shared_ptr<UpdateRoleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRoleResponse updateRole(shared_ptr<UpdateRoleRequest> request);
  UpdateSlsLogStoreResponse updateSlsLogStoreWithOptions(shared_ptr<UpdateSlsLogStoreRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSlsLogStoreResponse updateSlsLogStore(shared_ptr<UpdateSlsLogStoreRequest> request);
  UpdateSwimmingLaneResponse updateSwimmingLaneWithOptions(shared_ptr<UpdateSwimmingLaneRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSwimmingLaneResponse updateSwimmingLane(shared_ptr<UpdateSwimmingLaneRequest> request);
  UpdateSwimmingLaneGroupResponse updateSwimmingLaneGroupWithOptions(shared_ptr<UpdateSwimmingLaneGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSwimmingLaneGroupResponse updateSwimmingLaneGroup(shared_ptr<UpdateSwimmingLaneGroupRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Edas20170801

#endif
