// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_EDAS20170801_H_
#define ALIBABACLOUD_EDAS20170801_H_

#include <alibabacloud/open_api.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Edas20170801 {
class AbortAndRollbackChangeOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  AbortAndRollbackChangeOrderRequest() {}

  explicit AbortAndRollbackChangeOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~AbortAndRollbackChangeOrderRequest() = default;
};
class AbortAndRollbackChangeOrderResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  AbortAndRollbackChangeOrderResponseBodyData() {}

  explicit AbortAndRollbackChangeOrderResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~AbortAndRollbackChangeOrderResponseBodyData() = default;
};
class AbortAndRollbackChangeOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> traceId{};
  shared_ptr<AbortAndRollbackChangeOrderResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> code{};

  AbortAndRollbackChangeOrderResponseBody() {}

  explicit AbortAndRollbackChangeOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AbortAndRollbackChangeOrderResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AbortAndRollbackChangeOrderResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~AbortAndRollbackChangeOrderResponseBody() = default;
};
class AbortAndRollbackChangeOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AbortAndRollbackChangeOrderResponseBody> body{};

  AbortAndRollbackChangeOrderResponse() {}

  explicit AbortAndRollbackChangeOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AbortAndRollbackChangeOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AbortAndRollbackChangeOrderResponseBody>(model1);
      }
    }
  }


  virtual ~AbortAndRollbackChangeOrderResponse() = default;
};
class AbortChangeOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  AbortChangeOrderRequest() {}

  explicit AbortChangeOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~AbortChangeOrderRequest() = default;
};
class AbortChangeOrderResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  AbortChangeOrderResponseBodyData() {}

  explicit AbortChangeOrderResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~AbortChangeOrderResponseBodyData() = default;
};
class AbortChangeOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> traceId{};
  shared_ptr<AbortChangeOrderResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> code{};

  AbortChangeOrderResponseBody() {}

  explicit AbortChangeOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AbortChangeOrderResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AbortChangeOrderResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~AbortChangeOrderResponseBody() = default;
};
class AbortChangeOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AbortChangeOrderResponseBody> body{};

  AbortChangeOrderResponse() {}

  explicit AbortChangeOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AbortChangeOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AbortChangeOrderResponseBody>(model1);
      }
    }
  }


  virtual ~AbortChangeOrderResponse() = default;
};
class AddLogPathRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> path{};

  AddLogPathRequest() {}

  explicit AddLogPathRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~AddLogPathRequest() = default;
};
class AddLogPathResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  AddLogPathResponseBody() {}

  explicit AddLogPathResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~AddLogPathResponseBody() = default;
};
class AddLogPathResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddLogPathResponseBody> body{};

  AddLogPathResponse() {}

  explicit AddLogPathResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLogPathResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLogPathResponseBody>(model1);
      }
    }
  }


  virtual ~AddLogPathResponse() = default;
};
class AddMockRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> region{};
  shared_ptr<string> source{};
  shared_ptr<string> providerAppId{};
  shared_ptr<string> providerAppName{};
  shared_ptr<string> extraJson{};
  shared_ptr<string> scMockItemJson{};
  shared_ptr<string> dubboMockItemJson{};
  shared_ptr<string> consumerAppsJson{};
  shared_ptr<bool> enable{};
  shared_ptr<string> namespace_{};

  AddMockRuleRequest() {}

  explicit AddMockRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (providerAppId) {
      res["ProviderAppId"] = boost::any(*providerAppId);
    }
    if (providerAppName) {
      res["ProviderAppName"] = boost::any(*providerAppName);
    }
    if (extraJson) {
      res["ExtraJson"] = boost::any(*extraJson);
    }
    if (scMockItemJson) {
      res["ScMockItemJson"] = boost::any(*scMockItemJson);
    }
    if (dubboMockItemJson) {
      res["DubboMockItemJson"] = boost::any(*dubboMockItemJson);
    }
    if (consumerAppsJson) {
      res["ConsumerAppsJson"] = boost::any(*consumerAppsJson);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("ProviderAppId") != m.end() && !m["ProviderAppId"].empty()) {
      providerAppId = make_shared<string>(boost::any_cast<string>(m["ProviderAppId"]));
    }
    if (m.find("ProviderAppName") != m.end() && !m["ProviderAppName"].empty()) {
      providerAppName = make_shared<string>(boost::any_cast<string>(m["ProviderAppName"]));
    }
    if (m.find("ExtraJson") != m.end() && !m["ExtraJson"].empty()) {
      extraJson = make_shared<string>(boost::any_cast<string>(m["ExtraJson"]));
    }
    if (m.find("ScMockItemJson") != m.end() && !m["ScMockItemJson"].empty()) {
      scMockItemJson = make_shared<string>(boost::any_cast<string>(m["ScMockItemJson"]));
    }
    if (m.find("DubboMockItemJson") != m.end() && !m["DubboMockItemJson"].empty()) {
      dubboMockItemJson = make_shared<string>(boost::any_cast<string>(m["DubboMockItemJson"]));
    }
    if (m.find("ConsumerAppsJson") != m.end() && !m["ConsumerAppsJson"].empty()) {
      consumerAppsJson = make_shared<string>(boost::any_cast<string>(m["ConsumerAppsJson"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~AddMockRuleRequest() = default;
};
class AddMockRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<string> scMockItemJson{};
  shared_ptr<string> consumerAppName{};
  shared_ptr<string> consumerAppId{};
  shared_ptr<string> accountId{};
  shared_ptr<string> extraJson{};
  shared_ptr<string> source{};
  shared_ptr<string> region{};
  shared_ptr<string> providerAppId{};
  shared_ptr<string> providerAppName{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};
  shared_ptr<bool> enable{};

  AddMockRuleResponseBodyData() {}

  explicit AddMockRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (scMockItemJson) {
      res["ScMockItemJson"] = boost::any(*scMockItemJson);
    }
    if (consumerAppName) {
      res["ConsumerAppName"] = boost::any(*consumerAppName);
    }
    if (consumerAppId) {
      res["ConsumerAppId"] = boost::any(*consumerAppId);
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (extraJson) {
      res["ExtraJson"] = boost::any(*extraJson);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (providerAppId) {
      res["ProviderAppId"] = boost::any(*providerAppId);
    }
    if (providerAppName) {
      res["ProviderAppName"] = boost::any(*providerAppName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("ScMockItemJson") != m.end() && !m["ScMockItemJson"].empty()) {
      scMockItemJson = make_shared<string>(boost::any_cast<string>(m["ScMockItemJson"]));
    }
    if (m.find("ConsumerAppName") != m.end() && !m["ConsumerAppName"].empty()) {
      consumerAppName = make_shared<string>(boost::any_cast<string>(m["ConsumerAppName"]));
    }
    if (m.find("ConsumerAppId") != m.end() && !m["ConsumerAppId"].empty()) {
      consumerAppId = make_shared<string>(boost::any_cast<string>(m["ConsumerAppId"]));
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ExtraJson") != m.end() && !m["ExtraJson"].empty()) {
      extraJson = make_shared<string>(boost::any_cast<string>(m["ExtraJson"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ProviderAppId") != m.end() && !m["ProviderAppId"].empty()) {
      providerAppId = make_shared<string>(boost::any_cast<string>(m["ProviderAppId"]));
    }
    if (m.find("ProviderAppName") != m.end() && !m["ProviderAppName"].empty()) {
      providerAppName = make_shared<string>(boost::any_cast<string>(m["ProviderAppName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
  }


  virtual ~AddMockRuleResponseBodyData() = default;
};
class AddMockRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<AddMockRuleResponseBodyData> data{};
  shared_ptr<long> code{};
  shared_ptr<bool> success{};

  AddMockRuleResponseBody() {}

  explicit AddMockRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AddMockRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AddMockRuleResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddMockRuleResponseBody() = default;
};
class AddMockRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddMockRuleResponseBody> body{};

  AddMockRuleResponse() {}

  explicit AddMockRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddMockRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddMockRuleResponseBody>(model1);
      }
    }
  }


  virtual ~AddMockRuleResponse() = default;
};
class AddServiceTimeConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> region{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> appId{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceVersion{};
  shared_ptr<string> serviceGroup{};
  shared_ptr<string> path{};
  shared_ptr<string> consumerAppName{};
  shared_ptr<string> consumerAppId{};
  shared_ptr<string> timeout{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> source{};

  AddServiceTimeConfigRequest() {}

  explicit AddServiceTimeConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (serviceVersion) {
      res["ServiceVersion"] = boost::any(*serviceVersion);
    }
    if (serviceGroup) {
      res["ServiceGroup"] = boost::any(*serviceGroup);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (consumerAppName) {
      res["ConsumerAppName"] = boost::any(*consumerAppName);
    }
    if (consumerAppId) {
      res["ConsumerAppId"] = boost::any(*consumerAppId);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServiceVersion") != m.end() && !m["ServiceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["ServiceVersion"]));
    }
    if (m.find("ServiceGroup") != m.end() && !m["ServiceGroup"].empty()) {
      serviceGroup = make_shared<string>(boost::any_cast<string>(m["ServiceGroup"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ConsumerAppName") != m.end() && !m["ConsumerAppName"].empty()) {
      consumerAppName = make_shared<string>(boost::any_cast<string>(m["ConsumerAppName"]));
    }
    if (m.find("ConsumerAppId") != m.end() && !m["ConsumerAppId"].empty()) {
      consumerAppId = make_shared<string>(boost::any_cast<string>(m["ConsumerAppId"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<string>(boost::any_cast<string>(m["Timeout"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~AddServiceTimeConfigRequest() = default;
};
class AddServiceTimeConfigResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> timeout{};
  shared_ptr<string> consumerAppName{};
  shared_ptr<string> path{};
  shared_ptr<string> consumerAppId{};
  shared_ptr<long> id{};

  AddServiceTimeConfigResponseBodyData() {}

  explicit AddServiceTimeConfigResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (consumerAppName) {
      res["ConsumerAppName"] = boost::any(*consumerAppName);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (consumerAppId) {
      res["ConsumerAppId"] = boost::any(*consumerAppId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<string>(boost::any_cast<string>(m["Timeout"]));
    }
    if (m.find("ConsumerAppName") != m.end() && !m["ConsumerAppName"].empty()) {
      consumerAppName = make_shared<string>(boost::any_cast<string>(m["ConsumerAppName"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ConsumerAppId") != m.end() && !m["ConsumerAppId"].empty()) {
      consumerAppId = make_shared<string>(boost::any_cast<string>(m["ConsumerAppId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~AddServiceTimeConfigResponseBodyData() = default;
};
class AddServiceTimeConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<AddServiceTimeConfigResponseBodyData> data{};
  shared_ptr<long> code{};
  shared_ptr<bool> success{};

  AddServiceTimeConfigResponseBody() {}

  explicit AddServiceTimeConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AddServiceTimeConfigResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AddServiceTimeConfigResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddServiceTimeConfigResponseBody() = default;
};
class AddServiceTimeConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddServiceTimeConfigResponseBody> body{};

  AddServiceTimeConfigResponse() {}

  explicit AddServiceTimeConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddServiceTimeConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddServiceTimeConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddServiceTimeConfigResponse() = default;
};
class AuthorizeApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> targetUserId{};
  shared_ptr<string> appIds{};

  AuthorizeApplicationRequest() {}

  explicit AuthorizeApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetUserId) {
      res["TargetUserId"] = boost::any(*targetUserId);
    }
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetUserId") != m.end() && !m["TargetUserId"].empty()) {
      targetUserId = make_shared<string>(boost::any_cast<string>(m["TargetUserId"]));
    }
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      appIds = make_shared<string>(boost::any_cast<string>(m["AppIds"]));
    }
  }


  virtual ~AuthorizeApplicationRequest() = default;
};
class AuthorizeApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  AuthorizeApplicationResponseBody() {}

  explicit AuthorizeApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~AuthorizeApplicationResponseBody() = default;
};
class AuthorizeApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AuthorizeApplicationResponseBody> body{};

  AuthorizeApplicationResponse() {}

  explicit AuthorizeApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AuthorizeApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AuthorizeApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~AuthorizeApplicationResponse() = default;
};
class AuthorizeResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> targetUserId{};
  shared_ptr<string> resourceGroupIds{};

  AuthorizeResourceGroupRequest() {}

  explicit AuthorizeResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetUserId) {
      res["TargetUserId"] = boost::any(*targetUserId);
    }
    if (resourceGroupIds) {
      res["ResourceGroupIds"] = boost::any(*resourceGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetUserId") != m.end() && !m["TargetUserId"].empty()) {
      targetUserId = make_shared<string>(boost::any_cast<string>(m["TargetUserId"]));
    }
    if (m.find("ResourceGroupIds") != m.end() && !m["ResourceGroupIds"].empty()) {
      resourceGroupIds = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIds"]));
    }
  }


  virtual ~AuthorizeResourceGroupRequest() = default;
};
class AuthorizeResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  AuthorizeResourceGroupResponseBody() {}

  explicit AuthorizeResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~AuthorizeResourceGroupResponseBody() = default;
};
class AuthorizeResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AuthorizeResourceGroupResponseBody> body{};

  AuthorizeResourceGroupResponse() {}

  explicit AuthorizeResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AuthorizeResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AuthorizeResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AuthorizeResourceGroupResponse() = default;
};
class AuthorizeRoleRequest : public Darabonba::Model {
public:
  shared_ptr<string> targetUserId{};
  shared_ptr<string> roleIds{};

  AuthorizeRoleRequest() {}

  explicit AuthorizeRoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetUserId) {
      res["TargetUserId"] = boost::any(*targetUserId);
    }
    if (roleIds) {
      res["RoleIds"] = boost::any(*roleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetUserId") != m.end() && !m["TargetUserId"].empty()) {
      targetUserId = make_shared<string>(boost::any_cast<string>(m["TargetUserId"]));
    }
    if (m.find("RoleIds") != m.end() && !m["RoleIds"].empty()) {
      roleIds = make_shared<string>(boost::any_cast<string>(m["RoleIds"]));
    }
  }


  virtual ~AuthorizeRoleRequest() = default;
};
class AuthorizeRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  AuthorizeRoleResponseBody() {}

  explicit AuthorizeRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~AuthorizeRoleResponseBody() = default;
};
class AuthorizeRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AuthorizeRoleResponseBody> body{};

  AuthorizeRoleResponse() {}

  explicit AuthorizeRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AuthorizeRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AuthorizeRoleResponseBody>(model1);
      }
    }
  }


  virtual ~AuthorizeRoleResponse() = default;
};
class BindEcsSlbRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> slbId{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> VServerGroupId{};
  shared_ptr<string> listenerProtocol{};
  shared_ptr<string> deployGroupId{};
  shared_ptr<string> VServerGroupName{};
  shared_ptr<string> listenerHealthCheckUrl{};
  shared_ptr<string> VForwardingUrlRule{};

  BindEcsSlbRequest() {}

  explicit BindEcsSlbRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (VServerGroupId) {
      res["VServerGroupId"] = boost::any(*VServerGroupId);
    }
    if (listenerProtocol) {
      res["ListenerProtocol"] = boost::any(*listenerProtocol);
    }
    if (deployGroupId) {
      res["DeployGroupId"] = boost::any(*deployGroupId);
    }
    if (VServerGroupName) {
      res["VServerGroupName"] = boost::any(*VServerGroupName);
    }
    if (listenerHealthCheckUrl) {
      res["ListenerHealthCheckUrl"] = boost::any(*listenerHealthCheckUrl);
    }
    if (VForwardingUrlRule) {
      res["VForwardingUrlRule"] = boost::any(*VForwardingUrlRule);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("VServerGroupId") != m.end() && !m["VServerGroupId"].empty()) {
      VServerGroupId = make_shared<string>(boost::any_cast<string>(m["VServerGroupId"]));
    }
    if (m.find("ListenerProtocol") != m.end() && !m["ListenerProtocol"].empty()) {
      listenerProtocol = make_shared<string>(boost::any_cast<string>(m["ListenerProtocol"]));
    }
    if (m.find("DeployGroupId") != m.end() && !m["DeployGroupId"].empty()) {
      deployGroupId = make_shared<string>(boost::any_cast<string>(m["DeployGroupId"]));
    }
    if (m.find("VServerGroupName") != m.end() && !m["VServerGroupName"].empty()) {
      VServerGroupName = make_shared<string>(boost::any_cast<string>(m["VServerGroupName"]));
    }
    if (m.find("ListenerHealthCheckUrl") != m.end() && !m["ListenerHealthCheckUrl"].empty()) {
      listenerHealthCheckUrl = make_shared<string>(boost::any_cast<string>(m["ListenerHealthCheckUrl"]));
    }
    if (m.find("VForwardingUrlRule") != m.end() && !m["VForwardingUrlRule"].empty()) {
      VForwardingUrlRule = make_shared<string>(boost::any_cast<string>(m["VForwardingUrlRule"]));
    }
  }


  virtual ~BindEcsSlbRequest() = default;
};
class BindEcsSlbResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  BindEcsSlbResponseBody() {}

  explicit BindEcsSlbResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~BindEcsSlbResponseBody() = default;
};
class BindEcsSlbResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BindEcsSlbResponseBody> body{};

  BindEcsSlbResponse() {}

  explicit BindEcsSlbResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindEcsSlbResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindEcsSlbResponseBody>(model1);
      }
    }
  }


  virtual ~BindEcsSlbResponse() = default;
};
class BindK8sSlbRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> type{};
  shared_ptr<string> slbId{};
  shared_ptr<string> slbProtocol{};
  shared_ptr<string> targetPort{};
  shared_ptr<string> port{};
  shared_ptr<string> servicePortInfos{};
  shared_ptr<string> specification{};
  shared_ptr<string> scheduler{};

  BindK8sSlbRequest() {}

  explicit BindK8sSlbRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (slbProtocol) {
      res["SlbProtocol"] = boost::any(*slbProtocol);
    }
    if (targetPort) {
      res["TargetPort"] = boost::any(*targetPort);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (servicePortInfos) {
      res["ServicePortInfos"] = boost::any(*servicePortInfos);
    }
    if (specification) {
      res["Specification"] = boost::any(*specification);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("SlbProtocol") != m.end() && !m["SlbProtocol"].empty()) {
      slbProtocol = make_shared<string>(boost::any_cast<string>(m["SlbProtocol"]));
    }
    if (m.find("TargetPort") != m.end() && !m["TargetPort"].empty()) {
      targetPort = make_shared<string>(boost::any_cast<string>(m["TargetPort"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("ServicePortInfos") != m.end() && !m["ServicePortInfos"].empty()) {
      servicePortInfos = make_shared<string>(boost::any_cast<string>(m["ServicePortInfos"]));
    }
    if (m.find("Specification") != m.end() && !m["Specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["Specification"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
  }


  virtual ~BindK8sSlbRequest() = default;
};
class BindK8sSlbResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  BindK8sSlbResponseBody() {}

  explicit BindK8sSlbResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~BindK8sSlbResponseBody() = default;
};
class BindK8sSlbResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BindK8sSlbResponseBody> body{};

  BindK8sSlbResponse() {}

  explicit BindK8sSlbResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindK8sSlbResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindK8sSlbResponseBody>(model1);
      }
    }
  }


  virtual ~BindK8sSlbResponse() = default;
};
class BindSlbRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> slbId{};
  shared_ptr<string> slbIp{};
  shared_ptr<string> type{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> VServerGroupId{};

  BindSlbRequest() {}

  explicit BindSlbRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (slbIp) {
      res["SlbIp"] = boost::any(*slbIp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (VServerGroupId) {
      res["VServerGroupId"] = boost::any(*VServerGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("SlbIp") != m.end() && !m["SlbIp"].empty()) {
      slbIp = make_shared<string>(boost::any_cast<string>(m["SlbIp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("VServerGroupId") != m.end() && !m["VServerGroupId"].empty()) {
      VServerGroupId = make_shared<string>(boost::any_cast<string>(m["VServerGroupId"]));
    }
  }


  virtual ~BindSlbRequest() = default;
};
class BindSlbResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> VServerGroupId{};
  shared_ptr<string> slbId{};
  shared_ptr<string> extSlbIp{};
  shared_ptr<long> slbPort{};
  shared_ptr<string> extSlbName{};
  shared_ptr<string> extSlbId{};
  shared_ptr<string> extVServerGroupId{};
  shared_ptr<string> slbName{};
  shared_ptr<string> slbIp{};

  BindSlbResponseBodyData() {}

  explicit BindSlbResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (VServerGroupId) {
      res["VServerGroupId"] = boost::any(*VServerGroupId);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (extSlbIp) {
      res["ExtSlbIp"] = boost::any(*extSlbIp);
    }
    if (slbPort) {
      res["SlbPort"] = boost::any(*slbPort);
    }
    if (extSlbName) {
      res["ExtSlbName"] = boost::any(*extSlbName);
    }
    if (extSlbId) {
      res["ExtSlbId"] = boost::any(*extSlbId);
    }
    if (extVServerGroupId) {
      res["ExtVServerGroupId"] = boost::any(*extVServerGroupId);
    }
    if (slbName) {
      res["SlbName"] = boost::any(*slbName);
    }
    if (slbIp) {
      res["SlbIp"] = boost::any(*slbIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VServerGroupId") != m.end() && !m["VServerGroupId"].empty()) {
      VServerGroupId = make_shared<string>(boost::any_cast<string>(m["VServerGroupId"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("ExtSlbIp") != m.end() && !m["ExtSlbIp"].empty()) {
      extSlbIp = make_shared<string>(boost::any_cast<string>(m["ExtSlbIp"]));
    }
    if (m.find("SlbPort") != m.end() && !m["SlbPort"].empty()) {
      slbPort = make_shared<long>(boost::any_cast<long>(m["SlbPort"]));
    }
    if (m.find("ExtSlbName") != m.end() && !m["ExtSlbName"].empty()) {
      extSlbName = make_shared<string>(boost::any_cast<string>(m["ExtSlbName"]));
    }
    if (m.find("ExtSlbId") != m.end() && !m["ExtSlbId"].empty()) {
      extSlbId = make_shared<string>(boost::any_cast<string>(m["ExtSlbId"]));
    }
    if (m.find("ExtVServerGroupId") != m.end() && !m["ExtVServerGroupId"].empty()) {
      extVServerGroupId = make_shared<string>(boost::any_cast<string>(m["ExtVServerGroupId"]));
    }
    if (m.find("SlbName") != m.end() && !m["SlbName"].empty()) {
      slbName = make_shared<string>(boost::any_cast<string>(m["SlbName"]));
    }
    if (m.find("SlbIp") != m.end() && !m["SlbIp"].empty()) {
      slbIp = make_shared<string>(boost::any_cast<string>(m["SlbIp"]));
    }
  }


  virtual ~BindSlbResponseBodyData() = default;
};
class BindSlbResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<BindSlbResponseBodyData> data{};
  shared_ptr<long> code{};

  BindSlbResponseBody() {}

  explicit BindSlbResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BindSlbResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BindSlbResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~BindSlbResponseBody() = default;
};
class BindSlbResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BindSlbResponseBody> body{};

  BindSlbResponse() {}

  explicit BindSlbResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindSlbResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindSlbResponseBody>(model1);
      }
    }
  }


  virtual ~BindSlbResponse() = default;
};
class ChangeDeployGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> eccInfo{};
  shared_ptr<string> groupName{};
  shared_ptr<bool> forceStatus{};

  ChangeDeployGroupRequest() {}

  explicit ChangeDeployGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (eccInfo) {
      res["EccInfo"] = boost::any(*eccInfo);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (forceStatus) {
      res["ForceStatus"] = boost::any(*forceStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EccInfo") != m.end() && !m["EccInfo"].empty()) {
      eccInfo = make_shared<string>(boost::any_cast<string>(m["EccInfo"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ForceStatus") != m.end() && !m["ForceStatus"].empty()) {
      forceStatus = make_shared<bool>(boost::any_cast<bool>(m["ForceStatus"]));
    }
  }


  virtual ~ChangeDeployGroupRequest() = default;
};
class ChangeDeployGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  ChangeDeployGroupResponseBody() {}

  explicit ChangeDeployGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ChangeDeployGroupResponseBody() = default;
};
class ChangeDeployGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ChangeDeployGroupResponseBody> body{};

  ChangeDeployGroupResponse() {}

  explicit ChangeDeployGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeDeployGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeDeployGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeDeployGroupResponse() = default;
};
class ContinuePipelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<bool> confirm{};

  ContinuePipelineRequest() {}

  explicit ContinuePipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (confirm) {
      res["Confirm"] = boost::any(*confirm);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Confirm") != m.end() && !m["Confirm"].empty()) {
      confirm = make_shared<bool>(boost::any_cast<bool>(m["Confirm"]));
    }
  }


  virtual ~ContinuePipelineRequest() = default;
};
class ContinuePipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  ContinuePipelineResponseBody() {}

  explicit ContinuePipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ContinuePipelineResponseBody() = default;
};
class ContinuePipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ContinuePipelineResponseBody> body{};

  ContinuePipelineResponse() {}

  explicit ContinuePipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ContinuePipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ContinuePipelineResponseBody>(model1);
      }
    }
  }


  virtual ~ContinuePipelineResponse() = default;
};
class ConvertK8sResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> clusterId{};

  ConvertK8sResourceRequest() {}

  explicit ConvertK8sResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~ConvertK8sResourceRequest() = default;
};
class ConvertK8sResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  ConvertK8sResourceResponseBody() {}

  explicit ConvertK8sResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ConvertK8sResourceResponseBody() = default;
};
class ConvertK8sResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ConvertK8sResourceResponseBody> body{};

  ConvertK8sResourceResponse() {}

  explicit ConvertK8sResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConvertK8sResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConvertK8sResourceResponseBody>(model1);
      }
    }
  }


  virtual ~ConvertK8sResourceResponse() = default;
};
class CreateIDCImportCommandRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};

  CreateIDCImportCommandRequest() {}

  explicit CreateIDCImportCommandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~CreateIDCImportCommandRequest() = default;
};
class CreateIDCImportCommandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> data{};
  shared_ptr<string> code{};

  CreateIDCImportCommandResponseBody() {}

  explicit CreateIDCImportCommandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~CreateIDCImportCommandResponseBody() = default;
};
class CreateIDCImportCommandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateIDCImportCommandResponseBody> body{};

  CreateIDCImportCommandResponse() {}

  explicit CreateIDCImportCommandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIDCImportCommandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIDCImportCommandResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIDCImportCommandResponse() = default;
};
class CreateK8sIngressRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> name{};
  shared_ptr<string> rules{};

  CreateK8sIngressRuleRequest() {}

  explicit CreateK8sIngressRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (rules) {
      res["Rules"] = boost::any(*rules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rules = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
  }


  virtual ~CreateK8sIngressRuleRequest() = default;
};
class CreateK8sIngressRuleResponseBodyChangeOrderIds : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<string> appId{};

  CreateK8sIngressRuleResponseBodyChangeOrderIds() {}

  explicit CreateK8sIngressRuleResponseBodyChangeOrderIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~CreateK8sIngressRuleResponseBodyChangeOrderIds() = default;
};
class CreateK8sIngressRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<vector<CreateK8sIngressRuleResponseBodyChangeOrderIds>> changeOrderIds{};
  shared_ptr<long> code{};

  CreateK8sIngressRuleResponseBody() {}

  explicit CreateK8sIngressRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (changeOrderIds) {
      vector<boost::any> temp1;
      for(auto item1:*changeOrderIds){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChangeOrderIds"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ChangeOrderIds") != m.end() && !m["ChangeOrderIds"].empty()) {
      if (typeid(vector<boost::any>) == m["ChangeOrderIds"].type()) {
        vector<CreateK8sIngressRuleResponseBodyChangeOrderIds> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChangeOrderIds"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateK8sIngressRuleResponseBodyChangeOrderIds model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        changeOrderIds = make_shared<vector<CreateK8sIngressRuleResponseBodyChangeOrderIds>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~CreateK8sIngressRuleResponseBody() = default;
};
class CreateK8sIngressRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateK8sIngressRuleResponseBody> body{};

  CreateK8sIngressRuleResponse() {}

  explicit CreateK8sIngressRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateK8sIngressRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateK8sIngressRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateK8sIngressRuleResponse() = default;
};
class CreateK8sServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> servicePorts{};

  CreateK8sServiceRequest() {}

  explicit CreateK8sServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (servicePorts) {
      res["ServicePorts"] = boost::any(*servicePorts);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ServicePorts") != m.end() && !m["ServicePorts"].empty()) {
      servicePorts = make_shared<string>(boost::any_cast<string>(m["ServicePorts"]));
    }
  }


  virtual ~CreateK8sServiceRequest() = default;
};
class CreateK8sServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  CreateK8sServiceResponseBody() {}

  explicit CreateK8sServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~CreateK8sServiceResponseBody() = default;
};
class CreateK8sServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateK8sServiceResponseBody> body{};

  CreateK8sServiceResponse() {}

  explicit CreateK8sServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateK8sServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateK8sServiceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateK8sServiceResponse() = default;
};
class DelegateAdminRoleRequest : public Darabonba::Model {
public:
  shared_ptr<string> targetUserId{};

  DelegateAdminRoleRequest() {}

  explicit DelegateAdminRoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetUserId) {
      res["TargetUserId"] = boost::any(*targetUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetUserId") != m.end() && !m["TargetUserId"].empty()) {
      targetUserId = make_shared<string>(boost::any_cast<string>(m["TargetUserId"]));
    }
  }


  virtual ~DelegateAdminRoleRequest() = default;
};
class DelegateAdminRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  DelegateAdminRoleResponseBody() {}

  explicit DelegateAdminRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DelegateAdminRoleResponseBody() = default;
};
class DelegateAdminRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DelegateAdminRoleResponseBody> body{};

  DelegateAdminRoleResponse() {}

  explicit DelegateAdminRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DelegateAdminRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DelegateAdminRoleResponseBody>(model1);
      }
    }
  }


  virtual ~DelegateAdminRoleResponse() = default;
};
class DeleteApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  DeleteApplicationRequest() {}

  explicit DeleteApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~DeleteApplicationRequest() = default;
};
class DeleteApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  DeleteApplicationResponseBody() {}

  explicit DeleteApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DeleteApplicationResponseBody() = default;
};
class DeleteApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteApplicationResponseBody> body{};

  DeleteApplicationResponse() {}

  explicit DeleteApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteApplicationResponse() = default;
};
class DeleteClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> mode{};

  DeleteClusterRequest() {}

  explicit DeleteClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<long>(boost::any_cast<long>(m["Mode"]));
    }
  }


  virtual ~DeleteClusterRequest() = default;
};
class DeleteClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> data{};
  shared_ptr<long> code{};

  DeleteClusterResponseBody() {}

  explicit DeleteClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DeleteClusterResponseBody() = default;
};
class DeleteClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteClusterResponseBody> body{};

  DeleteClusterResponse() {}

  explicit DeleteClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteClusterResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteClusterResponse() = default;
};
class DeleteClusterMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterMemberId{};

  DeleteClusterMemberRequest() {}

  explicit DeleteClusterMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterMemberId) {
      res["ClusterMemberId"] = boost::any(*clusterMemberId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterMemberId") != m.end() && !m["ClusterMemberId"].empty()) {
      clusterMemberId = make_shared<string>(boost::any_cast<string>(m["ClusterMemberId"]));
    }
  }


  virtual ~DeleteClusterMemberRequest() = default;
};
class DeleteClusterMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> data{};
  shared_ptr<long> code{};

  DeleteClusterMemberResponseBody() {}

  explicit DeleteClusterMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DeleteClusterMemberResponseBody() = default;
};
class DeleteClusterMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteClusterMemberResponseBody> body{};

  DeleteClusterMemberResponse() {}

  explicit DeleteClusterMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteClusterMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteClusterMemberResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteClusterMemberResponse() = default;
};
class DeleteConfigCenterRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataId{};
  shared_ptr<string> group{};
  shared_ptr<string> logicalRegionId{};

  DeleteConfigCenterRequest() {}

  explicit DeleteConfigCenterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
  }


  virtual ~DeleteConfigCenterRequest() = default;
};
class DeleteConfigCenterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  DeleteConfigCenterResponseBody() {}

  explicit DeleteConfigCenterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DeleteConfigCenterResponseBody() = default;
};
class DeleteConfigCenterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteConfigCenterResponseBody> body{};

  DeleteConfigCenterResponse() {}

  explicit DeleteConfigCenterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteConfigCenterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteConfigCenterResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteConfigCenterResponse() = default;
};
class DeleteDegradeControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> ruleId{};

  DeleteDegradeControlRequest() {}

  explicit DeleteDegradeControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~DeleteDegradeControlRequest() = default;
};
class DeleteDegradeControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  DeleteDegradeControlResponseBody() {}

  explicit DeleteDegradeControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DeleteDegradeControlResponseBody() = default;
};
class DeleteDegradeControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDegradeControlResponseBody> body{};

  DeleteDegradeControlResponse() {}

  explicit DeleteDegradeControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDegradeControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDegradeControlResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDegradeControlResponse() = default;
};
class DeleteDeployGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupName{};

  DeleteDeployGroupRequest() {}

  explicit DeleteDeployGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~DeleteDeployGroupRequest() = default;
};
class DeleteDeployGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> data{};
  shared_ptr<long> code{};

  DeleteDeployGroupResponseBody() {}

  explicit DeleteDeployGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DeleteDeployGroupResponseBody() = default;
};
class DeleteDeployGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDeployGroupResponseBody> body{};

  DeleteDeployGroupResponse() {}

  explicit DeleteDeployGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDeployGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDeployGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDeployGroupResponse() = default;
};
class DeleteEcuRequest : public Darabonba::Model {
public:
  shared_ptr<string> ecuId{};

  DeleteEcuRequest() {}

  explicit DeleteEcuRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecuId) {
      res["EcuId"] = boost::any(*ecuId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcuId") != m.end() && !m["EcuId"].empty()) {
      ecuId = make_shared<string>(boost::any_cast<string>(m["EcuId"]));
    }
  }


  virtual ~DeleteEcuRequest() = default;
};
class DeleteEcuResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> data{};
  shared_ptr<long> code{};

  DeleteEcuResponseBody() {}

  explicit DeleteEcuResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DeleteEcuResponseBody() = default;
};
class DeleteEcuResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteEcuResponseBody> body{};

  DeleteEcuResponse() {}

  explicit DeleteEcuResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEcuResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEcuResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEcuResponse() = default;
};
class DeleteFlowControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> ruleId{};

  DeleteFlowControlRequest() {}

  explicit DeleteFlowControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~DeleteFlowControlRequest() = default;
};
class DeleteFlowControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  DeleteFlowControlResponseBody() {}

  explicit DeleteFlowControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DeleteFlowControlResponseBody() = default;
};
class DeleteFlowControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteFlowControlResponseBody> body{};

  DeleteFlowControlResponse() {}

  explicit DeleteFlowControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFlowControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFlowControlResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFlowControlResponse() = default;
};
class DeleteK8sApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  DeleteK8sApplicationRequest() {}

  explicit DeleteK8sApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~DeleteK8sApplicationRequest() = default;
};
class DeleteK8sApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  DeleteK8sApplicationResponseBody() {}

  explicit DeleteK8sApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DeleteK8sApplicationResponseBody() = default;
};
class DeleteK8sApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteK8sApplicationResponseBody> body{};

  DeleteK8sApplicationResponse() {}

  explicit DeleteK8sApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteK8sApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteK8sApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteK8sApplicationResponse() = default;
};
class DeleteK8sIngressRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> name{};

  DeleteK8sIngressRuleRequest() {}

  explicit DeleteK8sIngressRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DeleteK8sIngressRuleRequest() = default;
};
class DeleteK8sIngressRuleResponseBodyChangeOrderIds : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<string> appId{};

  DeleteK8sIngressRuleResponseBodyChangeOrderIds() {}

  explicit DeleteK8sIngressRuleResponseBodyChangeOrderIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~DeleteK8sIngressRuleResponseBodyChangeOrderIds() = default;
};
class DeleteK8sIngressRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<vector<DeleteK8sIngressRuleResponseBodyChangeOrderIds>> changeOrderIds{};
  shared_ptr<long> code{};

  DeleteK8sIngressRuleResponseBody() {}

  explicit DeleteK8sIngressRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (changeOrderIds) {
      vector<boost::any> temp1;
      for(auto item1:*changeOrderIds){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChangeOrderIds"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ChangeOrderIds") != m.end() && !m["ChangeOrderIds"].empty()) {
      if (typeid(vector<boost::any>) == m["ChangeOrderIds"].type()) {
        vector<DeleteK8sIngressRuleResponseBodyChangeOrderIds> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChangeOrderIds"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteK8sIngressRuleResponseBodyChangeOrderIds model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        changeOrderIds = make_shared<vector<DeleteK8sIngressRuleResponseBodyChangeOrderIds>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DeleteK8sIngressRuleResponseBody() = default;
};
class DeleteK8sIngressRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteK8sIngressRuleResponseBody> body{};

  DeleteK8sIngressRuleResponse() {}

  explicit DeleteK8sIngressRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteK8sIngressRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteK8sIngressRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteK8sIngressRuleResponse() = default;
};
class DeleteK8sServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> name{};

  DeleteK8sServiceRequest() {}

  explicit DeleteK8sServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DeleteK8sServiceRequest() = default;
};
class DeleteK8sServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  DeleteK8sServiceResponseBody() {}

  explicit DeleteK8sServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DeleteK8sServiceResponseBody() = default;
};
class DeleteK8sServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteK8sServiceResponseBody> body{};

  DeleteK8sServiceResponse() {}

  explicit DeleteK8sServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteK8sServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteK8sServiceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteK8sServiceResponse() = default;
};
class DeleteLogPathRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> path{};

  DeleteLogPathRequest() {}

  explicit DeleteLogPathRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~DeleteLogPathRequest() = default;
};
class DeleteLogPathResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};

  DeleteLogPathResponseBody() {}

  explicit DeleteLogPathResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~DeleteLogPathResponseBody() = default;
};
class DeleteLogPathResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteLogPathResponseBody> body{};

  DeleteLogPathResponse() {}

  explicit DeleteLogPathResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLogPathResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLogPathResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLogPathResponse() = default;
};
class DeleteRoleRequest : public Darabonba::Model {
public:
  shared_ptr<long> roleId{};

  DeleteRoleRequest() {}

  explicit DeleteRoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<long>(boost::any_cast<long>(m["RoleId"]));
    }
  }


  virtual ~DeleteRoleRequest() = default;
};
class DeleteRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  DeleteRoleResponseBody() {}

  explicit DeleteRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DeleteRoleResponseBody() = default;
};
class DeleteRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteRoleResponseBody> body{};

  DeleteRoleResponse() {}

  explicit DeleteRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRoleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRoleResponse() = default;
};
class DeleteServiceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};

  DeleteServiceGroupRequest() {}

  explicit DeleteServiceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~DeleteServiceGroupRequest() = default;
};
class DeleteServiceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  DeleteServiceGroupResponseBody() {}

  explicit DeleteServiceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DeleteServiceGroupResponseBody() = default;
};
class DeleteServiceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteServiceGroupResponseBody> body{};

  DeleteServiceGroupResponse() {}

  explicit DeleteServiceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteServiceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteServiceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteServiceGroupResponse() = default;
};
class DeleteServiceTimeConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  DeleteServiceTimeConfigRequest() {}

  explicit DeleteServiceTimeConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DeleteServiceTimeConfigRequest() = default;
};
class DeleteServiceTimeConfigResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> timeout{};
  shared_ptr<string> consumerAppName{};
  shared_ptr<string> path{};
  shared_ptr<string> consumerAppId{};
  shared_ptr<long> id{};

  DeleteServiceTimeConfigResponseBodyData() {}

  explicit DeleteServiceTimeConfigResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (consumerAppName) {
      res["ConsumerAppName"] = boost::any(*consumerAppName);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (consumerAppId) {
      res["ConsumerAppId"] = boost::any(*consumerAppId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<string>(boost::any_cast<string>(m["Timeout"]));
    }
    if (m.find("ConsumerAppName") != m.end() && !m["ConsumerAppName"].empty()) {
      consumerAppName = make_shared<string>(boost::any_cast<string>(m["ConsumerAppName"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ConsumerAppId") != m.end() && !m["ConsumerAppId"].empty()) {
      consumerAppId = make_shared<string>(boost::any_cast<string>(m["ConsumerAppId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteServiceTimeConfigResponseBodyData() = default;
};
class DeleteServiceTimeConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<DeleteServiceTimeConfigResponseBodyData> data{};
  shared_ptr<long> code{};
  shared_ptr<bool> success{};

  DeleteServiceTimeConfigResponseBody() {}

  explicit DeleteServiceTimeConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeleteServiceTimeConfigResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeleteServiceTimeConfigResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteServiceTimeConfigResponseBody() = default;
};
class DeleteServiceTimeConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteServiceTimeConfigResponseBody> body{};

  DeleteServiceTimeConfigResponse() {}

  explicit DeleteServiceTimeConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteServiceTimeConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteServiceTimeConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteServiceTimeConfigResponse() = default;
};
class DeleteSwimmingLaneRequest : public Darabonba::Model {
public:
  shared_ptr<long> laneId{};

  DeleteSwimmingLaneRequest() {}

  explicit DeleteSwimmingLaneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (laneId) {
      res["LaneId"] = boost::any(*laneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LaneId") != m.end() && !m["LaneId"].empty()) {
      laneId = make_shared<long>(boost::any_cast<long>(m["LaneId"]));
    }
  }


  virtual ~DeleteSwimmingLaneRequest() = default;
};
class DeleteSwimmingLaneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> data{};
  shared_ptr<long> code{};

  DeleteSwimmingLaneResponseBody() {}

  explicit DeleteSwimmingLaneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DeleteSwimmingLaneResponseBody() = default;
};
class DeleteSwimmingLaneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteSwimmingLaneResponseBody> body{};

  DeleteSwimmingLaneResponse() {}

  explicit DeleteSwimmingLaneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSwimmingLaneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSwimmingLaneResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSwimmingLaneResponse() = default;
};
class DeleteSwimmingLaneGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};

  DeleteSwimmingLaneGroupRequest() {}

  explicit DeleteSwimmingLaneGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
  }


  virtual ~DeleteSwimmingLaneGroupRequest() = default;
};
class DeleteSwimmingLaneGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> data{};
  shared_ptr<long> code{};

  DeleteSwimmingLaneGroupResponseBody() {}

  explicit DeleteSwimmingLaneGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DeleteSwimmingLaneGroupResponseBody() = default;
};
class DeleteSwimmingLaneGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteSwimmingLaneGroupResponseBody> body{};

  DeleteSwimmingLaneGroupResponse() {}

  explicit DeleteSwimmingLaneGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSwimmingLaneGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSwimmingLaneGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSwimmingLaneGroupResponse() = default;
};
class DeleteUserDefineRegionRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> regionTag{};

  DeleteUserDefineRegionRequest() {}

  explicit DeleteUserDefineRegionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionTag) {
      res["RegionTag"] = boost::any(*regionTag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RegionTag") != m.end() && !m["RegionTag"].empty()) {
      regionTag = make_shared<string>(boost::any_cast<string>(m["RegionTag"]));
    }
  }


  virtual ~DeleteUserDefineRegionRequest() = default;
};
class DeleteUserDefineRegionResponseBodyRegionDefine : public Darabonba::Model {
public:
  shared_ptr<string> belongRegion{};
  shared_ptr<string> regionName{};
  shared_ptr<string> description{};
  shared_ptr<string> userId{};
  shared_ptr<long> id{};
  shared_ptr<string> regionId{};

  DeleteUserDefineRegionResponseBodyRegionDefine() {}

  explicit DeleteUserDefineRegionResponseBodyRegionDefine(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (belongRegion) {
      res["BelongRegion"] = boost::any(*belongRegion);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BelongRegion") != m.end() && !m["BelongRegion"].empty()) {
      belongRegion = make_shared<string>(boost::any_cast<string>(m["BelongRegion"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteUserDefineRegionResponseBodyRegionDefine() = default;
};
class DeleteUserDefineRegionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DeleteUserDefineRegionResponseBodyRegionDefine> regionDefine{};
  shared_ptr<long> code{};

  DeleteUserDefineRegionResponseBody() {}

  explicit DeleteUserDefineRegionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (regionDefine) {
      res["RegionDefine"] = regionDefine ? boost::any(regionDefine->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RegionDefine") != m.end() && !m["RegionDefine"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegionDefine"].type()) {
        DeleteUserDefineRegionResponseBodyRegionDefine model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegionDefine"]));
        regionDefine = make_shared<DeleteUserDefineRegionResponseBodyRegionDefine>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DeleteUserDefineRegionResponseBody() = default;
};
class DeleteUserDefineRegionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteUserDefineRegionResponseBody> body{};

  DeleteUserDefineRegionResponse() {}

  explicit DeleteUserDefineRegionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteUserDefineRegionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteUserDefineRegionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteUserDefineRegionResponse() = default;
};
class DeployApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> packageVersion{};
  shared_ptr<string> desc{};
  shared_ptr<string> deployType{};
  shared_ptr<string> warUrl{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> groupId{};
  shared_ptr<long> batch{};
  shared_ptr<long> batchWaitTime{};
  shared_ptr<string> appEnv{};
  shared_ptr<long> buildPackId{};
  shared_ptr<string> componentIds{};
  shared_ptr<long> releaseType{};
  shared_ptr<bool> gray{};
  shared_ptr<string> trafficControlStrategy{};

  DeployApplicationRequest() {}

  explicit DeployApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (deployType) {
      res["DeployType"] = boost::any(*deployType);
    }
    if (warUrl) {
      res["WarUrl"] = boost::any(*warUrl);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (batch) {
      res["Batch"] = boost::any(*batch);
    }
    if (batchWaitTime) {
      res["BatchWaitTime"] = boost::any(*batchWaitTime);
    }
    if (appEnv) {
      res["AppEnv"] = boost::any(*appEnv);
    }
    if (buildPackId) {
      res["BuildPackId"] = boost::any(*buildPackId);
    }
    if (componentIds) {
      res["ComponentIds"] = boost::any(*componentIds);
    }
    if (releaseType) {
      res["ReleaseType"] = boost::any(*releaseType);
    }
    if (gray) {
      res["Gray"] = boost::any(*gray);
    }
    if (trafficControlStrategy) {
      res["TrafficControlStrategy"] = boost::any(*trafficControlStrategy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("DeployType") != m.end() && !m["DeployType"].empty()) {
      deployType = make_shared<string>(boost::any_cast<string>(m["DeployType"]));
    }
    if (m.find("WarUrl") != m.end() && !m["WarUrl"].empty()) {
      warUrl = make_shared<string>(boost::any_cast<string>(m["WarUrl"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Batch") != m.end() && !m["Batch"].empty()) {
      batch = make_shared<long>(boost::any_cast<long>(m["Batch"]));
    }
    if (m.find("BatchWaitTime") != m.end() && !m["BatchWaitTime"].empty()) {
      batchWaitTime = make_shared<long>(boost::any_cast<long>(m["BatchWaitTime"]));
    }
    if (m.find("AppEnv") != m.end() && !m["AppEnv"].empty()) {
      appEnv = make_shared<string>(boost::any_cast<string>(m["AppEnv"]));
    }
    if (m.find("BuildPackId") != m.end() && !m["BuildPackId"].empty()) {
      buildPackId = make_shared<long>(boost::any_cast<long>(m["BuildPackId"]));
    }
    if (m.find("ComponentIds") != m.end() && !m["ComponentIds"].empty()) {
      componentIds = make_shared<string>(boost::any_cast<string>(m["ComponentIds"]));
    }
    if (m.find("ReleaseType") != m.end() && !m["ReleaseType"].empty()) {
      releaseType = make_shared<long>(boost::any_cast<long>(m["ReleaseType"]));
    }
    if (m.find("Gray") != m.end() && !m["Gray"].empty()) {
      gray = make_shared<bool>(boost::any_cast<bool>(m["Gray"]));
    }
    if (m.find("TrafficControlStrategy") != m.end() && !m["TrafficControlStrategy"].empty()) {
      trafficControlStrategy = make_shared<string>(boost::any_cast<string>(m["TrafficControlStrategy"]));
    }
  }


  virtual ~DeployApplicationRequest() = default;
};
class DeployApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  DeployApplicationResponseBody() {}

  explicit DeployApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DeployApplicationResponseBody() = default;
};
class DeployApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeployApplicationResponseBody> body{};

  DeployApplicationResponse() {}

  explicit DeployApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeployApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeployApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~DeployApplicationResponse() = default;
};
class DeployK8sApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> preStop{};
  shared_ptr<string> envs{};
  shared_ptr<string> imageTag{};
  shared_ptr<long> batchWaitTime{};
  shared_ptr<string> command{};
  shared_ptr<string> appId{};
  shared_ptr<string> postStart{};
  shared_ptr<string> readiness{};
  shared_ptr<string> liveness{};
  shared_ptr<string> args{};
  shared_ptr<long> replicas{};
  shared_ptr<string> image{};
  shared_ptr<long> cpuLimit{};
  shared_ptr<long> memoryLimit{};
  shared_ptr<long> cpuRequest{};
  shared_ptr<long> memoryRequest{};
  shared_ptr<string> nasId{};
  shared_ptr<string> mountDescs{};
  shared_ptr<string> storageType{};
  shared_ptr<string> localVolume{};
  shared_ptr<string> packageUrl{};
  shared_ptr<string> packageVersion{};
  shared_ptr<string> JDK{};
  shared_ptr<string> webContainer{};
  shared_ptr<string> edasContainerVersion{};
  shared_ptr<string> uriEncoding{};
  shared_ptr<bool> useBodyEncoding{};
  shared_ptr<string> updateStrategy{};
  shared_ptr<long> mcpuRequest{};
  shared_ptr<long> mcpuLimit{};
  shared_ptr<string> volumesStr{};
  shared_ptr<string> packageVersionId{};
  shared_ptr<string> changeOrderDesc{};
  shared_ptr<string> runtimeClassName{};
  shared_ptr<string> deployAcrossZones{};
  shared_ptr<long> batchTimeout{};
  shared_ptr<bool> enableAhas{};
  shared_ptr<string> webContainerConfig{};
  shared_ptr<string> javaStartUpConfig{};
  shared_ptr<string> slsConfigs{};
  shared_ptr<string> deployAcrossNodes{};
  shared_ptr<string> trafficControlStrategy{};

  DeployK8sApplicationRequest() {}

  explicit DeployK8sApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preStop) {
      res["PreStop"] = boost::any(*preStop);
    }
    if (envs) {
      res["Envs"] = boost::any(*envs);
    }
    if (imageTag) {
      res["ImageTag"] = boost::any(*imageTag);
    }
    if (batchWaitTime) {
      res["BatchWaitTime"] = boost::any(*batchWaitTime);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (postStart) {
      res["PostStart"] = boost::any(*postStart);
    }
    if (readiness) {
      res["Readiness"] = boost::any(*readiness);
    }
    if (liveness) {
      res["Liveness"] = boost::any(*liveness);
    }
    if (args) {
      res["Args"] = boost::any(*args);
    }
    if (replicas) {
      res["Replicas"] = boost::any(*replicas);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (cpuLimit) {
      res["CpuLimit"] = boost::any(*cpuLimit);
    }
    if (memoryLimit) {
      res["MemoryLimit"] = boost::any(*memoryLimit);
    }
    if (cpuRequest) {
      res["CpuRequest"] = boost::any(*cpuRequest);
    }
    if (memoryRequest) {
      res["MemoryRequest"] = boost::any(*memoryRequest);
    }
    if (nasId) {
      res["NasId"] = boost::any(*nasId);
    }
    if (mountDescs) {
      res["MountDescs"] = boost::any(*mountDescs);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    if (localVolume) {
      res["LocalVolume"] = boost::any(*localVolume);
    }
    if (packageUrl) {
      res["PackageUrl"] = boost::any(*packageUrl);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    if (JDK) {
      res["JDK"] = boost::any(*JDK);
    }
    if (webContainer) {
      res["WebContainer"] = boost::any(*webContainer);
    }
    if (edasContainerVersion) {
      res["EdasContainerVersion"] = boost::any(*edasContainerVersion);
    }
    if (uriEncoding) {
      res["UriEncoding"] = boost::any(*uriEncoding);
    }
    if (useBodyEncoding) {
      res["UseBodyEncoding"] = boost::any(*useBodyEncoding);
    }
    if (updateStrategy) {
      res["UpdateStrategy"] = boost::any(*updateStrategy);
    }
    if (mcpuRequest) {
      res["McpuRequest"] = boost::any(*mcpuRequest);
    }
    if (mcpuLimit) {
      res["McpuLimit"] = boost::any(*mcpuLimit);
    }
    if (volumesStr) {
      res["VolumesStr"] = boost::any(*volumesStr);
    }
    if (packageVersionId) {
      res["PackageVersionId"] = boost::any(*packageVersionId);
    }
    if (changeOrderDesc) {
      res["ChangeOrderDesc"] = boost::any(*changeOrderDesc);
    }
    if (runtimeClassName) {
      res["RuntimeClassName"] = boost::any(*runtimeClassName);
    }
    if (deployAcrossZones) {
      res["DeployAcrossZones"] = boost::any(*deployAcrossZones);
    }
    if (batchTimeout) {
      res["BatchTimeout"] = boost::any(*batchTimeout);
    }
    if (enableAhas) {
      res["EnableAhas"] = boost::any(*enableAhas);
    }
    if (webContainerConfig) {
      res["WebContainerConfig"] = boost::any(*webContainerConfig);
    }
    if (javaStartUpConfig) {
      res["JavaStartUpConfig"] = boost::any(*javaStartUpConfig);
    }
    if (slsConfigs) {
      res["SlsConfigs"] = boost::any(*slsConfigs);
    }
    if (deployAcrossNodes) {
      res["DeployAcrossNodes"] = boost::any(*deployAcrossNodes);
    }
    if (trafficControlStrategy) {
      res["TrafficControlStrategy"] = boost::any(*trafficControlStrategy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreStop") != m.end() && !m["PreStop"].empty()) {
      preStop = make_shared<string>(boost::any_cast<string>(m["PreStop"]));
    }
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      envs = make_shared<string>(boost::any_cast<string>(m["Envs"]));
    }
    if (m.find("ImageTag") != m.end() && !m["ImageTag"].empty()) {
      imageTag = make_shared<string>(boost::any_cast<string>(m["ImageTag"]));
    }
    if (m.find("BatchWaitTime") != m.end() && !m["BatchWaitTime"].empty()) {
      batchWaitTime = make_shared<long>(boost::any_cast<long>(m["BatchWaitTime"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("PostStart") != m.end() && !m["PostStart"].empty()) {
      postStart = make_shared<string>(boost::any_cast<string>(m["PostStart"]));
    }
    if (m.find("Readiness") != m.end() && !m["Readiness"].empty()) {
      readiness = make_shared<string>(boost::any_cast<string>(m["Readiness"]));
    }
    if (m.find("Liveness") != m.end() && !m["Liveness"].empty()) {
      liveness = make_shared<string>(boost::any_cast<string>(m["Liveness"]));
    }
    if (m.find("Args") != m.end() && !m["Args"].empty()) {
      args = make_shared<string>(boost::any_cast<string>(m["Args"]));
    }
    if (m.find("Replicas") != m.end() && !m["Replicas"].empty()) {
      replicas = make_shared<long>(boost::any_cast<long>(m["Replicas"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("CpuLimit") != m.end() && !m["CpuLimit"].empty()) {
      cpuLimit = make_shared<long>(boost::any_cast<long>(m["CpuLimit"]));
    }
    if (m.find("MemoryLimit") != m.end() && !m["MemoryLimit"].empty()) {
      memoryLimit = make_shared<long>(boost::any_cast<long>(m["MemoryLimit"]));
    }
    if (m.find("CpuRequest") != m.end() && !m["CpuRequest"].empty()) {
      cpuRequest = make_shared<long>(boost::any_cast<long>(m["CpuRequest"]));
    }
    if (m.find("MemoryRequest") != m.end() && !m["MemoryRequest"].empty()) {
      memoryRequest = make_shared<long>(boost::any_cast<long>(m["MemoryRequest"]));
    }
    if (m.find("NasId") != m.end() && !m["NasId"].empty()) {
      nasId = make_shared<string>(boost::any_cast<string>(m["NasId"]));
    }
    if (m.find("MountDescs") != m.end() && !m["MountDescs"].empty()) {
      mountDescs = make_shared<string>(boost::any_cast<string>(m["MountDescs"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
    if (m.find("LocalVolume") != m.end() && !m["LocalVolume"].empty()) {
      localVolume = make_shared<string>(boost::any_cast<string>(m["LocalVolume"]));
    }
    if (m.find("PackageUrl") != m.end() && !m["PackageUrl"].empty()) {
      packageUrl = make_shared<string>(boost::any_cast<string>(m["PackageUrl"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
    if (m.find("JDK") != m.end() && !m["JDK"].empty()) {
      JDK = make_shared<string>(boost::any_cast<string>(m["JDK"]));
    }
    if (m.find("WebContainer") != m.end() && !m["WebContainer"].empty()) {
      webContainer = make_shared<string>(boost::any_cast<string>(m["WebContainer"]));
    }
    if (m.find("EdasContainerVersion") != m.end() && !m["EdasContainerVersion"].empty()) {
      edasContainerVersion = make_shared<string>(boost::any_cast<string>(m["EdasContainerVersion"]));
    }
    if (m.find("UriEncoding") != m.end() && !m["UriEncoding"].empty()) {
      uriEncoding = make_shared<string>(boost::any_cast<string>(m["UriEncoding"]));
    }
    if (m.find("UseBodyEncoding") != m.end() && !m["UseBodyEncoding"].empty()) {
      useBodyEncoding = make_shared<bool>(boost::any_cast<bool>(m["UseBodyEncoding"]));
    }
    if (m.find("UpdateStrategy") != m.end() && !m["UpdateStrategy"].empty()) {
      updateStrategy = make_shared<string>(boost::any_cast<string>(m["UpdateStrategy"]));
    }
    if (m.find("McpuRequest") != m.end() && !m["McpuRequest"].empty()) {
      mcpuRequest = make_shared<long>(boost::any_cast<long>(m["McpuRequest"]));
    }
    if (m.find("McpuLimit") != m.end() && !m["McpuLimit"].empty()) {
      mcpuLimit = make_shared<long>(boost::any_cast<long>(m["McpuLimit"]));
    }
    if (m.find("VolumesStr") != m.end() && !m["VolumesStr"].empty()) {
      volumesStr = make_shared<string>(boost::any_cast<string>(m["VolumesStr"]));
    }
    if (m.find("PackageVersionId") != m.end() && !m["PackageVersionId"].empty()) {
      packageVersionId = make_shared<string>(boost::any_cast<string>(m["PackageVersionId"]));
    }
    if (m.find("ChangeOrderDesc") != m.end() && !m["ChangeOrderDesc"].empty()) {
      changeOrderDesc = make_shared<string>(boost::any_cast<string>(m["ChangeOrderDesc"]));
    }
    if (m.find("RuntimeClassName") != m.end() && !m["RuntimeClassName"].empty()) {
      runtimeClassName = make_shared<string>(boost::any_cast<string>(m["RuntimeClassName"]));
    }
    if (m.find("DeployAcrossZones") != m.end() && !m["DeployAcrossZones"].empty()) {
      deployAcrossZones = make_shared<string>(boost::any_cast<string>(m["DeployAcrossZones"]));
    }
    if (m.find("BatchTimeout") != m.end() && !m["BatchTimeout"].empty()) {
      batchTimeout = make_shared<long>(boost::any_cast<long>(m["BatchTimeout"]));
    }
    if (m.find("EnableAhas") != m.end() && !m["EnableAhas"].empty()) {
      enableAhas = make_shared<bool>(boost::any_cast<bool>(m["EnableAhas"]));
    }
    if (m.find("WebContainerConfig") != m.end() && !m["WebContainerConfig"].empty()) {
      webContainerConfig = make_shared<string>(boost::any_cast<string>(m["WebContainerConfig"]));
    }
    if (m.find("JavaStartUpConfig") != m.end() && !m["JavaStartUpConfig"].empty()) {
      javaStartUpConfig = make_shared<string>(boost::any_cast<string>(m["JavaStartUpConfig"]));
    }
    if (m.find("SlsConfigs") != m.end() && !m["SlsConfigs"].empty()) {
      slsConfigs = make_shared<string>(boost::any_cast<string>(m["SlsConfigs"]));
    }
    if (m.find("DeployAcrossNodes") != m.end() && !m["DeployAcrossNodes"].empty()) {
      deployAcrossNodes = make_shared<string>(boost::any_cast<string>(m["DeployAcrossNodes"]));
    }
    if (m.find("TrafficControlStrategy") != m.end() && !m["TrafficControlStrategy"].empty()) {
      trafficControlStrategy = make_shared<string>(boost::any_cast<string>(m["TrafficControlStrategy"]));
    }
  }


  virtual ~DeployK8sApplicationRequest() = default;
};
class DeployK8sApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  DeployK8sApplicationResponseBody() {}

  explicit DeployK8sApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DeployK8sApplicationResponseBody() = default;
};
class DeployK8sApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeployK8sApplicationResponseBody> body{};

  DeployK8sApplicationResponse() {}

  explicit DeployK8sApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeployK8sApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeployK8sApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~DeployK8sApplicationResponse() = default;
};
class DisableDegradeControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> ruleId{};

  DisableDegradeControlRequest() {}

  explicit DisableDegradeControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~DisableDegradeControlRequest() = default;
};
class DisableDegradeControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  DisableDegradeControlResponseBody() {}

  explicit DisableDegradeControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DisableDegradeControlResponseBody() = default;
};
class DisableDegradeControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DisableDegradeControlResponseBody> body{};

  DisableDegradeControlResponse() {}

  explicit DisableDegradeControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableDegradeControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableDegradeControlResponseBody>(model1);
      }
    }
  }


  virtual ~DisableDegradeControlResponse() = default;
};
class DisableFlowControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> ruleId{};

  DisableFlowControlRequest() {}

  explicit DisableFlowControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~DisableFlowControlRequest() = default;
};
class DisableFlowControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  DisableFlowControlResponseBody() {}

  explicit DisableFlowControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DisableFlowControlResponseBody() = default;
};
class DisableFlowControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DisableFlowControlResponseBody> body{};

  DisableFlowControlResponse() {}

  explicit DisableFlowControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableFlowControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableFlowControlResponseBody>(model1);
      }
    }
  }


  virtual ~DisableFlowControlResponse() = default;
};
class DisableMockRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DisableMockRuleRequest() {}

  explicit DisableMockRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DisableMockRuleRequest() = default;
};
class DisableMockRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<string> scMockItemJson{};
  shared_ptr<string> consumerAppName{};
  shared_ptr<string> consumerAppId{};
  shared_ptr<string> accountId{};
  shared_ptr<string> extraJson{};
  shared_ptr<string> source{};
  shared_ptr<string> region{};
  shared_ptr<string> providerAppId{};
  shared_ptr<string> providerAppName{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};
  shared_ptr<bool> enable{};

  DisableMockRuleResponseBodyData() {}

  explicit DisableMockRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (scMockItemJson) {
      res["ScMockItemJson"] = boost::any(*scMockItemJson);
    }
    if (consumerAppName) {
      res["ConsumerAppName"] = boost::any(*consumerAppName);
    }
    if (consumerAppId) {
      res["ConsumerAppId"] = boost::any(*consumerAppId);
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (extraJson) {
      res["ExtraJson"] = boost::any(*extraJson);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (providerAppId) {
      res["ProviderAppId"] = boost::any(*providerAppId);
    }
    if (providerAppName) {
      res["ProviderAppName"] = boost::any(*providerAppName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("ScMockItemJson") != m.end() && !m["ScMockItemJson"].empty()) {
      scMockItemJson = make_shared<string>(boost::any_cast<string>(m["ScMockItemJson"]));
    }
    if (m.find("ConsumerAppName") != m.end() && !m["ConsumerAppName"].empty()) {
      consumerAppName = make_shared<string>(boost::any_cast<string>(m["ConsumerAppName"]));
    }
    if (m.find("ConsumerAppId") != m.end() && !m["ConsumerAppId"].empty()) {
      consumerAppId = make_shared<string>(boost::any_cast<string>(m["ConsumerAppId"]));
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ExtraJson") != m.end() && !m["ExtraJson"].empty()) {
      extraJson = make_shared<string>(boost::any_cast<string>(m["ExtraJson"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ProviderAppId") != m.end() && !m["ProviderAppId"].empty()) {
      providerAppId = make_shared<string>(boost::any_cast<string>(m["ProviderAppId"]));
    }
    if (m.find("ProviderAppName") != m.end() && !m["ProviderAppName"].empty()) {
      providerAppName = make_shared<string>(boost::any_cast<string>(m["ProviderAppName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
  }


  virtual ~DisableMockRuleResponseBodyData() = default;
};
class DisableMockRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DisableMockRuleResponseBodyData> data{};
  shared_ptr<long> code{};
  shared_ptr<bool> success{};

  DisableMockRuleResponseBody() {}

  explicit DisableMockRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DisableMockRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DisableMockRuleResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DisableMockRuleResponseBody() = default;
};
class DisableMockRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DisableMockRuleResponseBody> body{};

  DisableMockRuleResponse() {}

  explicit DisableMockRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableMockRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableMockRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DisableMockRuleResponse() = default;
};
class EnableDegradeControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> ruleId{};

  EnableDegradeControlRequest() {}

  explicit EnableDegradeControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~EnableDegradeControlRequest() = default;
};
class EnableDegradeControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  EnableDegradeControlResponseBody() {}

  explicit EnableDegradeControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~EnableDegradeControlResponseBody() = default;
};
class EnableDegradeControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<EnableDegradeControlResponseBody> body{};

  EnableDegradeControlResponse() {}

  explicit EnableDegradeControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableDegradeControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableDegradeControlResponseBody>(model1);
      }
    }
  }


  virtual ~EnableDegradeControlResponse() = default;
};
class EnableFlowControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> ruleId{};

  EnableFlowControlRequest() {}

  explicit EnableFlowControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~EnableFlowControlRequest() = default;
};
class EnableFlowControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  EnableFlowControlResponseBody() {}

  explicit EnableFlowControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~EnableFlowControlResponseBody() = default;
};
class EnableFlowControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<EnableFlowControlResponseBody> body{};

  EnableFlowControlResponse() {}

  explicit EnableFlowControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableFlowControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableFlowControlResponseBody>(model1);
      }
    }
  }


  virtual ~EnableFlowControlResponse() = default;
};
class EnableMockRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  EnableMockRuleRequest() {}

  explicit EnableMockRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~EnableMockRuleRequest() = default;
};
class EnableMockRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<string> scMockItemJson{};
  shared_ptr<string> consumerAppName{};
  shared_ptr<string> consumerAppId{};
  shared_ptr<string> accountId{};
  shared_ptr<string> extraJson{};
  shared_ptr<string> source{};
  shared_ptr<string> region{};
  shared_ptr<string> providerAppId{};
  shared_ptr<string> providerAppName{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};
  shared_ptr<bool> enable{};

  EnableMockRuleResponseBodyData() {}

  explicit EnableMockRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (scMockItemJson) {
      res["ScMockItemJson"] = boost::any(*scMockItemJson);
    }
    if (consumerAppName) {
      res["ConsumerAppName"] = boost::any(*consumerAppName);
    }
    if (consumerAppId) {
      res["ConsumerAppId"] = boost::any(*consumerAppId);
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (extraJson) {
      res["ExtraJson"] = boost::any(*extraJson);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (providerAppId) {
      res["ProviderAppId"] = boost::any(*providerAppId);
    }
    if (providerAppName) {
      res["ProviderAppName"] = boost::any(*providerAppName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("ScMockItemJson") != m.end() && !m["ScMockItemJson"].empty()) {
      scMockItemJson = make_shared<string>(boost::any_cast<string>(m["ScMockItemJson"]));
    }
    if (m.find("ConsumerAppName") != m.end() && !m["ConsumerAppName"].empty()) {
      consumerAppName = make_shared<string>(boost::any_cast<string>(m["ConsumerAppName"]));
    }
    if (m.find("ConsumerAppId") != m.end() && !m["ConsumerAppId"].empty()) {
      consumerAppId = make_shared<string>(boost::any_cast<string>(m["ConsumerAppId"]));
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ExtraJson") != m.end() && !m["ExtraJson"].empty()) {
      extraJson = make_shared<string>(boost::any_cast<string>(m["ExtraJson"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ProviderAppId") != m.end() && !m["ProviderAppId"].empty()) {
      providerAppId = make_shared<string>(boost::any_cast<string>(m["ProviderAppId"]));
    }
    if (m.find("ProviderAppName") != m.end() && !m["ProviderAppName"].empty()) {
      providerAppName = make_shared<string>(boost::any_cast<string>(m["ProviderAppName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
  }


  virtual ~EnableMockRuleResponseBodyData() = default;
};
class EnableMockRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<EnableMockRuleResponseBodyData> data{};
  shared_ptr<long> code{};
  shared_ptr<bool> success{};

  EnableMockRuleResponseBody() {}

  explicit EnableMockRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        EnableMockRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<EnableMockRuleResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~EnableMockRuleResponseBody() = default;
};
class EnableMockRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<EnableMockRuleResponseBody> body{};

  EnableMockRuleResponse() {}

  explicit EnableMockRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableMockRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableMockRuleResponseBody>(model1);
      }
    }
  }


  virtual ~EnableMockRuleResponse() = default;
};
class ExecuteStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> region{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> source{};
  shared_ptr<string> accountId{};
  shared_ptr<string> appId{};
  shared_ptr<string> ip{};
  shared_ptr<string> podName{};
  shared_ptr<string> status{};

  ExecuteStatusRequest() {}

  explicit ExecuteStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (podName) {
      res["PodName"] = boost::any(*podName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("PodName") != m.end() && !m["PodName"].empty()) {
      podName = make_shared<string>(boost::any_cast<string>(m["PodName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ExecuteStatusRequest() = default;
};
class ExecuteStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> podName{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> appId{};
  shared_ptr<string> region{};
  shared_ptr<string> ip{};
  shared_ptr<string> accountId{};
  shared_ptr<string> source{};
  shared_ptr<long> id{};
  shared_ptr<string> tenantId{};

  ExecuteStatusResponseBodyData() {}

  explicit ExecuteStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (podName) {
      res["PodName"] = boost::any(*podName);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PodName") != m.end() && !m["PodName"].empty()) {
      podName = make_shared<string>(boost::any_cast<string>(m["PodName"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~ExecuteStatusResponseBodyData() = default;
};
class ExecuteStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ExecuteStatusResponseBodyData> data{};
  shared_ptr<long> code{};
  shared_ptr<bool> success{};

  ExecuteStatusResponseBody() {}

  explicit ExecuteStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ExecuteStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ExecuteStatusResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ExecuteStatusResponseBody() = default;
};
class ExecuteStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ExecuteStatusResponseBody> body{};

  ExecuteStatusResponse() {}

  explicit ExecuteStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExecuteStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExecuteStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ExecuteStatusResponse() = default;
};
class GetAccountMockRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> region{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> name{};
  shared_ptr<string> consumerAppName{};
  shared_ptr<string> providerAppName{};
  shared_ptr<string> namespace_{};

  GetAccountMockRuleRequest() {}

  explicit GetAccountMockRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (consumerAppName) {
      res["ConsumerAppName"] = boost::any(*consumerAppName);
    }
    if (providerAppName) {
      res["ProviderAppName"] = boost::any(*providerAppName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ConsumerAppName") != m.end() && !m["ConsumerAppName"].empty()) {
      consumerAppName = make_shared<string>(boost::any_cast<string>(m["ConsumerAppName"]));
    }
    if (m.find("ProviderAppName") != m.end() && !m["ProviderAppName"].empty()) {
      providerAppName = make_shared<string>(boost::any_cast<string>(m["ProviderAppName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~GetAccountMockRuleRequest() = default;
};
class GetAccountMockRuleResponseBodyDataResultDubboMockItems : public Darabonba::Model {
public:
  shared_ptr<string> methodName{};
  shared_ptr<vector<string>> paramTypes{};
  shared_ptr<string> value{};
  shared_ptr<string> oper{};
  shared_ptr<string> executeCondition{};
  shared_ptr<string> version{};
  shared_ptr<string> exceptionClassName{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> group{};

  GetAccountMockRuleResponseBodyDataResultDubboMockItems() {}

  explicit GetAccountMockRuleResponseBodyDataResultDubboMockItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (paramTypes) {
      res["ParamTypes"] = boost::any(*paramTypes);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (oper) {
      res["Oper"] = boost::any(*oper);
    }
    if (executeCondition) {
      res["ExecuteCondition"] = boost::any(*executeCondition);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (exceptionClassName) {
      res["ExceptionClassName"] = boost::any(*exceptionClassName);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("ParamTypes") != m.end() && !m["ParamTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ParamTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ParamTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      paramTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Oper") != m.end() && !m["Oper"].empty()) {
      oper = make_shared<string>(boost::any_cast<string>(m["Oper"]));
    }
    if (m.find("ExecuteCondition") != m.end() && !m["ExecuteCondition"].empty()) {
      executeCondition = make_shared<string>(boost::any_cast<string>(m["ExecuteCondition"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("ExceptionClassName") != m.end() && !m["ExceptionClassName"].empty()) {
      exceptionClassName = make_shared<string>(boost::any_cast<string>(m["ExceptionClassName"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
  }


  virtual ~GetAccountMockRuleResponseBodyDataResultDubboMockItems() = default;
};
class GetAccountMockRuleResponseBodyDataResultScMockItems : public Darabonba::Model {
public:
  shared_ptr<string> value{};
  shared_ptr<string> oper{};
  shared_ptr<string> executeCondition{};
  shared_ptr<string> path{};
  shared_ptr<string> method{};
  shared_ptr<string> exceptionClassName{};
  shared_ptr<string> serviceName{};

  GetAccountMockRuleResponseBodyDataResultScMockItems() {}

  explicit GetAccountMockRuleResponseBodyDataResultScMockItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (oper) {
      res["Oper"] = boost::any(*oper);
    }
    if (executeCondition) {
      res["ExecuteCondition"] = boost::any(*executeCondition);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (exceptionClassName) {
      res["ExceptionClassName"] = boost::any(*exceptionClassName);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Oper") != m.end() && !m["Oper"].empty()) {
      oper = make_shared<string>(boost::any_cast<string>(m["Oper"]));
    }
    if (m.find("ExecuteCondition") != m.end() && !m["ExecuteCondition"].empty()) {
      executeCondition = make_shared<string>(boost::any_cast<string>(m["ExecuteCondition"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("ExceptionClassName") != m.end() && !m["ExceptionClassName"].empty()) {
      exceptionClassName = make_shared<string>(boost::any_cast<string>(m["ExceptionClassName"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~GetAccountMockRuleResponseBodyDataResultScMockItems() = default;
};
class GetAccountMockRuleResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetAccountMockRuleResponseBodyDataResultDubboMockItems>> dubboMockItems{};
  shared_ptr<long> status{};
  shared_ptr<string> consumerAppName{};
  shared_ptr<string> consumerAppId{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> region{};
  shared_ptr<vector<GetAccountMockRuleResponseBodyDataResultScMockItems>> scMockItems{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> providerAppId{};
  shared_ptr<string> providerAppName{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};
  shared_ptr<bool> enable{};

  GetAccountMockRuleResponseBodyDataResult() {}

  explicit GetAccountMockRuleResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dubboMockItems) {
      vector<boost::any> temp1;
      for(auto item1:*dubboMockItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DubboMockItems"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (consumerAppName) {
      res["ConsumerAppName"] = boost::any(*consumerAppName);
    }
    if (consumerAppId) {
      res["ConsumerAppId"] = boost::any(*consumerAppId);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (scMockItems) {
      vector<boost::any> temp1;
      for(auto item1:*scMockItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScMockItems"] = boost::any(temp1);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (providerAppId) {
      res["ProviderAppId"] = boost::any(*providerAppId);
    }
    if (providerAppName) {
      res["ProviderAppName"] = boost::any(*providerAppName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DubboMockItems") != m.end() && !m["DubboMockItems"].empty()) {
      if (typeid(vector<boost::any>) == m["DubboMockItems"].type()) {
        vector<GetAccountMockRuleResponseBodyDataResultDubboMockItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DubboMockItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAccountMockRuleResponseBodyDataResultDubboMockItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dubboMockItems = make_shared<vector<GetAccountMockRuleResponseBodyDataResultDubboMockItems>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("ConsumerAppName") != m.end() && !m["ConsumerAppName"].empty()) {
      consumerAppName = make_shared<string>(boost::any_cast<string>(m["ConsumerAppName"]));
    }
    if (m.find("ConsumerAppId") != m.end() && !m["ConsumerAppId"].empty()) {
      consumerAppId = make_shared<string>(boost::any_cast<string>(m["ConsumerAppId"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ScMockItems") != m.end() && !m["ScMockItems"].empty()) {
      if (typeid(vector<boost::any>) == m["ScMockItems"].type()) {
        vector<GetAccountMockRuleResponseBodyDataResultScMockItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScMockItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAccountMockRuleResponseBodyDataResultScMockItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scMockItems = make_shared<vector<GetAccountMockRuleResponseBodyDataResultScMockItems>>(expect1);
      }
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("ProviderAppId") != m.end() && !m["ProviderAppId"].empty()) {
      providerAppId = make_shared<string>(boost::any_cast<string>(m["ProviderAppId"]));
    }
    if (m.find("ProviderAppName") != m.end() && !m["ProviderAppName"].empty()) {
      providerAppName = make_shared<string>(boost::any_cast<string>(m["ProviderAppName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
  }


  virtual ~GetAccountMockRuleResponseBodyDataResult() = default;
};
class GetAccountMockRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetAccountMockRuleResponseBodyDataResult>> result{};
  shared_ptr<long> totalSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  GetAccountMockRuleResponseBodyData() {}

  explicit GetAccountMockRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<GetAccountMockRuleResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAccountMockRuleResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<GetAccountMockRuleResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~GetAccountMockRuleResponseBodyData() = default;
};
class GetAccountMockRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<GetAccountMockRuleResponseBodyData> data{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetAccountMockRuleResponseBody() {}

  explicit GetAccountMockRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAccountMockRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAccountMockRuleResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAccountMockRuleResponseBody() = default;
};
class GetAccountMockRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetAccountMockRuleResponseBody> body{};

  GetAccountMockRuleResponse() {}

  explicit GetAccountMockRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAccountMockRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAccountMockRuleResponseBody>(model1);
      }
    }
  }


  virtual ~GetAccountMockRuleResponse() = default;
};
class GetApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  GetApplicationRequest() {}

  explicit GetApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~GetApplicationRequest() = default;
};
class GetApplicationResponseBodyApplication : public Darabonba::Model {
public:
  shared_ptr<string> extSlbIp{};
  shared_ptr<string> owner{};
  shared_ptr<long> slbPort{};
  shared_ptr<string> nameSpace_{};
  shared_ptr<string> extSlbName{};
  shared_ptr<long> createTime{};
  shared_ptr<string> userId{};
  shared_ptr<long> port{};
  shared_ptr<long> runningInstanceCount{};
  shared_ptr<string> slbIp{};
  shared_ptr<bool> dockerize{};
  shared_ptr<long> instanceCount{};
  shared_ptr<string> description{};
  shared_ptr<string> appId{};
  shared_ptr<string> slbInfo{};
  shared_ptr<long> memory{};
  shared_ptr<string> name{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> healthCheckUrl{};
  shared_ptr<string> slbId{};
  shared_ptr<string> applicationType{};
  shared_ptr<string> extSlbId{};
  shared_ptr<long> buildPackageId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> email{};
  shared_ptr<long> cpu{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> slbName{};

  GetApplicationResponseBodyApplication() {}

  explicit GetApplicationResponseBodyApplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSlbIp) {
      res["ExtSlbIp"] = boost::any(*extSlbIp);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (slbPort) {
      res["SlbPort"] = boost::any(*slbPort);
    }
    if (nameSpace_) {
      res["NameSpace"] = boost::any(*nameSpace_);
    }
    if (extSlbName) {
      res["ExtSlbName"] = boost::any(*extSlbName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (runningInstanceCount) {
      res["RunningInstanceCount"] = boost::any(*runningInstanceCount);
    }
    if (slbIp) {
      res["SlbIp"] = boost::any(*slbIp);
    }
    if (dockerize) {
      res["Dockerize"] = boost::any(*dockerize);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (slbInfo) {
      res["SlbInfo"] = boost::any(*slbInfo);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (healthCheckUrl) {
      res["HealthCheckUrl"] = boost::any(*healthCheckUrl);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (applicationType) {
      res["ApplicationType"] = boost::any(*applicationType);
    }
    if (extSlbId) {
      res["ExtSlbId"] = boost::any(*extSlbId);
    }
    if (buildPackageId) {
      res["BuildPackageId"] = boost::any(*buildPackageId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (slbName) {
      res["SlbName"] = boost::any(*slbName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSlbIp") != m.end() && !m["ExtSlbIp"].empty()) {
      extSlbIp = make_shared<string>(boost::any_cast<string>(m["ExtSlbIp"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("SlbPort") != m.end() && !m["SlbPort"].empty()) {
      slbPort = make_shared<long>(boost::any_cast<long>(m["SlbPort"]));
    }
    if (m.find("NameSpace") != m.end() && !m["NameSpace"].empty()) {
      nameSpace_ = make_shared<string>(boost::any_cast<string>(m["NameSpace"]));
    }
    if (m.find("ExtSlbName") != m.end() && !m["ExtSlbName"].empty()) {
      extSlbName = make_shared<string>(boost::any_cast<string>(m["ExtSlbName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("RunningInstanceCount") != m.end() && !m["RunningInstanceCount"].empty()) {
      runningInstanceCount = make_shared<long>(boost::any_cast<long>(m["RunningInstanceCount"]));
    }
    if (m.find("SlbIp") != m.end() && !m["SlbIp"].empty()) {
      slbIp = make_shared<string>(boost::any_cast<string>(m["SlbIp"]));
    }
    if (m.find("Dockerize") != m.end() && !m["Dockerize"].empty()) {
      dockerize = make_shared<bool>(boost::any_cast<bool>(m["Dockerize"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("SlbInfo") != m.end() && !m["SlbInfo"].empty()) {
      slbInfo = make_shared<string>(boost::any_cast<string>(m["SlbInfo"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("HealthCheckUrl") != m.end() && !m["HealthCheckUrl"].empty()) {
      healthCheckUrl = make_shared<string>(boost::any_cast<string>(m["HealthCheckUrl"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("ApplicationType") != m.end() && !m["ApplicationType"].empty()) {
      applicationType = make_shared<string>(boost::any_cast<string>(m["ApplicationType"]));
    }
    if (m.find("ExtSlbId") != m.end() && !m["ExtSlbId"].empty()) {
      extSlbId = make_shared<string>(boost::any_cast<string>(m["ExtSlbId"]));
    }
    if (m.find("BuildPackageId") != m.end() && !m["BuildPackageId"].empty()) {
      buildPackageId = make_shared<long>(boost::any_cast<long>(m["BuildPackageId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("SlbName") != m.end() && !m["SlbName"].empty()) {
      slbName = make_shared<string>(boost::any_cast<string>(m["SlbName"]));
    }
  }


  virtual ~GetApplicationResponseBodyApplication() = default;
};
class GetApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};
  shared_ptr<GetApplicationResponseBodyApplication> application{};

  GetApplicationResponseBody() {}

  explicit GetApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (application) {
      res["Application"] = application ? boost::any(application->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Application") != m.end() && !m["Application"].empty()) {
      if (typeid(map<string, boost::any>) == m["Application"].type()) {
        GetApplicationResponseBodyApplication model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Application"]));
        application = make_shared<GetApplicationResponseBodyApplication>(model1);
      }
    }
  }


  virtual ~GetApplicationResponseBody() = default;
};
class GetApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetApplicationResponseBody> body{};

  GetApplicationResponse() {}

  explicit GetApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~GetApplicationResponse() = default;
};
class GetChangeOrderInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  GetChangeOrderInfoRequest() {}

  explicit GetChangeOrderInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~GetChangeOrderInfoRequest() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl : public Darabonba::Model {
public:
  shared_ptr<string> tips{};
  shared_ptr<string> routes{};
  shared_ptr<string> rules{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tips) {
      res["Tips"] = boost::any(*tips);
    }
    if (routes) {
      res["Routes"] = boost::any(*routes);
    }
    if (rules) {
      res["Rules"] = boost::any(*rules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tips") != m.end() && !m["Tips"].empty()) {
      tips = make_shared<string>(boost::any_cast<string>(m["Tips"]));
    }
    if (m.find("Routes") != m.end() && !m["Routes"].empty()) {
      routes = make_shared<string>(boost::any_cast<string>(m["Routes"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rules = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO : public Darabonba::Model {
public:
  shared_ptr<long> taskErrorIgnorance{};
  shared_ptr<bool> showManualIgnorance{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskMessage{};
  shared_ptr<string> taskErrorCode{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskErrorMessage{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskErrorIgnorance) {
      res["TaskErrorIgnorance"] = boost::any(*taskErrorIgnorance);
    }
    if (showManualIgnorance) {
      res["ShowManualIgnorance"] = boost::any(*showManualIgnorance);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskMessage) {
      res["TaskMessage"] = boost::any(*taskMessage);
    }
    if (taskErrorCode) {
      res["TaskErrorCode"] = boost::any(*taskErrorCode);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskErrorMessage) {
      res["TaskErrorMessage"] = boost::any(*taskErrorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskErrorIgnorance") != m.end() && !m["TaskErrorIgnorance"].empty()) {
      taskErrorIgnorance = make_shared<long>(boost::any_cast<long>(m["TaskErrorIgnorance"]));
    }
    if (m.find("ShowManualIgnorance") != m.end() && !m["ShowManualIgnorance"].empty()) {
      showManualIgnorance = make_shared<bool>(boost::any_cast<bool>(m["ShowManualIgnorance"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskMessage") != m.end() && !m["TaskMessage"].empty()) {
      taskMessage = make_shared<string>(boost::any_cast<string>(m["TaskMessage"]));
    }
    if (m.find("TaskErrorCode") != m.end() && !m["TaskErrorCode"].empty()) {
      taskErrorCode = make_shared<string>(boost::any_cast<string>(m["TaskErrorCode"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskErrorMessage") != m.end() && !m["TaskErrorMessage"].empty()) {
      taskErrorMessage = make_shared<string>(boost::any_cast<string>(m["TaskErrorMessage"]));
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskList : public Darabonba::Model {
public:
  shared_ptr<vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO>> taskInfoDTO{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskList() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskInfoDTO) {
      vector<boost::any> temp1;
      for(auto item1:*taskInfoDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskInfoDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskInfoDTO") != m.end() && !m["TaskInfoDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskInfoDTO"].type()) {
        vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskInfoDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskInfoDTO = make_shared<vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO>>(expect1);
      }
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskList() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO : public Darabonba::Model {
public:
  shared_ptr<string> stageId{};
  shared_ptr<long> stageStatus{};
  shared_ptr<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskList> taskList{};
  shared_ptr<string> stageName{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (stageStatus) {
      res["StageStatus"] = boost::any(*stageStatus);
    }
    if (taskList) {
      res["TaskList"] = taskList ? boost::any(taskList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("StageStatus") != m.end() && !m["StageStatus"].empty()) {
      stageStatus = make_shared<long>(boost::any_cast<long>(m["StageStatus"]));
    }
    if (m.find("TaskList") != m.end() && !m["TaskList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskList"].type()) {
        GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskList"]));
        taskList = make_shared<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskList>(model1);
      }
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailList : public Darabonba::Model {
public:
  shared_ptr<vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO>> stageDetailDTO{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailList() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stageDetailDTO) {
      vector<boost::any> temp1;
      for(auto item1:*stageDetailDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StageDetailDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StageDetailDTO") != m.end() && !m["StageDetailDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["StageDetailDTO"].type()) {
        vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StageDetailDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stageDetailDTO = make_shared<vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO>>(expect1);
      }
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailList() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage : public Darabonba::Model {
public:
  shared_ptr<string> stageId{};
  shared_ptr<long> status{};
  shared_ptr<string> message{};
  shared_ptr<string> stageName{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO : public Darabonba::Model {
public:
  shared_ptr<string> stageId{};
  shared_ptr<long> status{};
  shared_ptr<string> startTime{};
  shared_ptr<string> stageMessage{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> stageName{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (stageMessage) {
      res["StageMessage"] = boost::any(*stageMessage);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StageMessage") != m.end() && !m["StageMessage"].empty()) {
      stageMessage = make_shared<string>(boost::any_cast<string>(m["StageMessage"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOList : public Darabonba::Model {
public:
  shared_ptr<vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO>> instanceStageDTO{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOList() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceStageDTO) {
      vector<boost::any> temp1;
      for(auto item1:*instanceStageDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceStageDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceStageDTO") != m.end() && !m["InstanceStageDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceStageDTO"].type()) {
        vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceStageDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceStageDTO = make_shared<vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO>>(expect1);
      }
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOList() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<string> instanceIp{};
  shared_ptr<string> podName{};
  shared_ptr<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOList> instanceStageDTOList{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> podStatus{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (instanceIp) {
      res["InstanceIp"] = boost::any(*instanceIp);
    }
    if (podName) {
      res["PodName"] = boost::any(*podName);
    }
    if (instanceStageDTOList) {
      res["InstanceStageDTOList"] = instanceStageDTOList ? boost::any(instanceStageDTOList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (podStatus) {
      res["PodStatus"] = boost::any(*podStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("InstanceIp") != m.end() && !m["InstanceIp"].empty()) {
      instanceIp = make_shared<string>(boost::any_cast<string>(m["InstanceIp"]));
    }
    if (m.find("PodName") != m.end() && !m["PodName"].empty()) {
      podName = make_shared<string>(boost::any_cast<string>(m["PodName"]));
    }
    if (m.find("InstanceStageDTOList") != m.end() && !m["InstanceStageDTOList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceStageDTOList"].type()) {
        GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceStageDTOList"]));
        instanceStageDTOList = make_shared<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOList>(model1);
      }
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("PodStatus") != m.end() && !m["PodStatus"].empty()) {
      podStatus = make_shared<string>(boost::any_cast<string>(m["PodStatus"]));
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOList : public Darabonba::Model {
public:
  shared_ptr<vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO>> instanceDTO{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOList() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceDTO) {
      vector<boost::any> temp1;
      for(auto item1:*instanceDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceDTO") != m.end() && !m["InstanceDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceDTO"].type()) {
        vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceDTO = make_shared<vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO>>(expect1);
      }
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOList() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO : public Darabonba::Model {
public:
  shared_ptr<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage> serviceStage{};
  shared_ptr<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOList> instanceDTOList{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceStage) {
      res["ServiceStage"] = serviceStage ? boost::any(serviceStage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceDTOList) {
      res["InstanceDTOList"] = instanceDTOList ? boost::any(instanceDTOList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceStage") != m.end() && !m["ServiceStage"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceStage"].type()) {
        GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceStage"]));
        serviceStage = make_shared<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage>(model1);
      }
    }
    if (m.find("InstanceDTOList") != m.end() && !m["InstanceDTOList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceDTOList"].type()) {
        GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceDTOList"]));
        instanceDTOList = make_shared<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOList>(model1);
      }
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO : public Darabonba::Model {
public:
  shared_ptr<string> stageId{};
  shared_ptr<long> status{};
  shared_ptr<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO> stageResultDTO{};
  shared_ptr<string> stageName{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (stageResultDTO) {
      res["StageResultDTO"] = stageResultDTO ? boost::any(stageResultDTO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("StageResultDTO") != m.end() && !m["StageResultDTO"].empty()) {
      if (typeid(map<string, boost::any>) == m["StageResultDTO"].type()) {
        GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StageResultDTO"]));
        stageResultDTO = make_shared<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO>(model1);
      }
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageList : public Darabonba::Model {
public:
  shared_ptr<vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO>> stageInfoDTO{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageList() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stageInfoDTO) {
      vector<boost::any> temp1;
      for(auto item1:*stageInfoDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StageInfoDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StageInfoDTO") != m.end() && !m["StageInfoDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["StageInfoDTO"].type()) {
        vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StageInfoDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stageInfoDTO = make_shared<vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO>>(expect1);
      }
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageList() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo : public Darabonba::Model {
public:
  shared_ptr<string> startTime{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> pipelineStatus{};
  shared_ptr<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailList> stageDetailList{};
  shared_ptr<string> pipelineName{};
  shared_ptr<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageList> stageList{};
  shared_ptr<string> pipelineId{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (pipelineStatus) {
      res["PipelineStatus"] = boost::any(*pipelineStatus);
    }
    if (stageDetailList) {
      res["StageDetailList"] = stageDetailList ? boost::any(stageDetailList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineName) {
      res["PipelineName"] = boost::any(*pipelineName);
    }
    if (stageList) {
      res["StageList"] = stageList ? boost::any(stageList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("PipelineStatus") != m.end() && !m["PipelineStatus"].empty()) {
      pipelineStatus = make_shared<long>(boost::any_cast<long>(m["PipelineStatus"]));
    }
    if (m.find("StageDetailList") != m.end() && !m["StageDetailList"].empty()) {
      if (typeid(map<string, boost::any>) == m["StageDetailList"].type()) {
        GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StageDetailList"]));
        stageDetailList = make_shared<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailList>(model1);
      }
    }
    if (m.find("PipelineName") != m.end() && !m["PipelineName"].empty()) {
      pipelineName = make_shared<string>(boost::any_cast<string>(m["PipelineName"]));
    }
    if (m.find("StageList") != m.end() && !m["StageList"].empty()) {
      if (typeid(map<string, boost::any>) == m["StageList"].type()) {
        GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StageList"]));
        stageList = make_shared<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageList>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo>> pipelineInfo{};

  GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoList() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineInfo) {
      vector<boost::any> temp1;
      for(auto item1:*pipelineInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PipelineInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineInfo") != m.end() && !m["PipelineInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PipelineInfo"].type()) {
        vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PipelineInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipelineInfo = make_shared<vector<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo>>(expect1);
      }
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoList() = default;
};
class GetChangeOrderInfoResponseBodyChangeOrderInfo : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<string> createTime{};
  shared_ptr<string> changeOrderDescription{};
  shared_ptr<long> batchCount{};
  shared_ptr<string> createUserId{};
  shared_ptr<bool> supportRollback{};
  shared_ptr<string> desc{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<string> batchType{};
  shared_ptr<string> coType{};
  shared_ptr<GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl> trafficControl{};
  shared_ptr<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoList> pipelineInfoList{};

  GetChangeOrderInfoResponseBodyChangeOrderInfo() {}

  explicit GetChangeOrderInfoResponseBodyChangeOrderInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (changeOrderDescription) {
      res["ChangeOrderDescription"] = boost::any(*changeOrderDescription);
    }
    if (batchCount) {
      res["BatchCount"] = boost::any(*batchCount);
    }
    if (createUserId) {
      res["CreateUserId"] = boost::any(*createUserId);
    }
    if (supportRollback) {
      res["SupportRollback"] = boost::any(*supportRollback);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (batchType) {
      res["BatchType"] = boost::any(*batchType);
    }
    if (coType) {
      res["CoType"] = boost::any(*coType);
    }
    if (trafficControl) {
      res["TrafficControl"] = trafficControl ? boost::any(trafficControl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineInfoList) {
      res["PipelineInfoList"] = pipelineInfoList ? boost::any(pipelineInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ChangeOrderDescription") != m.end() && !m["ChangeOrderDescription"].empty()) {
      changeOrderDescription = make_shared<string>(boost::any_cast<string>(m["ChangeOrderDescription"]));
    }
    if (m.find("BatchCount") != m.end() && !m["BatchCount"].empty()) {
      batchCount = make_shared<long>(boost::any_cast<long>(m["BatchCount"]));
    }
    if (m.find("CreateUserId") != m.end() && !m["CreateUserId"].empty()) {
      createUserId = make_shared<string>(boost::any_cast<string>(m["CreateUserId"]));
    }
    if (m.find("SupportRollback") != m.end() && !m["SupportRollback"].empty()) {
      supportRollback = make_shared<bool>(boost::any_cast<bool>(m["SupportRollback"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("BatchType") != m.end() && !m["BatchType"].empty()) {
      batchType = make_shared<string>(boost::any_cast<string>(m["BatchType"]));
    }
    if (m.find("CoType") != m.end() && !m["CoType"].empty()) {
      coType = make_shared<string>(boost::any_cast<string>(m["CoType"]));
    }
    if (m.find("TrafficControl") != m.end() && !m["TrafficControl"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficControl"].type()) {
        GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficControl"]));
        trafficControl = make_shared<GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl>(model1);
      }
    }
    if (m.find("PipelineInfoList") != m.end() && !m["PipelineInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PipelineInfoList"].type()) {
        GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PipelineInfoList"]));
        pipelineInfoList = make_shared<GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoList>(model1);
      }
    }
  }


  virtual ~GetChangeOrderInfoResponseBodyChangeOrderInfo() = default;
};
class GetChangeOrderInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};
  shared_ptr<GetChangeOrderInfoResponseBodyChangeOrderInfo> changeOrderInfo{};

  GetChangeOrderInfoResponseBody() {}

  explicit GetChangeOrderInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (changeOrderInfo) {
      res["changeOrderInfo"] = changeOrderInfo ? boost::any(changeOrderInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("changeOrderInfo") != m.end() && !m["changeOrderInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["changeOrderInfo"].type()) {
        GetChangeOrderInfoResponseBodyChangeOrderInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["changeOrderInfo"]));
        changeOrderInfo = make_shared<GetChangeOrderInfoResponseBodyChangeOrderInfo>(model1);
      }
    }
  }


  virtual ~GetChangeOrderInfoResponseBody() = default;
};
class GetChangeOrderInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetChangeOrderInfoResponseBody> body{};

  GetChangeOrderInfoResponse() {}

  explicit GetChangeOrderInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetChangeOrderInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetChangeOrderInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetChangeOrderInfoResponse() = default;
};
class GetClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};

  GetClusterRequest() {}

  explicit GetClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~GetClusterRequest() = default;
};
class GetClusterResponseBodyCluster : public Darabonba::Model {
public:
  shared_ptr<long> oversoldFactor{};
  shared_ptr<string> vpcId{};
  shared_ptr<long> updateTime{};
  shared_ptr<long> memUsed{};
  shared_ptr<string> iaasProvider{};
  shared_ptr<long> createTime{};
  shared_ptr<long> cpuUsed{};
  shared_ptr<long> mem{};
  shared_ptr<string> regionId{};
  shared_ptr<long> cpu{};
  shared_ptr<string> csClusterId{};
  shared_ptr<string> description{};
  shared_ptr<long> networkMode{};
  shared_ptr<long> clusterType{};
  shared_ptr<string> clusterName{};
  shared_ptr<long> nodeNum{};
  shared_ptr<long> clusterImportStatus{};
  shared_ptr<string> clusterId{};

  GetClusterResponseBodyCluster() {}

  explicit GetClusterResponseBodyCluster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (oversoldFactor) {
      res["OversoldFactor"] = boost::any(*oversoldFactor);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (memUsed) {
      res["MemUsed"] = boost::any(*memUsed);
    }
    if (iaasProvider) {
      res["IaasProvider"] = boost::any(*iaasProvider);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (cpuUsed) {
      res["CpuUsed"] = boost::any(*cpuUsed);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (csClusterId) {
      res["CsClusterId"] = boost::any(*csClusterId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (networkMode) {
      res["NetworkMode"] = boost::any(*networkMode);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (nodeNum) {
      res["NodeNum"] = boost::any(*nodeNum);
    }
    if (clusterImportStatus) {
      res["ClusterImportStatus"] = boost::any(*clusterImportStatus);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OversoldFactor") != m.end() && !m["OversoldFactor"].empty()) {
      oversoldFactor = make_shared<long>(boost::any_cast<long>(m["OversoldFactor"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("MemUsed") != m.end() && !m["MemUsed"].empty()) {
      memUsed = make_shared<long>(boost::any_cast<long>(m["MemUsed"]));
    }
    if (m.find("IaasProvider") != m.end() && !m["IaasProvider"].empty()) {
      iaasProvider = make_shared<string>(boost::any_cast<string>(m["IaasProvider"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CpuUsed") != m.end() && !m["CpuUsed"].empty()) {
      cpuUsed = make_shared<long>(boost::any_cast<long>(m["CpuUsed"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CsClusterId") != m.end() && !m["CsClusterId"].empty()) {
      csClusterId = make_shared<string>(boost::any_cast<string>(m["CsClusterId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NetworkMode") != m.end() && !m["NetworkMode"].empty()) {
      networkMode = make_shared<long>(boost::any_cast<long>(m["NetworkMode"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<long>(boost::any_cast<long>(m["ClusterType"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("NodeNum") != m.end() && !m["NodeNum"].empty()) {
      nodeNum = make_shared<long>(boost::any_cast<long>(m["NodeNum"]));
    }
    if (m.find("ClusterImportStatus") != m.end() && !m["ClusterImportStatus"].empty()) {
      clusterImportStatus = make_shared<long>(boost::any_cast<long>(m["ClusterImportStatus"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~GetClusterResponseBodyCluster() = default;
};
class GetClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<GetClusterResponseBodyCluster> cluster{};
  shared_ptr<long> code{};

  GetClusterResponseBody() {}

  explicit GetClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (cluster) {
      res["Cluster"] = cluster ? boost::any(cluster->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Cluster") != m.end() && !m["Cluster"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cluster"].type()) {
        GetClusterResponseBodyCluster model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cluster"]));
        cluster = make_shared<GetClusterResponseBodyCluster>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~GetClusterResponseBody() = default;
};
class GetClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetClusterResponseBody> body{};

  GetClusterResponse() {}

  explicit GetClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetClusterResponseBody>(model1);
      }
    }
  }


  virtual ~GetClusterResponse() = default;
};
class GetContainerConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};

  GetContainerConfigurationRequest() {}

  explicit GetContainerConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~GetContainerConfigurationRequest() = default;
};
class GetContainerConfigurationResponseBodyContainerConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> contextPath{};
  shared_ptr<string> URIEncoding{};
  shared_ptr<long> httpPort{};
  shared_ptr<bool> useBodyEncoding{};
  shared_ptr<long> maxThreads{};

  GetContainerConfigurationResponseBodyContainerConfiguration() {}

  explicit GetContainerConfigurationResponseBodyContainerConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contextPath) {
      res["ContextPath"] = boost::any(*contextPath);
    }
    if (URIEncoding) {
      res["URIEncoding"] = boost::any(*URIEncoding);
    }
    if (httpPort) {
      res["HttpPort"] = boost::any(*httpPort);
    }
    if (useBodyEncoding) {
      res["UseBodyEncoding"] = boost::any(*useBodyEncoding);
    }
    if (maxThreads) {
      res["MaxThreads"] = boost::any(*maxThreads);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContextPath") != m.end() && !m["ContextPath"].empty()) {
      contextPath = make_shared<string>(boost::any_cast<string>(m["ContextPath"]));
    }
    if (m.find("URIEncoding") != m.end() && !m["URIEncoding"].empty()) {
      URIEncoding = make_shared<string>(boost::any_cast<string>(m["URIEncoding"]));
    }
    if (m.find("HttpPort") != m.end() && !m["HttpPort"].empty()) {
      httpPort = make_shared<long>(boost::any_cast<long>(m["HttpPort"]));
    }
    if (m.find("UseBodyEncoding") != m.end() && !m["UseBodyEncoding"].empty()) {
      useBodyEncoding = make_shared<bool>(boost::any_cast<bool>(m["UseBodyEncoding"]));
    }
    if (m.find("MaxThreads") != m.end() && !m["MaxThreads"].empty()) {
      maxThreads = make_shared<long>(boost::any_cast<long>(m["MaxThreads"]));
    }
  }


  virtual ~GetContainerConfigurationResponseBodyContainerConfiguration() = default;
};
class GetContainerConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};
  shared_ptr<GetContainerConfigurationResponseBodyContainerConfiguration> containerConfiguration{};

  GetContainerConfigurationResponseBody() {}

  explicit GetContainerConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (containerConfiguration) {
      res["ContainerConfiguration"] = containerConfiguration ? boost::any(containerConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("ContainerConfiguration") != m.end() && !m["ContainerConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContainerConfiguration"].type()) {
        GetContainerConfigurationResponseBodyContainerConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContainerConfiguration"]));
        containerConfiguration = make_shared<GetContainerConfigurationResponseBodyContainerConfiguration>(model1);
      }
    }
  }


  virtual ~GetContainerConfigurationResponseBody() = default;
};
class GetContainerConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetContainerConfigurationResponseBody> body{};

  GetContainerConfigurationResponse() {}

  explicit GetContainerConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetContainerConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetContainerConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~GetContainerConfigurationResponse() = default;
};
class GetJvmConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};

  GetJvmConfigurationRequest() {}

  explicit GetJvmConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~GetJvmConfigurationRequest() = default;
};
class GetJvmConfigurationResponseBodyJvmConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> maxPermSize{};
  shared_ptr<long> maxHeapSize{};
  shared_ptr<string> options{};
  shared_ptr<long> minHeapSize{};

  GetJvmConfigurationResponseBodyJvmConfiguration() {}

  explicit GetJvmConfigurationResponseBodyJvmConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxPermSize) {
      res["MaxPermSize"] = boost::any(*maxPermSize);
    }
    if (maxHeapSize) {
      res["MaxHeapSize"] = boost::any(*maxHeapSize);
    }
    if (options) {
      res["Options"] = boost::any(*options);
    }
    if (minHeapSize) {
      res["MinHeapSize"] = boost::any(*minHeapSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxPermSize") != m.end() && !m["MaxPermSize"].empty()) {
      maxPermSize = make_shared<long>(boost::any_cast<long>(m["MaxPermSize"]));
    }
    if (m.find("MaxHeapSize") != m.end() && !m["MaxHeapSize"].empty()) {
      maxHeapSize = make_shared<long>(boost::any_cast<long>(m["MaxHeapSize"]));
    }
    if (m.find("Options") != m.end() && !m["Options"].empty()) {
      options = make_shared<string>(boost::any_cast<string>(m["Options"]));
    }
    if (m.find("MinHeapSize") != m.end() && !m["MinHeapSize"].empty()) {
      minHeapSize = make_shared<long>(boost::any_cast<long>(m["MinHeapSize"]));
    }
  }


  virtual ~GetJvmConfigurationResponseBodyJvmConfiguration() = default;
};
class GetJvmConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<GetJvmConfigurationResponseBodyJvmConfiguration> jvmConfiguration{};
  shared_ptr<long> code{};

  GetJvmConfigurationResponseBody() {}

  explicit GetJvmConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jvmConfiguration) {
      res["JvmConfiguration"] = jvmConfiguration ? boost::any(jvmConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JvmConfiguration") != m.end() && !m["JvmConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["JvmConfiguration"].type()) {
        GetJvmConfigurationResponseBodyJvmConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JvmConfiguration"]));
        jvmConfiguration = make_shared<GetJvmConfigurationResponseBodyJvmConfiguration>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~GetJvmConfigurationResponseBody() = default;
};
class GetJvmConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetJvmConfigurationResponseBody> body{};

  GetJvmConfigurationResponse() {}

  explicit GetJvmConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetJvmConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetJvmConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~GetJvmConfigurationResponse() = default;
};
class GetK8sApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> from{};

  GetK8sApplicationRequest() {}

  explicit GetK8sApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
  }


  virtual ~GetK8sApplicationRequest() = default;
};
class GetK8sApplicationResponseBodyApplcationConf : public Darabonba::Model {
public:
  shared_ptr<string> postStart{};
  shared_ptr<string> readiness{};
  shared_ptr<bool> ahasEnabled{};
  shared_ptr<string> k8sCmdArgs{};
  shared_ptr<string> liveness{};
  shared_ptr<string> deployAcrossNodes{};
  shared_ptr<string> k8sCmd{};
  shared_ptr<string> preStop{};
  shared_ptr<string> jarStartArgs{};
  shared_ptr<string> deployAcrossZones{};
  shared_ptr<string> k8sNasInfo{};
  shared_ptr<string> jarStartOptions{};
  shared_ptr<string> runtimeClassName{};
  shared_ptr<string> k8sLocalvolumeInfo{};
  shared_ptr<string> k8sVolumeInfo{};

  GetK8sApplicationResponseBodyApplcationConf() {}

  explicit GetK8sApplicationResponseBodyApplcationConf(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (postStart) {
      res["PostStart"] = boost::any(*postStart);
    }
    if (readiness) {
      res["Readiness"] = boost::any(*readiness);
    }
    if (ahasEnabled) {
      res["AhasEnabled"] = boost::any(*ahasEnabled);
    }
    if (k8sCmdArgs) {
      res["K8sCmdArgs"] = boost::any(*k8sCmdArgs);
    }
    if (liveness) {
      res["Liveness"] = boost::any(*liveness);
    }
    if (deployAcrossNodes) {
      res["DeployAcrossNodes"] = boost::any(*deployAcrossNodes);
    }
    if (k8sCmd) {
      res["K8sCmd"] = boost::any(*k8sCmd);
    }
    if (preStop) {
      res["PreStop"] = boost::any(*preStop);
    }
    if (jarStartArgs) {
      res["JarStartArgs"] = boost::any(*jarStartArgs);
    }
    if (deployAcrossZones) {
      res["DeployAcrossZones"] = boost::any(*deployAcrossZones);
    }
    if (k8sNasInfo) {
      res["K8sNasInfo"] = boost::any(*k8sNasInfo);
    }
    if (jarStartOptions) {
      res["JarStartOptions"] = boost::any(*jarStartOptions);
    }
    if (runtimeClassName) {
      res["RuntimeClassName"] = boost::any(*runtimeClassName);
    }
    if (k8sLocalvolumeInfo) {
      res["K8sLocalvolumeInfo"] = boost::any(*k8sLocalvolumeInfo);
    }
    if (k8sVolumeInfo) {
      res["K8sVolumeInfo"] = boost::any(*k8sVolumeInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PostStart") != m.end() && !m["PostStart"].empty()) {
      postStart = make_shared<string>(boost::any_cast<string>(m["PostStart"]));
    }
    if (m.find("Readiness") != m.end() && !m["Readiness"].empty()) {
      readiness = make_shared<string>(boost::any_cast<string>(m["Readiness"]));
    }
    if (m.find("AhasEnabled") != m.end() && !m["AhasEnabled"].empty()) {
      ahasEnabled = make_shared<bool>(boost::any_cast<bool>(m["AhasEnabled"]));
    }
    if (m.find("K8sCmdArgs") != m.end() && !m["K8sCmdArgs"].empty()) {
      k8sCmdArgs = make_shared<string>(boost::any_cast<string>(m["K8sCmdArgs"]));
    }
    if (m.find("Liveness") != m.end() && !m["Liveness"].empty()) {
      liveness = make_shared<string>(boost::any_cast<string>(m["Liveness"]));
    }
    if (m.find("DeployAcrossNodes") != m.end() && !m["DeployAcrossNodes"].empty()) {
      deployAcrossNodes = make_shared<string>(boost::any_cast<string>(m["DeployAcrossNodes"]));
    }
    if (m.find("K8sCmd") != m.end() && !m["K8sCmd"].empty()) {
      k8sCmd = make_shared<string>(boost::any_cast<string>(m["K8sCmd"]));
    }
    if (m.find("PreStop") != m.end() && !m["PreStop"].empty()) {
      preStop = make_shared<string>(boost::any_cast<string>(m["PreStop"]));
    }
    if (m.find("JarStartArgs") != m.end() && !m["JarStartArgs"].empty()) {
      jarStartArgs = make_shared<string>(boost::any_cast<string>(m["JarStartArgs"]));
    }
    if (m.find("DeployAcrossZones") != m.end() && !m["DeployAcrossZones"].empty()) {
      deployAcrossZones = make_shared<string>(boost::any_cast<string>(m["DeployAcrossZones"]));
    }
    if (m.find("K8sNasInfo") != m.end() && !m["K8sNasInfo"].empty()) {
      k8sNasInfo = make_shared<string>(boost::any_cast<string>(m["K8sNasInfo"]));
    }
    if (m.find("JarStartOptions") != m.end() && !m["JarStartOptions"].empty()) {
      jarStartOptions = make_shared<string>(boost::any_cast<string>(m["JarStartOptions"]));
    }
    if (m.find("RuntimeClassName") != m.end() && !m["RuntimeClassName"].empty()) {
      runtimeClassName = make_shared<string>(boost::any_cast<string>(m["RuntimeClassName"]));
    }
    if (m.find("K8sLocalvolumeInfo") != m.end() && !m["K8sLocalvolumeInfo"].empty()) {
      k8sLocalvolumeInfo = make_shared<string>(boost::any_cast<string>(m["K8sLocalvolumeInfo"]));
    }
    if (m.find("K8sVolumeInfo") != m.end() && !m["K8sVolumeInfo"].empty()) {
      k8sVolumeInfo = make_shared<string>(boost::any_cast<string>(m["K8sVolumeInfo"]));
    }
  }


  virtual ~GetK8sApplicationResponseBodyApplcationConf() = default;
};
class GetK8sApplicationResponseBodyApplcationAppCmdArgs : public Darabonba::Model {
public:
  shared_ptr<vector<string>> cmdArg{};

  GetK8sApplicationResponseBodyApplcationAppCmdArgs() {}

  explicit GetK8sApplicationResponseBodyApplcationAppCmdArgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cmdArg) {
      res["CmdArg"] = boost::any(*cmdArg);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CmdArg") != m.end() && !m["CmdArg"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CmdArg"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CmdArg"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cmdArg = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetK8sApplicationResponseBodyApplcationAppCmdArgs() = default;
};
class GetK8sApplicationResponseBodyApplcationAppEnvListEnv : public Darabonba::Model {
public:
  shared_ptr<string> value{};
  shared_ptr<string> name{};

  GetK8sApplicationResponseBodyApplcationAppEnvListEnv() {}

  explicit GetK8sApplicationResponseBodyApplcationAppEnvListEnv(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetK8sApplicationResponseBodyApplcationAppEnvListEnv() = default;
};
class GetK8sApplicationResponseBodyApplcationAppEnvList : public Darabonba::Model {
public:
  shared_ptr<vector<GetK8sApplicationResponseBodyApplcationAppEnvListEnv>> env{};

  GetK8sApplicationResponseBodyApplcationAppEnvList() {}

  explicit GetK8sApplicationResponseBodyApplcationAppEnvList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      vector<boost::any> temp1;
      for(auto item1:*env){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Env"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      if (typeid(vector<boost::any>) == m["Env"].type()) {
        vector<GetK8sApplicationResponseBodyApplcationAppEnvListEnv> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Env"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetK8sApplicationResponseBodyApplcationAppEnvListEnv model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        env = make_shared<vector<GetK8sApplicationResponseBodyApplcationAppEnvListEnv>>(expect1);
      }
    }
  }


  virtual ~GetK8sApplicationResponseBodyApplcationAppEnvList() = default;
};
class GetK8sApplicationResponseBodyApplcationApp : public Darabonba::Model {
public:
  shared_ptr<long> instancesBeforeScaling{};
  shared_ptr<string> deployType{};
  shared_ptr<string> applicationName{};
  shared_ptr<string> applicationType{};
  shared_ptr<long> instances{};
  shared_ptr<GetK8sApplicationResponseBodyApplcationAppCmdArgs> cmdArgs{};
  shared_ptr<string> cmd{};
  shared_ptr<long> buildpackId{};
  shared_ptr<string> tomcatVersion{};
  shared_ptr<string> csClusterId{};
  shared_ptr<string> appId{};
  shared_ptr<string> edasContainerVersion{};
  shared_ptr<string> clusterId{};
  shared_ptr<GetK8sApplicationResponseBodyApplcationAppEnvList> envList{};

  GetK8sApplicationResponseBodyApplcationApp() {}

  explicit GetK8sApplicationResponseBodyApplcationApp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instancesBeforeScaling) {
      res["InstancesBeforeScaling"] = boost::any(*instancesBeforeScaling);
    }
    if (deployType) {
      res["DeployType"] = boost::any(*deployType);
    }
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (applicationType) {
      res["ApplicationType"] = boost::any(*applicationType);
    }
    if (instances) {
      res["Instances"] = boost::any(*instances);
    }
    if (cmdArgs) {
      res["CmdArgs"] = cmdArgs ? boost::any(cmdArgs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cmd) {
      res["Cmd"] = boost::any(*cmd);
    }
    if (buildpackId) {
      res["BuildpackId"] = boost::any(*buildpackId);
    }
    if (tomcatVersion) {
      res["TomcatVersion"] = boost::any(*tomcatVersion);
    }
    if (csClusterId) {
      res["CsClusterId"] = boost::any(*csClusterId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (edasContainerVersion) {
      res["EdasContainerVersion"] = boost::any(*edasContainerVersion);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (envList) {
      res["EnvList"] = envList ? boost::any(envList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstancesBeforeScaling") != m.end() && !m["InstancesBeforeScaling"].empty()) {
      instancesBeforeScaling = make_shared<long>(boost::any_cast<long>(m["InstancesBeforeScaling"]));
    }
    if (m.find("DeployType") != m.end() && !m["DeployType"].empty()) {
      deployType = make_shared<string>(boost::any_cast<string>(m["DeployType"]));
    }
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ApplicationType") != m.end() && !m["ApplicationType"].empty()) {
      applicationType = make_shared<string>(boost::any_cast<string>(m["ApplicationType"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      instances = make_shared<long>(boost::any_cast<long>(m["Instances"]));
    }
    if (m.find("CmdArgs") != m.end() && !m["CmdArgs"].empty()) {
      if (typeid(map<string, boost::any>) == m["CmdArgs"].type()) {
        GetK8sApplicationResponseBodyApplcationAppCmdArgs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CmdArgs"]));
        cmdArgs = make_shared<GetK8sApplicationResponseBodyApplcationAppCmdArgs>(model1);
      }
    }
    if (m.find("Cmd") != m.end() && !m["Cmd"].empty()) {
      cmd = make_shared<string>(boost::any_cast<string>(m["Cmd"]));
    }
    if (m.find("BuildpackId") != m.end() && !m["BuildpackId"].empty()) {
      buildpackId = make_shared<long>(boost::any_cast<long>(m["BuildpackId"]));
    }
    if (m.find("TomcatVersion") != m.end() && !m["TomcatVersion"].empty()) {
      tomcatVersion = make_shared<string>(boost::any_cast<string>(m["TomcatVersion"]));
    }
    if (m.find("CsClusterId") != m.end() && !m["CsClusterId"].empty()) {
      csClusterId = make_shared<string>(boost::any_cast<string>(m["CsClusterId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EdasContainerVersion") != m.end() && !m["EdasContainerVersion"].empty()) {
      edasContainerVersion = make_shared<string>(boost::any_cast<string>(m["EdasContainerVersion"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EnvList") != m.end() && !m["EnvList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EnvList"].type()) {
        GetK8sApplicationResponseBodyApplcationAppEnvList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EnvList"]));
        envList = make_shared<GetK8sApplicationResponseBodyApplcationAppEnvList>(model1);
      }
    }
  }


  virtual ~GetK8sApplicationResponseBodyApplcationApp() = default;
};
class GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents : public Darabonba::Model {
public:
  shared_ptr<string> componentKey{};
  shared_ptr<string> componentId{};

  GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents() {}

  explicit GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentKey) {
      res["ComponentKey"] = boost::any(*componentKey);
    }
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentKey") != m.end() && !m["ComponentKey"].empty()) {
      componentKey = make_shared<string>(boost::any_cast<string>(m["ComponentKey"]));
    }
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      componentId = make_shared<string>(boost::any_cast<string>(m["ComponentId"]));
    }
  }


  virtual ~GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents() = default;
};
class GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponents : public Darabonba::Model {
public:
  shared_ptr<vector<GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents>> components{};

  GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponents() {}

  explicit GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (components) {
      vector<boost::any> temp1;
      for(auto item1:*components){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Components"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Components") != m.end() && !m["Components"].empty()) {
      if (typeid(vector<boost::any>) == m["Components"].type()) {
        vector<GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Components"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        components = make_shared<vector<GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents>>(expect1);
      }
    }
  }


  virtual ~GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponents() = default;
};
class GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup : public Darabonba::Model {
public:
  shared_ptr<GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponents> components{};

  GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup() {}

  explicit GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (components) {
      res["Components"] = components ? boost::any(components->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Components") != m.end() && !m["Components"].empty()) {
      if (typeid(map<string, boost::any>) == m["Components"].type()) {
        GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponents model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Components"]));
        components = make_shared<GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponents>(model1);
      }
    }
  }


  virtual ~GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup() = default;
};
class GetK8sApplicationResponseBodyApplcationDeployGroups : public Darabonba::Model {
public:
  shared_ptr<vector<GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup>> deployGroup{};

  GetK8sApplicationResponseBodyApplcationDeployGroups() {}

  explicit GetK8sApplicationResponseBodyApplcationDeployGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployGroup) {
      vector<boost::any> temp1;
      for(auto item1:*deployGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeployGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployGroup") != m.end() && !m["DeployGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["DeployGroup"].type()) {
        vector<GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeployGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deployGroup = make_shared<vector<GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup>>(expect1);
      }
    }
  }


  virtual ~GetK8sApplicationResponseBodyApplcationDeployGroups() = default;
};
class GetK8sApplicationResponseBodyApplcationImageInfo : public Darabonba::Model {
public:
  shared_ptr<string> repoId{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> repoOriginType{};
  shared_ptr<string> tag{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<string> regionId{};

  GetK8sApplicationResponseBodyApplcationImageInfo() {}

  explicit GetK8sApplicationResponseBodyApplcationImageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (repoOriginType) {
      res["RepoOriginType"] = boost::any(*repoOriginType);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("RepoOriginType") != m.end() && !m["RepoOriginType"].empty()) {
      repoOriginType = make_shared<string>(boost::any_cast<string>(m["RepoOriginType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetK8sApplicationResponseBodyApplcationImageInfo() = default;
};
class GetK8sApplicationResponseBodyApplcation : public Darabonba::Model {
public:
  shared_ptr<GetK8sApplicationResponseBodyApplcationConf> conf{};
  shared_ptr<string> appId{};
  shared_ptr<GetK8sApplicationResponseBodyApplcationApp> app{};
  shared_ptr<GetK8sApplicationResponseBodyApplcationDeployGroups> deployGroups{};
  shared_ptr<GetK8sApplicationResponseBodyApplcationImageInfo> imageInfo{};

  GetK8sApplicationResponseBodyApplcation() {}

  explicit GetK8sApplicationResponseBodyApplcation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conf) {
      res["Conf"] = conf ? boost::any(conf->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (app) {
      res["App"] = app ? boost::any(app->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deployGroups) {
      res["DeployGroups"] = deployGroups ? boost::any(deployGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageInfo) {
      res["ImageInfo"] = imageInfo ? boost::any(imageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Conf") != m.end() && !m["Conf"].empty()) {
      if (typeid(map<string, boost::any>) == m["Conf"].type()) {
        GetK8sApplicationResponseBodyApplcationConf model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Conf"]));
        conf = make_shared<GetK8sApplicationResponseBodyApplcationConf>(model1);
      }
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("App") != m.end() && !m["App"].empty()) {
      if (typeid(map<string, boost::any>) == m["App"].type()) {
        GetK8sApplicationResponseBodyApplcationApp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["App"]));
        app = make_shared<GetK8sApplicationResponseBodyApplcationApp>(model1);
      }
    }
    if (m.find("DeployGroups") != m.end() && !m["DeployGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeployGroups"].type()) {
        GetK8sApplicationResponseBodyApplcationDeployGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeployGroups"]));
        deployGroups = make_shared<GetK8sApplicationResponseBodyApplcationDeployGroups>(model1);
      }
    }
    if (m.find("ImageInfo") != m.end() && !m["ImageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageInfo"].type()) {
        GetK8sApplicationResponseBodyApplcationImageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageInfo"]));
        imageInfo = make_shared<GetK8sApplicationResponseBodyApplcationImageInfo>(model1);
      }
    }
  }


  virtual ~GetK8sApplicationResponseBodyApplcation() = default;
};
class GetK8sApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<GetK8sApplicationResponseBodyApplcation> applcation{};
  shared_ptr<long> code{};

  GetK8sApplicationResponseBody() {}

  explicit GetK8sApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (applcation) {
      res["Applcation"] = applcation ? boost::any(applcation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Applcation") != m.end() && !m["Applcation"].empty()) {
      if (typeid(map<string, boost::any>) == m["Applcation"].type()) {
        GetK8sApplicationResponseBodyApplcation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Applcation"]));
        applcation = make_shared<GetK8sApplicationResponseBodyApplcation>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~GetK8sApplicationResponseBody() = default;
};
class GetK8sApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetK8sApplicationResponseBody> body{};

  GetK8sApplicationResponse() {}

  explicit GetK8sApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetK8sApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetK8sApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~GetK8sApplicationResponse() = default;
};
class GetK8sClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionTag{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> clusterType{};

  GetK8sClusterRequest() {}

  explicit GetK8sClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionTag) {
      res["RegionTag"] = boost::any(*regionTag);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionTag") != m.end() && !m["RegionTag"].empty()) {
      regionTag = make_shared<string>(boost::any_cast<string>(m["RegionTag"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<long>(boost::any_cast<long>(m["ClusterType"]));
    }
  }


  virtual ~GetK8sClusterRequest() = default;
};
class GetK8sClusterResponseBodyClusterPageClusterListCluster : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<string> vswitchId{};
  shared_ptr<string> subNetCidr{};
  shared_ptr<long> mem{};
  shared_ptr<string> regionId{};
  shared_ptr<string> csClusterStatus{};
  shared_ptr<long> cpu{};
  shared_ptr<string> description{};
  shared_ptr<string> csClusterId{};
  shared_ptr<long> networkMode{};
  shared_ptr<long> clusterType{};
  shared_ptr<long> clusterStatus{};
  shared_ptr<string> clusterName{};
  shared_ptr<long> nodeNum{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> clusterImportStatus{};

  GetK8sClusterResponseBodyClusterPageClusterListCluster() {}

  explicit GetK8sClusterResponseBodyClusterPageClusterListCluster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    if (subNetCidr) {
      res["SubNetCidr"] = boost::any(*subNetCidr);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (csClusterStatus) {
      res["CsClusterStatus"] = boost::any(*csClusterStatus);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (csClusterId) {
      res["CsClusterId"] = boost::any(*csClusterId);
    }
    if (networkMode) {
      res["NetworkMode"] = boost::any(*networkMode);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (clusterStatus) {
      res["ClusterStatus"] = boost::any(*clusterStatus);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (nodeNum) {
      res["NodeNum"] = boost::any(*nodeNum);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterImportStatus) {
      res["ClusterImportStatus"] = boost::any(*clusterImportStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
    if (m.find("SubNetCidr") != m.end() && !m["SubNetCidr"].empty()) {
      subNetCidr = make_shared<string>(boost::any_cast<string>(m["SubNetCidr"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("CsClusterStatus") != m.end() && !m["CsClusterStatus"].empty()) {
      csClusterStatus = make_shared<string>(boost::any_cast<string>(m["CsClusterStatus"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("CsClusterId") != m.end() && !m["CsClusterId"].empty()) {
      csClusterId = make_shared<string>(boost::any_cast<string>(m["CsClusterId"]));
    }
    if (m.find("NetworkMode") != m.end() && !m["NetworkMode"].empty()) {
      networkMode = make_shared<long>(boost::any_cast<long>(m["NetworkMode"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<long>(boost::any_cast<long>(m["ClusterType"]));
    }
    if (m.find("ClusterStatus") != m.end() && !m["ClusterStatus"].empty()) {
      clusterStatus = make_shared<long>(boost::any_cast<long>(m["ClusterStatus"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("NodeNum") != m.end() && !m["NodeNum"].empty()) {
      nodeNum = make_shared<long>(boost::any_cast<long>(m["NodeNum"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterImportStatus") != m.end() && !m["ClusterImportStatus"].empty()) {
      clusterImportStatus = make_shared<long>(boost::any_cast<long>(m["ClusterImportStatus"]));
    }
  }


  virtual ~GetK8sClusterResponseBodyClusterPageClusterListCluster() = default;
};
class GetK8sClusterResponseBodyClusterPageClusterList : public Darabonba::Model {
public:
  shared_ptr<vector<GetK8sClusterResponseBodyClusterPageClusterListCluster>> cluster{};

  GetK8sClusterResponseBodyClusterPageClusterList() {}

  explicit GetK8sClusterResponseBodyClusterPageClusterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cluster) {
      vector<boost::any> temp1;
      for(auto item1:*cluster){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Cluster"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cluster") != m.end() && !m["Cluster"].empty()) {
      if (typeid(vector<boost::any>) == m["Cluster"].type()) {
        vector<GetK8sClusterResponseBodyClusterPageClusterListCluster> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Cluster"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetK8sClusterResponseBodyClusterPageClusterListCluster model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cluster = make_shared<vector<GetK8sClusterResponseBodyClusterPageClusterListCluster>>(expect1);
      }
    }
  }


  virtual ~GetK8sClusterResponseBodyClusterPageClusterList() = default;
};
class GetK8sClusterResponseBodyClusterPage : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<GetK8sClusterResponseBodyClusterPageClusterList> clusterList{};
  shared_ptr<long> totalSize{};
  shared_ptr<long> pageSize{};

  GetK8sClusterResponseBodyClusterPage() {}

  explicit GetK8sClusterResponseBodyClusterPage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (clusterList) {
      res["ClusterList"] = clusterList ? boost::any(clusterList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ClusterList") != m.end() && !m["ClusterList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterList"].type()) {
        GetK8sClusterResponseBodyClusterPageClusterList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterList"]));
        clusterList = make_shared<GetK8sClusterResponseBodyClusterPageClusterList>(model1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~GetK8sClusterResponseBodyClusterPage() = default;
};
class GetK8sClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<GetK8sClusterResponseBodyClusterPage> clusterPage{};
  shared_ptr<long> code{};

  GetK8sClusterResponseBody() {}

  explicit GetK8sClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (clusterPage) {
      res["ClusterPage"] = clusterPage ? boost::any(clusterPage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ClusterPage") != m.end() && !m["ClusterPage"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterPage"].type()) {
        GetK8sClusterResponseBodyClusterPage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterPage"]));
        clusterPage = make_shared<GetK8sClusterResponseBodyClusterPage>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~GetK8sClusterResponseBody() = default;
};
class GetK8sClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetK8sClusterResponseBody> body{};

  GetK8sClusterResponse() {}

  explicit GetK8sClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetK8sClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetK8sClusterResponseBody>(model1);
      }
    }
  }


  virtual ~GetK8sClusterResponse() = default;
};
class GetK8sServicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  GetK8sServicesRequest() {}

  explicit GetK8sServicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~GetK8sServicesRequest() = default;
};
class GetK8sServicesResponseBodyServicesServicePorts : public Darabonba::Model {
public:
  shared_ptr<string> protocol{};
  shared_ptr<string> targetPort{};
  shared_ptr<long> nodePort{};
  shared_ptr<long> port{};

  GetK8sServicesResponseBodyServicesServicePorts() {}

  explicit GetK8sServicesResponseBodyServicesServicePorts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (targetPort) {
      res["TargetPort"] = boost::any(*targetPort);
    }
    if (nodePort) {
      res["NodePort"] = boost::any(*nodePort);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("TargetPort") != m.end() && !m["TargetPort"].empty()) {
      targetPort = make_shared<string>(boost::any_cast<string>(m["TargetPort"]));
    }
    if (m.find("NodePort") != m.end() && !m["NodePort"].empty()) {
      nodePort = make_shared<long>(boost::any_cast<long>(m["NodePort"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
  }


  virtual ~GetK8sServicesResponseBodyServicesServicePorts() = default;
};
class GetK8sServicesResponseBodyServices : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<vector<GetK8sServicesResponseBodyServicesServicePorts>> servicePorts{};
  shared_ptr<string> name{};
  shared_ptr<string> clusterIP{};

  GetK8sServicesResponseBodyServices() {}

  explicit GetK8sServicesResponseBodyServices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (servicePorts) {
      vector<boost::any> temp1;
      for(auto item1:*servicePorts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServicePorts"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (clusterIP) {
      res["ClusterIP"] = boost::any(*clusterIP);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ServicePorts") != m.end() && !m["ServicePorts"].empty()) {
      if (typeid(vector<boost::any>) == m["ServicePorts"].type()) {
        vector<GetK8sServicesResponseBodyServicesServicePorts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServicePorts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetK8sServicesResponseBodyServicesServicePorts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        servicePorts = make_shared<vector<GetK8sServicesResponseBodyServicesServicePorts>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ClusterIP") != m.end() && !m["ClusterIP"].empty()) {
      clusterIP = make_shared<string>(boost::any_cast<string>(m["ClusterIP"]));
    }
  }


  virtual ~GetK8sServicesResponseBodyServices() = default;
};
class GetK8sServicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetK8sServicesResponseBodyServices>> services{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  GetK8sServicesResponseBody() {}

  explicit GetK8sServicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (services) {
      vector<boost::any> temp1;
      for(auto item1:*services){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Services"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Services") != m.end() && !m["Services"].empty()) {
      if (typeid(vector<boost::any>) == m["Services"].type()) {
        vector<GetK8sServicesResponseBodyServices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Services"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetK8sServicesResponseBodyServices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        services = make_shared<vector<GetK8sServicesResponseBodyServices>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~GetK8sServicesResponseBody() = default;
};
class GetK8sServicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetK8sServicesResponseBody> body{};

  GetK8sServicesResponse() {}

  explicit GetK8sServicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetK8sServicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetK8sServicesResponseBody>(model1);
      }
    }
  }


  virtual ~GetK8sServicesResponse() = default;
};
class GetMockRuleByConsumerAppIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> region{};
  shared_ptr<string> consumerAppId{};

  GetMockRuleByConsumerAppIdRequest() {}

  explicit GetMockRuleByConsumerAppIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (consumerAppId) {
      res["ConsumerAppId"] = boost::any(*consumerAppId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ConsumerAppId") != m.end() && !m["ConsumerAppId"].empty()) {
      consumerAppId = make_shared<string>(boost::any_cast<string>(m["ConsumerAppId"]));
    }
  }


  virtual ~GetMockRuleByConsumerAppIdRequest() = default;
};
class GetMockRuleByConsumerAppIdResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<string> scMockItemJson{};
  shared_ptr<string> consumerAppName{};
  shared_ptr<string> consumerAppId{};
  shared_ptr<string> accountId{};
  shared_ptr<string> extraJson{};
  shared_ptr<string> source{};
  shared_ptr<string> region{};
  shared_ptr<string> providerAppId{};
  shared_ptr<string> providerAppName{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};
  shared_ptr<bool> enable{};

  GetMockRuleByConsumerAppIdResponseBodyData() {}

  explicit GetMockRuleByConsumerAppIdResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (scMockItemJson) {
      res["ScMockItemJson"] = boost::any(*scMockItemJson);
    }
    if (consumerAppName) {
      res["ConsumerAppName"] = boost::any(*consumerAppName);
    }
    if (consumerAppId) {
      res["ConsumerAppId"] = boost::any(*consumerAppId);
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (extraJson) {
      res["ExtraJson"] = boost::any(*extraJson);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (providerAppId) {
      res["ProviderAppId"] = boost::any(*providerAppId);
    }
    if (providerAppName) {
      res["ProviderAppName"] = boost::any(*providerAppName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("ScMockItemJson") != m.end() && !m["ScMockItemJson"].empty()) {
      scMockItemJson = make_shared<string>(boost::any_cast<string>(m["ScMockItemJson"]));
    }
    if (m.find("ConsumerAppName") != m.end() && !m["ConsumerAppName"].empty()) {
      consumerAppName = make_shared<string>(boost::any_cast<string>(m["ConsumerAppName"]));
    }
    if (m.find("ConsumerAppId") != m.end() && !m["ConsumerAppId"].empty()) {
      consumerAppId = make_shared<string>(boost::any_cast<string>(m["ConsumerAppId"]));
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ExtraJson") != m.end() && !m["ExtraJson"].empty()) {
      extraJson = make_shared<string>(boost::any_cast<string>(m["ExtraJson"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ProviderAppId") != m.end() && !m["ProviderAppId"].empty()) {
      providerAppId = make_shared<string>(boost::any_cast<string>(m["ProviderAppId"]));
    }
    if (m.find("ProviderAppName") != m.end() && !m["ProviderAppName"].empty()) {
      providerAppName = make_shared<string>(boost::any_cast<string>(m["ProviderAppName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
  }


  virtual ~GetMockRuleByConsumerAppIdResponseBodyData() = default;
};
class GetMockRuleByConsumerAppIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetMockRuleByConsumerAppIdResponseBodyData>> data{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetMockRuleByConsumerAppIdResponseBody() {}

  explicit GetMockRuleByConsumerAppIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetMockRuleByConsumerAppIdResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMockRuleByConsumerAppIdResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetMockRuleByConsumerAppIdResponseBodyData>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetMockRuleByConsumerAppIdResponseBody() = default;
};
class GetMockRuleByConsumerAppIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetMockRuleByConsumerAppIdResponseBody> body{};

  GetMockRuleByConsumerAppIdResponse() {}

  explicit GetMockRuleByConsumerAppIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMockRuleByConsumerAppIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMockRuleByConsumerAppIdResponseBody>(model1);
      }
    }
  }


  virtual ~GetMockRuleByConsumerAppIdResponse() = default;
};
class GetMockRuleByIdRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  GetMockRuleByIdRequest() {}

  explicit GetMockRuleByIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetMockRuleByIdRequest() = default;
};
class GetMockRuleByIdResponseBodyDataDubboMockItems : public Darabonba::Model {
public:
  shared_ptr<string> paramTypes{};
  shared_ptr<string> methodName{};
  shared_ptr<string> value{};
  shared_ptr<string> oper{};
  shared_ptr<string> exceptionMessage{};
  shared_ptr<string> executeCondition{};
  shared_ptr<string> version{};
  shared_ptr<string> path{};
  shared_ptr<string> exceptionClassName{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> group{};

  GetMockRuleByIdResponseBodyDataDubboMockItems() {}

  explicit GetMockRuleByIdResponseBodyDataDubboMockItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (paramTypes) {
      res["ParamTypes"] = boost::any(*paramTypes);
    }
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (oper) {
      res["Oper"] = boost::any(*oper);
    }
    if (exceptionMessage) {
      res["ExceptionMessage"] = boost::any(*exceptionMessage);
    }
    if (executeCondition) {
      res["ExecuteCondition"] = boost::any(*executeCondition);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (exceptionClassName) {
      res["ExceptionClassName"] = boost::any(*exceptionClassName);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParamTypes") != m.end() && !m["ParamTypes"].empty()) {
      paramTypes = make_shared<string>(boost::any_cast<string>(m["ParamTypes"]));
    }
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Oper") != m.end() && !m["Oper"].empty()) {
      oper = make_shared<string>(boost::any_cast<string>(m["Oper"]));
    }
    if (m.find("ExceptionMessage") != m.end() && !m["ExceptionMessage"].empty()) {
      exceptionMessage = make_shared<string>(boost::any_cast<string>(m["ExceptionMessage"]));
    }
    if (m.find("ExecuteCondition") != m.end() && !m["ExecuteCondition"].empty()) {
      executeCondition = make_shared<string>(boost::any_cast<string>(m["ExecuteCondition"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ExceptionClassName") != m.end() && !m["ExceptionClassName"].empty()) {
      exceptionClassName = make_shared<string>(boost::any_cast<string>(m["ExceptionClassName"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
  }


  virtual ~GetMockRuleByIdResponseBodyDataDubboMockItems() = default;
};
class GetMockRuleByIdResponseBodyDataScMockItems : public Darabonba::Model {
public:
  shared_ptr<string> value{};
  shared_ptr<string> oper{};
  shared_ptr<string> executeCondition{};
  shared_ptr<string> path{};
  shared_ptr<string> method{};
  shared_ptr<string> exceptionClassName{};
  shared_ptr<string> serviceName{};

  GetMockRuleByIdResponseBodyDataScMockItems() {}

  explicit GetMockRuleByIdResponseBodyDataScMockItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (oper) {
      res["Oper"] = boost::any(*oper);
    }
    if (executeCondition) {
      res["ExecuteCondition"] = boost::any(*executeCondition);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (exceptionClassName) {
      res["ExceptionClassName"] = boost::any(*exceptionClassName);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Oper") != m.end() && !m["Oper"].empty()) {
      oper = make_shared<string>(boost::any_cast<string>(m["Oper"]));
    }
    if (m.find("ExecuteCondition") != m.end() && !m["ExecuteCondition"].empty()) {
      executeCondition = make_shared<string>(boost::any_cast<string>(m["ExecuteCondition"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("ExceptionClassName") != m.end() && !m["ExceptionClassName"].empty()) {
      exceptionClassName = make_shared<string>(boost::any_cast<string>(m["ExceptionClassName"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~GetMockRuleByIdResponseBodyDataScMockItems() = default;
};
class GetMockRuleByIdResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetMockRuleByIdResponseBodyDataDubboMockItems>> dubboMockItems{};
  shared_ptr<string> consumerAppName{};
  shared_ptr<string> consumerAppId{};
  shared_ptr<string> accountId{};
  shared_ptr<string> extraJson{};
  shared_ptr<string> source{};
  shared_ptr<string> region{};
  shared_ptr<vector<GetMockRuleByIdResponseBodyDataScMockItems>> scMockItems{};
  shared_ptr<string> providerAppId{};
  shared_ptr<string> providerAppName{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};
  shared_ptr<bool> enable{};

  GetMockRuleByIdResponseBodyData() {}

  explicit GetMockRuleByIdResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dubboMockItems) {
      vector<boost::any> temp1;
      for(auto item1:*dubboMockItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DubboMockItems"] = boost::any(temp1);
    }
    if (consumerAppName) {
      res["ConsumerAppName"] = boost::any(*consumerAppName);
    }
    if (consumerAppId) {
      res["ConsumerAppId"] = boost::any(*consumerAppId);
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (extraJson) {
      res["ExtraJson"] = boost::any(*extraJson);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (scMockItems) {
      vector<boost::any> temp1;
      for(auto item1:*scMockItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScMockItems"] = boost::any(temp1);
    }
    if (providerAppId) {
      res["ProviderAppId"] = boost::any(*providerAppId);
    }
    if (providerAppName) {
      res["ProviderAppName"] = boost::any(*providerAppName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DubboMockItems") != m.end() && !m["DubboMockItems"].empty()) {
      if (typeid(vector<boost::any>) == m["DubboMockItems"].type()) {
        vector<GetMockRuleByIdResponseBodyDataDubboMockItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DubboMockItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMockRuleByIdResponseBodyDataDubboMockItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dubboMockItems = make_shared<vector<GetMockRuleByIdResponseBodyDataDubboMockItems>>(expect1);
      }
    }
    if (m.find("ConsumerAppName") != m.end() && !m["ConsumerAppName"].empty()) {
      consumerAppName = make_shared<string>(boost::any_cast<string>(m["ConsumerAppName"]));
    }
    if (m.find("ConsumerAppId") != m.end() && !m["ConsumerAppId"].empty()) {
      consumerAppId = make_shared<string>(boost::any_cast<string>(m["ConsumerAppId"]));
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ExtraJson") != m.end() && !m["ExtraJson"].empty()) {
      extraJson = make_shared<string>(boost::any_cast<string>(m["ExtraJson"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ScMockItems") != m.end() && !m["ScMockItems"].empty()) {
      if (typeid(vector<boost::any>) == m["ScMockItems"].type()) {
        vector<GetMockRuleByIdResponseBodyDataScMockItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScMockItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMockRuleByIdResponseBodyDataScMockItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scMockItems = make_shared<vector<GetMockRuleByIdResponseBodyDataScMockItems>>(expect1);
      }
    }
    if (m.find("ProviderAppId") != m.end() && !m["ProviderAppId"].empty()) {
      providerAppId = make_shared<string>(boost::any_cast<string>(m["ProviderAppId"]));
    }
    if (m.find("ProviderAppName") != m.end() && !m["ProviderAppName"].empty()) {
      providerAppName = make_shared<string>(boost::any_cast<string>(m["ProviderAppName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
  }


  virtual ~GetMockRuleByIdResponseBodyData() = default;
};
class GetMockRuleByIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<GetMockRuleByIdResponseBodyData> data{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetMockRuleByIdResponseBody() {}

  explicit GetMockRuleByIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMockRuleByIdResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMockRuleByIdResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetMockRuleByIdResponseBody() = default;
};
class GetMockRuleByIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetMockRuleByIdResponseBody> body{};

  GetMockRuleByIdResponse() {}

  explicit GetMockRuleByIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMockRuleByIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMockRuleByIdResponseBody>(model1);
      }
    }
  }


  virtual ~GetMockRuleByIdResponse() = default;
};
class GetMockRuleByProviderAppIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> region{};
  shared_ptr<string> providerAppId{};

  GetMockRuleByProviderAppIdRequest() {}

  explicit GetMockRuleByProviderAppIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (providerAppId) {
      res["ProviderAppId"] = boost::any(*providerAppId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ProviderAppId") != m.end() && !m["ProviderAppId"].empty()) {
      providerAppId = make_shared<string>(boost::any_cast<string>(m["ProviderAppId"]));
    }
  }


  virtual ~GetMockRuleByProviderAppIdRequest() = default;
};
class GetMockRuleByProviderAppIdResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<string> scMockItemJson{};
  shared_ptr<string> consumerAppName{};
  shared_ptr<string> consumerAppId{};
  shared_ptr<string> accountId{};
  shared_ptr<string> extraJson{};
  shared_ptr<string> source{};
  shared_ptr<string> region{};
  shared_ptr<string> providerAppId{};
  shared_ptr<string> providerAppName{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};
  shared_ptr<bool> enable{};

  GetMockRuleByProviderAppIdResponseBodyData() {}

  explicit GetMockRuleByProviderAppIdResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (scMockItemJson) {
      res["ScMockItemJson"] = boost::any(*scMockItemJson);
    }
    if (consumerAppName) {
      res["ConsumerAppName"] = boost::any(*consumerAppName);
    }
    if (consumerAppId) {
      res["ConsumerAppId"] = boost::any(*consumerAppId);
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (extraJson) {
      res["ExtraJson"] = boost::any(*extraJson);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (providerAppId) {
      res["ProviderAppId"] = boost::any(*providerAppId);
    }
    if (providerAppName) {
      res["ProviderAppName"] = boost::any(*providerAppName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("ScMockItemJson") != m.end() && !m["ScMockItemJson"].empty()) {
      scMockItemJson = make_shared<string>(boost::any_cast<string>(m["ScMockItemJson"]));
    }
    if (m.find("ConsumerAppName") != m.end() && !m["ConsumerAppName"].empty()) {
      consumerAppName = make_shared<string>(boost::any_cast<string>(m["ConsumerAppName"]));
    }
    if (m.find("ConsumerAppId") != m.end() && !m["ConsumerAppId"].empty()) {
      consumerAppId = make_shared<string>(boost::any_cast<string>(m["ConsumerAppId"]));
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ExtraJson") != m.end() && !m["ExtraJson"].empty()) {
      extraJson = make_shared<string>(boost::any_cast<string>(m["ExtraJson"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ProviderAppId") != m.end() && !m["ProviderAppId"].empty()) {
      providerAppId = make_shared<string>(boost::any_cast<string>(m["ProviderAppId"]));
    }
    if (m.find("ProviderAppName") != m.end() && !m["ProviderAppName"].empty()) {
      providerAppName = make_shared<string>(boost::any_cast<string>(m["ProviderAppName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
  }


  virtual ~GetMockRuleByProviderAppIdResponseBodyData() = default;
};
class GetMockRuleByProviderAppIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetMockRuleByProviderAppIdResponseBodyData>> data{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetMockRuleByProviderAppIdResponseBody() {}

  explicit GetMockRuleByProviderAppIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetMockRuleByProviderAppIdResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMockRuleByProviderAppIdResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetMockRuleByProviderAppIdResponseBodyData>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetMockRuleByProviderAppIdResponseBody() = default;
};
class GetMockRuleByProviderAppIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetMockRuleByProviderAppIdResponseBody> body{};

  GetMockRuleByProviderAppIdResponse() {}

  explicit GetMockRuleByProviderAppIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMockRuleByProviderAppIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMockRuleByProviderAppIdResponseBody>(model1);
      }
    }
  }


  virtual ~GetMockRuleByProviderAppIdResponse() = default;
};
class GetPackageStorageCredentialResponseBodyCredential : public Darabonba::Model {
public:
  shared_ptr<string> keyPrefix{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> accessKeySecret{};
  shared_ptr<string> expiration{};
  shared_ptr<string> accessKeyId{};
  shared_ptr<string> bucket{};
  shared_ptr<string> regionId{};

  GetPackageStorageCredentialResponseBodyCredential() {}

  explicit GetPackageStorageCredentialResponseBodyCredential(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPrefix) {
      res["KeyPrefix"] = boost::any(*keyPrefix);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (accessKeySecret) {
      res["AccessKeySecret"] = boost::any(*accessKeySecret);
    }
    if (expiration) {
      res["Expiration"] = boost::any(*expiration);
    }
    if (accessKeyId) {
      res["AccessKeyId"] = boost::any(*accessKeyId);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPrefix") != m.end() && !m["KeyPrefix"].empty()) {
      keyPrefix = make_shared<string>(boost::any_cast<string>(m["KeyPrefix"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("AccessKeySecret") != m.end() && !m["AccessKeySecret"].empty()) {
      accessKeySecret = make_shared<string>(boost::any_cast<string>(m["AccessKeySecret"]));
    }
    if (m.find("Expiration") != m.end() && !m["Expiration"].empty()) {
      expiration = make_shared<string>(boost::any_cast<string>(m["Expiration"]));
    }
    if (m.find("AccessKeyId") != m.end() && !m["AccessKeyId"].empty()) {
      accessKeyId = make_shared<string>(boost::any_cast<string>(m["AccessKeyId"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetPackageStorageCredentialResponseBodyCredential() = default;
};
class GetPackageStorageCredentialResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetPackageStorageCredentialResponseBodyCredential> credential{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  GetPackageStorageCredentialResponseBody() {}

  explicit GetPackageStorageCredentialResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credential) {
      res["Credential"] = credential ? boost::any(credential->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Credential") != m.end() && !m["Credential"].empty()) {
      if (typeid(map<string, boost::any>) == m["Credential"].type()) {
        GetPackageStorageCredentialResponseBodyCredential model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Credential"]));
        credential = make_shared<GetPackageStorageCredentialResponseBodyCredential>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~GetPackageStorageCredentialResponseBody() = default;
};
class GetPackageStorageCredentialResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetPackageStorageCredentialResponseBody> body{};

  GetPackageStorageCredentialResponse() {}

  explicit GetPackageStorageCredentialResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPackageStorageCredentialResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPackageStorageCredentialResponseBody>(model1);
      }
    }
  }


  virtual ~GetPackageStorageCredentialResponse() = default;
};
class GetScalingRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> mode{};

  GetScalingRulesRequest() {}

  explicit GetScalingRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
  }


  virtual ~GetScalingRulesRequest() = default;
};
class GetScalingRulesResponseBodyDataRuleListRule : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<long> updateTime{};
  shared_ptr<long> rt{};
  shared_ptr<long> createTime{};
  shared_ptr<string> resourceFrom{};
  shared_ptr<string> multiAzPolicy{};
  shared_ptr<string> specId{};
  shared_ptr<string> mode{};
  shared_ptr<long> loadNum{};
  shared_ptr<long> templateVersion{};
  shared_ptr<string> cond{};
  shared_ptr<long> step{};
  shared_ptr<long> cpu{};
  shared_ptr<string> groupId{};
  shared_ptr<long> instNum{};
  shared_ptr<string> appId{};
  shared_ptr<long> duration{};
  shared_ptr<string> vSwitchIds{};
  shared_ptr<string> metricType{};
  shared_ptr<string> templateId{};
  shared_ptr<bool> enable{};

  GetScalingRulesResponseBodyDataRuleListRule() {}

  explicit GetScalingRulesResponseBodyDataRuleListRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (rt) {
      res["Rt"] = boost::any(*rt);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (resourceFrom) {
      res["ResourceFrom"] = boost::any(*resourceFrom);
    }
    if (multiAzPolicy) {
      res["MultiAzPolicy"] = boost::any(*multiAzPolicy);
    }
    if (specId) {
      res["SpecId"] = boost::any(*specId);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (loadNum) {
      res["LoadNum"] = boost::any(*loadNum);
    }
    if (templateVersion) {
      res["TemplateVersion"] = boost::any(*templateVersion);
    }
    if (cond) {
      res["Cond"] = boost::any(*cond);
    }
    if (step) {
      res["Step"] = boost::any(*step);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instNum) {
      res["InstNum"] = boost::any(*instNum);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = boost::any(*vSwitchIds);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("Rt") != m.end() && !m["Rt"].empty()) {
      rt = make_shared<long>(boost::any_cast<long>(m["Rt"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ResourceFrom") != m.end() && !m["ResourceFrom"].empty()) {
      resourceFrom = make_shared<string>(boost::any_cast<string>(m["ResourceFrom"]));
    }
    if (m.find("MultiAzPolicy") != m.end() && !m["MultiAzPolicy"].empty()) {
      multiAzPolicy = make_shared<string>(boost::any_cast<string>(m["MultiAzPolicy"]));
    }
    if (m.find("SpecId") != m.end() && !m["SpecId"].empty()) {
      specId = make_shared<string>(boost::any_cast<string>(m["SpecId"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("LoadNum") != m.end() && !m["LoadNum"].empty()) {
      loadNum = make_shared<long>(boost::any_cast<long>(m["LoadNum"]));
    }
    if (m.find("TemplateVersion") != m.end() && !m["TemplateVersion"].empty()) {
      templateVersion = make_shared<long>(boost::any_cast<long>(m["TemplateVersion"]));
    }
    if (m.find("Cond") != m.end() && !m["Cond"].empty()) {
      cond = make_shared<string>(boost::any_cast<string>(m["Cond"]));
    }
    if (m.find("Step") != m.end() && !m["Step"].empty()) {
      step = make_shared<long>(boost::any_cast<long>(m["Step"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("InstNum") != m.end() && !m["InstNum"].empty()) {
      instNum = make_shared<long>(boost::any_cast<long>(m["InstNum"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      vSwitchIds = make_shared<string>(boost::any_cast<string>(m["VSwitchIds"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
  }


  virtual ~GetScalingRulesResponseBodyDataRuleListRule() = default;
};
class GetScalingRulesResponseBodyDataRuleList : public Darabonba::Model {
public:
  shared_ptr<vector<GetScalingRulesResponseBodyDataRuleListRule>> rule{};

  GetScalingRulesResponseBodyDataRuleList() {}

  explicit GetScalingRulesResponseBodyDataRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rule) {
      vector<boost::any> temp1;
      for(auto item1:*rule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(vector<boost::any>) == m["Rule"].type()) {
        vector<GetScalingRulesResponseBodyDataRuleListRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetScalingRulesResponseBodyDataRuleListRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rule = make_shared<vector<GetScalingRulesResponseBodyDataRuleListRule>>(expect1);
      }
    }
  }


  virtual ~GetScalingRulesResponseBodyDataRuleList() = default;
};
class GetScalingRulesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> oversoldFactor{};
  shared_ptr<string> vpcId{};
  shared_ptr<long> updateTime{};
  shared_ptr<long> clusterType{};
  shared_ptr<GetScalingRulesResponseBodyDataRuleList> ruleList{};

  GetScalingRulesResponseBodyData() {}

  explicit GetScalingRulesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (oversoldFactor) {
      res["OversoldFactor"] = boost::any(*oversoldFactor);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (ruleList) {
      res["RuleList"] = ruleList ? boost::any(ruleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OversoldFactor") != m.end() && !m["OversoldFactor"].empty()) {
      oversoldFactor = make_shared<long>(boost::any_cast<long>(m["OversoldFactor"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<long>(boost::any_cast<long>(m["ClusterType"]));
    }
    if (m.find("RuleList") != m.end() && !m["RuleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleList"].type()) {
        GetScalingRulesResponseBodyDataRuleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleList"]));
        ruleList = make_shared<GetScalingRulesResponseBodyDataRuleList>(model1);
      }
    }
  }


  virtual ~GetScalingRulesResponseBodyData() = default;
};
class GetScalingRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> updateTime{};
  shared_ptr<GetScalingRulesResponseBodyData> data{};
  shared_ptr<long> code{};

  GetScalingRulesResponseBody() {}

  explicit GetScalingRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetScalingRulesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetScalingRulesResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~GetScalingRulesResponseBody() = default;
};
class GetScalingRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetScalingRulesResponseBody> body{};

  GetScalingRulesResponse() {}

  explicit GetScalingRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetScalingRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetScalingRulesResponseBody>(model1);
      }
    }
  }


  virtual ~GetScalingRulesResponse() = default;
};
class GetSecureTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};

  GetSecureTokenRequest() {}

  explicit GetSecureTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~GetSecureTokenRequest() = default;
};
class GetSecureTokenResponseBodySecureToken : public Darabonba::Model {
public:
  shared_ptr<string> secretKey{};
  shared_ptr<string> accessKey{};
  shared_ptr<string> belongRegion{};
  shared_ptr<string> description{};
  shared_ptr<string> regionName{};
  shared_ptr<string> edasId{};
  shared_ptr<string> addressServerHost{};
  shared_ptr<string> userId{};
  shared_ptr<long> id{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> regionId{};

  GetSecureTokenResponseBodySecureToken() {}

  explicit GetSecureTokenResponseBodySecureToken(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (secretKey) {
      res["SecretKey"] = boost::any(*secretKey);
    }
    if (accessKey) {
      res["AccessKey"] = boost::any(*accessKey);
    }
    if (belongRegion) {
      res["BelongRegion"] = boost::any(*belongRegion);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (edasId) {
      res["EdasId"] = boost::any(*edasId);
    }
    if (addressServerHost) {
      res["AddressServerHost"] = boost::any(*addressServerHost);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecretKey") != m.end() && !m["SecretKey"].empty()) {
      secretKey = make_shared<string>(boost::any_cast<string>(m["SecretKey"]));
    }
    if (m.find("AccessKey") != m.end() && !m["AccessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["AccessKey"]));
    }
    if (m.find("BelongRegion") != m.end() && !m["BelongRegion"].empty()) {
      belongRegion = make_shared<string>(boost::any_cast<string>(m["BelongRegion"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("EdasId") != m.end() && !m["EdasId"].empty()) {
      edasId = make_shared<string>(boost::any_cast<string>(m["EdasId"]));
    }
    if (m.find("AddressServerHost") != m.end() && !m["AddressServerHost"].empty()) {
      addressServerHost = make_shared<string>(boost::any_cast<string>(m["AddressServerHost"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetSecureTokenResponseBodySecureToken() = default;
};
class GetSecureTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetSecureTokenResponseBodySecureToken> secureToken{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  GetSecureTokenResponseBody() {}

  explicit GetSecureTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (secureToken) {
      res["SecureToken"] = secureToken ? boost::any(secureToken->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecureToken") != m.end() && !m["SecureToken"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecureToken"].type()) {
        GetSecureTokenResponseBodySecureToken model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecureToken"]));
        secureToken = make_shared<GetSecureTokenResponseBodySecureToken>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~GetSecureTokenResponseBody() = default;
};
class GetSecureTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetSecureTokenResponseBody> body{};

  GetSecureTokenResponse() {}

  explicit GetSecureTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSecureTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSecureTokenResponseBody>(model1);
      }
    }
  }


  virtual ~GetSecureTokenResponse() = default;
};
class GetServiceConsumersPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> region{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> origin{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> appId{};
  shared_ptr<string> source{};
  shared_ptr<string> serviceId{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceVersion{};
  shared_ptr<string> group{};
  shared_ptr<string> ip{};
  shared_ptr<string> registryType{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};

  GetServiceConsumersPageRequest() {}

  explicit GetServiceConsumersPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      res["region"] = boost::any(*region);
    }
    if (namespace_) {
      res["namespace"] = boost::any(*namespace_);
    }
    if (origin) {
      res["origin"] = boost::any(*origin);
    }
    if (serviceType) {
      res["serviceType"] = boost::any(*serviceType);
    }
    if (appId) {
      res["appId"] = boost::any(*appId);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (serviceId) {
      res["serviceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    if (serviceVersion) {
      res["serviceVersion"] = boost::any(*serviceVersion);
    }
    if (group) {
      res["group"] = boost::any(*group);
    }
    if (ip) {
      res["ip"] = boost::any(*ip);
    }
    if (registryType) {
      res["registryType"] = boost::any(*registryType);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("region") != m.end() && !m["region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["region"]));
    }
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["namespace"]));
    }
    if (m.find("origin") != m.end() && !m["origin"].empty()) {
      origin = make_shared<string>(boost::any_cast<string>(m["origin"]));
    }
    if (m.find("serviceType") != m.end() && !m["serviceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["serviceType"]));
    }
    if (m.find("appId") != m.end() && !m["appId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["appId"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("serviceId") != m.end() && !m["serviceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["serviceId"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
    if (m.find("serviceVersion") != m.end() && !m["serviceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["serviceVersion"]));
    }
    if (m.find("group") != m.end() && !m["group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["group"]));
    }
    if (m.find("ip") != m.end() && !m["ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["ip"]));
    }
    if (m.find("registryType") != m.end() && !m["registryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["registryType"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
  }


  virtual ~GetServiceConsumersPageRequest() = default;
};
class GetServiceConsumersPageResponseBodyDataContent : public Darabonba::Model {
public:
  shared_ptr<string> edasAppName{};
  shared_ptr<string> ip{};
  shared_ptr<string> edassAppId{};

  GetServiceConsumersPageResponseBodyDataContent() {}

  explicit GetServiceConsumersPageResponseBodyDataContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edasAppName) {
      res["EdasAppName"] = boost::any(*edasAppName);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (edassAppId) {
      res["EdassAppId"] = boost::any(*edassAppId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EdasAppName") != m.end() && !m["EdasAppName"].empty()) {
      edasAppName = make_shared<string>(boost::any_cast<string>(m["EdasAppName"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("EdassAppId") != m.end() && !m["EdassAppId"].empty()) {
      edassAppId = make_shared<string>(boost::any_cast<string>(m["EdassAppId"]));
    }
  }


  virtual ~GetServiceConsumersPageResponseBodyDataContent() = default;
};
class GetServiceConsumersPageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> size{};
  shared_ptr<long> totalPages{};
  shared_ptr<long> totalElements{};
  shared_ptr<vector<GetServiceConsumersPageResponseBodyDataContent>> content{};

  GetServiceConsumersPageResponseBodyData() {}

  explicit GetServiceConsumersPageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    if (totalElements) {
      res["TotalElements"] = boost::any(*totalElements);
    }
    if (content) {
      vector<boost::any> temp1;
      for(auto item1:*content){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Content"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
    if (m.find("TotalElements") != m.end() && !m["TotalElements"].empty()) {
      totalElements = make_shared<long>(boost::any_cast<long>(m["TotalElements"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(vector<boost::any>) == m["Content"].type()) {
        vector<GetServiceConsumersPageResponseBodyDataContent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Content"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceConsumersPageResponseBodyDataContent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        content = make_shared<vector<GetServiceConsumersPageResponseBodyDataContent>>(expect1);
      }
    }
  }


  virtual ~GetServiceConsumersPageResponseBodyData() = default;
};
class GetServiceConsumersPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<GetServiceConsumersPageResponseBodyData> data{};
  shared_ptr<long> code{};
  shared_ptr<bool> success{};

  GetServiceConsumersPageResponseBody() {}

  explicit GetServiceConsumersPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetServiceConsumersPageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetServiceConsumersPageResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetServiceConsumersPageResponseBody() = default;
};
class GetServiceConsumersPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetServiceConsumersPageResponseBody> body{};

  GetServiceConsumersPageResponse() {}

  explicit GetServiceConsumersPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetServiceConsumersPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetServiceConsumersPageResponseBody>(model1);
      }
    }
  }


  virtual ~GetServiceConsumersPageResponse() = default;
};
class GetServiceDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> region{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> origin{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> appId{};
  shared_ptr<string> source{};
  shared_ptr<string> serviceId{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceVersion{};
  shared_ptr<string> group{};
  shared_ptr<string> ip{};
  shared_ptr<string> registryType{};

  GetServiceDetailRequest() {}

  explicit GetServiceDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      res["region"] = boost::any(*region);
    }
    if (namespace_) {
      res["namespace"] = boost::any(*namespace_);
    }
    if (origin) {
      res["origin"] = boost::any(*origin);
    }
    if (serviceType) {
      res["serviceType"] = boost::any(*serviceType);
    }
    if (appId) {
      res["appId"] = boost::any(*appId);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (serviceId) {
      res["serviceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    if (serviceVersion) {
      res["serviceVersion"] = boost::any(*serviceVersion);
    }
    if (group) {
      res["group"] = boost::any(*group);
    }
    if (ip) {
      res["ip"] = boost::any(*ip);
    }
    if (registryType) {
      res["registryType"] = boost::any(*registryType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("region") != m.end() && !m["region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["region"]));
    }
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["namespace"]));
    }
    if (m.find("origin") != m.end() && !m["origin"].empty()) {
      origin = make_shared<string>(boost::any_cast<string>(m["origin"]));
    }
    if (m.find("serviceType") != m.end() && !m["serviceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["serviceType"]));
    }
    if (m.find("appId") != m.end() && !m["appId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["appId"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("serviceId") != m.end() && !m["serviceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["serviceId"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
    if (m.find("serviceVersion") != m.end() && !m["serviceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["serviceVersion"]));
    }
    if (m.find("group") != m.end() && !m["group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["group"]));
    }
    if (m.find("ip") != m.end() && !m["ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["ip"]));
    }
    if (m.find("registryType") != m.end() && !m["registryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["registryType"]));
    }
  }


  virtual ~GetServiceDetailRequest() = default;
};
class GetServiceDetailResponseBodyDataMethodsReturnDefinition : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> id{};

  GetServiceDetailResponseBodyDataMethodsReturnDefinition() {}

  explicit GetServiceDetailResponseBodyDataMethodsReturnDefinition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetServiceDetailResponseBodyDataMethodsReturnDefinition() = default;
};
class GetServiceDetailResponseBodyDataMethods : public Darabonba::Model {
public:
  shared_ptr<string> parameterDetails{};
  shared_ptr<string> parameterNames{};
  shared_ptr<string> paths{};
  shared_ptr<string> parameterTypes{};
  shared_ptr<string> returnType{};
  shared_ptr<string> nameDetail{};
  shared_ptr<string> parameterDefinitions{};
  shared_ptr<GetServiceDetailResponseBodyDataMethodsReturnDefinition> returnDefinition{};
  shared_ptr<string> requestMethods{};
  shared_ptr<string> returnDetails{};
  shared_ptr<string> name{};
  shared_ptr<string> methodController{};

  GetServiceDetailResponseBodyDataMethods() {}

  explicit GetServiceDetailResponseBodyDataMethods(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterDetails) {
      res["ParameterDetails"] = boost::any(*parameterDetails);
    }
    if (parameterNames) {
      res["ParameterNames"] = boost::any(*parameterNames);
    }
    if (paths) {
      res["Paths"] = boost::any(*paths);
    }
    if (parameterTypes) {
      res["ParameterTypes"] = boost::any(*parameterTypes);
    }
    if (returnType) {
      res["ReturnType"] = boost::any(*returnType);
    }
    if (nameDetail) {
      res["NameDetail"] = boost::any(*nameDetail);
    }
    if (parameterDefinitions) {
      res["ParameterDefinitions"] = boost::any(*parameterDefinitions);
    }
    if (returnDefinition) {
      res["ReturnDefinition"] = returnDefinition ? boost::any(returnDefinition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestMethods) {
      res["RequestMethods"] = boost::any(*requestMethods);
    }
    if (returnDetails) {
      res["ReturnDetails"] = boost::any(*returnDetails);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (methodController) {
      res["MethodController"] = boost::any(*methodController);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterDetails") != m.end() && !m["ParameterDetails"].empty()) {
      parameterDetails = make_shared<string>(boost::any_cast<string>(m["ParameterDetails"]));
    }
    if (m.find("ParameterNames") != m.end() && !m["ParameterNames"].empty()) {
      parameterNames = make_shared<string>(boost::any_cast<string>(m["ParameterNames"]));
    }
    if (m.find("Paths") != m.end() && !m["Paths"].empty()) {
      paths = make_shared<string>(boost::any_cast<string>(m["Paths"]));
    }
    if (m.find("ParameterTypes") != m.end() && !m["ParameterTypes"].empty()) {
      parameterTypes = make_shared<string>(boost::any_cast<string>(m["ParameterTypes"]));
    }
    if (m.find("ReturnType") != m.end() && !m["ReturnType"].empty()) {
      returnType = make_shared<string>(boost::any_cast<string>(m["ReturnType"]));
    }
    if (m.find("NameDetail") != m.end() && !m["NameDetail"].empty()) {
      nameDetail = make_shared<string>(boost::any_cast<string>(m["NameDetail"]));
    }
    if (m.find("ParameterDefinitions") != m.end() && !m["ParameterDefinitions"].empty()) {
      parameterDefinitions = make_shared<string>(boost::any_cast<string>(m["ParameterDefinitions"]));
    }
    if (m.find("ReturnDefinition") != m.end() && !m["ReturnDefinition"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReturnDefinition"].type()) {
        GetServiceDetailResponseBodyDataMethodsReturnDefinition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReturnDefinition"]));
        returnDefinition = make_shared<GetServiceDetailResponseBodyDataMethodsReturnDefinition>(model1);
      }
    }
    if (m.find("RequestMethods") != m.end() && !m["RequestMethods"].empty()) {
      requestMethods = make_shared<string>(boost::any_cast<string>(m["RequestMethods"]));
    }
    if (m.find("ReturnDetails") != m.end() && !m["ReturnDetails"].empty()) {
      returnDetails = make_shared<string>(boost::any_cast<string>(m["ReturnDetails"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("MethodController") != m.end() && !m["MethodController"].empty()) {
      methodController = make_shared<string>(boost::any_cast<string>(m["MethodController"]));
    }
  }


  virtual ~GetServiceDetailResponseBodyDataMethods() = default;
};
class GetServiceDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> edasAppName{};
  shared_ptr<string> dubboApplicationName{};
  shared_ptr<string> version{};
  shared_ptr<string> registryType{};
  shared_ptr<string> springApplicationName{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> serviceName{};
  shared_ptr<vector<GetServiceDetailResponseBodyDataMethods>> methods{};
  shared_ptr<string> metadata{};
  shared_ptr<string> group{};

  GetServiceDetailResponseBodyData() {}

  explicit GetServiceDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edasAppName) {
      res["EdasAppName"] = boost::any(*edasAppName);
    }
    if (dubboApplicationName) {
      res["DubboApplicationName"] = boost::any(*dubboApplicationName);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (registryType) {
      res["RegistryType"] = boost::any(*registryType);
    }
    if (springApplicationName) {
      res["SpringApplicationName"] = boost::any(*springApplicationName);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (methods) {
      vector<boost::any> temp1;
      for(auto item1:*methods){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Methods"] = boost::any(temp1);
    }
    if (metadata) {
      res["Metadata"] = boost::any(*metadata);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EdasAppName") != m.end() && !m["EdasAppName"].empty()) {
      edasAppName = make_shared<string>(boost::any_cast<string>(m["EdasAppName"]));
    }
    if (m.find("DubboApplicationName") != m.end() && !m["DubboApplicationName"].empty()) {
      dubboApplicationName = make_shared<string>(boost::any_cast<string>(m["DubboApplicationName"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("RegistryType") != m.end() && !m["RegistryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["RegistryType"]));
    }
    if (m.find("SpringApplicationName") != m.end() && !m["SpringApplicationName"].empty()) {
      springApplicationName = make_shared<string>(boost::any_cast<string>(m["SpringApplicationName"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Methods") != m.end() && !m["Methods"].empty()) {
      if (typeid(vector<boost::any>) == m["Methods"].type()) {
        vector<GetServiceDetailResponseBodyDataMethods> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Methods"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceDetailResponseBodyDataMethods model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        methods = make_shared<vector<GetServiceDetailResponseBodyDataMethods>>(expect1);
      }
    }
    if (m.find("Metadata") != m.end() && !m["Metadata"].empty()) {
      metadata = make_shared<string>(boost::any_cast<string>(m["Metadata"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
  }


  virtual ~GetServiceDetailResponseBodyData() = default;
};
class GetServiceDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<GetServiceDetailResponseBodyData> data{};
  shared_ptr<long> code{};
  shared_ptr<bool> success{};

  GetServiceDetailResponseBody() {}

  explicit GetServiceDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetServiceDetailResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetServiceDetailResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetServiceDetailResponseBody() = default;
};
class GetServiceDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetServiceDetailResponseBody> body{};

  GetServiceDetailResponse() {}

  explicit GetServiceDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetServiceDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetServiceDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetServiceDetailResponse() = default;
};
class GetServiceListRequest : public Darabonba::Model {
public:
  shared_ptr<string> region{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> origin{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> searchType{};
  shared_ptr<string> searchValue{};
  shared_ptr<string> side{};

  GetServiceListRequest() {}

  explicit GetServiceListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      res["region"] = boost::any(*region);
    }
    if (namespace_) {
      res["namespace"] = boost::any(*namespace_);
    }
    if (origin) {
      res["origin"] = boost::any(*origin);
    }
    if (serviceType) {
      res["serviceType"] = boost::any(*serviceType);
    }
    if (searchType) {
      res["searchType"] = boost::any(*searchType);
    }
    if (searchValue) {
      res["searchValue"] = boost::any(*searchValue);
    }
    if (side) {
      res["side"] = boost::any(*side);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("region") != m.end() && !m["region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["region"]));
    }
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["namespace"]));
    }
    if (m.find("origin") != m.end() && !m["origin"].empty()) {
      origin = make_shared<string>(boost::any_cast<string>(m["origin"]));
    }
    if (m.find("serviceType") != m.end() && !m["serviceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["serviceType"]));
    }
    if (m.find("searchType") != m.end() && !m["searchType"].empty()) {
      searchType = make_shared<string>(boost::any_cast<string>(m["searchType"]));
    }
    if (m.find("searchValue") != m.end() && !m["searchValue"].empty()) {
      searchValue = make_shared<string>(boost::any_cast<string>(m["searchValue"]));
    }
    if (m.find("side") != m.end() && !m["side"].empty()) {
      side = make_shared<string>(boost::any_cast<string>(m["side"]));
    }
  }


  virtual ~GetServiceListRequest() = default;
};
class GetServiceListResponseBodyDataMethods : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> returnType{};
  shared_ptr<string> methodController{};
  shared_ptr<string> parameterNames{};
  shared_ptr<string> nameDetail{};
  shared_ptr<string> returnDetails{};
  shared_ptr<string> parameterTypes{};
  shared_ptr<string> parameterDetails{};
  shared_ptr<string> requestMethods{};
  shared_ptr<string> paths{};
  shared_ptr<string> parameterDefinitions{};

  GetServiceListResponseBodyDataMethods() {}

  explicit GetServiceListResponseBodyDataMethods(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (returnType) {
      res["ReturnType"] = boost::any(*returnType);
    }
    if (methodController) {
      res["MethodController"] = boost::any(*methodController);
    }
    if (parameterNames) {
      res["ParameterNames"] = boost::any(*parameterNames);
    }
    if (nameDetail) {
      res["NameDetail"] = boost::any(*nameDetail);
    }
    if (returnDetails) {
      res["ReturnDetails"] = boost::any(*returnDetails);
    }
    if (parameterTypes) {
      res["ParameterTypes"] = boost::any(*parameterTypes);
    }
    if (parameterDetails) {
      res["ParameterDetails"] = boost::any(*parameterDetails);
    }
    if (requestMethods) {
      res["RequestMethods"] = boost::any(*requestMethods);
    }
    if (paths) {
      res["Paths"] = boost::any(*paths);
    }
    if (parameterDefinitions) {
      res["ParameterDefinitions"] = boost::any(*parameterDefinitions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ReturnType") != m.end() && !m["ReturnType"].empty()) {
      returnType = make_shared<string>(boost::any_cast<string>(m["ReturnType"]));
    }
    if (m.find("MethodController") != m.end() && !m["MethodController"].empty()) {
      methodController = make_shared<string>(boost::any_cast<string>(m["MethodController"]));
    }
    if (m.find("ParameterNames") != m.end() && !m["ParameterNames"].empty()) {
      parameterNames = make_shared<string>(boost::any_cast<string>(m["ParameterNames"]));
    }
    if (m.find("NameDetail") != m.end() && !m["NameDetail"].empty()) {
      nameDetail = make_shared<string>(boost::any_cast<string>(m["NameDetail"]));
    }
    if (m.find("ReturnDetails") != m.end() && !m["ReturnDetails"].empty()) {
      returnDetails = make_shared<string>(boost::any_cast<string>(m["ReturnDetails"]));
    }
    if (m.find("ParameterTypes") != m.end() && !m["ParameterTypes"].empty()) {
      parameterTypes = make_shared<string>(boost::any_cast<string>(m["ParameterTypes"]));
    }
    if (m.find("ParameterDetails") != m.end() && !m["ParameterDetails"].empty()) {
      parameterDetails = make_shared<string>(boost::any_cast<string>(m["ParameterDetails"]));
    }
    if (m.find("RequestMethods") != m.end() && !m["RequestMethods"].empty()) {
      requestMethods = make_shared<string>(boost::any_cast<string>(m["RequestMethods"]));
    }
    if (m.find("Paths") != m.end() && !m["Paths"].empty()) {
      paths = make_shared<string>(boost::any_cast<string>(m["Paths"]));
    }
    if (m.find("ParameterDefinitions") != m.end() && !m["ParameterDefinitions"].empty()) {
      parameterDefinitions = make_shared<string>(boost::any_cast<string>(m["ParameterDefinitions"]));
    }
  }


  virtual ~GetServiceListResponseBodyDataMethods() = default;
};
class GetServiceListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> serviceName{};
  shared_ptr<string> edasAppName{};
  shared_ptr<string> dubboApplicationName{};
  shared_ptr<string> springApplicationName{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> registryType{};
  shared_ptr<string> version{};
  shared_ptr<string> group{};
  shared_ptr<string> metadata{};
  shared_ptr<vector<GetServiceListResponseBodyDataMethods>> methods{};

  GetServiceListResponseBodyData() {}

  explicit GetServiceListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (edasAppName) {
      res["EdasAppName"] = boost::any(*edasAppName);
    }
    if (dubboApplicationName) {
      res["DubboApplicationName"] = boost::any(*dubboApplicationName);
    }
    if (springApplicationName) {
      res["SpringApplicationName"] = boost::any(*springApplicationName);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (registryType) {
      res["RegistryType"] = boost::any(*registryType);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (metadata) {
      res["Metadata"] = boost::any(*metadata);
    }
    if (methods) {
      vector<boost::any> temp1;
      for(auto item1:*methods){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Methods"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("EdasAppName") != m.end() && !m["EdasAppName"].empty()) {
      edasAppName = make_shared<string>(boost::any_cast<string>(m["EdasAppName"]));
    }
    if (m.find("DubboApplicationName") != m.end() && !m["DubboApplicationName"].empty()) {
      dubboApplicationName = make_shared<string>(boost::any_cast<string>(m["DubboApplicationName"]));
    }
    if (m.find("SpringApplicationName") != m.end() && !m["SpringApplicationName"].empty()) {
      springApplicationName = make_shared<string>(boost::any_cast<string>(m["SpringApplicationName"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
    if (m.find("RegistryType") != m.end() && !m["RegistryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["RegistryType"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("Metadata") != m.end() && !m["Metadata"].empty()) {
      metadata = make_shared<string>(boost::any_cast<string>(m["Metadata"]));
    }
    if (m.find("Methods") != m.end() && !m["Methods"].empty()) {
      if (typeid(vector<boost::any>) == m["Methods"].type()) {
        vector<GetServiceListResponseBodyDataMethods> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Methods"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceListResponseBodyDataMethods model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        methods = make_shared<vector<GetServiceListResponseBodyDataMethods>>(expect1);
      }
    }
  }


  virtual ~GetServiceListResponseBodyData() = default;
};
class GetServiceListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};
  shared_ptr<vector<GetServiceListResponseBodyData>> data{};

  GetServiceListResponseBody() {}

  explicit GetServiceListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetServiceListResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceListResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetServiceListResponseBodyData>>(expect1);
      }
    }
  }


  virtual ~GetServiceListResponseBody() = default;
};
class GetServiceListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetServiceListResponseBody> body{};

  GetServiceListResponse() {}

  explicit GetServiceListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetServiceListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetServiceListResponseBody>(model1);
      }
    }
  }


  virtual ~GetServiceListResponse() = default;
};
class GetServiceListPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> region{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> origin{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> searchType{};
  shared_ptr<string> searchValue{};
  shared_ptr<string> side{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};

  GetServiceListPageRequest() {}

  explicit GetServiceListPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      res["region"] = boost::any(*region);
    }
    if (namespace_) {
      res["namespace"] = boost::any(*namespace_);
    }
    if (origin) {
      res["origin"] = boost::any(*origin);
    }
    if (serviceType) {
      res["serviceType"] = boost::any(*serviceType);
    }
    if (searchType) {
      res["searchType"] = boost::any(*searchType);
    }
    if (searchValue) {
      res["searchValue"] = boost::any(*searchValue);
    }
    if (side) {
      res["side"] = boost::any(*side);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("region") != m.end() && !m["region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["region"]));
    }
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["namespace"]));
    }
    if (m.find("origin") != m.end() && !m["origin"].empty()) {
      origin = make_shared<string>(boost::any_cast<string>(m["origin"]));
    }
    if (m.find("serviceType") != m.end() && !m["serviceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["serviceType"]));
    }
    if (m.find("searchType") != m.end() && !m["searchType"].empty()) {
      searchType = make_shared<string>(boost::any_cast<string>(m["searchType"]));
    }
    if (m.find("searchValue") != m.end() && !m["searchValue"].empty()) {
      searchValue = make_shared<string>(boost::any_cast<string>(m["searchValue"]));
    }
    if (m.find("side") != m.end() && !m["side"].empty()) {
      side = make_shared<string>(boost::any_cast<string>(m["side"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
  }


  virtual ~GetServiceListPageRequest() = default;
};
class GetServiceListPageResponseBodyDataContent : public Darabonba::Model {
public:
  shared_ptr<string> edasAppName{};
  shared_ptr<long> instanceNum{};
  shared_ptr<string> version{};
  shared_ptr<string> serviceId{};
  shared_ptr<string> edasAppId{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> registerType{};
  shared_ptr<string> group{};

  GetServiceListPageResponseBodyDataContent() {}

  explicit GetServiceListPageResponseBodyDataContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edasAppName) {
      res["EdasAppName"] = boost::any(*edasAppName);
    }
    if (instanceNum) {
      res["InstanceNum"] = boost::any(*instanceNum);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    if (edasAppId) {
      res["EdasAppId"] = boost::any(*edasAppId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (registerType) {
      res["RegisterType"] = boost::any(*registerType);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EdasAppName") != m.end() && !m["EdasAppName"].empty()) {
      edasAppName = make_shared<string>(boost::any_cast<string>(m["EdasAppName"]));
    }
    if (m.find("InstanceNum") != m.end() && !m["InstanceNum"].empty()) {
      instanceNum = make_shared<long>(boost::any_cast<long>(m["InstanceNum"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["ServiceId"]));
    }
    if (m.find("EdasAppId") != m.end() && !m["EdasAppId"].empty()) {
      edasAppId = make_shared<string>(boost::any_cast<string>(m["EdasAppId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("RegisterType") != m.end() && !m["RegisterType"].empty()) {
      registerType = make_shared<string>(boost::any_cast<string>(m["RegisterType"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
  }


  virtual ~GetServiceListPageResponseBodyDataContent() = default;
};
class GetServiceListPageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> size{};
  shared_ptr<long> totalPages{};
  shared_ptr<long> totalElements{};
  shared_ptr<vector<GetServiceListPageResponseBodyDataContent>> content{};

  GetServiceListPageResponseBodyData() {}

  explicit GetServiceListPageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    if (totalElements) {
      res["TotalElements"] = boost::any(*totalElements);
    }
    if (content) {
      vector<boost::any> temp1;
      for(auto item1:*content){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Content"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
    if (m.find("TotalElements") != m.end() && !m["TotalElements"].empty()) {
      totalElements = make_shared<long>(boost::any_cast<long>(m["TotalElements"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(vector<boost::any>) == m["Content"].type()) {
        vector<GetServiceListPageResponseBodyDataContent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Content"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceListPageResponseBodyDataContent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        content = make_shared<vector<GetServiceListPageResponseBodyDataContent>>(expect1);
      }
    }
  }


  virtual ~GetServiceListPageResponseBodyData() = default;
};
class GetServiceListPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<GetServiceListPageResponseBodyData> data{};
  shared_ptr<long> code{};
  shared_ptr<bool> success{};

  GetServiceListPageResponseBody() {}

  explicit GetServiceListPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetServiceListPageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetServiceListPageResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetServiceListPageResponseBody() = default;
};
class GetServiceListPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetServiceListPageResponseBody> body{};

  GetServiceListPageResponse() {}

  explicit GetServiceListPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetServiceListPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetServiceListPageResponseBody>(model1);
      }
    }
  }


  virtual ~GetServiceListPageResponse() = default;
};
class GetServiceMethodPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> region{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> origin{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> appId{};
  shared_ptr<string> source{};
  shared_ptr<string> serviceId{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceVersion{};
  shared_ptr<string> group{};
  shared_ptr<string> ip{};
  shared_ptr<string> registryType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> methodController{};
  shared_ptr<string> path{};
  shared_ptr<string> name{};

  GetServiceMethodPageRequest() {}

  explicit GetServiceMethodPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      res["region"] = boost::any(*region);
    }
    if (namespace_) {
      res["namespace"] = boost::any(*namespace_);
    }
    if (origin) {
      res["origin"] = boost::any(*origin);
    }
    if (serviceType) {
      res["serviceType"] = boost::any(*serviceType);
    }
    if (appId) {
      res["appId"] = boost::any(*appId);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (serviceId) {
      res["serviceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    if (serviceVersion) {
      res["serviceVersion"] = boost::any(*serviceVersion);
    }
    if (group) {
      res["group"] = boost::any(*group);
    }
    if (ip) {
      res["ip"] = boost::any(*ip);
    }
    if (registryType) {
      res["registryType"] = boost::any(*registryType);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (methodController) {
      res["methodController"] = boost::any(*methodController);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("region") != m.end() && !m["region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["region"]));
    }
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["namespace"]));
    }
    if (m.find("origin") != m.end() && !m["origin"].empty()) {
      origin = make_shared<string>(boost::any_cast<string>(m["origin"]));
    }
    if (m.find("serviceType") != m.end() && !m["serviceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["serviceType"]));
    }
    if (m.find("appId") != m.end() && !m["appId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["appId"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("serviceId") != m.end() && !m["serviceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["serviceId"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
    if (m.find("serviceVersion") != m.end() && !m["serviceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["serviceVersion"]));
    }
    if (m.find("group") != m.end() && !m["group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["group"]));
    }
    if (m.find("ip") != m.end() && !m["ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["ip"]));
    }
    if (m.find("registryType") != m.end() && !m["registryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["registryType"]));
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("methodController") != m.end() && !m["methodController"].empty()) {
      methodController = make_shared<string>(boost::any_cast<string>(m["methodController"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~GetServiceMethodPageRequest() = default;
};
class GetServiceMethodPageResponseBodyDataResultReturnDefinition : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> id{};

  GetServiceMethodPageResponseBodyDataResultReturnDefinition() {}

  explicit GetServiceMethodPageResponseBodyDataResultReturnDefinition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetServiceMethodPageResponseBodyDataResultReturnDefinition() = default;
};
class GetServiceMethodPageResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<string> parameterDetails{};
  shared_ptr<string> parameterNames{};
  shared_ptr<string> paths{};
  shared_ptr<string> parameterTypes{};
  shared_ptr<string> returnType{};
  shared_ptr<string> nameDetail{};
  shared_ptr<string> parameterDefinitions{};
  shared_ptr<GetServiceMethodPageResponseBodyDataResultReturnDefinition> returnDefinition{};
  shared_ptr<string> requestMethods{};
  shared_ptr<string> returnDetails{};
  shared_ptr<string> name{};
  shared_ptr<string> methodController{};

  GetServiceMethodPageResponseBodyDataResult() {}

  explicit GetServiceMethodPageResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterDetails) {
      res["ParameterDetails"] = boost::any(*parameterDetails);
    }
    if (parameterNames) {
      res["ParameterNames"] = boost::any(*parameterNames);
    }
    if (paths) {
      res["Paths"] = boost::any(*paths);
    }
    if (parameterTypes) {
      res["ParameterTypes"] = boost::any(*parameterTypes);
    }
    if (returnType) {
      res["ReturnType"] = boost::any(*returnType);
    }
    if (nameDetail) {
      res["NameDetail"] = boost::any(*nameDetail);
    }
    if (parameterDefinitions) {
      res["ParameterDefinitions"] = boost::any(*parameterDefinitions);
    }
    if (returnDefinition) {
      res["ReturnDefinition"] = returnDefinition ? boost::any(returnDefinition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestMethods) {
      res["RequestMethods"] = boost::any(*requestMethods);
    }
    if (returnDetails) {
      res["ReturnDetails"] = boost::any(*returnDetails);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (methodController) {
      res["MethodController"] = boost::any(*methodController);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterDetails") != m.end() && !m["ParameterDetails"].empty()) {
      parameterDetails = make_shared<string>(boost::any_cast<string>(m["ParameterDetails"]));
    }
    if (m.find("ParameterNames") != m.end() && !m["ParameterNames"].empty()) {
      parameterNames = make_shared<string>(boost::any_cast<string>(m["ParameterNames"]));
    }
    if (m.find("Paths") != m.end() && !m["Paths"].empty()) {
      paths = make_shared<string>(boost::any_cast<string>(m["Paths"]));
    }
    if (m.find("ParameterTypes") != m.end() && !m["ParameterTypes"].empty()) {
      parameterTypes = make_shared<string>(boost::any_cast<string>(m["ParameterTypes"]));
    }
    if (m.find("ReturnType") != m.end() && !m["ReturnType"].empty()) {
      returnType = make_shared<string>(boost::any_cast<string>(m["ReturnType"]));
    }
    if (m.find("NameDetail") != m.end() && !m["NameDetail"].empty()) {
      nameDetail = make_shared<string>(boost::any_cast<string>(m["NameDetail"]));
    }
    if (m.find("ParameterDefinitions") != m.end() && !m["ParameterDefinitions"].empty()) {
      parameterDefinitions = make_shared<string>(boost::any_cast<string>(m["ParameterDefinitions"]));
    }
    if (m.find("ReturnDefinition") != m.end() && !m["ReturnDefinition"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReturnDefinition"].type()) {
        GetServiceMethodPageResponseBodyDataResultReturnDefinition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReturnDefinition"]));
        returnDefinition = make_shared<GetServiceMethodPageResponseBodyDataResultReturnDefinition>(model1);
      }
    }
    if (m.find("RequestMethods") != m.end() && !m["RequestMethods"].empty()) {
      requestMethods = make_shared<string>(boost::any_cast<string>(m["RequestMethods"]));
    }
    if (m.find("ReturnDetails") != m.end() && !m["ReturnDetails"].empty()) {
      returnDetails = make_shared<string>(boost::any_cast<string>(m["ReturnDetails"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("MethodController") != m.end() && !m["MethodController"].empty()) {
      methodController = make_shared<string>(boost::any_cast<string>(m["MethodController"]));
    }
  }


  virtual ~GetServiceMethodPageResponseBodyDataResult() = default;
};
class GetServiceMethodPageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetServiceMethodPageResponseBodyDataResult>> result{};
  shared_ptr<long> totalSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  GetServiceMethodPageResponseBodyData() {}

  explicit GetServiceMethodPageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<GetServiceMethodPageResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceMethodPageResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<GetServiceMethodPageResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~GetServiceMethodPageResponseBodyData() = default;
};
class GetServiceMethodPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<GetServiceMethodPageResponseBodyData> data{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetServiceMethodPageResponseBody() {}

  explicit GetServiceMethodPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetServiceMethodPageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetServiceMethodPageResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetServiceMethodPageResponseBody() = default;
};
class GetServiceMethodPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetServiceMethodPageResponseBody> body{};

  GetServiceMethodPageResponse() {}

  explicit GetServiceMethodPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetServiceMethodPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetServiceMethodPageResponseBody>(model1);
      }
    }
  }


  virtual ~GetServiceMethodPageResponse() = default;
};
class GetServiceProvidersPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> region{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> origin{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> appId{};
  shared_ptr<string> source{};
  shared_ptr<string> serviceId{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceVersion{};
  shared_ptr<string> group{};
  shared_ptr<string> ip{};
  shared_ptr<string> registryType{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};

  GetServiceProvidersPageRequest() {}

  explicit GetServiceProvidersPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      res["region"] = boost::any(*region);
    }
    if (namespace_) {
      res["namespace"] = boost::any(*namespace_);
    }
    if (origin) {
      res["origin"] = boost::any(*origin);
    }
    if (serviceType) {
      res["serviceType"] = boost::any(*serviceType);
    }
    if (appId) {
      res["appId"] = boost::any(*appId);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (serviceId) {
      res["serviceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    if (serviceVersion) {
      res["serviceVersion"] = boost::any(*serviceVersion);
    }
    if (group) {
      res["group"] = boost::any(*group);
    }
    if (ip) {
      res["ip"] = boost::any(*ip);
    }
    if (registryType) {
      res["registryType"] = boost::any(*registryType);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("region") != m.end() && !m["region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["region"]));
    }
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["namespace"]));
    }
    if (m.find("origin") != m.end() && !m["origin"].empty()) {
      origin = make_shared<string>(boost::any_cast<string>(m["origin"]));
    }
    if (m.find("serviceType") != m.end() && !m["serviceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["serviceType"]));
    }
    if (m.find("appId") != m.end() && !m["appId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["appId"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("serviceId") != m.end() && !m["serviceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["serviceId"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
    if (m.find("serviceVersion") != m.end() && !m["serviceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["serviceVersion"]));
    }
    if (m.find("group") != m.end() && !m["group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["group"]));
    }
    if (m.find("ip") != m.end() && !m["ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["ip"]));
    }
    if (m.find("registryType") != m.end() && !m["registryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["registryType"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
  }


  virtual ~GetServiceProvidersPageRequest() = default;
};
class GetServiceProvidersPageResponseBodyDataContent : public Darabonba::Model {
public:
  shared_ptr<string> timeout{};
  shared_ptr<string> ip{};
  shared_ptr<string> port{};
  shared_ptr<string> serializeType{};

  GetServiceProvidersPageResponseBodyDataContent() {}

  explicit GetServiceProvidersPageResponseBodyDataContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (serializeType) {
      res["SerializeType"] = boost::any(*serializeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<string>(boost::any_cast<string>(m["Timeout"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("SerializeType") != m.end() && !m["SerializeType"].empty()) {
      serializeType = make_shared<string>(boost::any_cast<string>(m["SerializeType"]));
    }
  }


  virtual ~GetServiceProvidersPageResponseBodyDataContent() = default;
};
class GetServiceProvidersPageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> size{};
  shared_ptr<long> totalPages{};
  shared_ptr<long> totalElements{};
  shared_ptr<vector<GetServiceProvidersPageResponseBodyDataContent>> content{};

  GetServiceProvidersPageResponseBodyData() {}

  explicit GetServiceProvidersPageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    if (totalElements) {
      res["TotalElements"] = boost::any(*totalElements);
    }
    if (content) {
      vector<boost::any> temp1;
      for(auto item1:*content){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Content"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
    if (m.find("TotalElements") != m.end() && !m["TotalElements"].empty()) {
      totalElements = make_shared<long>(boost::any_cast<long>(m["TotalElements"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(vector<boost::any>) == m["Content"].type()) {
        vector<GetServiceProvidersPageResponseBodyDataContent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Content"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceProvidersPageResponseBodyDataContent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        content = make_shared<vector<GetServiceProvidersPageResponseBodyDataContent>>(expect1);
      }
    }
  }


  virtual ~GetServiceProvidersPageResponseBodyData() = default;
};
class GetServiceProvidersPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<GetServiceProvidersPageResponseBodyData> data{};
  shared_ptr<long> code{};
  shared_ptr<bool> success{};

  GetServiceProvidersPageResponseBody() {}

  explicit GetServiceProvidersPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetServiceProvidersPageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetServiceProvidersPageResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetServiceProvidersPageResponseBody() = default;
};
class GetServiceProvidersPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetServiceProvidersPageResponseBody> body{};

  GetServiceProvidersPageResponse() {}

  explicit GetServiceProvidersPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetServiceProvidersPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetServiceProvidersPageResponseBody>(model1);
      }
    }
  }


  virtual ~GetServiceProvidersPageResponse() = default;
};
class GetSubAccountInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> targetUserId{};

  GetSubAccountInfoRequest() {}

  explicit GetSubAccountInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetUserId) {
      res["TargetUserId"] = boost::any(*targetUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetUserId") != m.end() && !m["TargetUserId"].empty()) {
      targetUserId = make_shared<string>(boost::any_cast<string>(m["TargetUserId"]));
    }
  }


  virtual ~GetSubAccountInfoRequest() = default;
};
class GetSubAccountInfoResponseBodyAuthorization : public Darabonba::Model {
public:
  shared_ptr<string> roleIdData{};
  shared_ptr<bool> ramOperation{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> edasId{};
  shared_ptr<bool> isRamDel{};
  shared_ptr<long> createTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> adminEdasId{};
  shared_ptr<long> resGroupId{};
  shared_ptr<bool> isRamSlave{};
  shared_ptr<string> adminUserId{};
  shared_ptr<string> subUserKp{};
  shared_ptr<string> appIdData{};
  shared_ptr<string> resGroupIdData{};
  shared_ptr<bool> sts{};
  shared_ptr<bool> delegateAdmin{};

  GetSubAccountInfoResponseBodyAuthorization() {}

  explicit GetSubAccountInfoResponseBodyAuthorization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleIdData) {
      res["RoleIdData"] = boost::any(*roleIdData);
    }
    if (ramOperation) {
      res["RamOperation"] = boost::any(*ramOperation);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (edasId) {
      res["EdasId"] = boost::any(*edasId);
    }
    if (isRamDel) {
      res["IsRamDel"] = boost::any(*isRamDel);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (adminEdasId) {
      res["AdminEdasId"] = boost::any(*adminEdasId);
    }
    if (resGroupId) {
      res["ResGroupId"] = boost::any(*resGroupId);
    }
    if (isRamSlave) {
      res["IsRamSlave"] = boost::any(*isRamSlave);
    }
    if (adminUserId) {
      res["AdminUserId"] = boost::any(*adminUserId);
    }
    if (subUserKp) {
      res["SubUserKp"] = boost::any(*subUserKp);
    }
    if (appIdData) {
      res["AppIdData"] = boost::any(*appIdData);
    }
    if (resGroupIdData) {
      res["ResGroupIdData"] = boost::any(*resGroupIdData);
    }
    if (sts) {
      res["Sts"] = boost::any(*sts);
    }
    if (delegateAdmin) {
      res["DelegateAdmin"] = boost::any(*delegateAdmin);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleIdData") != m.end() && !m["RoleIdData"].empty()) {
      roleIdData = make_shared<string>(boost::any_cast<string>(m["RoleIdData"]));
    }
    if (m.find("RamOperation") != m.end() && !m["RamOperation"].empty()) {
      ramOperation = make_shared<bool>(boost::any_cast<bool>(m["RamOperation"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("EdasId") != m.end() && !m["EdasId"].empty()) {
      edasId = make_shared<string>(boost::any_cast<string>(m["EdasId"]));
    }
    if (m.find("IsRamDel") != m.end() && !m["IsRamDel"].empty()) {
      isRamDel = make_shared<bool>(boost::any_cast<bool>(m["IsRamDel"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("AdminEdasId") != m.end() && !m["AdminEdasId"].empty()) {
      adminEdasId = make_shared<string>(boost::any_cast<string>(m["AdminEdasId"]));
    }
    if (m.find("ResGroupId") != m.end() && !m["ResGroupId"].empty()) {
      resGroupId = make_shared<long>(boost::any_cast<long>(m["ResGroupId"]));
    }
    if (m.find("IsRamSlave") != m.end() && !m["IsRamSlave"].empty()) {
      isRamSlave = make_shared<bool>(boost::any_cast<bool>(m["IsRamSlave"]));
    }
    if (m.find("AdminUserId") != m.end() && !m["AdminUserId"].empty()) {
      adminUserId = make_shared<string>(boost::any_cast<string>(m["AdminUserId"]));
    }
    if (m.find("SubUserKp") != m.end() && !m["SubUserKp"].empty()) {
      subUserKp = make_shared<string>(boost::any_cast<string>(m["SubUserKp"]));
    }
    if (m.find("AppIdData") != m.end() && !m["AppIdData"].empty()) {
      appIdData = make_shared<string>(boost::any_cast<string>(m["AppIdData"]));
    }
    if (m.find("ResGroupIdData") != m.end() && !m["ResGroupIdData"].empty()) {
      resGroupIdData = make_shared<string>(boost::any_cast<string>(m["ResGroupIdData"]));
    }
    if (m.find("Sts") != m.end() && !m["Sts"].empty()) {
      sts = make_shared<bool>(boost::any_cast<bool>(m["Sts"]));
    }
    if (m.find("DelegateAdmin") != m.end() && !m["DelegateAdmin"].empty()) {
      delegateAdmin = make_shared<bool>(boost::any_cast<bool>(m["DelegateAdmin"]));
    }
  }


  virtual ~GetSubAccountInfoResponseBodyAuthorization() = default;
};
class GetSubAccountInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetSubAccountInfoResponseBodyAuthorization> authorization{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  GetSubAccountInfoResponseBody() {}

  explicit GetSubAccountInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorization) {
      res["Authorization"] = authorization ? boost::any(authorization->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Authorization") != m.end() && !m["Authorization"].empty()) {
      if (typeid(map<string, boost::any>) == m["Authorization"].type()) {
        GetSubAccountInfoResponseBodyAuthorization model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Authorization"]));
        authorization = make_shared<GetSubAccountInfoResponseBodyAuthorization>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~GetSubAccountInfoResponseBody() = default;
};
class GetSubAccountInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetSubAccountInfoResponseBody> body{};

  GetSubAccountInfoResponse() {}

  explicit GetSubAccountInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSubAccountInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSubAccountInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetSubAccountInfoResponse() = default;
};
class GetSwimmingLaneRequest : public Darabonba::Model {
public:
  shared_ptr<long> laneId{};

  GetSwimmingLaneRequest() {}

  explicit GetSwimmingLaneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (laneId) {
      res["LaneId"] = boost::any(*laneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LaneId") != m.end() && !m["LaneId"].empty()) {
      laneId = make_shared<long>(boost::any_cast<long>(m["LaneId"]));
    }
  }


  virtual ~GetSwimmingLaneRequest() = default;
};
class GetSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> appId{};
  shared_ptr<string> rules{};
  shared_ptr<long> laneId{};

  GetSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList() {}

  explicit GetSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (rules) {
      res["Rules"] = boost::any(*rules);
    }
    if (laneId) {
      res["LaneId"] = boost::any(*laneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rules = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
    if (m.find("LaneId") != m.end() && !m["LaneId"].empty()) {
      laneId = make_shared<long>(boost::any_cast<long>(m["LaneId"]));
    }
  }


  virtual ~GetSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList() = default;
};
class GetSwimmingLaneResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<long> groupId{};
  shared_ptr<string> scenarioSign{};
  shared_ptr<string> entryRule{};
  shared_ptr<string> tag{};
  shared_ptr<bool> enableRules{};
  shared_ptr<string> name{};
  shared_ptr<vector<GetSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList>> swimmingLaneAppRelationShipList{};
  shared_ptr<string> id{};

  GetSwimmingLaneResponseBodyData() {}

  explicit GetSwimmingLaneResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (scenarioSign) {
      res["ScenarioSign"] = boost::any(*scenarioSign);
    }
    if (entryRule) {
      res["EntryRule"] = boost::any(*entryRule);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (enableRules) {
      res["EnableRules"] = boost::any(*enableRules);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (swimmingLaneAppRelationShipList) {
      vector<boost::any> temp1;
      for(auto item1:*swimmingLaneAppRelationShipList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SwimmingLaneAppRelationShipList"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("ScenarioSign") != m.end() && !m["ScenarioSign"].empty()) {
      scenarioSign = make_shared<string>(boost::any_cast<string>(m["ScenarioSign"]));
    }
    if (m.find("EntryRule") != m.end() && !m["EntryRule"].empty()) {
      entryRule = make_shared<string>(boost::any_cast<string>(m["EntryRule"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("EnableRules") != m.end() && !m["EnableRules"].empty()) {
      enableRules = make_shared<bool>(boost::any_cast<bool>(m["EnableRules"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SwimmingLaneAppRelationShipList") != m.end() && !m["SwimmingLaneAppRelationShipList"].empty()) {
      if (typeid(vector<boost::any>) == m["SwimmingLaneAppRelationShipList"].type()) {
        vector<GetSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SwimmingLaneAppRelationShipList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        swimmingLaneAppRelationShipList = make_shared<vector<GetSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetSwimmingLaneResponseBodyData() = default;
};
class GetSwimmingLaneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<GetSwimmingLaneResponseBodyData> data{};
  shared_ptr<long> code{};

  GetSwimmingLaneResponseBody() {}

  explicit GetSwimmingLaneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetSwimmingLaneResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetSwimmingLaneResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~GetSwimmingLaneResponseBody() = default;
};
class GetSwimmingLaneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetSwimmingLaneResponseBody> body{};

  GetSwimmingLaneResponse() {}

  explicit GetSwimmingLaneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSwimmingLaneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSwimmingLaneResponseBody>(model1);
      }
    }
  }


  virtual ~GetSwimmingLaneResponse() = default;
};
class ImportK8sClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> namespaceId{};
  shared_ptr<long> mode{};
  shared_ptr<bool> enableAsm{};

  ImportK8sClusterRequest() {}

  explicit ImportK8sClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (enableAsm) {
      res["EnableAsm"] = boost::any(*enableAsm);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<long>(boost::any_cast<long>(m["Mode"]));
    }
    if (m.find("EnableAsm") != m.end() && !m["EnableAsm"].empty()) {
      enableAsm = make_shared<bool>(boost::any_cast<bool>(m["EnableAsm"]));
    }
  }


  virtual ~ImportK8sClusterRequest() = default;
};
class ImportK8sClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> data{};
  shared_ptr<long> code{};

  ImportK8sClusterResponseBody() {}

  explicit ImportK8sClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ImportK8sClusterResponseBody() = default;
};
class ImportK8sClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ImportK8sClusterResponseBody> body{};

  ImportK8sClusterResponse() {}

  explicit ImportK8sClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportK8sClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportK8sClusterResponseBody>(model1);
      }
    }
  }


  virtual ~ImportK8sClusterResponse() = default;
};
class InsertApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> buildPackId{};
  shared_ptr<string> description{};
  shared_ptr<string> applicationName{};
  shared_ptr<string> reservedPortStr{};
  shared_ptr<string> ecuInfo{};
  shared_ptr<long> cpu{};
  shared_ptr<long> mem{};
  shared_ptr<string> healthCheckURL{};
  shared_ptr<string> logicalRegionId{};
  shared_ptr<string> jdk{};
  shared_ptr<string> webContainer{};
  shared_ptr<string> packageType{};
  shared_ptr<string> componentIds{};
  shared_ptr<string> hooks{};
  shared_ptr<string> jvmOptions{};
  shared_ptr<long> minHeapSize{};
  shared_ptr<long> maxPermSize{};
  shared_ptr<long> maxHeapSize{};
  shared_ptr<bool> enableUrlCheck{};
  shared_ptr<bool> enablePortCheck{};
  shared_ptr<string> healthCheckUrl{};

  InsertApplicationRequest() {}

  explicit InsertApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (buildPackId) {
      res["BuildPackId"] = boost::any(*buildPackId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (reservedPortStr) {
      res["ReservedPortStr"] = boost::any(*reservedPortStr);
    }
    if (ecuInfo) {
      res["EcuInfo"] = boost::any(*ecuInfo);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (healthCheckURL) {
      res["HealthCheckURL"] = boost::any(*healthCheckURL);
    }
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    if (jdk) {
      res["Jdk"] = boost::any(*jdk);
    }
    if (webContainer) {
      res["WebContainer"] = boost::any(*webContainer);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (componentIds) {
      res["ComponentIds"] = boost::any(*componentIds);
    }
    if (hooks) {
      res["Hooks"] = boost::any(*hooks);
    }
    if (jvmOptions) {
      res["JvmOptions"] = boost::any(*jvmOptions);
    }
    if (minHeapSize) {
      res["MinHeapSize"] = boost::any(*minHeapSize);
    }
    if (maxPermSize) {
      res["MaxPermSize"] = boost::any(*maxPermSize);
    }
    if (maxHeapSize) {
      res["MaxHeapSize"] = boost::any(*maxHeapSize);
    }
    if (enableUrlCheck) {
      res["EnableUrlCheck"] = boost::any(*enableUrlCheck);
    }
    if (enablePortCheck) {
      res["EnablePortCheck"] = boost::any(*enablePortCheck);
    }
    if (healthCheckUrl) {
      res["HealthCheckUrl"] = boost::any(*healthCheckUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("BuildPackId") != m.end() && !m["BuildPackId"].empty()) {
      buildPackId = make_shared<long>(boost::any_cast<long>(m["BuildPackId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ReservedPortStr") != m.end() && !m["ReservedPortStr"].empty()) {
      reservedPortStr = make_shared<string>(boost::any_cast<string>(m["ReservedPortStr"]));
    }
    if (m.find("EcuInfo") != m.end() && !m["EcuInfo"].empty()) {
      ecuInfo = make_shared<string>(boost::any_cast<string>(m["EcuInfo"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("HealthCheckURL") != m.end() && !m["HealthCheckURL"].empty()) {
      healthCheckURL = make_shared<string>(boost::any_cast<string>(m["HealthCheckURL"]));
    }
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
    if (m.find("Jdk") != m.end() && !m["Jdk"].empty()) {
      jdk = make_shared<string>(boost::any_cast<string>(m["Jdk"]));
    }
    if (m.find("WebContainer") != m.end() && !m["WebContainer"].empty()) {
      webContainer = make_shared<string>(boost::any_cast<string>(m["WebContainer"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("ComponentIds") != m.end() && !m["ComponentIds"].empty()) {
      componentIds = make_shared<string>(boost::any_cast<string>(m["ComponentIds"]));
    }
    if (m.find("Hooks") != m.end() && !m["Hooks"].empty()) {
      hooks = make_shared<string>(boost::any_cast<string>(m["Hooks"]));
    }
    if (m.find("JvmOptions") != m.end() && !m["JvmOptions"].empty()) {
      jvmOptions = make_shared<string>(boost::any_cast<string>(m["JvmOptions"]));
    }
    if (m.find("MinHeapSize") != m.end() && !m["MinHeapSize"].empty()) {
      minHeapSize = make_shared<long>(boost::any_cast<long>(m["MinHeapSize"]));
    }
    if (m.find("MaxPermSize") != m.end() && !m["MaxPermSize"].empty()) {
      maxPermSize = make_shared<long>(boost::any_cast<long>(m["MaxPermSize"]));
    }
    if (m.find("MaxHeapSize") != m.end() && !m["MaxHeapSize"].empty()) {
      maxHeapSize = make_shared<long>(boost::any_cast<long>(m["MaxHeapSize"]));
    }
    if (m.find("EnableUrlCheck") != m.end() && !m["EnableUrlCheck"].empty()) {
      enableUrlCheck = make_shared<bool>(boost::any_cast<bool>(m["EnableUrlCheck"]));
    }
    if (m.find("EnablePortCheck") != m.end() && !m["EnablePortCheck"].empty()) {
      enablePortCheck = make_shared<bool>(boost::any_cast<bool>(m["EnablePortCheck"]));
    }
    if (m.find("HealthCheckUrl") != m.end() && !m["HealthCheckUrl"].empty()) {
      healthCheckUrl = make_shared<string>(boost::any_cast<string>(m["HealthCheckUrl"]));
    }
  }


  virtual ~InsertApplicationRequest() = default;
};
class InsertApplicationResponseBodyApplicationInfo : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<string> appName{};
  shared_ptr<string> owner{};
  shared_ptr<bool> dockerize{};
  shared_ptr<string> regionName{};
  shared_ptr<string> appId{};
  shared_ptr<string> userId{};
  shared_ptr<long> port{};

  InsertApplicationResponseBodyApplicationInfo() {}

  explicit InsertApplicationResponseBodyApplicationInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (dockerize) {
      res["Dockerize"] = boost::any(*dockerize);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Dockerize") != m.end() && !m["Dockerize"].empty()) {
      dockerize = make_shared<bool>(boost::any_cast<bool>(m["Dockerize"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
  }


  virtual ~InsertApplicationResponseBodyApplicationInfo() = default;
};
class InsertApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<InsertApplicationResponseBodyApplicationInfo> applicationInfo{};
  shared_ptr<long> code{};

  InsertApplicationResponseBody() {}

  explicit InsertApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (applicationInfo) {
      res["ApplicationInfo"] = applicationInfo ? boost::any(applicationInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ApplicationInfo") != m.end() && !m["ApplicationInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplicationInfo"].type()) {
        InsertApplicationResponseBodyApplicationInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplicationInfo"]));
        applicationInfo = make_shared<InsertApplicationResponseBodyApplicationInfo>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~InsertApplicationResponseBody() = default;
};
class InsertApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<InsertApplicationResponseBody> body{};

  InsertApplicationResponse() {}

  explicit InsertApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~InsertApplicationResponse() = default;
};
class InsertClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> logicalRegionId{};
  shared_ptr<string> clusterName{};
  shared_ptr<long> clusterType{};
  shared_ptr<long> networkMode{};
  shared_ptr<string> vpcId{};
  shared_ptr<long> oversoldFactor{};
  shared_ptr<string> iaasProvider{};

  InsertClusterRequest() {}

  explicit InsertClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (networkMode) {
      res["NetworkMode"] = boost::any(*networkMode);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (oversoldFactor) {
      res["OversoldFactor"] = boost::any(*oversoldFactor);
    }
    if (iaasProvider) {
      res["IaasProvider"] = boost::any(*iaasProvider);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<long>(boost::any_cast<long>(m["ClusterType"]));
    }
    if (m.find("NetworkMode") != m.end() && !m["NetworkMode"].empty()) {
      networkMode = make_shared<long>(boost::any_cast<long>(m["NetworkMode"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("OversoldFactor") != m.end() && !m["OversoldFactor"].empty()) {
      oversoldFactor = make_shared<long>(boost::any_cast<long>(m["OversoldFactor"]));
    }
    if (m.find("IaasProvider") != m.end() && !m["IaasProvider"].empty()) {
      iaasProvider = make_shared<string>(boost::any_cast<string>(m["IaasProvider"]));
    }
  }


  virtual ~InsertClusterRequest() = default;
};
class InsertClusterResponseBodyCluster : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<long> oversoldFactor{};
  shared_ptr<long> networkMode{};
  shared_ptr<string> iaasProvider{};
  shared_ptr<long> clusterType{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  InsertClusterResponseBodyCluster() {}

  explicit InsertClusterResponseBodyCluster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (oversoldFactor) {
      res["OversoldFactor"] = boost::any(*oversoldFactor);
    }
    if (networkMode) {
      res["NetworkMode"] = boost::any(*networkMode);
    }
    if (iaasProvider) {
      res["IaasProvider"] = boost::any(*iaasProvider);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("OversoldFactor") != m.end() && !m["OversoldFactor"].empty()) {
      oversoldFactor = make_shared<long>(boost::any_cast<long>(m["OversoldFactor"]));
    }
    if (m.find("NetworkMode") != m.end() && !m["NetworkMode"].empty()) {
      networkMode = make_shared<long>(boost::any_cast<long>(m["NetworkMode"]));
    }
    if (m.find("IaasProvider") != m.end() && !m["IaasProvider"].empty()) {
      iaasProvider = make_shared<string>(boost::any_cast<string>(m["IaasProvider"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<long>(boost::any_cast<long>(m["ClusterType"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~InsertClusterResponseBodyCluster() = default;
};
class InsertClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<InsertClusterResponseBodyCluster> cluster{};
  shared_ptr<long> code{};

  InsertClusterResponseBody() {}

  explicit InsertClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (cluster) {
      res["Cluster"] = cluster ? boost::any(cluster->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Cluster") != m.end() && !m["Cluster"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cluster"].type()) {
        InsertClusterResponseBodyCluster model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cluster"]));
        cluster = make_shared<InsertClusterResponseBodyCluster>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~InsertClusterResponseBody() = default;
};
class InsertClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<InsertClusterResponseBody> body{};

  InsertClusterResponse() {}

  explicit InsertClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertClusterResponseBody>(model1);
      }
    }
  }


  virtual ~InsertClusterResponse() = default;
};
class InsertClusterMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> password{};

  InsertClusterMemberRequest() {}

  explicit InsertClusterMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["clusterId"] = boost::any(*clusterId);
    }
    if (instanceIds) {
      res["instanceIds"] = boost::any(*instanceIds);
    }
    if (password) {
      res["password"] = boost::any(*password);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clusterId") != m.end() && !m["clusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["clusterId"]));
    }
    if (m.find("instanceIds") != m.end() && !m["instanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["instanceIds"]));
    }
    if (m.find("password") != m.end() && !m["password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["password"]));
    }
  }


  virtual ~InsertClusterMemberRequest() = default;
};
class InsertClusterMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> data{};
  shared_ptr<long> code{};

  InsertClusterMemberResponseBody() {}

  explicit InsertClusterMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~InsertClusterMemberResponseBody() = default;
};
class InsertClusterMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<InsertClusterMemberResponseBody> body{};

  InsertClusterMemberResponse() {}

  explicit InsertClusterMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertClusterMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertClusterMemberResponseBody>(model1);
      }
    }
  }


  virtual ~InsertClusterMemberResponse() = default;
};
class InsertConfigCenterRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataId{};
  shared_ptr<string> group{};
  shared_ptr<string> data{};
  shared_ptr<string> logicalRegionId{};
  shared_ptr<string> appName{};

  InsertConfigCenterRequest() {}

  explicit InsertConfigCenterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
  }


  virtual ~InsertConfigCenterRequest() = default;
};
class InsertConfigCenterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  InsertConfigCenterResponseBody() {}

  explicit InsertConfigCenterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~InsertConfigCenterResponseBody() = default;
};
class InsertConfigCenterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<InsertConfigCenterResponseBody> body{};

  InsertConfigCenterResponse() {}

  explicit InsertConfigCenterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertConfigCenterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertConfigCenterResponseBody>(model1);
      }
    }
  }


  virtual ~InsertConfigCenterResponse() = default;
};
class InsertDegradeControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> duration{};
  shared_ptr<string> methodName{};
  shared_ptr<long> rtThreshold{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> urlVar{};
  shared_ptr<string> ruleType{};

  InsertDegradeControlRequest() {}

  explicit InsertDegradeControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (rtThreshold) {
      res["RtThreshold"] = boost::any(*rtThreshold);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (urlVar) {
      res["UrlVar"] = boost::any(*urlVar);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("RtThreshold") != m.end() && !m["RtThreshold"].empty()) {
      rtThreshold = make_shared<long>(boost::any_cast<long>(m["RtThreshold"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("UrlVar") != m.end() && !m["UrlVar"].empty()) {
      urlVar = make_shared<string>(boost::any_cast<string>(m["UrlVar"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
  }


  virtual ~InsertDegradeControlRequest() = default;
};
class InsertDegradeControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  InsertDegradeControlResponseBody() {}

  explicit InsertDegradeControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~InsertDegradeControlResponseBody() = default;
};
class InsertDegradeControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<InsertDegradeControlResponseBody> body{};

  InsertDegradeControlResponse() {}

  explicit InsertDegradeControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertDegradeControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertDegradeControlResponseBody>(model1);
      }
    }
  }


  virtual ~InsertDegradeControlResponse() = default;
};
class InsertDeployGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> initPackageVersionId{};

  InsertDeployGroupRequest() {}

  explicit InsertDeployGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (initPackageVersionId) {
      res["InitPackageVersionId"] = boost::any(*initPackageVersionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InitPackageVersionId") != m.end() && !m["InitPackageVersionId"].empty()) {
      initPackageVersionId = make_shared<string>(boost::any_cast<string>(m["InitPackageVersionId"]));
    }
  }


  virtual ~InsertDeployGroupRequest() = default;
};
class InsertDeployGroupResponseBodyDeployGroupEntity : public Darabonba::Model {
public:
  shared_ptr<long> updateTime{};
  shared_ptr<string> groupName{};
  shared_ptr<long> createTime{};
  shared_ptr<string> appVersionId{};
  shared_ptr<string> appId{};
  shared_ptr<string> packageVersionId{};
  shared_ptr<long> groupType{};
  shared_ptr<string> id{};
  shared_ptr<string> clusterId{};

  InsertDeployGroupResponseBodyDeployGroupEntity() {}

  explicit InsertDeployGroupResponseBodyDeployGroupEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (appVersionId) {
      res["AppVersionId"] = boost::any(*appVersionId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (packageVersionId) {
      res["PackageVersionId"] = boost::any(*packageVersionId);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("AppVersionId") != m.end() && !m["AppVersionId"].empty()) {
      appVersionId = make_shared<string>(boost::any_cast<string>(m["AppVersionId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("PackageVersionId") != m.end() && !m["PackageVersionId"].empty()) {
      packageVersionId = make_shared<string>(boost::any_cast<string>(m["PackageVersionId"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<long>(boost::any_cast<long>(m["GroupType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~InsertDeployGroupResponseBodyDeployGroupEntity() = default;
};
class InsertDeployGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};
  shared_ptr<InsertDeployGroupResponseBodyDeployGroupEntity> deployGroupEntity{};

  InsertDeployGroupResponseBody() {}

  explicit InsertDeployGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (deployGroupEntity) {
      res["DeployGroupEntity"] = deployGroupEntity ? boost::any(deployGroupEntity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("DeployGroupEntity") != m.end() && !m["DeployGroupEntity"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeployGroupEntity"].type()) {
        InsertDeployGroupResponseBodyDeployGroupEntity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeployGroupEntity"]));
        deployGroupEntity = make_shared<InsertDeployGroupResponseBodyDeployGroupEntity>(model1);
      }
    }
  }


  virtual ~InsertDeployGroupResponseBody() = default;
};
class InsertDeployGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<InsertDeployGroupResponseBody> body{};

  InsertDeployGroupResponse() {}

  explicit InsertDeployGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertDeployGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertDeployGroupResponseBody>(model1);
      }
    }
  }


  virtual ~InsertDeployGroupResponse() = default;
};
class InsertFlowControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> consumerAppId{};
  shared_ptr<string> granularity{};
  shared_ptr<string> methodName{};
  shared_ptr<string> ruleType{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> strategy{};
  shared_ptr<long> threshold{};
  shared_ptr<string> urlVar{};

  InsertFlowControlRequest() {}

  explicit InsertFlowControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (consumerAppId) {
      res["ConsumerAppId"] = boost::any(*consumerAppId);
    }
    if (granularity) {
      res["Granularity"] = boost::any(*granularity);
    }
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (strategy) {
      res["Strategy"] = boost::any(*strategy);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (urlVar) {
      res["UrlVar"] = boost::any(*urlVar);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ConsumerAppId") != m.end() && !m["ConsumerAppId"].empty()) {
      consumerAppId = make_shared<string>(boost::any_cast<string>(m["ConsumerAppId"]));
    }
    if (m.find("Granularity") != m.end() && !m["Granularity"].empty()) {
      granularity = make_shared<string>(boost::any_cast<string>(m["Granularity"]));
    }
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      strategy = make_shared<string>(boost::any_cast<string>(m["Strategy"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<long>(boost::any_cast<long>(m["Threshold"]));
    }
    if (m.find("UrlVar") != m.end() && !m["UrlVar"].empty()) {
      urlVar = make_shared<string>(boost::any_cast<string>(m["UrlVar"]));
    }
  }


  virtual ~InsertFlowControlRequest() = default;
};
class InsertFlowControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  InsertFlowControlResponseBody() {}

  explicit InsertFlowControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~InsertFlowControlResponseBody() = default;
};
class InsertFlowControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<InsertFlowControlResponseBody> body{};

  InsertFlowControlResponse() {}

  explicit InsertFlowControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertFlowControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertFlowControlResponseBody>(model1);
      }
    }
  }


  virtual ~InsertFlowControlResponse() = default;
};
class InsertK8sApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<long> intranetTargetPort{};
  shared_ptr<long> intranetSlbPort{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> applicationDescription{};
  shared_ptr<string> repoId{};
  shared_ptr<long> replicas{};
  shared_ptr<long> limitCpu{};
  shared_ptr<long> limitMem{};
  shared_ptr<long> requestsCpu{};
  shared_ptr<long> requestsMem{};
  shared_ptr<string> command{};
  shared_ptr<string> commandArgs{};
  shared_ptr<string> appName{};
  shared_ptr<string> intranetSlbProtocol{};
  shared_ptr<string> intranetSlbId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> internetSlbId{};
  shared_ptr<string> internetSlbProtocol{};
  shared_ptr<long> internetSlbPort{};
  shared_ptr<long> internetTargetPort{};
  shared_ptr<string> envs{};
  shared_ptr<string> preStop{};
  shared_ptr<string> postStart{};
  shared_ptr<string> liveness{};
  shared_ptr<string> readiness{};
  shared_ptr<string> nasId{};
  shared_ptr<string> mountDescs{};
  shared_ptr<string> storageType{};
  shared_ptr<string> localVolume{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> logicalRegionId{};
  shared_ptr<string> packageType{};
  shared_ptr<string> packageUrl{};
  shared_ptr<string> packageVersion{};
  shared_ptr<string> JDK{};
  shared_ptr<string> webContainer{};
  shared_ptr<string> edasContainerVersion{};
  shared_ptr<string> uriEncoding{};
  shared_ptr<bool> useBodyEncoding{};
  shared_ptr<long> requestsmCpu{};
  shared_ptr<long> limitmCpu{};
  shared_ptr<string> runtimeClassName{};
  shared_ptr<string> deployAcrossZones{};
  shared_ptr<long> timeout{};
  shared_ptr<bool> enableAhas{};
  shared_ptr<string> webContainerConfig{};
  shared_ptr<string> javaStartUpConfig{};
  shared_ptr<string> slsConfigs{};
  shared_ptr<bool> isMultilingualApp{};
  shared_ptr<string> deployAcrossNodes{};

  InsertK8sApplicationRequest() {}

  explicit InsertK8sApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (intranetTargetPort) {
      res["IntranetTargetPort"] = boost::any(*intranetTargetPort);
    }
    if (intranetSlbPort) {
      res["IntranetSlbPort"] = boost::any(*intranetSlbPort);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (applicationDescription) {
      res["ApplicationDescription"] = boost::any(*applicationDescription);
    }
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    if (replicas) {
      res["Replicas"] = boost::any(*replicas);
    }
    if (limitCpu) {
      res["LimitCpu"] = boost::any(*limitCpu);
    }
    if (limitMem) {
      res["LimitMem"] = boost::any(*limitMem);
    }
    if (requestsCpu) {
      res["RequestsCpu"] = boost::any(*requestsCpu);
    }
    if (requestsMem) {
      res["RequestsMem"] = boost::any(*requestsMem);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (commandArgs) {
      res["CommandArgs"] = boost::any(*commandArgs);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (intranetSlbProtocol) {
      res["IntranetSlbProtocol"] = boost::any(*intranetSlbProtocol);
    }
    if (intranetSlbId) {
      res["IntranetSlbId"] = boost::any(*intranetSlbId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (internetSlbId) {
      res["InternetSlbId"] = boost::any(*internetSlbId);
    }
    if (internetSlbProtocol) {
      res["InternetSlbProtocol"] = boost::any(*internetSlbProtocol);
    }
    if (internetSlbPort) {
      res["InternetSlbPort"] = boost::any(*internetSlbPort);
    }
    if (internetTargetPort) {
      res["InternetTargetPort"] = boost::any(*internetTargetPort);
    }
    if (envs) {
      res["Envs"] = boost::any(*envs);
    }
    if (preStop) {
      res["PreStop"] = boost::any(*preStop);
    }
    if (postStart) {
      res["PostStart"] = boost::any(*postStart);
    }
    if (liveness) {
      res["Liveness"] = boost::any(*liveness);
    }
    if (readiness) {
      res["Readiness"] = boost::any(*readiness);
    }
    if (nasId) {
      res["NasId"] = boost::any(*nasId);
    }
    if (mountDescs) {
      res["MountDescs"] = boost::any(*mountDescs);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    if (localVolume) {
      res["LocalVolume"] = boost::any(*localVolume);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (packageUrl) {
      res["PackageUrl"] = boost::any(*packageUrl);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    if (JDK) {
      res["JDK"] = boost::any(*JDK);
    }
    if (webContainer) {
      res["WebContainer"] = boost::any(*webContainer);
    }
    if (edasContainerVersion) {
      res["EdasContainerVersion"] = boost::any(*edasContainerVersion);
    }
    if (uriEncoding) {
      res["UriEncoding"] = boost::any(*uriEncoding);
    }
    if (useBodyEncoding) {
      res["UseBodyEncoding"] = boost::any(*useBodyEncoding);
    }
    if (requestsmCpu) {
      res["RequestsmCpu"] = boost::any(*requestsmCpu);
    }
    if (limitmCpu) {
      res["LimitmCpu"] = boost::any(*limitmCpu);
    }
    if (runtimeClassName) {
      res["RuntimeClassName"] = boost::any(*runtimeClassName);
    }
    if (deployAcrossZones) {
      res["DeployAcrossZones"] = boost::any(*deployAcrossZones);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (enableAhas) {
      res["EnableAhas"] = boost::any(*enableAhas);
    }
    if (webContainerConfig) {
      res["WebContainerConfig"] = boost::any(*webContainerConfig);
    }
    if (javaStartUpConfig) {
      res["JavaStartUpConfig"] = boost::any(*javaStartUpConfig);
    }
    if (slsConfigs) {
      res["SlsConfigs"] = boost::any(*slsConfigs);
    }
    if (isMultilingualApp) {
      res["IsMultilingualApp"] = boost::any(*isMultilingualApp);
    }
    if (deployAcrossNodes) {
      res["DeployAcrossNodes"] = boost::any(*deployAcrossNodes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntranetTargetPort") != m.end() && !m["IntranetTargetPort"].empty()) {
      intranetTargetPort = make_shared<long>(boost::any_cast<long>(m["IntranetTargetPort"]));
    }
    if (m.find("IntranetSlbPort") != m.end() && !m["IntranetSlbPort"].empty()) {
      intranetSlbPort = make_shared<long>(boost::any_cast<long>(m["IntranetSlbPort"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("ApplicationDescription") != m.end() && !m["ApplicationDescription"].empty()) {
      applicationDescription = make_shared<string>(boost::any_cast<string>(m["ApplicationDescription"]));
    }
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
    if (m.find("Replicas") != m.end() && !m["Replicas"].empty()) {
      replicas = make_shared<long>(boost::any_cast<long>(m["Replicas"]));
    }
    if (m.find("LimitCpu") != m.end() && !m["LimitCpu"].empty()) {
      limitCpu = make_shared<long>(boost::any_cast<long>(m["LimitCpu"]));
    }
    if (m.find("LimitMem") != m.end() && !m["LimitMem"].empty()) {
      limitMem = make_shared<long>(boost::any_cast<long>(m["LimitMem"]));
    }
    if (m.find("RequestsCpu") != m.end() && !m["RequestsCpu"].empty()) {
      requestsCpu = make_shared<long>(boost::any_cast<long>(m["RequestsCpu"]));
    }
    if (m.find("RequestsMem") != m.end() && !m["RequestsMem"].empty()) {
      requestsMem = make_shared<long>(boost::any_cast<long>(m["RequestsMem"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("CommandArgs") != m.end() && !m["CommandArgs"].empty()) {
      commandArgs = make_shared<string>(boost::any_cast<string>(m["CommandArgs"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("IntranetSlbProtocol") != m.end() && !m["IntranetSlbProtocol"].empty()) {
      intranetSlbProtocol = make_shared<string>(boost::any_cast<string>(m["IntranetSlbProtocol"]));
    }
    if (m.find("IntranetSlbId") != m.end() && !m["IntranetSlbId"].empty()) {
      intranetSlbId = make_shared<string>(boost::any_cast<string>(m["IntranetSlbId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("InternetSlbId") != m.end() && !m["InternetSlbId"].empty()) {
      internetSlbId = make_shared<string>(boost::any_cast<string>(m["InternetSlbId"]));
    }
    if (m.find("InternetSlbProtocol") != m.end() && !m["InternetSlbProtocol"].empty()) {
      internetSlbProtocol = make_shared<string>(boost::any_cast<string>(m["InternetSlbProtocol"]));
    }
    if (m.find("InternetSlbPort") != m.end() && !m["InternetSlbPort"].empty()) {
      internetSlbPort = make_shared<long>(boost::any_cast<long>(m["InternetSlbPort"]));
    }
    if (m.find("InternetTargetPort") != m.end() && !m["InternetTargetPort"].empty()) {
      internetTargetPort = make_shared<long>(boost::any_cast<long>(m["InternetTargetPort"]));
    }
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      envs = make_shared<string>(boost::any_cast<string>(m["Envs"]));
    }
    if (m.find("PreStop") != m.end() && !m["PreStop"].empty()) {
      preStop = make_shared<string>(boost::any_cast<string>(m["PreStop"]));
    }
    if (m.find("PostStart") != m.end() && !m["PostStart"].empty()) {
      postStart = make_shared<string>(boost::any_cast<string>(m["PostStart"]));
    }
    if (m.find("Liveness") != m.end() && !m["Liveness"].empty()) {
      liveness = make_shared<string>(boost::any_cast<string>(m["Liveness"]));
    }
    if (m.find("Readiness") != m.end() && !m["Readiness"].empty()) {
      readiness = make_shared<string>(boost::any_cast<string>(m["Readiness"]));
    }
    if (m.find("NasId") != m.end() && !m["NasId"].empty()) {
      nasId = make_shared<string>(boost::any_cast<string>(m["NasId"]));
    }
    if (m.find("MountDescs") != m.end() && !m["MountDescs"].empty()) {
      mountDescs = make_shared<string>(boost::any_cast<string>(m["MountDescs"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
    if (m.find("LocalVolume") != m.end() && !m["LocalVolume"].empty()) {
      localVolume = make_shared<string>(boost::any_cast<string>(m["LocalVolume"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("PackageUrl") != m.end() && !m["PackageUrl"].empty()) {
      packageUrl = make_shared<string>(boost::any_cast<string>(m["PackageUrl"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
    if (m.find("JDK") != m.end() && !m["JDK"].empty()) {
      JDK = make_shared<string>(boost::any_cast<string>(m["JDK"]));
    }
    if (m.find("WebContainer") != m.end() && !m["WebContainer"].empty()) {
      webContainer = make_shared<string>(boost::any_cast<string>(m["WebContainer"]));
    }
    if (m.find("EdasContainerVersion") != m.end() && !m["EdasContainerVersion"].empty()) {
      edasContainerVersion = make_shared<string>(boost::any_cast<string>(m["EdasContainerVersion"]));
    }
    if (m.find("UriEncoding") != m.end() && !m["UriEncoding"].empty()) {
      uriEncoding = make_shared<string>(boost::any_cast<string>(m["UriEncoding"]));
    }
    if (m.find("UseBodyEncoding") != m.end() && !m["UseBodyEncoding"].empty()) {
      useBodyEncoding = make_shared<bool>(boost::any_cast<bool>(m["UseBodyEncoding"]));
    }
    if (m.find("RequestsmCpu") != m.end() && !m["RequestsmCpu"].empty()) {
      requestsmCpu = make_shared<long>(boost::any_cast<long>(m["RequestsmCpu"]));
    }
    if (m.find("LimitmCpu") != m.end() && !m["LimitmCpu"].empty()) {
      limitmCpu = make_shared<long>(boost::any_cast<long>(m["LimitmCpu"]));
    }
    if (m.find("RuntimeClassName") != m.end() && !m["RuntimeClassName"].empty()) {
      runtimeClassName = make_shared<string>(boost::any_cast<string>(m["RuntimeClassName"]));
    }
    if (m.find("DeployAcrossZones") != m.end() && !m["DeployAcrossZones"].empty()) {
      deployAcrossZones = make_shared<string>(boost::any_cast<string>(m["DeployAcrossZones"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("EnableAhas") != m.end() && !m["EnableAhas"].empty()) {
      enableAhas = make_shared<bool>(boost::any_cast<bool>(m["EnableAhas"]));
    }
    if (m.find("WebContainerConfig") != m.end() && !m["WebContainerConfig"].empty()) {
      webContainerConfig = make_shared<string>(boost::any_cast<string>(m["WebContainerConfig"]));
    }
    if (m.find("JavaStartUpConfig") != m.end() && !m["JavaStartUpConfig"].empty()) {
      javaStartUpConfig = make_shared<string>(boost::any_cast<string>(m["JavaStartUpConfig"]));
    }
    if (m.find("SlsConfigs") != m.end() && !m["SlsConfigs"].empty()) {
      slsConfigs = make_shared<string>(boost::any_cast<string>(m["SlsConfigs"]));
    }
    if (m.find("IsMultilingualApp") != m.end() && !m["IsMultilingualApp"].empty()) {
      isMultilingualApp = make_shared<bool>(boost::any_cast<bool>(m["IsMultilingualApp"]));
    }
    if (m.find("DeployAcrossNodes") != m.end() && !m["DeployAcrossNodes"].empty()) {
      deployAcrossNodes = make_shared<string>(boost::any_cast<string>(m["DeployAcrossNodes"]));
    }
  }


  virtual ~InsertK8sApplicationRequest() = default;
};
class InsertK8sApplicationResponseBodyApplicationInfo : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<string> appName{};
  shared_ptr<bool> dockerize{};
  shared_ptr<string> owner{};
  shared_ptr<string> edasId{};
  shared_ptr<long> clusterType{};
  shared_ptr<string> appId{};
  shared_ptr<string> userId{};
  shared_ptr<string> regionId{};

  InsertK8sApplicationResponseBodyApplicationInfo() {}

  explicit InsertK8sApplicationResponseBodyApplicationInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (dockerize) {
      res["Dockerize"] = boost::any(*dockerize);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (edasId) {
      res["EdasId"] = boost::any(*edasId);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Dockerize") != m.end() && !m["Dockerize"].empty()) {
      dockerize = make_shared<bool>(boost::any_cast<bool>(m["Dockerize"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("EdasId") != m.end() && !m["EdasId"].empty()) {
      edasId = make_shared<string>(boost::any_cast<string>(m["EdasId"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<long>(boost::any_cast<long>(m["ClusterType"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~InsertK8sApplicationResponseBodyApplicationInfo() = default;
};
class InsertK8sApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<InsertK8sApplicationResponseBodyApplicationInfo> applicationInfo{};
  shared_ptr<long> code{};

  InsertK8sApplicationResponseBody() {}

  explicit InsertK8sApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (applicationInfo) {
      res["ApplicationInfo"] = applicationInfo ? boost::any(applicationInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ApplicationInfo") != m.end() && !m["ApplicationInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplicationInfo"].type()) {
        InsertK8sApplicationResponseBodyApplicationInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplicationInfo"]));
        applicationInfo = make_shared<InsertK8sApplicationResponseBodyApplicationInfo>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~InsertK8sApplicationResponseBody() = default;
};
class InsertK8sApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<InsertK8sApplicationResponseBody> body{};

  InsertK8sApplicationResponse() {}

  explicit InsertK8sApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertK8sApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertK8sApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~InsertK8sApplicationResponse() = default;
};
class InsertOrUpdateRegionRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionTag{};
  shared_ptr<string> regionName{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<bool> debugEnable{};

  InsertOrUpdateRegionRequest() {}

  explicit InsertOrUpdateRegionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionTag) {
      res["RegionTag"] = boost::any(*regionTag);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (debugEnable) {
      res["DebugEnable"] = boost::any(*debugEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionTag") != m.end() && !m["RegionTag"].empty()) {
      regionTag = make_shared<string>(boost::any_cast<string>(m["RegionTag"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("DebugEnable") != m.end() && !m["DebugEnable"].empty()) {
      debugEnable = make_shared<bool>(boost::any_cast<bool>(m["DebugEnable"]));
    }
  }


  virtual ~InsertOrUpdateRegionRequest() = default;
};
class InsertOrUpdateRegionResponseBodyUserDefineRegionEntity : public Darabonba::Model {
public:
  shared_ptr<string> belongRegion{};
  shared_ptr<string> regionName{};
  shared_ptr<string> description{};
  shared_ptr<bool> debugEnable{};
  shared_ptr<string> userId{};
  shared_ptr<long> id{};
  shared_ptr<string> regionId{};

  InsertOrUpdateRegionResponseBodyUserDefineRegionEntity() {}

  explicit InsertOrUpdateRegionResponseBodyUserDefineRegionEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (belongRegion) {
      res["BelongRegion"] = boost::any(*belongRegion);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (debugEnable) {
      res["DebugEnable"] = boost::any(*debugEnable);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BelongRegion") != m.end() && !m["BelongRegion"].empty()) {
      belongRegion = make_shared<string>(boost::any_cast<string>(m["BelongRegion"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DebugEnable") != m.end() && !m["DebugEnable"].empty()) {
      debugEnable = make_shared<bool>(boost::any_cast<bool>(m["DebugEnable"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~InsertOrUpdateRegionResponseBodyUserDefineRegionEntity() = default;
};
class InsertOrUpdateRegionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<InsertOrUpdateRegionResponseBodyUserDefineRegionEntity> userDefineRegionEntity{};
  shared_ptr<long> code{};

  InsertOrUpdateRegionResponseBody() {}

  explicit InsertOrUpdateRegionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userDefineRegionEntity) {
      res["UserDefineRegionEntity"] = userDefineRegionEntity ? boost::any(userDefineRegionEntity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserDefineRegionEntity") != m.end() && !m["UserDefineRegionEntity"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserDefineRegionEntity"].type()) {
        InsertOrUpdateRegionResponseBodyUserDefineRegionEntity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserDefineRegionEntity"]));
        userDefineRegionEntity = make_shared<InsertOrUpdateRegionResponseBodyUserDefineRegionEntity>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~InsertOrUpdateRegionResponseBody() = default;
};
class InsertOrUpdateRegionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<InsertOrUpdateRegionResponseBody> body{};

  InsertOrUpdateRegionResponse() {}

  explicit InsertOrUpdateRegionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertOrUpdateRegionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertOrUpdateRegionResponseBody>(model1);
      }
    }
  }


  virtual ~InsertOrUpdateRegionResponse() = default;
};
class InsertRoleRequest : public Darabonba::Model {
public:
  shared_ptr<string> roleName{};
  shared_ptr<string> actionData{};

  InsertRoleRequest() {}

  explicit InsertRoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (actionData) {
      res["ActionData"] = boost::any(*actionData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("ActionData") != m.end() && !m["ActionData"].empty()) {
      actionData = make_shared<string>(boost::any_cast<string>(m["ActionData"]));
    }
  }


  virtual ~InsertRoleRequest() = default;
};
class InsertRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};
  shared_ptr<long> roleId{};

  InsertRoleResponseBody() {}

  explicit InsertRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<long>(boost::any_cast<long>(m["RoleId"]));
    }
  }


  virtual ~InsertRoleResponseBody() = default;
};
class InsertRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<InsertRoleResponseBody> body{};

  InsertRoleResponse() {}

  explicit InsertRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertRoleResponseBody>(model1);
      }
    }
  }


  virtual ~InsertRoleResponse() = default;
};
class InsertServiceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};

  InsertServiceGroupRequest() {}

  explicit InsertServiceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~InsertServiceGroupRequest() = default;
};
class InsertServiceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  InsertServiceGroupResponseBody() {}

  explicit InsertServiceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~InsertServiceGroupResponseBody() = default;
};
class InsertServiceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<InsertServiceGroupResponseBody> body{};

  InsertServiceGroupResponse() {}

  explicit InsertServiceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertServiceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertServiceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~InsertServiceGroupResponse() = default;
};
class InsertSwimmingLaneRequest : public Darabonba::Model {
public:
  shared_ptr<string> logicalRegionId{};
  shared_ptr<string> name{};
  shared_ptr<string> tag{};
  shared_ptr<long> groupId{};
  shared_ptr<string> entryRules{};
  shared_ptr<bool> enableRules{};
  shared_ptr<string> appInfos{};

  InsertSwimmingLaneRequest() {}

  explicit InsertSwimmingLaneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (entryRules) {
      res["EntryRules"] = boost::any(*entryRules);
    }
    if (enableRules) {
      res["EnableRules"] = boost::any(*enableRules);
    }
    if (appInfos) {
      res["AppInfos"] = boost::any(*appInfos);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("EntryRules") != m.end() && !m["EntryRules"].empty()) {
      entryRules = make_shared<string>(boost::any_cast<string>(m["EntryRules"]));
    }
    if (m.find("EnableRules") != m.end() && !m["EnableRules"].empty()) {
      enableRules = make_shared<bool>(boost::any_cast<bool>(m["EnableRules"]));
    }
    if (m.find("AppInfos") != m.end() && !m["AppInfos"].empty()) {
      appInfos = make_shared<string>(boost::any_cast<string>(m["AppInfos"]));
    }
  }


  virtual ~InsertSwimmingLaneRequest() = default;
};
class InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> appId{};
  shared_ptr<string> rules{};
  shared_ptr<long> laneId{};

  InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList() {}

  explicit InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (rules) {
      res["Rules"] = boost::any(*rules);
    }
    if (laneId) {
      res["LaneId"] = boost::any(*laneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rules = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
    if (m.find("LaneId") != m.end() && !m["LaneId"].empty()) {
      laneId = make_shared<long>(boost::any_cast<long>(m["LaneId"]));
    }
  }


  virtual ~InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList() = default;
};
class InsertSwimmingLaneResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<long> groupId{};
  shared_ptr<string> entryRule{};
  shared_ptr<string> appInfos{};
  shared_ptr<string> tag{};
  shared_ptr<string> name{};
  shared_ptr<vector<InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList>> swimmingLaneAppRelationShipList{};
  shared_ptr<long> id{};

  InsertSwimmingLaneResponseBodyData() {}

  explicit InsertSwimmingLaneResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (entryRule) {
      res["EntryRule"] = boost::any(*entryRule);
    }
    if (appInfos) {
      res["AppInfos"] = boost::any(*appInfos);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (swimmingLaneAppRelationShipList) {
      vector<boost::any> temp1;
      for(auto item1:*swimmingLaneAppRelationShipList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SwimmingLaneAppRelationShipList"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("EntryRule") != m.end() && !m["EntryRule"].empty()) {
      entryRule = make_shared<string>(boost::any_cast<string>(m["EntryRule"]));
    }
    if (m.find("AppInfos") != m.end() && !m["AppInfos"].empty()) {
      appInfos = make_shared<string>(boost::any_cast<string>(m["AppInfos"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SwimmingLaneAppRelationShipList") != m.end() && !m["SwimmingLaneAppRelationShipList"].empty()) {
      if (typeid(vector<boost::any>) == m["SwimmingLaneAppRelationShipList"].type()) {
        vector<InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SwimmingLaneAppRelationShipList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        swimmingLaneAppRelationShipList = make_shared<vector<InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~InsertSwimmingLaneResponseBodyData() = default;
};
class InsertSwimmingLaneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<InsertSwimmingLaneResponseBodyData> data{};
  shared_ptr<long> code{};

  InsertSwimmingLaneResponseBody() {}

  explicit InsertSwimmingLaneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        InsertSwimmingLaneResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<InsertSwimmingLaneResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~InsertSwimmingLaneResponseBody() = default;
};
class InsertSwimmingLaneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<InsertSwimmingLaneResponseBody> body{};

  InsertSwimmingLaneResponse() {}

  explicit InsertSwimmingLaneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertSwimmingLaneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertSwimmingLaneResponseBody>(model1);
      }
    }
  }


  virtual ~InsertSwimmingLaneResponse() = default;
};
class InsertSwimmingLaneGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> entryApp{};
  shared_ptr<string> appIds{};
  shared_ptr<string> logicalRegionId{};

  InsertSwimmingLaneGroupRequest() {}

  explicit InsertSwimmingLaneGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (entryApp) {
      res["EntryApp"] = boost::any(*entryApp);
    }
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("EntryApp") != m.end() && !m["EntryApp"].empty()) {
      entryApp = make_shared<string>(boost::any_cast<string>(m["EntryApp"]));
    }
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      appIds = make_shared<string>(boost::any_cast<string>(m["AppIds"]));
    }
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
  }


  virtual ~InsertSwimmingLaneGroupRequest() = default;
};
class InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> appId{};

  InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication() {}

  explicit InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication() = default;
};
class InsertSwimmingLaneGroupResponseBodyDataApplicationList : public Darabonba::Model {
public:
  shared_ptr<vector<InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication>> application{};

  InsertSwimmingLaneGroupResponseBodyDataApplicationList() {}

  explicit InsertSwimmingLaneGroupResponseBodyDataApplicationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (application) {
      vector<boost::any> temp1;
      for(auto item1:*application){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Application"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Application") != m.end() && !m["Application"].empty()) {
      if (typeid(vector<boost::any>) == m["Application"].type()) {
        vector<InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Application"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        application = make_shared<vector<InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication>>(expect1);
      }
    }
  }


  virtual ~InsertSwimmingLaneGroupResponseBodyDataApplicationList() = default;
};
class InsertSwimmingLaneGroupResponseBodyDataEntryApplication : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> appId{};

  InsertSwimmingLaneGroupResponseBodyDataEntryApplication() {}

  explicit InsertSwimmingLaneGroupResponseBodyDataEntryApplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~InsertSwimmingLaneGroupResponseBodyDataEntryApplication() = default;
};
class InsertSwimmingLaneGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<InsertSwimmingLaneGroupResponseBodyDataApplicationList> applicationList{};
  shared_ptr<InsertSwimmingLaneGroupResponseBodyDataEntryApplication> entryApplication{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};

  InsertSwimmingLaneGroupResponseBodyData() {}

  explicit InsertSwimmingLaneGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (applicationList) {
      res["ApplicationList"] = applicationList ? boost::any(applicationList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (entryApplication) {
      res["EntryApplication"] = entryApplication ? boost::any(entryApplication->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("ApplicationList") != m.end() && !m["ApplicationList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplicationList"].type()) {
        InsertSwimmingLaneGroupResponseBodyDataApplicationList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplicationList"]));
        applicationList = make_shared<InsertSwimmingLaneGroupResponseBodyDataApplicationList>(model1);
      }
    }
    if (m.find("EntryApplication") != m.end() && !m["EntryApplication"].empty()) {
      if (typeid(map<string, boost::any>) == m["EntryApplication"].type()) {
        InsertSwimmingLaneGroupResponseBodyDataEntryApplication model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EntryApplication"]));
        entryApplication = make_shared<InsertSwimmingLaneGroupResponseBodyDataEntryApplication>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~InsertSwimmingLaneGroupResponseBodyData() = default;
};
class InsertSwimmingLaneGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<InsertSwimmingLaneGroupResponseBodyData> data{};
  shared_ptr<long> code{};

  InsertSwimmingLaneGroupResponseBody() {}

  explicit InsertSwimmingLaneGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        InsertSwimmingLaneGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<InsertSwimmingLaneGroupResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~InsertSwimmingLaneGroupResponseBody() = default;
};
class InsertSwimmingLaneGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<InsertSwimmingLaneGroupResponseBody> body{};

  InsertSwimmingLaneGroupResponse() {}

  explicit InsertSwimmingLaneGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertSwimmingLaneGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertSwimmingLaneGroupResponseBody>(model1);
      }
    }
  }


  virtual ~InsertSwimmingLaneGroupResponse() = default;
};
class InstallAgentRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> instanceIds{};
  shared_ptr<bool> doAsync{};

  InstallAgentRequest() {}

  explicit InstallAgentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (doAsync) {
      res["DoAsync"] = boost::any(*doAsync);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("DoAsync") != m.end() && !m["DoAsync"].empty()) {
      doAsync = make_shared<bool>(boost::any_cast<bool>(m["DoAsync"]));
    }
  }


  virtual ~InstallAgentRequest() = default;
};
class InstallAgentResponseBodyExecutionResultListExecutionResult : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<bool> success{};
  shared_ptr<string> finishedTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> invokeRecordStatus{};

  InstallAgentResponseBodyExecutionResultListExecutionResult() {}

  explicit InstallAgentResponseBodyExecutionResultListExecutionResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (invokeRecordStatus) {
      res["InvokeRecordStatus"] = boost::any(*invokeRecordStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<string>(boost::any_cast<string>(m["FinishedTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InvokeRecordStatus") != m.end() && !m["InvokeRecordStatus"].empty()) {
      invokeRecordStatus = make_shared<string>(boost::any_cast<string>(m["InvokeRecordStatus"]));
    }
  }


  virtual ~InstallAgentResponseBodyExecutionResultListExecutionResult() = default;
};
class InstallAgentResponseBodyExecutionResultList : public Darabonba::Model {
public:
  shared_ptr<vector<InstallAgentResponseBodyExecutionResultListExecutionResult>> executionResult{};

  InstallAgentResponseBodyExecutionResultList() {}

  explicit InstallAgentResponseBodyExecutionResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (executionResult) {
      vector<boost::any> temp1;
      for(auto item1:*executionResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExecutionResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExecutionResult") != m.end() && !m["ExecutionResult"].empty()) {
      if (typeid(vector<boost::any>) == m["ExecutionResult"].type()) {
        vector<InstallAgentResponseBodyExecutionResultListExecutionResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExecutionResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InstallAgentResponseBodyExecutionResultListExecutionResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        executionResult = make_shared<vector<InstallAgentResponseBodyExecutionResultListExecutionResult>>(expect1);
      }
    }
  }


  virtual ~InstallAgentResponseBodyExecutionResultList() = default;
};
class InstallAgentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<InstallAgentResponseBodyExecutionResultList> executionResultList{};
  shared_ptr<long> code{};

  InstallAgentResponseBody() {}

  explicit InstallAgentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (executionResultList) {
      res["ExecutionResultList"] = executionResultList ? boost::any(executionResultList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ExecutionResultList") != m.end() && !m["ExecutionResultList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExecutionResultList"].type()) {
        InstallAgentResponseBodyExecutionResultList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExecutionResultList"]));
        executionResultList = make_shared<InstallAgentResponseBodyExecutionResultList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~InstallAgentResponseBody() = default;
};
class InstallAgentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<InstallAgentResponseBody> body{};

  InstallAgentResponse() {}

  explicit InstallAgentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallAgentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallAgentResponseBody>(model1);
      }
    }
  }


  virtual ~InstallAgentResponse() = default;
};
class ListAliyunRegionResponseBodyRegionEntityListRegionEntity : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  ListAliyunRegionResponseBodyRegionEntityListRegionEntity() {}

  explicit ListAliyunRegionResponseBodyRegionEntityListRegionEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListAliyunRegionResponseBodyRegionEntityListRegionEntity() = default;
};
class ListAliyunRegionResponseBodyRegionEntityList : public Darabonba::Model {
public:
  shared_ptr<vector<ListAliyunRegionResponseBodyRegionEntityListRegionEntity>> regionEntity{};

  ListAliyunRegionResponseBodyRegionEntityList() {}

  explicit ListAliyunRegionResponseBodyRegionEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionEntity) {
      vector<boost::any> temp1;
      for(auto item1:*regionEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegionEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionEntity") != m.end() && !m["RegionEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["RegionEntity"].type()) {
        vector<ListAliyunRegionResponseBodyRegionEntityListRegionEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegionEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAliyunRegionResponseBodyRegionEntityListRegionEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regionEntity = make_shared<vector<ListAliyunRegionResponseBodyRegionEntityListRegionEntity>>(expect1);
      }
    }
  }


  virtual ~ListAliyunRegionResponseBodyRegionEntityList() = default;
};
class ListAliyunRegionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};
  shared_ptr<ListAliyunRegionResponseBodyRegionEntityList> regionEntityList{};

  ListAliyunRegionResponseBody() {}

  explicit ListAliyunRegionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (regionEntityList) {
      res["RegionEntityList"] = regionEntityList ? boost::any(regionEntityList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RegionEntityList") != m.end() && !m["RegionEntityList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegionEntityList"].type()) {
        ListAliyunRegionResponseBodyRegionEntityList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegionEntityList"]));
        regionEntityList = make_shared<ListAliyunRegionResponseBodyRegionEntityList>(model1);
      }
    }
  }


  virtual ~ListAliyunRegionResponseBody() = default;
};
class ListAliyunRegionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListAliyunRegionResponseBody> body{};

  ListAliyunRegionResponse() {}

  explicit ListAliyunRegionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAliyunRegionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAliyunRegionResponseBody>(model1);
      }
    }
  }


  virtual ~ListAliyunRegionResponse() = default;
};
class ListApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> logicalRegionId{};
  shared_ptr<string> appName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> logicalRegionIdFilter{};

  ListApplicationRequest() {}

  explicit ListApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (logicalRegionIdFilter) {
      res["LogicalRegionIdFilter"] = boost::any(*logicalRegionIdFilter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("LogicalRegionIdFilter") != m.end() && !m["LogicalRegionIdFilter"].empty()) {
      logicalRegionIdFilter = make_shared<string>(boost::any_cast<string>(m["LogicalRegionIdFilter"]));
    }
  }


  virtual ~ListApplicationRequest() = default;
};
class ListApplicationResponseBodyApplicationListApplication : public Darabonba::Model {
public:
  shared_ptr<long> clusterType{};
  shared_ptr<string> appId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> applicationType{};
  shared_ptr<string> name{};
  shared_ptr<long> runningInstanceCount{};
  shared_ptr<long> buildPackageId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  ListApplicationResponseBodyApplicationListApplication() {}

  explicit ListApplicationResponseBodyApplicationListApplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (applicationType) {
      res["ApplicationType"] = boost::any(*applicationType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (runningInstanceCount) {
      res["RunningInstanceCount"] = boost::any(*runningInstanceCount);
    }
    if (buildPackageId) {
      res["BuildPackageId"] = boost::any(*buildPackageId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<long>(boost::any_cast<long>(m["ClusterType"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ApplicationType") != m.end() && !m["ApplicationType"].empty()) {
      applicationType = make_shared<string>(boost::any_cast<string>(m["ApplicationType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RunningInstanceCount") != m.end() && !m["RunningInstanceCount"].empty()) {
      runningInstanceCount = make_shared<long>(boost::any_cast<long>(m["RunningInstanceCount"]));
    }
    if (m.find("BuildPackageId") != m.end() && !m["BuildPackageId"].empty()) {
      buildPackageId = make_shared<long>(boost::any_cast<long>(m["BuildPackageId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListApplicationResponseBodyApplicationListApplication() = default;
};
class ListApplicationResponseBodyApplicationList : public Darabonba::Model {
public:
  shared_ptr<vector<ListApplicationResponseBodyApplicationListApplication>> application{};

  ListApplicationResponseBodyApplicationList() {}

  explicit ListApplicationResponseBodyApplicationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (application) {
      vector<boost::any> temp1;
      for(auto item1:*application){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Application"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Application") != m.end() && !m["Application"].empty()) {
      if (typeid(vector<boost::any>) == m["Application"].type()) {
        vector<ListApplicationResponseBodyApplicationListApplication> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Application"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationResponseBodyApplicationListApplication model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        application = make_shared<vector<ListApplicationResponseBodyApplicationListApplication>>(expect1);
      }
    }
  }


  virtual ~ListApplicationResponseBodyApplicationList() = default;
};
class ListApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListApplicationResponseBodyApplicationList> applicationList{};
  shared_ptr<long> code{};

  ListApplicationResponseBody() {}

  explicit ListApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (applicationList) {
      res["ApplicationList"] = applicationList ? boost::any(applicationList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ApplicationList") != m.end() && !m["ApplicationList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplicationList"].type()) {
        ListApplicationResponseBodyApplicationList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplicationList"]));
        applicationList = make_shared<ListApplicationResponseBodyApplicationList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListApplicationResponseBody() = default;
};
class ListApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListApplicationResponseBody> body{};

  ListApplicationResponse() {}

  explicit ListApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~ListApplicationResponse() = default;
};
class ListApplicationEcuRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  ListApplicationEcuRequest() {}

  explicit ListApplicationEcuRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~ListApplicationEcuRequest() = default;
};
class ListApplicationEcuResponseBodyEcuInfoListEcuEntity : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> ipAddr{};
  shared_ptr<long> availableCpu{};
  shared_ptr<long> createTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> mem{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ecuId{};
  shared_ptr<long> cpu{};
  shared_ptr<string> appId{};
  shared_ptr<bool> dockerEnv{};
  shared_ptr<bool> online{};
  shared_ptr<long> availableMem{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> name{};
  shared_ptr<long> heartbeatTime{};

  ListApplicationEcuResponseBodyEcuInfoListEcuEntity() {}

  explicit ListApplicationEcuResponseBodyEcuInfoListEcuEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (ipAddr) {
      res["IpAddr"] = boost::any(*ipAddr);
    }
    if (availableCpu) {
      res["AvailableCpu"] = boost::any(*availableCpu);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ecuId) {
      res["EcuId"] = boost::any(*ecuId);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dockerEnv) {
      res["DockerEnv"] = boost::any(*dockerEnv);
    }
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (availableMem) {
      res["AvailableMem"] = boost::any(*availableMem);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (heartbeatTime) {
      res["HeartbeatTime"] = boost::any(*heartbeatTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("IpAddr") != m.end() && !m["IpAddr"].empty()) {
      ipAddr = make_shared<string>(boost::any_cast<string>(m["IpAddr"]));
    }
    if (m.find("AvailableCpu") != m.end() && !m["AvailableCpu"].empty()) {
      availableCpu = make_shared<long>(boost::any_cast<long>(m["AvailableCpu"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("EcuId") != m.end() && !m["EcuId"].empty()) {
      ecuId = make_shared<string>(boost::any_cast<string>(m["EcuId"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DockerEnv") != m.end() && !m["DockerEnv"].empty()) {
      dockerEnv = make_shared<bool>(boost::any_cast<bool>(m["DockerEnv"]));
    }
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<bool>(boost::any_cast<bool>(m["Online"]));
    }
    if (m.find("AvailableMem") != m.end() && !m["AvailableMem"].empty()) {
      availableMem = make_shared<long>(boost::any_cast<long>(m["AvailableMem"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("HeartbeatTime") != m.end() && !m["HeartbeatTime"].empty()) {
      heartbeatTime = make_shared<long>(boost::any_cast<long>(m["HeartbeatTime"]));
    }
  }


  virtual ~ListApplicationEcuResponseBodyEcuInfoListEcuEntity() = default;
};
class ListApplicationEcuResponseBodyEcuInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<ListApplicationEcuResponseBodyEcuInfoListEcuEntity>> ecuEntity{};

  ListApplicationEcuResponseBodyEcuInfoList() {}

  explicit ListApplicationEcuResponseBodyEcuInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecuEntity) {
      vector<boost::any> temp1;
      for(auto item1:*ecuEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EcuEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcuEntity") != m.end() && !m["EcuEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["EcuEntity"].type()) {
        vector<ListApplicationEcuResponseBodyEcuInfoListEcuEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EcuEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationEcuResponseBodyEcuInfoListEcuEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ecuEntity = make_shared<vector<ListApplicationEcuResponseBodyEcuInfoListEcuEntity>>(expect1);
      }
    }
  }


  virtual ~ListApplicationEcuResponseBodyEcuInfoList() = default;
};
class ListApplicationEcuResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListApplicationEcuResponseBodyEcuInfoList> ecuInfoList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  ListApplicationEcuResponseBody() {}

  explicit ListApplicationEcuResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecuInfoList) {
      res["EcuInfoList"] = ecuInfoList ? boost::any(ecuInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcuInfoList") != m.end() && !m["EcuInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EcuInfoList"].type()) {
        ListApplicationEcuResponseBodyEcuInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EcuInfoList"]));
        ecuInfoList = make_shared<ListApplicationEcuResponseBodyEcuInfoList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListApplicationEcuResponseBody() = default;
};
class ListApplicationEcuResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListApplicationEcuResponseBody> body{};

  ListApplicationEcuResponse() {}

  explicit ListApplicationEcuResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApplicationEcuResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApplicationEcuResponseBody>(model1);
      }
    }
  }


  virtual ~ListApplicationEcuResponse() = default;
};
class ListAuthorityResponseBodyAuthorityListAuthorityActionListAction : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> code{};
  shared_ptr<string> name{};

  ListAuthorityResponseBodyAuthorityListAuthorityActionListAction() {}

  explicit ListAuthorityResponseBodyAuthorityListAuthorityActionListAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListAuthorityResponseBodyAuthorityListAuthorityActionListAction() = default;
};
class ListAuthorityResponseBodyAuthorityListAuthorityActionList : public Darabonba::Model {
public:
  shared_ptr<vector<ListAuthorityResponseBodyAuthorityListAuthorityActionListAction>> action{};

  ListAuthorityResponseBodyAuthorityListAuthorityActionList() {}

  explicit ListAuthorityResponseBodyAuthorityListAuthorityActionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      vector<boost::any> temp1;
      for(auto item1:*action){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Action"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      if (typeid(vector<boost::any>) == m["Action"].type()) {
        vector<ListAuthorityResponseBodyAuthorityListAuthorityActionListAction> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Action"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAuthorityResponseBodyAuthorityListAuthorityActionListAction model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        action = make_shared<vector<ListAuthorityResponseBodyAuthorityListAuthorityActionListAction>>(expect1);
      }
    }
  }


  virtual ~ListAuthorityResponseBodyAuthorityListAuthorityActionList() = default;
};
class ListAuthorityResponseBodyAuthorityListAuthority : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> description{};
  shared_ptr<ListAuthorityResponseBodyAuthorityListAuthorityActionList> actionList{};
  shared_ptr<string> name{};

  ListAuthorityResponseBodyAuthorityListAuthority() {}

  explicit ListAuthorityResponseBodyAuthorityListAuthority(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (actionList) {
      res["ActionList"] = actionList ? boost::any(actionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ActionList") != m.end() && !m["ActionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ActionList"].type()) {
        ListAuthorityResponseBodyAuthorityListAuthorityActionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ActionList"]));
        actionList = make_shared<ListAuthorityResponseBodyAuthorityListAuthorityActionList>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListAuthorityResponseBodyAuthorityListAuthority() = default;
};
class ListAuthorityResponseBodyAuthorityList : public Darabonba::Model {
public:
  shared_ptr<vector<ListAuthorityResponseBodyAuthorityListAuthority>> authority{};

  ListAuthorityResponseBodyAuthorityList() {}

  explicit ListAuthorityResponseBodyAuthorityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authority) {
      vector<boost::any> temp1;
      for(auto item1:*authority){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Authority"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Authority") != m.end() && !m["Authority"].empty()) {
      if (typeid(vector<boost::any>) == m["Authority"].type()) {
        vector<ListAuthorityResponseBodyAuthorityListAuthority> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Authority"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAuthorityResponseBodyAuthorityListAuthority model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authority = make_shared<vector<ListAuthorityResponseBodyAuthorityListAuthority>>(expect1);
      }
    }
  }


  virtual ~ListAuthorityResponseBodyAuthorityList() = default;
};
class ListAuthorityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};
  shared_ptr<ListAuthorityResponseBodyAuthorityList> authorityList{};

  ListAuthorityResponseBody() {}

  explicit ListAuthorityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (authorityList) {
      res["AuthorityList"] = authorityList ? boost::any(authorityList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("AuthorityList") != m.end() && !m["AuthorityList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthorityList"].type()) {
        ListAuthorityResponseBodyAuthorityList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthorityList"]));
        authorityList = make_shared<ListAuthorityResponseBodyAuthorityList>(model1);
      }
    }
  }


  virtual ~ListAuthorityResponseBody() = default;
};
class ListAuthorityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListAuthorityResponseBody> body{};

  ListAuthorityResponse() {}

  explicit ListAuthorityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAuthorityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAuthorityResponseBody>(model1);
      }
    }
  }


  virtual ~ListAuthorityResponse() = default;
};
class ListBuildPackResponseBodyBuildPackListBuildPack : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> pandoraVersion{};
  shared_ptr<string> pandoraDesc{};
  shared_ptr<string> feature{};
  shared_ptr<string> pluginInfo{};
  shared_ptr<string> tengineDownloadUrl{};
  shared_ptr<bool> disabled{};
  shared_ptr<string> tomcatPath{};
  shared_ptr<string> tomcatDesc{};
  shared_ptr<string> supportFeatures{};
  shared_ptr<string> tomcatDownloadUrl{};
  shared_ptr<string> tomcatVersion{};
  shared_ptr<string> pandoraDownloadUrl{};
  shared_ptr<string> packVersion{};
  shared_ptr<bool> multipleTenant{};
  shared_ptr<string> tengineImageId{};
  shared_ptr<bool> withTengine{};
  shared_ptr<string> imageId{};
  shared_ptr<string> scriptName{};
  shared_ptr<string> scriptVersion{};

  ListBuildPackResponseBodyBuildPackListBuildPack() {}

  explicit ListBuildPackResponseBodyBuildPackListBuildPack(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (pandoraVersion) {
      res["PandoraVersion"] = boost::any(*pandoraVersion);
    }
    if (pandoraDesc) {
      res["PandoraDesc"] = boost::any(*pandoraDesc);
    }
    if (feature) {
      res["Feature"] = boost::any(*feature);
    }
    if (pluginInfo) {
      res["PluginInfo"] = boost::any(*pluginInfo);
    }
    if (tengineDownloadUrl) {
      res["TengineDownloadUrl"] = boost::any(*tengineDownloadUrl);
    }
    if (disabled) {
      res["Disabled"] = boost::any(*disabled);
    }
    if (tomcatPath) {
      res["TomcatPath"] = boost::any(*tomcatPath);
    }
    if (tomcatDesc) {
      res["TomcatDesc"] = boost::any(*tomcatDesc);
    }
    if (supportFeatures) {
      res["SupportFeatures"] = boost::any(*supportFeatures);
    }
    if (tomcatDownloadUrl) {
      res["TomcatDownloadUrl"] = boost::any(*tomcatDownloadUrl);
    }
    if (tomcatVersion) {
      res["TomcatVersion"] = boost::any(*tomcatVersion);
    }
    if (pandoraDownloadUrl) {
      res["PandoraDownloadUrl"] = boost::any(*pandoraDownloadUrl);
    }
    if (packVersion) {
      res["PackVersion"] = boost::any(*packVersion);
    }
    if (multipleTenant) {
      res["MultipleTenant"] = boost::any(*multipleTenant);
    }
    if (tengineImageId) {
      res["TengineImageId"] = boost::any(*tengineImageId);
    }
    if (withTengine) {
      res["WithTengine"] = boost::any(*withTengine);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (scriptName) {
      res["ScriptName"] = boost::any(*scriptName);
    }
    if (scriptVersion) {
      res["ScriptVersion"] = boost::any(*scriptVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("PandoraVersion") != m.end() && !m["PandoraVersion"].empty()) {
      pandoraVersion = make_shared<string>(boost::any_cast<string>(m["PandoraVersion"]));
    }
    if (m.find("PandoraDesc") != m.end() && !m["PandoraDesc"].empty()) {
      pandoraDesc = make_shared<string>(boost::any_cast<string>(m["PandoraDesc"]));
    }
    if (m.find("Feature") != m.end() && !m["Feature"].empty()) {
      feature = make_shared<string>(boost::any_cast<string>(m["Feature"]));
    }
    if (m.find("PluginInfo") != m.end() && !m["PluginInfo"].empty()) {
      pluginInfo = make_shared<string>(boost::any_cast<string>(m["PluginInfo"]));
    }
    if (m.find("TengineDownloadUrl") != m.end() && !m["TengineDownloadUrl"].empty()) {
      tengineDownloadUrl = make_shared<string>(boost::any_cast<string>(m["TengineDownloadUrl"]));
    }
    if (m.find("Disabled") != m.end() && !m["Disabled"].empty()) {
      disabled = make_shared<bool>(boost::any_cast<bool>(m["Disabled"]));
    }
    if (m.find("TomcatPath") != m.end() && !m["TomcatPath"].empty()) {
      tomcatPath = make_shared<string>(boost::any_cast<string>(m["TomcatPath"]));
    }
    if (m.find("TomcatDesc") != m.end() && !m["TomcatDesc"].empty()) {
      tomcatDesc = make_shared<string>(boost::any_cast<string>(m["TomcatDesc"]));
    }
    if (m.find("SupportFeatures") != m.end() && !m["SupportFeatures"].empty()) {
      supportFeatures = make_shared<string>(boost::any_cast<string>(m["SupportFeatures"]));
    }
    if (m.find("TomcatDownloadUrl") != m.end() && !m["TomcatDownloadUrl"].empty()) {
      tomcatDownloadUrl = make_shared<string>(boost::any_cast<string>(m["TomcatDownloadUrl"]));
    }
    if (m.find("TomcatVersion") != m.end() && !m["TomcatVersion"].empty()) {
      tomcatVersion = make_shared<string>(boost::any_cast<string>(m["TomcatVersion"]));
    }
    if (m.find("PandoraDownloadUrl") != m.end() && !m["PandoraDownloadUrl"].empty()) {
      pandoraDownloadUrl = make_shared<string>(boost::any_cast<string>(m["PandoraDownloadUrl"]));
    }
    if (m.find("PackVersion") != m.end() && !m["PackVersion"].empty()) {
      packVersion = make_shared<string>(boost::any_cast<string>(m["PackVersion"]));
    }
    if (m.find("MultipleTenant") != m.end() && !m["MultipleTenant"].empty()) {
      multipleTenant = make_shared<bool>(boost::any_cast<bool>(m["MultipleTenant"]));
    }
    if (m.find("TengineImageId") != m.end() && !m["TengineImageId"].empty()) {
      tengineImageId = make_shared<string>(boost::any_cast<string>(m["TengineImageId"]));
    }
    if (m.find("WithTengine") != m.end() && !m["WithTengine"].empty()) {
      withTengine = make_shared<bool>(boost::any_cast<bool>(m["WithTengine"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ScriptName") != m.end() && !m["ScriptName"].empty()) {
      scriptName = make_shared<string>(boost::any_cast<string>(m["ScriptName"]));
    }
    if (m.find("ScriptVersion") != m.end() && !m["ScriptVersion"].empty()) {
      scriptVersion = make_shared<string>(boost::any_cast<string>(m["ScriptVersion"]));
    }
  }


  virtual ~ListBuildPackResponseBodyBuildPackListBuildPack() = default;
};
class ListBuildPackResponseBodyBuildPackList : public Darabonba::Model {
public:
  shared_ptr<vector<ListBuildPackResponseBodyBuildPackListBuildPack>> buildPack{};

  ListBuildPackResponseBodyBuildPackList() {}

  explicit ListBuildPackResponseBodyBuildPackList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (buildPack) {
      vector<boost::any> temp1;
      for(auto item1:*buildPack){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BuildPack"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BuildPack") != m.end() && !m["BuildPack"].empty()) {
      if (typeid(vector<boost::any>) == m["BuildPack"].type()) {
        vector<ListBuildPackResponseBodyBuildPackListBuildPack> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BuildPack"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBuildPackResponseBodyBuildPackListBuildPack model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        buildPack = make_shared<vector<ListBuildPackResponseBodyBuildPackListBuildPack>>(expect1);
      }
    }
  }


  virtual ~ListBuildPackResponseBodyBuildPackList() = default;
};
class ListBuildPackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListBuildPackResponseBodyBuildPackList> buildPackList{};
  shared_ptr<long> code{};

  ListBuildPackResponseBody() {}

  explicit ListBuildPackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (buildPackList) {
      res["BuildPackList"] = buildPackList ? boost::any(buildPackList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("BuildPackList") != m.end() && !m["BuildPackList"].empty()) {
      if (typeid(map<string, boost::any>) == m["BuildPackList"].type()) {
        ListBuildPackResponseBodyBuildPackList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BuildPackList"]));
        buildPackList = make_shared<ListBuildPackResponseBodyBuildPackList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListBuildPackResponseBody() = default;
};
class ListBuildPackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListBuildPackResponseBody> body{};

  ListBuildPackResponse() {}

  explicit ListBuildPackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBuildPackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBuildPackResponseBody>(model1);
      }
    }
  }


  virtual ~ListBuildPackResponse() = default;
};
class ListChildrenStacksRequest : public Darabonba::Model {
public:
  shared_ptr<long> stackId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  ListChildrenStacksRequest() {}

  explicit ListChildrenStacksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stackId) {
      res["StackId"] = boost::any(*stackId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StackId") != m.end() && !m["StackId"].empty()) {
      stackId = make_shared<long>(boost::any_cast<long>(m["StackId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListChildrenStacksRequest() = default;
};
class ListChildrenStacksResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<vector<string>> buildTypes{};
  shared_ptr<bool> latest{};
  shared_ptr<string> name{};
  shared_ptr<bool> preferred{};
  shared_ptr<long> id{};

  ListChildrenStacksResponseBodyDataResult() {}

  explicit ListChildrenStacksResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (buildTypes) {
      res["BuildTypes"] = boost::any(*buildTypes);
    }
    if (latest) {
      res["Latest"] = boost::any(*latest);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (preferred) {
      res["Preferred"] = boost::any(*preferred);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("BuildTypes") != m.end() && !m["BuildTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BuildTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BuildTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      buildTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Latest") != m.end() && !m["Latest"].empty()) {
      latest = make_shared<bool>(boost::any_cast<bool>(m["Latest"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Preferred") != m.end() && !m["Preferred"].empty()) {
      preferred = make_shared<bool>(boost::any_cast<bool>(m["Preferred"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~ListChildrenStacksResponseBodyDataResult() = default;
};
class ListChildrenStacksResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<ListChildrenStacksResponseBodyDataResult>> result{};
  shared_ptr<long> totalSize{};
  shared_ptr<long> pageSize{};

  ListChildrenStacksResponseBodyData() {}

  explicit ListChildrenStacksResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListChildrenStacksResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListChildrenStacksResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListChildrenStacksResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListChildrenStacksResponseBodyData() = default;
};
class ListChildrenStacksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListChildrenStacksResponseBodyData> data{};
  shared_ptr<long> code{};

  ListChildrenStacksResponseBody() {}

  explicit ListChildrenStacksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListChildrenStacksResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListChildrenStacksResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListChildrenStacksResponseBody() = default;
};
class ListChildrenStacksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListChildrenStacksResponseBody> body{};

  ListChildrenStacksResponse() {}

  explicit ListChildrenStacksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListChildrenStacksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListChildrenStacksResponseBody>(model1);
      }
    }
  }


  virtual ~ListChildrenStacksResponse() = default;
};
class ListClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> logicalRegionId{};
  shared_ptr<string> resourceGroupId{};

  ListClusterRequest() {}

  explicit ListClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListClusterRequest() = default;
};
class ListClusterResponseBodyClusterListCluster : public Darabonba::Model {
public:
  shared_ptr<long> oversoldFactor{};
  shared_ptr<string> vpcId{};
  shared_ptr<long> updateTime{};
  shared_ptr<long> memUsed{};
  shared_ptr<string> iaasProvider{};
  shared_ptr<long> createTime{};
  shared_ptr<long> cpuUsed{};
  shared_ptr<long> mem{};
  shared_ptr<string> regionId{};
  shared_ptr<long> cpu{};
  shared_ptr<string> csClusterId{};
  shared_ptr<string> description{};
  shared_ptr<long> networkMode{};
  shared_ptr<long> clusterType{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> clusterName{};
  shared_ptr<long> nodeNum{};
  shared_ptr<string> clusterId{};

  ListClusterResponseBodyClusterListCluster() {}

  explicit ListClusterResponseBodyClusterListCluster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (oversoldFactor) {
      res["OversoldFactor"] = boost::any(*oversoldFactor);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (memUsed) {
      res["MemUsed"] = boost::any(*memUsed);
    }
    if (iaasProvider) {
      res["IaasProvider"] = boost::any(*iaasProvider);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (cpuUsed) {
      res["CpuUsed"] = boost::any(*cpuUsed);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (csClusterId) {
      res["CsClusterId"] = boost::any(*csClusterId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (networkMode) {
      res["NetworkMode"] = boost::any(*networkMode);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (nodeNum) {
      res["NodeNum"] = boost::any(*nodeNum);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OversoldFactor") != m.end() && !m["OversoldFactor"].empty()) {
      oversoldFactor = make_shared<long>(boost::any_cast<long>(m["OversoldFactor"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("MemUsed") != m.end() && !m["MemUsed"].empty()) {
      memUsed = make_shared<long>(boost::any_cast<long>(m["MemUsed"]));
    }
    if (m.find("IaasProvider") != m.end() && !m["IaasProvider"].empty()) {
      iaasProvider = make_shared<string>(boost::any_cast<string>(m["IaasProvider"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CpuUsed") != m.end() && !m["CpuUsed"].empty()) {
      cpuUsed = make_shared<long>(boost::any_cast<long>(m["CpuUsed"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CsClusterId") != m.end() && !m["CsClusterId"].empty()) {
      csClusterId = make_shared<string>(boost::any_cast<string>(m["CsClusterId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NetworkMode") != m.end() && !m["NetworkMode"].empty()) {
      networkMode = make_shared<long>(boost::any_cast<long>(m["NetworkMode"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<long>(boost::any_cast<long>(m["ClusterType"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("NodeNum") != m.end() && !m["NodeNum"].empty()) {
      nodeNum = make_shared<long>(boost::any_cast<long>(m["NodeNum"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~ListClusterResponseBodyClusterListCluster() = default;
};
class ListClusterResponseBodyClusterList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterResponseBodyClusterListCluster>> cluster{};

  ListClusterResponseBodyClusterList() {}

  explicit ListClusterResponseBodyClusterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cluster) {
      vector<boost::any> temp1;
      for(auto item1:*cluster){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Cluster"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cluster") != m.end() && !m["Cluster"].empty()) {
      if (typeid(vector<boost::any>) == m["Cluster"].type()) {
        vector<ListClusterResponseBodyClusterListCluster> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Cluster"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterResponseBodyClusterListCluster model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cluster = make_shared<vector<ListClusterResponseBodyClusterListCluster>>(expect1);
      }
    }
  }


  virtual ~ListClusterResponseBodyClusterList() = default;
};
class ListClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListClusterResponseBodyClusterList> clusterList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  ListClusterResponseBody() {}

  explicit ListClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterList) {
      res["ClusterList"] = clusterList ? boost::any(clusterList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterList") != m.end() && !m["ClusterList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterList"].type()) {
        ListClusterResponseBodyClusterList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterList"]));
        clusterList = make_shared<ListClusterResponseBodyClusterList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListClusterResponseBody() = default;
};
class ListClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListClusterResponseBody> body{};

  ListClusterResponse() {}

  explicit ListClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterResponse() = default;
};
class ListClusterMembersRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ecsList{};

  ListClusterMembersRequest() {}

  explicit ListClusterMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ecsList) {
      res["EcsList"] = boost::any(*ecsList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("EcsList") != m.end() && !m["EcsList"].empty()) {
      ecsList = make_shared<string>(boost::any_cast<string>(m["EcsList"]));
    }
  }


  virtual ~ListClusterMembersRequest() = default;
};
class ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> ecuId{};
  shared_ptr<string> ecsId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> clusterMemberId{};
  shared_ptr<string> clusterId{};

  ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember() {}

  explicit ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (ecuId) {
      res["EcuId"] = boost::any(*ecuId);
    }
    if (ecsId) {
      res["EcsId"] = boost::any(*ecsId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (clusterMemberId) {
      res["ClusterMemberId"] = boost::any(*clusterMemberId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("EcuId") != m.end() && !m["EcuId"].empty()) {
      ecuId = make_shared<string>(boost::any_cast<string>(m["EcuId"]));
    }
    if (m.find("EcsId") != m.end() && !m["EcsId"].empty()) {
      ecsId = make_shared<string>(boost::any_cast<string>(m["EcsId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ClusterMemberId") != m.end() && !m["ClusterMemberId"].empty()) {
      clusterMemberId = make_shared<string>(boost::any_cast<string>(m["ClusterMemberId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember() = default;
};
class ListClusterMembersResponseBodyClusterMemberPageClusterMemberList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember>> clusterMember{};

  ListClusterMembersResponseBodyClusterMemberPageClusterMemberList() {}

  explicit ListClusterMembersResponseBodyClusterMemberPageClusterMemberList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterMember) {
      vector<boost::any> temp1;
      for(auto item1:*clusterMember){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterMember"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterMember") != m.end() && !m["ClusterMember"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterMember"].type()) {
        vector<ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterMember"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterMember = make_shared<vector<ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember>>(expect1);
      }
    }
  }


  virtual ~ListClusterMembersResponseBodyClusterMemberPageClusterMemberList() = default;
};
class ListClusterMembersResponseBodyClusterMemberPage : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> totalSize{};
  shared_ptr<long> pageSize{};
  shared_ptr<ListClusterMembersResponseBodyClusterMemberPageClusterMemberList> clusterMemberList{};

  ListClusterMembersResponseBodyClusterMemberPage() {}

  explicit ListClusterMembersResponseBodyClusterMemberPage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (clusterMemberList) {
      res["ClusterMemberList"] = clusterMemberList ? boost::any(clusterMemberList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ClusterMemberList") != m.end() && !m["ClusterMemberList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterMemberList"].type()) {
        ListClusterMembersResponseBodyClusterMemberPageClusterMemberList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterMemberList"]));
        clusterMemberList = make_shared<ListClusterMembersResponseBodyClusterMemberPageClusterMemberList>(model1);
      }
    }
  }


  virtual ~ListClusterMembersResponseBodyClusterMemberPage() = default;
};
class ListClusterMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListClusterMembersResponseBodyClusterMemberPage> clusterMemberPage{};
  shared_ptr<long> code{};

  ListClusterMembersResponseBody() {}

  explicit ListClusterMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (clusterMemberPage) {
      res["ClusterMemberPage"] = clusterMemberPage ? boost::any(clusterMemberPage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ClusterMemberPage") != m.end() && !m["ClusterMemberPage"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterMemberPage"].type()) {
        ListClusterMembersResponseBodyClusterMemberPage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterMemberPage"]));
        clusterMemberPage = make_shared<ListClusterMembersResponseBodyClusterMemberPage>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListClusterMembersResponseBody() = default;
};
class ListClusterMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListClusterMembersResponseBody> body{};

  ListClusterMembersResponse() {}

  explicit ListClusterMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterMembersResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterMembersResponse() = default;
};
class ListComponentsResponseBodyComponentListComponent : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> componentKey{};
  shared_ptr<string> version{};
  shared_ptr<bool> expired{};
  shared_ptr<string> componentId{};
  shared_ptr<string> desc{};

  ListComponentsResponseBodyComponentListComponent() {}

  explicit ListComponentsResponseBodyComponentListComponent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (componentKey) {
      res["ComponentKey"] = boost::any(*componentKey);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (expired) {
      res["Expired"] = boost::any(*expired);
    }
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ComponentKey") != m.end() && !m["ComponentKey"].empty()) {
      componentKey = make_shared<string>(boost::any_cast<string>(m["ComponentKey"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("Expired") != m.end() && !m["Expired"].empty()) {
      expired = make_shared<bool>(boost::any_cast<bool>(m["Expired"]));
    }
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      componentId = make_shared<string>(boost::any_cast<string>(m["ComponentId"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
  }


  virtual ~ListComponentsResponseBodyComponentListComponent() = default;
};
class ListComponentsResponseBodyComponentList : public Darabonba::Model {
public:
  shared_ptr<vector<ListComponentsResponseBodyComponentListComponent>> component{};

  ListComponentsResponseBodyComponentList() {}

  explicit ListComponentsResponseBodyComponentList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (component) {
      vector<boost::any> temp1;
      for(auto item1:*component){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Component"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Component") != m.end() && !m["Component"].empty()) {
      if (typeid(vector<boost::any>) == m["Component"].type()) {
        vector<ListComponentsResponseBodyComponentListComponent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Component"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListComponentsResponseBodyComponentListComponent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        component = make_shared<vector<ListComponentsResponseBodyComponentListComponent>>(expect1);
      }
    }
  }


  virtual ~ListComponentsResponseBodyComponentList() = default;
};
class ListComponentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<ListComponentsResponseBodyComponentList> componentList{};
  shared_ptr<long> code{};

  ListComponentsResponseBody() {}

  explicit ListComponentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (componentList) {
      res["ComponentList"] = componentList ? boost::any(componentList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ComponentList") != m.end() && !m["ComponentList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComponentList"].type()) {
        ListComponentsResponseBodyComponentList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComponentList"]));
        componentList = make_shared<ListComponentsResponseBodyComponentList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListComponentsResponseBody() = default;
};
class ListComponentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListComponentsResponseBody> body{};

  ListComponentsResponse() {}

  explicit ListComponentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListComponentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListComponentsResponseBody>(model1);
      }
    }
  }


  virtual ~ListComponentsResponse() = default;
};
class ListConfigCentersRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataIdPattern{};
  shared_ptr<string> group{};
  shared_ptr<string> logicalRegionId{};
  shared_ptr<string> appName{};

  ListConfigCentersRequest() {}

  explicit ListConfigCentersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataIdPattern) {
      res["DataIdPattern"] = boost::any(*dataIdPattern);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataIdPattern") != m.end() && !m["DataIdPattern"].empty()) {
      dataIdPattern = make_shared<string>(boost::any_cast<string>(m["DataIdPattern"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
  }


  virtual ~ListConfigCentersRequest() = default;
};
class ListConfigCentersResponseBodyConfigCentersListListConfigCenters : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> dataId{};
  shared_ptr<string> id{};
  shared_ptr<string> group{};

  ListConfigCentersResponseBodyConfigCentersListListConfigCenters() {}

  explicit ListConfigCentersResponseBodyConfigCentersListListConfigCenters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
  }


  virtual ~ListConfigCentersResponseBodyConfigCentersListListConfigCenters() = default;
};
class ListConfigCentersResponseBodyConfigCentersList : public Darabonba::Model {
public:
  shared_ptr<vector<ListConfigCentersResponseBodyConfigCentersListListConfigCenters>> listConfigCenters{};

  ListConfigCentersResponseBodyConfigCentersList() {}

  explicit ListConfigCentersResponseBodyConfigCentersList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listConfigCenters) {
      vector<boost::any> temp1;
      for(auto item1:*listConfigCenters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ListConfigCenters"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListConfigCenters") != m.end() && !m["ListConfigCenters"].empty()) {
      if (typeid(vector<boost::any>) == m["ListConfigCenters"].type()) {
        vector<ListConfigCentersResponseBodyConfigCentersListListConfigCenters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ListConfigCenters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConfigCentersResponseBodyConfigCentersListListConfigCenters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        listConfigCenters = make_shared<vector<ListConfigCentersResponseBodyConfigCentersListListConfigCenters>>(expect1);
      }
    }
  }


  virtual ~ListConfigCentersResponseBodyConfigCentersList() = default;
};
class ListConfigCentersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListConfigCentersResponseBodyConfigCentersList> configCentersList{};
  shared_ptr<long> code{};

  ListConfigCentersResponseBody() {}

  explicit ListConfigCentersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (configCentersList) {
      res["ConfigCentersList"] = configCentersList ? boost::any(configCentersList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ConfigCentersList") != m.end() && !m["ConfigCentersList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigCentersList"].type()) {
        ListConfigCentersResponseBodyConfigCentersList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigCentersList"]));
        configCentersList = make_shared<ListConfigCentersResponseBodyConfigCentersList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListConfigCentersResponseBody() = default;
};
class ListConfigCentersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListConfigCentersResponseBody> body{};

  ListConfigCentersResponse() {}

  explicit ListConfigCentersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListConfigCentersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListConfigCentersResponseBody>(model1);
      }
    }
  }


  virtual ~ListConfigCentersResponse() = default;
};
class ListConsumedServicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  ListConsumedServicesRequest() {}

  explicit ListConsumedServicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~ListConsumedServicesRequest() = default;
};
class ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesGroups : public Darabonba::Model {
public:
  shared_ptr<vector<string>> group{};

  ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesGroups() {}

  explicit ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (group) {
      res["group"] = boost::any(*group);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("group") != m.end() && !m["group"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["group"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["group"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      group = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesGroups() = default;
};
class ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesIps : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ip{};

  ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesIps() {}

  explicit ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesIps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["ip"] = boost::any(*ip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ip") != m.end() && !m["ip"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ip"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ip"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ip = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesIps() = default;
};
class ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices : public Darabonba::Model {
public:
  shared_ptr<bool> dockerApplication{};
  shared_ptr<string> type{};
  shared_ptr<ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesGroups> groups{};
  shared_ptr<string> version{};
  shared_ptr<string> appId{};
  shared_ptr<string> group2Ip{};
  shared_ptr<ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesIps> ips{};
  shared_ptr<string> name{};

  ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices() {}

  explicit ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dockerApplication) {
      res["DockerApplication"] = boost::any(*dockerApplication);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (groups) {
      res["Groups"] = groups ? boost::any(groups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (group2Ip) {
      res["Group2Ip"] = boost::any(*group2Ip);
    }
    if (ips) {
      res["Ips"] = ips ? boost::any(ips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DockerApplication") != m.end() && !m["DockerApplication"].empty()) {
      dockerApplication = make_shared<bool>(boost::any_cast<bool>(m["DockerApplication"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      if (typeid(map<string, boost::any>) == m["Groups"].type()) {
        ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Groups"]));
        groups = make_shared<ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesGroups>(model1);
      }
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Group2Ip") != m.end() && !m["Group2Ip"].empty()) {
      group2Ip = make_shared<string>(boost::any_cast<string>(m["Group2Ip"]));
    }
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ips"].type()) {
        ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesIps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ips"]));
        ips = make_shared<ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesIps>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices() = default;
};
class ListConsumedServicesResponseBodyConsumedServicesList : public Darabonba::Model {
public:
  shared_ptr<vector<ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices>> listConsumedServices{};

  ListConsumedServicesResponseBodyConsumedServicesList() {}

  explicit ListConsumedServicesResponseBodyConsumedServicesList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listConsumedServices) {
      vector<boost::any> temp1;
      for(auto item1:*listConsumedServices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ListConsumedServices"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListConsumedServices") != m.end() && !m["ListConsumedServices"].empty()) {
      if (typeid(vector<boost::any>) == m["ListConsumedServices"].type()) {
        vector<ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ListConsumedServices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        listConsumedServices = make_shared<vector<ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices>>(expect1);
      }
    }
  }


  virtual ~ListConsumedServicesResponseBodyConsumedServicesList() = default;
};
class ListConsumedServicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListConsumedServicesResponseBodyConsumedServicesList> consumedServicesList{};
  shared_ptr<long> code{};

  ListConsumedServicesResponseBody() {}

  explicit ListConsumedServicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (consumedServicesList) {
      res["ConsumedServicesList"] = consumedServicesList ? boost::any(consumedServicesList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ConsumedServicesList") != m.end() && !m["ConsumedServicesList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConsumedServicesList"].type()) {
        ListConsumedServicesResponseBodyConsumedServicesList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConsumedServicesList"]));
        consumedServicesList = make_shared<ListConsumedServicesResponseBodyConsumedServicesList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListConsumedServicesResponseBody() = default;
};
class ListConsumedServicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListConsumedServicesResponseBody> body{};

  ListConsumedServicesResponse() {}

  explicit ListConsumedServicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListConsumedServicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListConsumedServicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListConsumedServicesResponse() = default;
};
class ListConvertableEcuRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};

  ListConvertableEcuRequest() {}

  explicit ListConvertableEcuRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["clusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clusterId") != m.end() && !m["clusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["clusterId"]));
    }
  }


  virtual ~ListConvertableEcuRequest() = default;
};
class ListConvertableEcuResponseBodyInstanceListInstance : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> privateIp{};
  shared_ptr<bool> expired{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> mem{};
  shared_ptr<string> regionId{};
  shared_ptr<string> vpcName{};
  shared_ptr<string> ecuId{};
  shared_ptr<string> innerIp{};
  shared_ptr<long> cpu{};
  shared_ptr<string> eip{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> publicIp{};

  ListConvertableEcuResponseBodyInstanceListInstance() {}

  explicit ListConvertableEcuResponseBodyInstanceListInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (privateIp) {
      res["PrivateIp"] = boost::any(*privateIp);
    }
    if (expired) {
      res["Expired"] = boost::any(*expired);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    if (ecuId) {
      res["EcuId"] = boost::any(*ecuId);
    }
    if (innerIp) {
      res["InnerIp"] = boost::any(*innerIp);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (eip) {
      res["Eip"] = boost::any(*eip);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (publicIp) {
      res["PublicIp"] = boost::any(*publicIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("PrivateIp") != m.end() && !m["PrivateIp"].empty()) {
      privateIp = make_shared<string>(boost::any_cast<string>(m["PrivateIp"]));
    }
    if (m.find("Expired") != m.end() && !m["Expired"].empty()) {
      expired = make_shared<bool>(boost::any_cast<bool>(m["Expired"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
    if (m.find("EcuId") != m.end() && !m["EcuId"].empty()) {
      ecuId = make_shared<string>(boost::any_cast<string>(m["EcuId"]));
    }
    if (m.find("InnerIp") != m.end() && !m["InnerIp"].empty()) {
      innerIp = make_shared<string>(boost::any_cast<string>(m["InnerIp"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("Eip") != m.end() && !m["Eip"].empty()) {
      eip = make_shared<string>(boost::any_cast<string>(m["Eip"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("PublicIp") != m.end() && !m["PublicIp"].empty()) {
      publicIp = make_shared<string>(boost::any_cast<string>(m["PublicIp"]));
    }
  }


  virtual ~ListConvertableEcuResponseBodyInstanceListInstance() = default;
};
class ListConvertableEcuResponseBodyInstanceList : public Darabonba::Model {
public:
  shared_ptr<vector<ListConvertableEcuResponseBodyInstanceListInstance>> instance{};

  ListConvertableEcuResponseBodyInstanceList() {}

  explicit ListConvertableEcuResponseBodyInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      vector<boost::any> temp1;
      for(auto item1:*instance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(vector<boost::any>) == m["Instance"].type()) {
        vector<ListConvertableEcuResponseBodyInstanceListInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConvertableEcuResponseBodyInstanceListInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instance = make_shared<vector<ListConvertableEcuResponseBodyInstanceListInstance>>(expect1);
      }
    }
  }


  virtual ~ListConvertableEcuResponseBodyInstanceList() = default;
};
class ListConvertableEcuResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListConvertableEcuResponseBodyInstanceList> instanceList{};
  shared_ptr<long> code{};

  ListConvertableEcuResponseBody() {}

  explicit ListConvertableEcuResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceList) {
      res["InstanceList"] = instanceList ? boost::any(instanceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceList") != m.end() && !m["InstanceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceList"].type()) {
        ListConvertableEcuResponseBodyInstanceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceList"]));
        instanceList = make_shared<ListConvertableEcuResponseBodyInstanceList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListConvertableEcuResponseBody() = default;
};
class ListConvertableEcuResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListConvertableEcuResponseBody> body{};

  ListConvertableEcuResponse() {}

  explicit ListConvertableEcuResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListConvertableEcuResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListConvertableEcuResponseBody>(model1);
      }
    }
  }


  virtual ~ListConvertableEcuResponse() = default;
};
class ListCSBGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> logicalRegionId{};

  ListCSBGatewayRequest() {}

  explicit ListCSBGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
  }


  virtual ~ListCSBGatewayRequest() = default;
};
class ListCSBGatewayResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> gatewayType{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};

  ListCSBGatewayResponseBodyData() {}

  explicit ListCSBGatewayResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewayType) {
      res["GatewayType"] = boost::any(*gatewayType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewayType") != m.end() && !m["GatewayType"].empty()) {
      gatewayType = make_shared<string>(boost::any_cast<string>(m["GatewayType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~ListCSBGatewayResponseBodyData() = default;
};
class ListCSBGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListCSBGatewayResponseBodyData>> data{};
  shared_ptr<long> code{};

  ListCSBGatewayResponseBody() {}

  explicit ListCSBGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListCSBGatewayResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCSBGatewayResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListCSBGatewayResponseBodyData>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListCSBGatewayResponseBody() = default;
};
class ListCSBGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListCSBGatewayResponseBody> body{};

  ListCSBGatewayResponse() {}

  explicit ListCSBGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCSBGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCSBGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~ListCSBGatewayResponse() = default;
};
class ListDegradeControlsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  ListDegradeControlsRequest() {}

  explicit ListDegradeControlsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~ListDegradeControlsRequest() = default;
};
class ListDegradeControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethodMethods : public Darabonba::Model {
public:
  shared_ptr<vector<string>> method{};

  ListDegradeControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethodMethods() {}

  explicit ListDegradeControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethodMethods(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (method) {
      res["Method"] = boost::any(*method);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Method"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Method"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      method = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDegradeControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethodMethods() = default;
};
class ListDegradeControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethod : public Darabonba::Model {
public:
  shared_ptr<string> version{};
  shared_ptr<string> name{};
  shared_ptr<ListDegradeControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethodMethods> methods{};

  ListDegradeControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethod() {}

  explicit ListDegradeControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethod(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (methods) {
      res["Methods"] = methods ? boost::any(methods->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("Methods") != m.end() && !m["Methods"].empty()) {
      if (typeid(map<string, boost::any>) == m["Methods"].type()) {
        ListDegradeControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethodMethods model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Methods"]));
        methods = make_shared<ListDegradeControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethodMethods>(model1);
      }
    }
  }


  virtual ~ListDegradeControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethod() = default;
};
class ListDegradeControlsResponseBodyFlowControlsMapInterfaceMethods : public Darabonba::Model {
public:
  shared_ptr<vector<ListDegradeControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethod>> interfaceMethod{};

  ListDegradeControlsResponseBodyFlowControlsMapInterfaceMethods() {}

  explicit ListDegradeControlsResponseBodyFlowControlsMapInterfaceMethods(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interfaceMethod) {
      vector<boost::any> temp1;
      for(auto item1:*interfaceMethod){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InterfaceMethod"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InterfaceMethod") != m.end() && !m["InterfaceMethod"].empty()) {
      if (typeid(vector<boost::any>) == m["InterfaceMethod"].type()) {
        vector<ListDegradeControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethod> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InterfaceMethod"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDegradeControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethod model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        interfaceMethod = make_shared<vector<ListDegradeControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethod>>(expect1);
      }
    }
  }


  virtual ~ListDegradeControlsResponseBodyFlowControlsMapInterfaceMethods() = default;
};
class ListDegradeControlsResponseBodyFlowControlsMapRuleListRuleResultListRule : public Darabonba::Model {
public:
  shared_ptr<string> resource{};
  shared_ptr<string> ruleType{};
  shared_ptr<long> updateTime{};
  shared_ptr<long> state{};
  shared_ptr<long> createTime{};
  shared_ptr<string> appId{};
  shared_ptr<long> duration{};
  shared_ptr<long> rtThreshold{};
  shared_ptr<string> ruleId{};

  ListDegradeControlsResponseBodyFlowControlsMapRuleListRuleResultListRule() {}

  explicit ListDegradeControlsResponseBodyFlowControlsMapRuleListRuleResultListRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (rtThreshold) {
      res["RtThreshold"] = boost::any(*rtThreshold);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["State"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("RtThreshold") != m.end() && !m["RtThreshold"].empty()) {
      rtThreshold = make_shared<long>(boost::any_cast<long>(m["RtThreshold"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~ListDegradeControlsResponseBodyFlowControlsMapRuleListRuleResultListRule() = default;
};
class ListDegradeControlsResponseBodyFlowControlsMapRuleListRuleResultList : public Darabonba::Model {
public:
  shared_ptr<vector<ListDegradeControlsResponseBodyFlowControlsMapRuleListRuleResultListRule>> rule{};

  ListDegradeControlsResponseBodyFlowControlsMapRuleListRuleResultList() {}

  explicit ListDegradeControlsResponseBodyFlowControlsMapRuleListRuleResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rule) {
      vector<boost::any> temp1;
      for(auto item1:*rule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(vector<boost::any>) == m["Rule"].type()) {
        vector<ListDegradeControlsResponseBodyFlowControlsMapRuleListRuleResultListRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDegradeControlsResponseBodyFlowControlsMapRuleListRuleResultListRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rule = make_shared<vector<ListDegradeControlsResponseBodyFlowControlsMapRuleListRuleResultListRule>>(expect1);
      }
    }
  }


  virtual ~ListDegradeControlsResponseBodyFlowControlsMapRuleListRuleResultList() = default;
};
class ListDegradeControlsResponseBodyFlowControlsMapRuleList : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> totalSize{};
  shared_ptr<ListDegradeControlsResponseBodyFlowControlsMapRuleListRuleResultList> ruleResultList{};
  shared_ptr<long> pageSize{};

  ListDegradeControlsResponseBodyFlowControlsMapRuleList() {}

  explicit ListDegradeControlsResponseBodyFlowControlsMapRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    if (ruleResultList) {
      res["RuleResultList"] = ruleResultList ? boost::any(ruleResultList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
    if (m.find("RuleResultList") != m.end() && !m["RuleResultList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleResultList"].type()) {
        ListDegradeControlsResponseBodyFlowControlsMapRuleListRuleResultList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleResultList"]));
        ruleResultList = make_shared<ListDegradeControlsResponseBodyFlowControlsMapRuleListRuleResultList>(model1);
      }
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
  }


  virtual ~ListDegradeControlsResponseBodyFlowControlsMapRuleList() = default;
};
class ListDegradeControlsResponseBodyFlowControlsMap : public Darabonba::Model {
public:
  shared_ptr<ListDegradeControlsResponseBodyFlowControlsMapInterfaceMethods> interfaceMethods{};
  shared_ptr<string> appName{};
  shared_ptr<string> appId{};
  shared_ptr<ListDegradeControlsResponseBodyFlowControlsMapRuleList> ruleList{};

  ListDegradeControlsResponseBodyFlowControlsMap() {}

  explicit ListDegradeControlsResponseBodyFlowControlsMap(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interfaceMethods) {
      res["InterfaceMethods"] = interfaceMethods ? boost::any(interfaceMethods->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (ruleList) {
      res["RuleList"] = ruleList ? boost::any(ruleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InterfaceMethods") != m.end() && !m["InterfaceMethods"].empty()) {
      if (typeid(map<string, boost::any>) == m["InterfaceMethods"].type()) {
        ListDegradeControlsResponseBodyFlowControlsMapInterfaceMethods model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InterfaceMethods"]));
        interfaceMethods = make_shared<ListDegradeControlsResponseBodyFlowControlsMapInterfaceMethods>(model1);
      }
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("RuleList") != m.end() && !m["RuleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleList"].type()) {
        ListDegradeControlsResponseBodyFlowControlsMapRuleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleList"]));
        ruleList = make_shared<ListDegradeControlsResponseBodyFlowControlsMapRuleList>(model1);
      }
    }
  }


  virtual ~ListDegradeControlsResponseBodyFlowControlsMap() = default;
};
class ListDegradeControlsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListDegradeControlsResponseBodyFlowControlsMap> flowControlsMap{};
  shared_ptr<long> code{};

  ListDegradeControlsResponseBody() {}

  explicit ListDegradeControlsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (flowControlsMap) {
      res["FlowControlsMap"] = flowControlsMap ? boost::any(flowControlsMap->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("FlowControlsMap") != m.end() && !m["FlowControlsMap"].empty()) {
      if (typeid(map<string, boost::any>) == m["FlowControlsMap"].type()) {
        ListDegradeControlsResponseBodyFlowControlsMap model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FlowControlsMap"]));
        flowControlsMap = make_shared<ListDegradeControlsResponseBodyFlowControlsMap>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListDegradeControlsResponseBody() = default;
};
class ListDegradeControlsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListDegradeControlsResponseBody> body{};

  ListDegradeControlsResponse() {}

  explicit ListDegradeControlsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDegradeControlsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDegradeControlsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDegradeControlsResponse() = default;
};
class ListDeployGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  ListDeployGroupRequest() {}

  explicit ListDeployGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~ListDeployGroupRequest() = default;
};
class ListDeployGroupResponseBodyDeployGroupListDeployGroup : public Darabonba::Model {
public:
  shared_ptr<string> VServerGroupId{};
  shared_ptr<string> status{};
  shared_ptr<string> cpuRequest{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> memoryRequest{};
  shared_ptr<string> nameSpace_{};
  shared_ptr<string> appVersionId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> deploymentName{};
  shared_ptr<string> preStop{};
  shared_ptr<string> packageUrl{};
  shared_ptr<string> packageVersion{};
  shared_ptr<string> baseComponentMetaName{};
  shared_ptr<string> csClusterId{};
  shared_ptr<string> appId{};
  shared_ptr<string> env{};
  shared_ptr<long> lastUpdateTime{};
  shared_ptr<long> groupType{};
  shared_ptr<string> cpuLimit{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> postStart{};
  shared_ptr<string> labels{};
  shared_ptr<string> memoryLimit{};
  shared_ptr<string> strategy{};
  shared_ptr<string> selector{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> packageVersionId{};
  shared_ptr<string> reversion{};
  shared_ptr<string> VExtServerGroupId{};
  shared_ptr<string> packagePublicUrl{};

  ListDeployGroupResponseBodyDeployGroupListDeployGroup() {}

  explicit ListDeployGroupResponseBodyDeployGroupListDeployGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (VServerGroupId) {
      res["VServerGroupId"] = boost::any(*VServerGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (cpuRequest) {
      res["CpuRequest"] = boost::any(*cpuRequest);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (memoryRequest) {
      res["MemoryRequest"] = boost::any(*memoryRequest);
    }
    if (nameSpace_) {
      res["NameSpace"] = boost::any(*nameSpace_);
    }
    if (appVersionId) {
      res["AppVersionId"] = boost::any(*appVersionId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deploymentName) {
      res["DeploymentName"] = boost::any(*deploymentName);
    }
    if (preStop) {
      res["PreStop"] = boost::any(*preStop);
    }
    if (packageUrl) {
      res["PackageUrl"] = boost::any(*packageUrl);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    if (baseComponentMetaName) {
      res["BaseComponentMetaName"] = boost::any(*baseComponentMetaName);
    }
    if (csClusterId) {
      res["CsClusterId"] = boost::any(*csClusterId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (lastUpdateTime) {
      res["LastUpdateTime"] = boost::any(*lastUpdateTime);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (cpuLimit) {
      res["CpuLimit"] = boost::any(*cpuLimit);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (postStart) {
      res["PostStart"] = boost::any(*postStart);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (memoryLimit) {
      res["MemoryLimit"] = boost::any(*memoryLimit);
    }
    if (strategy) {
      res["Strategy"] = boost::any(*strategy);
    }
    if (selector) {
      res["Selector"] = boost::any(*selector);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (packageVersionId) {
      res["PackageVersionId"] = boost::any(*packageVersionId);
    }
    if (reversion) {
      res["Reversion"] = boost::any(*reversion);
    }
    if (VExtServerGroupId) {
      res["VExtServerGroupId"] = boost::any(*VExtServerGroupId);
    }
    if (packagePublicUrl) {
      res["PackagePublicUrl"] = boost::any(*packagePublicUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VServerGroupId") != m.end() && !m["VServerGroupId"].empty()) {
      VServerGroupId = make_shared<string>(boost::any_cast<string>(m["VServerGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CpuRequest") != m.end() && !m["CpuRequest"].empty()) {
      cpuRequest = make_shared<string>(boost::any_cast<string>(m["CpuRequest"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("MemoryRequest") != m.end() && !m["MemoryRequest"].empty()) {
      memoryRequest = make_shared<string>(boost::any_cast<string>(m["MemoryRequest"]));
    }
    if (m.find("NameSpace") != m.end() && !m["NameSpace"].empty()) {
      nameSpace_ = make_shared<string>(boost::any_cast<string>(m["NameSpace"]));
    }
    if (m.find("AppVersionId") != m.end() && !m["AppVersionId"].empty()) {
      appVersionId = make_shared<string>(boost::any_cast<string>(m["AppVersionId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DeploymentName") != m.end() && !m["DeploymentName"].empty()) {
      deploymentName = make_shared<string>(boost::any_cast<string>(m["DeploymentName"]));
    }
    if (m.find("PreStop") != m.end() && !m["PreStop"].empty()) {
      preStop = make_shared<string>(boost::any_cast<string>(m["PreStop"]));
    }
    if (m.find("PackageUrl") != m.end() && !m["PackageUrl"].empty()) {
      packageUrl = make_shared<string>(boost::any_cast<string>(m["PackageUrl"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
    if (m.find("BaseComponentMetaName") != m.end() && !m["BaseComponentMetaName"].empty()) {
      baseComponentMetaName = make_shared<string>(boost::any_cast<string>(m["BaseComponentMetaName"]));
    }
    if (m.find("CsClusterId") != m.end() && !m["CsClusterId"].empty()) {
      csClusterId = make_shared<string>(boost::any_cast<string>(m["CsClusterId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("LastUpdateTime") != m.end() && !m["LastUpdateTime"].empty()) {
      lastUpdateTime = make_shared<long>(boost::any_cast<long>(m["LastUpdateTime"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<long>(boost::any_cast<long>(m["GroupType"]));
    }
    if (m.find("CpuLimit") != m.end() && !m["CpuLimit"].empty()) {
      cpuLimit = make_shared<string>(boost::any_cast<string>(m["CpuLimit"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("PostStart") != m.end() && !m["PostStart"].empty()) {
      postStart = make_shared<string>(boost::any_cast<string>(m["PostStart"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("MemoryLimit") != m.end() && !m["MemoryLimit"].empty()) {
      memoryLimit = make_shared<string>(boost::any_cast<string>(m["MemoryLimit"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      strategy = make_shared<string>(boost::any_cast<string>(m["Strategy"]));
    }
    if (m.find("Selector") != m.end() && !m["Selector"].empty()) {
      selector = make_shared<string>(boost::any_cast<string>(m["Selector"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("PackageVersionId") != m.end() && !m["PackageVersionId"].empty()) {
      packageVersionId = make_shared<string>(boost::any_cast<string>(m["PackageVersionId"]));
    }
    if (m.find("Reversion") != m.end() && !m["Reversion"].empty()) {
      reversion = make_shared<string>(boost::any_cast<string>(m["Reversion"]));
    }
    if (m.find("VExtServerGroupId") != m.end() && !m["VExtServerGroupId"].empty()) {
      VExtServerGroupId = make_shared<string>(boost::any_cast<string>(m["VExtServerGroupId"]));
    }
    if (m.find("PackagePublicUrl") != m.end() && !m["PackagePublicUrl"].empty()) {
      packagePublicUrl = make_shared<string>(boost::any_cast<string>(m["PackagePublicUrl"]));
    }
  }


  virtual ~ListDeployGroupResponseBodyDeployGroupListDeployGroup() = default;
};
class ListDeployGroupResponseBodyDeployGroupList : public Darabonba::Model {
public:
  shared_ptr<vector<ListDeployGroupResponseBodyDeployGroupListDeployGroup>> deployGroup{};

  ListDeployGroupResponseBodyDeployGroupList() {}

  explicit ListDeployGroupResponseBodyDeployGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployGroup) {
      vector<boost::any> temp1;
      for(auto item1:*deployGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeployGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployGroup") != m.end() && !m["DeployGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["DeployGroup"].type()) {
        vector<ListDeployGroupResponseBodyDeployGroupListDeployGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeployGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDeployGroupResponseBodyDeployGroupListDeployGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deployGroup = make_shared<vector<ListDeployGroupResponseBodyDeployGroupListDeployGroup>>(expect1);
      }
    }
  }


  virtual ~ListDeployGroupResponseBodyDeployGroupList() = default;
};
class ListDeployGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDeployGroupResponseBodyDeployGroupList> deployGroupList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  ListDeployGroupResponseBody() {}

  explicit ListDeployGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployGroupList) {
      res["DeployGroupList"] = deployGroupList ? boost::any(deployGroupList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployGroupList") != m.end() && !m["DeployGroupList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeployGroupList"].type()) {
        ListDeployGroupResponseBodyDeployGroupList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeployGroupList"]));
        deployGroupList = make_shared<ListDeployGroupResponseBodyDeployGroupList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListDeployGroupResponseBody() = default;
};
class ListDeployGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListDeployGroupResponseBody> body{};

  ListDeployGroupResponse() {}

  explicit ListDeployGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDeployGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDeployGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListDeployGroupResponse() = default;
};
class ListEcsNotInClusterRequest : public Darabonba::Model {
public:
  shared_ptr<long> networkMode{};
  shared_ptr<string> vpcId{};

  ListEcsNotInClusterRequest() {}

  explicit ListEcsNotInClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkMode) {
      res["NetworkMode"] = boost::any(*networkMode);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkMode") != m.end() && !m["NetworkMode"].empty()) {
      networkMode = make_shared<long>(boost::any_cast<long>(m["NetworkMode"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ListEcsNotInClusterRequest() = default;
};
class ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> privateIp{};
  shared_ptr<bool> expired{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> mem{};
  shared_ptr<string> regionId{};
  shared_ptr<string> vpcName{};
  shared_ptr<string> innerIp{};
  shared_ptr<long> cpu{};
  shared_ptr<string> eip{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> publicIp{};

  ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity() {}

  explicit ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (privateIp) {
      res["PrivateIp"] = boost::any(*privateIp);
    }
    if (expired) {
      res["Expired"] = boost::any(*expired);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    if (innerIp) {
      res["InnerIp"] = boost::any(*innerIp);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (eip) {
      res["Eip"] = boost::any(*eip);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (publicIp) {
      res["PublicIp"] = boost::any(*publicIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("PrivateIp") != m.end() && !m["PrivateIp"].empty()) {
      privateIp = make_shared<string>(boost::any_cast<string>(m["PrivateIp"]));
    }
    if (m.find("Expired") != m.end() && !m["Expired"].empty()) {
      expired = make_shared<bool>(boost::any_cast<bool>(m["Expired"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
    if (m.find("InnerIp") != m.end() && !m["InnerIp"].empty()) {
      innerIp = make_shared<string>(boost::any_cast<string>(m["InnerIp"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("Eip") != m.end() && !m["Eip"].empty()) {
      eip = make_shared<string>(boost::any_cast<string>(m["Eip"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("PublicIp") != m.end() && !m["PublicIp"].empty()) {
      publicIp = make_shared<string>(boost::any_cast<string>(m["PublicIp"]));
    }
  }


  virtual ~ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity() = default;
};
class ListEcsNotInClusterResponseBodyEcsEntityList : public Darabonba::Model {
public:
  shared_ptr<vector<ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity>> ecsEntity{};

  ListEcsNotInClusterResponseBodyEcsEntityList() {}

  explicit ListEcsNotInClusterResponseBodyEcsEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecsEntity) {
      vector<boost::any> temp1;
      for(auto item1:*ecsEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EcsEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcsEntity") != m.end() && !m["EcsEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["EcsEntity"].type()) {
        vector<ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EcsEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ecsEntity = make_shared<vector<ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity>>(expect1);
      }
    }
  }


  virtual ~ListEcsNotInClusterResponseBodyEcsEntityList() = default;
};
class ListEcsNotInClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};
  shared_ptr<ListEcsNotInClusterResponseBodyEcsEntityList> ecsEntityList{};

  ListEcsNotInClusterResponseBody() {}

  explicit ListEcsNotInClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (ecsEntityList) {
      res["EcsEntityList"] = ecsEntityList ? boost::any(ecsEntityList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("EcsEntityList") != m.end() && !m["EcsEntityList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EcsEntityList"].type()) {
        ListEcsNotInClusterResponseBodyEcsEntityList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EcsEntityList"]));
        ecsEntityList = make_shared<ListEcsNotInClusterResponseBodyEcsEntityList>(model1);
      }
    }
  }


  virtual ~ListEcsNotInClusterResponseBody() = default;
};
class ListEcsNotInClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListEcsNotInClusterResponseBody> body{};

  ListEcsNotInClusterResponse() {}

  explicit ListEcsNotInClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEcsNotInClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEcsNotInClusterResponseBody>(model1);
      }
    }
  }


  virtual ~ListEcsNotInClusterResponse() = default;
};
class ListEcuByRegionRequest : public Darabonba::Model {
public:
  shared_ptr<string> logicalRegionId{};
  shared_ptr<string> act{};

  ListEcuByRegionRequest() {}

  explicit ListEcuByRegionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    if (act) {
      res["Act"] = boost::any(*act);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
    if (m.find("Act") != m.end() && !m["Act"].empty()) {
      act = make_shared<string>(boost::any_cast<string>(m["Act"]));
    }
  }


  virtual ~ListEcuByRegionRequest() = default;
};
class ListEcuByRegionResponseBodyEcuEntityListEcuEntity : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> ipAddr{};
  shared_ptr<long> availableCpu{};
  shared_ptr<long> createTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> mem{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ecuId{};
  shared_ptr<long> cpu{};
  shared_ptr<bool> dockerEnv{};
  shared_ptr<bool> online{};
  shared_ptr<long> availableMem{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> name{};
  shared_ptr<long> heartbeatTime{};

  ListEcuByRegionResponseBodyEcuEntityListEcuEntity() {}

  explicit ListEcuByRegionResponseBodyEcuEntityListEcuEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (ipAddr) {
      res["IpAddr"] = boost::any(*ipAddr);
    }
    if (availableCpu) {
      res["AvailableCpu"] = boost::any(*availableCpu);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ecuId) {
      res["EcuId"] = boost::any(*ecuId);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (dockerEnv) {
      res["DockerEnv"] = boost::any(*dockerEnv);
    }
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (availableMem) {
      res["AvailableMem"] = boost::any(*availableMem);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (heartbeatTime) {
      res["HeartbeatTime"] = boost::any(*heartbeatTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("IpAddr") != m.end() && !m["IpAddr"].empty()) {
      ipAddr = make_shared<string>(boost::any_cast<string>(m["IpAddr"]));
    }
    if (m.find("AvailableCpu") != m.end() && !m["AvailableCpu"].empty()) {
      availableCpu = make_shared<long>(boost::any_cast<long>(m["AvailableCpu"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("EcuId") != m.end() && !m["EcuId"].empty()) {
      ecuId = make_shared<string>(boost::any_cast<string>(m["EcuId"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("DockerEnv") != m.end() && !m["DockerEnv"].empty()) {
      dockerEnv = make_shared<bool>(boost::any_cast<bool>(m["DockerEnv"]));
    }
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<bool>(boost::any_cast<bool>(m["Online"]));
    }
    if (m.find("AvailableMem") != m.end() && !m["AvailableMem"].empty()) {
      availableMem = make_shared<long>(boost::any_cast<long>(m["AvailableMem"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("HeartbeatTime") != m.end() && !m["HeartbeatTime"].empty()) {
      heartbeatTime = make_shared<long>(boost::any_cast<long>(m["HeartbeatTime"]));
    }
  }


  virtual ~ListEcuByRegionResponseBodyEcuEntityListEcuEntity() = default;
};
class ListEcuByRegionResponseBodyEcuEntityList : public Darabonba::Model {
public:
  shared_ptr<vector<ListEcuByRegionResponseBodyEcuEntityListEcuEntity>> ecuEntity{};

  ListEcuByRegionResponseBodyEcuEntityList() {}

  explicit ListEcuByRegionResponseBodyEcuEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecuEntity) {
      vector<boost::any> temp1;
      for(auto item1:*ecuEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EcuEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcuEntity") != m.end() && !m["EcuEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["EcuEntity"].type()) {
        vector<ListEcuByRegionResponseBodyEcuEntityListEcuEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EcuEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEcuByRegionResponseBodyEcuEntityListEcuEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ecuEntity = make_shared<vector<ListEcuByRegionResponseBodyEcuEntityListEcuEntity>>(expect1);
      }
    }
  }


  virtual ~ListEcuByRegionResponseBodyEcuEntityList() = default;
};
class ListEcuByRegionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListEcuByRegionResponseBodyEcuEntityList> ecuEntityList{};
  shared_ptr<long> code{};

  ListEcuByRegionResponseBody() {}

  explicit ListEcuByRegionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ecuEntityList) {
      res["EcuEntityList"] = ecuEntityList ? boost::any(ecuEntityList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("EcuEntityList") != m.end() && !m["EcuEntityList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EcuEntityList"].type()) {
        ListEcuByRegionResponseBodyEcuEntityList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EcuEntityList"]));
        ecuEntityList = make_shared<ListEcuByRegionResponseBodyEcuEntityList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListEcuByRegionResponseBody() = default;
};
class ListEcuByRegionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListEcuByRegionResponseBody> body{};

  ListEcuByRegionResponse() {}

  explicit ListEcuByRegionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEcuByRegionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEcuByRegionResponseBody>(model1);
      }
    }
  }


  virtual ~ListEcuByRegionResponse() = default;
};
class ListFlowControlsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  ListFlowControlsRequest() {}

  explicit ListFlowControlsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~ListFlowControlsRequest() = default;
};
class ListFlowControlsResponseBodyFlowControlsMapAppListApp : public Darabonba::Model {
public:
  shared_ptr<string> slbId{};
  shared_ptr<string> extSlbIp{};
  shared_ptr<string> healthCheckUrl{};
  shared_ptr<string> owner{};
  shared_ptr<long> slbPort{};
  shared_ptr<long> createTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> applicationType{};
  shared_ptr<string> extSlbId{};
  shared_ptr<long> port{};
  shared_ptr<long> runningInstanceCount{};
  shared_ptr<string> slbIp{};
  shared_ptr<long> buildPackageId{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> dockerize{};
  shared_ptr<long> cpu{};
  shared_ptr<long> instanceCount{};
  shared_ptr<string> description{};
  shared_ptr<long> clusterType{};
  shared_ptr<string> appId{};
  shared_ptr<long> memory{};
  shared_ptr<string> name{};
  shared_ptr<string> clusterId{};

  ListFlowControlsResponseBodyFlowControlsMapAppListApp() {}

  explicit ListFlowControlsResponseBodyFlowControlsMapAppListApp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (extSlbIp) {
      res["ExtSlbIp"] = boost::any(*extSlbIp);
    }
    if (healthCheckUrl) {
      res["HealthCheckUrl"] = boost::any(*healthCheckUrl);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (slbPort) {
      res["SlbPort"] = boost::any(*slbPort);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (applicationType) {
      res["ApplicationType"] = boost::any(*applicationType);
    }
    if (extSlbId) {
      res["ExtSlbId"] = boost::any(*extSlbId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (runningInstanceCount) {
      res["RunningInstanceCount"] = boost::any(*runningInstanceCount);
    }
    if (slbIp) {
      res["SlbIp"] = boost::any(*slbIp);
    }
    if (buildPackageId) {
      res["BuildPackageId"] = boost::any(*buildPackageId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dockerize) {
      res["Dockerize"] = boost::any(*dockerize);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("ExtSlbIp") != m.end() && !m["ExtSlbIp"].empty()) {
      extSlbIp = make_shared<string>(boost::any_cast<string>(m["ExtSlbIp"]));
    }
    if (m.find("HealthCheckUrl") != m.end() && !m["HealthCheckUrl"].empty()) {
      healthCheckUrl = make_shared<string>(boost::any_cast<string>(m["HealthCheckUrl"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("SlbPort") != m.end() && !m["SlbPort"].empty()) {
      slbPort = make_shared<long>(boost::any_cast<long>(m["SlbPort"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("ApplicationType") != m.end() && !m["ApplicationType"].empty()) {
      applicationType = make_shared<string>(boost::any_cast<string>(m["ApplicationType"]));
    }
    if (m.find("ExtSlbId") != m.end() && !m["ExtSlbId"].empty()) {
      extSlbId = make_shared<string>(boost::any_cast<string>(m["ExtSlbId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("RunningInstanceCount") != m.end() && !m["RunningInstanceCount"].empty()) {
      runningInstanceCount = make_shared<long>(boost::any_cast<long>(m["RunningInstanceCount"]));
    }
    if (m.find("SlbIp") != m.end() && !m["SlbIp"].empty()) {
      slbIp = make_shared<string>(boost::any_cast<string>(m["SlbIp"]));
    }
    if (m.find("BuildPackageId") != m.end() && !m["BuildPackageId"].empty()) {
      buildPackageId = make_shared<long>(boost::any_cast<long>(m["BuildPackageId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Dockerize") != m.end() && !m["Dockerize"].empty()) {
      dockerize = make_shared<bool>(boost::any_cast<bool>(m["Dockerize"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<long>(boost::any_cast<long>(m["ClusterType"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~ListFlowControlsResponseBodyFlowControlsMapAppListApp() = default;
};
class ListFlowControlsResponseBodyFlowControlsMapAppList : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowControlsResponseBodyFlowControlsMapAppListApp>> app{};

  ListFlowControlsResponseBodyFlowControlsMapAppList() {}

  explicit ListFlowControlsResponseBodyFlowControlsMapAppList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      vector<boost::any> temp1;
      for(auto item1:*app){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["App"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      if (typeid(vector<boost::any>) == m["App"].type()) {
        vector<ListFlowControlsResponseBodyFlowControlsMapAppListApp> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["App"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowControlsResponseBodyFlowControlsMapAppListApp model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        app = make_shared<vector<ListFlowControlsResponseBodyFlowControlsMapAppListApp>>(expect1);
      }
    }
  }


  virtual ~ListFlowControlsResponseBodyFlowControlsMapAppList() = default;
};
class ListFlowControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethodMethods : public Darabonba::Model {
public:
  shared_ptr<vector<string>> method{};

  ListFlowControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethodMethods() {}

  explicit ListFlowControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethodMethods(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (method) {
      res["Method"] = boost::any(*method);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Method"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Method"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      method = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListFlowControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethodMethods() = default;
};
class ListFlowControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethod : public Darabonba::Model {
public:
  shared_ptr<string> version{};
  shared_ptr<string> name{};
  shared_ptr<ListFlowControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethodMethods> methods{};

  ListFlowControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethod() {}

  explicit ListFlowControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethod(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (methods) {
      res["Methods"] = methods ? boost::any(methods->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("Methods") != m.end() && !m["Methods"].empty()) {
      if (typeid(map<string, boost::any>) == m["Methods"].type()) {
        ListFlowControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethodMethods model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Methods"]));
        methods = make_shared<ListFlowControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethodMethods>(model1);
      }
    }
  }


  virtual ~ListFlowControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethod() = default;
};
class ListFlowControlsResponseBodyFlowControlsMapInterfaceMethods : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethod>> interfaceMethod{};

  ListFlowControlsResponseBodyFlowControlsMapInterfaceMethods() {}

  explicit ListFlowControlsResponseBodyFlowControlsMapInterfaceMethods(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interfaceMethod) {
      vector<boost::any> temp1;
      for(auto item1:*interfaceMethod){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InterfaceMethod"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InterfaceMethod") != m.end() && !m["InterfaceMethod"].empty()) {
      if (typeid(vector<boost::any>) == m["InterfaceMethod"].type()) {
        vector<ListFlowControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethod> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InterfaceMethod"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethod model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        interfaceMethod = make_shared<vector<ListFlowControlsResponseBodyFlowControlsMapInterfaceMethodsInterfaceMethod>>(expect1);
      }
    }
  }


  virtual ~ListFlowControlsResponseBodyFlowControlsMapInterfaceMethods() = default;
};
class ListFlowControlsResponseBodyFlowControlsMapRuleListRuleResultListRule : public Darabonba::Model {
public:
  shared_ptr<long> updateTime{};
  shared_ptr<string> ruleType{};
  shared_ptr<long> state{};
  shared_ptr<long> createTime{};
  shared_ptr<string> consumerAppId{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> strategy{};
  shared_ptr<string> resource{};
  shared_ptr<string> appId{};
  shared_ptr<string> granularity{};
  shared_ptr<long> threshold{};
  shared_ptr<string> id{};

  ListFlowControlsResponseBodyFlowControlsMapRuleListRuleResultListRule() {}

  explicit ListFlowControlsResponseBodyFlowControlsMapRuleListRuleResultListRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (consumerAppId) {
      res["ConsumerAppId"] = boost::any(*consumerAppId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (strategy) {
      res["Strategy"] = boost::any(*strategy);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (granularity) {
      res["Granularity"] = boost::any(*granularity);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["State"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ConsumerAppId") != m.end() && !m["ConsumerAppId"].empty()) {
      consumerAppId = make_shared<string>(boost::any_cast<string>(m["ConsumerAppId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      strategy = make_shared<string>(boost::any_cast<string>(m["Strategy"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Granularity") != m.end() && !m["Granularity"].empty()) {
      granularity = make_shared<string>(boost::any_cast<string>(m["Granularity"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<long>(boost::any_cast<long>(m["Threshold"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListFlowControlsResponseBodyFlowControlsMapRuleListRuleResultListRule() = default;
};
class ListFlowControlsResponseBodyFlowControlsMapRuleListRuleResultList : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowControlsResponseBodyFlowControlsMapRuleListRuleResultListRule>> rule{};

  ListFlowControlsResponseBodyFlowControlsMapRuleListRuleResultList() {}

  explicit ListFlowControlsResponseBodyFlowControlsMapRuleListRuleResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rule) {
      vector<boost::any> temp1;
      for(auto item1:*rule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(vector<boost::any>) == m["Rule"].type()) {
        vector<ListFlowControlsResponseBodyFlowControlsMapRuleListRuleResultListRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowControlsResponseBodyFlowControlsMapRuleListRuleResultListRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rule = make_shared<vector<ListFlowControlsResponseBodyFlowControlsMapRuleListRuleResultListRule>>(expect1);
      }
    }
  }


  virtual ~ListFlowControlsResponseBodyFlowControlsMapRuleListRuleResultList() = default;
};
class ListFlowControlsResponseBodyFlowControlsMapRuleList : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> totalSize{};
  shared_ptr<ListFlowControlsResponseBodyFlowControlsMapRuleListRuleResultList> ruleResultList{};
  shared_ptr<long> pageSize{};

  ListFlowControlsResponseBodyFlowControlsMapRuleList() {}

  explicit ListFlowControlsResponseBodyFlowControlsMapRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    if (ruleResultList) {
      res["RuleResultList"] = ruleResultList ? boost::any(ruleResultList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
    if (m.find("RuleResultList") != m.end() && !m["RuleResultList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleResultList"].type()) {
        ListFlowControlsResponseBodyFlowControlsMapRuleListRuleResultList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleResultList"]));
        ruleResultList = make_shared<ListFlowControlsResponseBodyFlowControlsMapRuleListRuleResultList>(model1);
      }
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
  }


  virtual ~ListFlowControlsResponseBodyFlowControlsMapRuleList() = default;
};
class ListFlowControlsResponseBodyFlowControlsMap : public Darabonba::Model {
public:
  shared_ptr<ListFlowControlsResponseBodyFlowControlsMapAppList> appList{};
  shared_ptr<ListFlowControlsResponseBodyFlowControlsMapInterfaceMethods> interfaceMethods{};
  shared_ptr<string> appName{};
  shared_ptr<string> appId{};
  shared_ptr<ListFlowControlsResponseBodyFlowControlsMapRuleList> ruleList{};

  ListFlowControlsResponseBodyFlowControlsMap() {}

  explicit ListFlowControlsResponseBodyFlowControlsMap(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appList) {
      res["AppList"] = appList ? boost::any(appList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (interfaceMethods) {
      res["InterfaceMethods"] = interfaceMethods ? boost::any(interfaceMethods->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (ruleList) {
      res["RuleList"] = ruleList ? boost::any(ruleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppList") != m.end() && !m["AppList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppList"].type()) {
        ListFlowControlsResponseBodyFlowControlsMapAppList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppList"]));
        appList = make_shared<ListFlowControlsResponseBodyFlowControlsMapAppList>(model1);
      }
    }
    if (m.find("InterfaceMethods") != m.end() && !m["InterfaceMethods"].empty()) {
      if (typeid(map<string, boost::any>) == m["InterfaceMethods"].type()) {
        ListFlowControlsResponseBodyFlowControlsMapInterfaceMethods model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InterfaceMethods"]));
        interfaceMethods = make_shared<ListFlowControlsResponseBodyFlowControlsMapInterfaceMethods>(model1);
      }
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("RuleList") != m.end() && !m["RuleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleList"].type()) {
        ListFlowControlsResponseBodyFlowControlsMapRuleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleList"]));
        ruleList = make_shared<ListFlowControlsResponseBodyFlowControlsMapRuleList>(model1);
      }
    }
  }


  virtual ~ListFlowControlsResponseBodyFlowControlsMap() = default;
};
class ListFlowControlsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListFlowControlsResponseBodyFlowControlsMap> flowControlsMap{};
  shared_ptr<long> code{};

  ListFlowControlsResponseBody() {}

  explicit ListFlowControlsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (flowControlsMap) {
      res["FlowControlsMap"] = flowControlsMap ? boost::any(flowControlsMap->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("FlowControlsMap") != m.end() && !m["FlowControlsMap"].empty()) {
      if (typeid(map<string, boost::any>) == m["FlowControlsMap"].type()) {
        ListFlowControlsResponseBodyFlowControlsMap model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FlowControlsMap"]));
        flowControlsMap = make_shared<ListFlowControlsResponseBodyFlowControlsMap>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListFlowControlsResponseBody() = default;
};
class ListFlowControlsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFlowControlsResponseBody> body{};

  ListFlowControlsResponse() {}

  explicit ListFlowControlsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowControlsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowControlsResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowControlsResponse() = default;
};
class ListHistoryDeployVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  ListHistoryDeployVersionRequest() {}

  explicit ListHistoryDeployVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~ListHistoryDeployVersionRequest() = default;
};
class ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> publicUrl{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> description{};
  shared_ptr<long> createTime{};
  shared_ptr<string> appId{};
  shared_ptr<string> warUrl{};
  shared_ptr<string> id{};
  shared_ptr<string> packageVersion{};

  ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion() {}

  explicit ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (publicUrl) {
      res["PublicUrl"] = boost::any(*publicUrl);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (warUrl) {
      res["WarUrl"] = boost::any(*warUrl);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("PublicUrl") != m.end() && !m["PublicUrl"].empty()) {
      publicUrl = make_shared<string>(boost::any_cast<string>(m["PublicUrl"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("WarUrl") != m.end() && !m["WarUrl"].empty()) {
      warUrl = make_shared<string>(boost::any_cast<string>(m["WarUrl"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
  }


  virtual ~ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion() = default;
};
class ListHistoryDeployVersionResponseBodyPackageVersionList : public Darabonba::Model {
public:
  shared_ptr<vector<ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion>> packageVersion{};

  ListHistoryDeployVersionResponseBodyPackageVersionList() {}

  explicit ListHistoryDeployVersionResponseBodyPackageVersionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (packageVersion) {
      vector<boost::any> temp1;
      for(auto item1:*packageVersion){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PackageVersion"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      if (typeid(vector<boost::any>) == m["PackageVersion"].type()) {
        vector<ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PackageVersion"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        packageVersion = make_shared<vector<ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion>>(expect1);
      }
    }
  }


  virtual ~ListHistoryDeployVersionResponseBodyPackageVersionList() = default;
};
class ListHistoryDeployVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListHistoryDeployVersionResponseBodyPackageVersionList> packageVersionList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  ListHistoryDeployVersionResponseBody() {}

  explicit ListHistoryDeployVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (packageVersionList) {
      res["PackageVersionList"] = packageVersionList ? boost::any(packageVersionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PackageVersionList") != m.end() && !m["PackageVersionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PackageVersionList"].type()) {
        ListHistoryDeployVersionResponseBodyPackageVersionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PackageVersionList"]));
        packageVersionList = make_shared<ListHistoryDeployVersionResponseBodyPackageVersionList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListHistoryDeployVersionResponseBody() = default;
};
class ListHistoryDeployVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListHistoryDeployVersionResponseBody> body{};

  ListHistoryDeployVersionResponse() {}

  explicit ListHistoryDeployVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHistoryDeployVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHistoryDeployVersionResponseBody>(model1);
      }
    }
  }


  virtual ~ListHistoryDeployVersionResponse() = default;
};
class ListK8sIngressRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> namespace_{};

  ListK8sIngressRulesRequest() {}

  explicit ListK8sIngressRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~ListK8sIngressRulesRequest() = default;
};
class ListK8sIngressRulesResponseBodyIngressConfigsIngressRulesIngressPaths : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> appName{};
  shared_ptr<string> host{};
  shared_ptr<long> servicePort{};
  shared_ptr<string> appId{};
  shared_ptr<string> path{};
  shared_ptr<string> serviceName{};

  ListK8sIngressRulesResponseBodyIngressConfigsIngressRulesIngressPaths() {}

  explicit ListK8sIngressRulesResponseBodyIngressConfigsIngressRulesIngressPaths(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (servicePort) {
      res["ServicePort"] = boost::any(*servicePort);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("ServicePort") != m.end() && !m["ServicePort"].empty()) {
      servicePort = make_shared<long>(boost::any_cast<long>(m["ServicePort"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~ListK8sIngressRulesResponseBodyIngressConfigsIngressRulesIngressPaths() = default;
};
class ListK8sIngressRulesResponseBodyIngressConfigsIngressRules : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<vector<ListK8sIngressRulesResponseBodyIngressConfigsIngressRulesIngressPaths>> ingressPaths{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> name{};

  ListK8sIngressRulesResponseBodyIngressConfigsIngressRules() {}

  explicit ListK8sIngressRulesResponseBodyIngressConfigsIngressRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (ingressPaths) {
      vector<boost::any> temp1;
      for(auto item1:*ingressPaths){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IngressPaths"] = boost::any(temp1);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("IngressPaths") != m.end() && !m["IngressPaths"].empty()) {
      if (typeid(vector<boost::any>) == m["IngressPaths"].type()) {
        vector<ListK8sIngressRulesResponseBodyIngressConfigsIngressRulesIngressPaths> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IngressPaths"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListK8sIngressRulesResponseBodyIngressConfigsIngressRulesIngressPaths model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ingressPaths = make_shared<vector<ListK8sIngressRulesResponseBodyIngressConfigsIngressRulesIngressPaths>>(expect1);
      }
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListK8sIngressRulesResponseBodyIngressConfigsIngressRules() = default;
};
class ListK8sIngressRulesResponseBodyIngressConfigs : public Darabonba::Model {
public:
  shared_ptr<string> clusterName{};
  shared_ptr<vector<ListK8sIngressRulesResponseBodyIngressConfigsIngressRules>> ingressRules{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  ListK8sIngressRulesResponseBodyIngressConfigs() {}

  explicit ListK8sIngressRulesResponseBodyIngressConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (ingressRules) {
      vector<boost::any> temp1;
      for(auto item1:*ingressRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IngressRules"] = boost::any(temp1);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("IngressRules") != m.end() && !m["IngressRules"].empty()) {
      if (typeid(vector<boost::any>) == m["IngressRules"].type()) {
        vector<ListK8sIngressRulesResponseBodyIngressConfigsIngressRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IngressRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListK8sIngressRulesResponseBodyIngressConfigsIngressRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ingressRules = make_shared<vector<ListK8sIngressRulesResponseBodyIngressConfigsIngressRules>>(expect1);
      }
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListK8sIngressRulesResponseBodyIngressConfigs() = default;
};
class ListK8sIngressRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListK8sIngressRulesResponseBodyIngressConfigs>> ingressConfigs{};
  shared_ptr<long> code{};

  ListK8sIngressRulesResponseBody() {}

  explicit ListK8sIngressRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ingressConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*ingressConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IngressConfigs"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("IngressConfigs") != m.end() && !m["IngressConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["IngressConfigs"].type()) {
        vector<ListK8sIngressRulesResponseBodyIngressConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IngressConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListK8sIngressRulesResponseBodyIngressConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ingressConfigs = make_shared<vector<ListK8sIngressRulesResponseBodyIngressConfigs>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListK8sIngressRulesResponseBody() = default;
};
class ListK8sIngressRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListK8sIngressRulesResponseBody> body{};

  ListK8sIngressRulesResponse() {}

  explicit ListK8sIngressRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListK8sIngressRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListK8sIngressRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListK8sIngressRulesResponse() = default;
};
class ListMethodsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> serviceName{};

  ListMethodsRequest() {}

  explicit ListMethodsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~ListMethodsRequest() = default;
};
class ListMethodsResponseBodyServiceMethodListServiceMethodParamTypes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> paramType{};

  ListMethodsResponseBodyServiceMethodListServiceMethodParamTypes() {}

  explicit ListMethodsResponseBodyServiceMethodListServiceMethodParamTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (paramType) {
      res["ParamType"] = boost::any(*paramType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParamType") != m.end() && !m["ParamType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ParamType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ParamType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      paramType = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListMethodsResponseBodyServiceMethodListServiceMethodParamTypes() = default;
};
class ListMethodsResponseBodyServiceMethodListServiceMethodInputParams : public Darabonba::Model {
public:
  shared_ptr<vector<string>> inputParam{};

  ListMethodsResponseBodyServiceMethodListServiceMethodInputParams() {}

  explicit ListMethodsResponseBodyServiceMethodListServiceMethodInputParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputParam) {
      res["InputParam"] = boost::any(*inputParam);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputParam") != m.end() && !m["InputParam"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InputParam"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InputParam"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      inputParam = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListMethodsResponseBodyServiceMethodListServiceMethodInputParams() = default;
};
class ListMethodsResponseBodyServiceMethodListServiceMethod : public Darabonba::Model {
public:
  shared_ptr<string> methodName{};
  shared_ptr<ListMethodsResponseBodyServiceMethodListServiceMethodParamTypes> paramTypes{};
  shared_ptr<ListMethodsResponseBodyServiceMethodListServiceMethodInputParams> inputParams{};
  shared_ptr<string> appName{};
  shared_ptr<string> output{};
  shared_ptr<string> serviceName{};

  ListMethodsResponseBodyServiceMethodListServiceMethod() {}

  explicit ListMethodsResponseBodyServiceMethodListServiceMethod(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (paramTypes) {
      res["ParamTypes"] = paramTypes ? boost::any(paramTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (inputParams) {
      res["InputParams"] = inputParams ? boost::any(inputParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("ParamTypes") != m.end() && !m["ParamTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["ParamTypes"].type()) {
        ListMethodsResponseBodyServiceMethodListServiceMethodParamTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ParamTypes"]));
        paramTypes = make_shared<ListMethodsResponseBodyServiceMethodListServiceMethodParamTypes>(model1);
      }
    }
    if (m.find("InputParams") != m.end() && !m["InputParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputParams"].type()) {
        ListMethodsResponseBodyServiceMethodListServiceMethodInputParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputParams"]));
        inputParams = make_shared<ListMethodsResponseBodyServiceMethodListServiceMethodInputParams>(model1);
      }
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~ListMethodsResponseBodyServiceMethodListServiceMethod() = default;
};
class ListMethodsResponseBodyServiceMethodList : public Darabonba::Model {
public:
  shared_ptr<vector<ListMethodsResponseBodyServiceMethodListServiceMethod>> serviceMethod{};

  ListMethodsResponseBodyServiceMethodList() {}

  explicit ListMethodsResponseBodyServiceMethodList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceMethod) {
      vector<boost::any> temp1;
      for(auto item1:*serviceMethod){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceMethod"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceMethod") != m.end() && !m["ServiceMethod"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceMethod"].type()) {
        vector<ListMethodsResponseBodyServiceMethodListServiceMethod> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceMethod"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMethodsResponseBodyServiceMethodListServiceMethod model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceMethod = make_shared<vector<ListMethodsResponseBodyServiceMethodListServiceMethod>>(expect1);
      }
    }
  }


  virtual ~ListMethodsResponseBodyServiceMethodList() = default;
};
class ListMethodsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListMethodsResponseBodyServiceMethodList> serviceMethodList{};
  shared_ptr<long> code{};

  ListMethodsResponseBody() {}

  explicit ListMethodsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (serviceMethodList) {
      res["ServiceMethodList"] = serviceMethodList ? boost::any(serviceMethodList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ServiceMethodList") != m.end() && !m["ServiceMethodList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceMethodList"].type()) {
        ListMethodsResponseBodyServiceMethodList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceMethodList"]));
        serviceMethodList = make_shared<ListMethodsResponseBodyServiceMethodList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListMethodsResponseBody() = default;
};
class ListMethodsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListMethodsResponseBody> body{};

  ListMethodsResponse() {}

  explicit ListMethodsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMethodsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMethodsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMethodsResponse() = default;
};
class ListOperationLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> beginTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> userId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  ListOperationLogsRequest() {}

  explicit ListOperationLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["BeginTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListOperationLogsRequest() = default;
};
class ListOperationLogsResponseBodyLogList : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> endTime{};
  shared_ptr<string> actionGroup{};
  shared_ptr<string> operatorId{};
  shared_ptr<string> operatorName{};
  shared_ptr<string> appId{};
  shared_ptr<long> beginTime{};
  shared_ptr<string> message{};
  shared_ptr<string> actionName{};
  shared_ptr<string> extraParameters{};
  shared_ptr<string> source{};

  ListOperationLogsResponseBodyLogList() {}

  explicit ListOperationLogsResponseBodyLogList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (actionGroup) {
      res["ActionGroup"] = boost::any(*actionGroup);
    }
    if (operatorId) {
      res["OperatorId"] = boost::any(*operatorId);
    }
    if (operatorName) {
      res["OperatorName"] = boost::any(*operatorName);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (actionName) {
      res["ActionName"] = boost::any(*actionName);
    }
    if (extraParameters) {
      res["ExtraParameters"] = boost::any(*extraParameters);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ActionGroup") != m.end() && !m["ActionGroup"].empty()) {
      actionGroup = make_shared<string>(boost::any_cast<string>(m["ActionGroup"]));
    }
    if (m.find("OperatorId") != m.end() && !m["OperatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["OperatorId"]));
    }
    if (m.find("OperatorName") != m.end() && !m["OperatorName"].empty()) {
      operatorName = make_shared<string>(boost::any_cast<string>(m["OperatorName"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["BeginTime"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ActionName") != m.end() && !m["ActionName"].empty()) {
      actionName = make_shared<string>(boost::any_cast<string>(m["ActionName"]));
    }
    if (m.find("ExtraParameters") != m.end() && !m["ExtraParameters"].empty()) {
      extraParameters = make_shared<string>(boost::any_cast<string>(m["ExtraParameters"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~ListOperationLogsResponseBodyLogList() = default;
};
class ListOperationLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListOperationLogsResponseBodyLogList>> logList{};
  shared_ptr<string> requestId{};
  shared_ptr<string> message{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> totalSize{};
  shared_ptr<long> code{};

  ListOperationLogsResponseBody() {}

  explicit ListOperationLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logList) {
      vector<boost::any> temp1;
      for(auto item1:*logList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogList") != m.end() && !m["LogList"].empty()) {
      if (typeid(vector<boost::any>) == m["LogList"].type()) {
        vector<ListOperationLogsResponseBodyLogList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOperationLogsResponseBodyLogList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logList = make_shared<vector<ListOperationLogsResponseBodyLogList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListOperationLogsResponseBody() = default;
};
class ListOperationLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListOperationLogsResponseBody> body{};

  ListOperationLogsResponse() {}

  explicit ListOperationLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOperationLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOperationLogsResponseBody>(model1);
      }
    }
  }


  virtual ~ListOperationLogsResponse() = default;
};
class ListPublishedServicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  ListPublishedServicesRequest() {}

  explicit ListPublishedServicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~ListPublishedServicesRequest() = default;
};
class ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesGroups : public Darabonba::Model {
public:
  shared_ptr<vector<string>> group{};

  ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesGroups() {}

  explicit ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (group) {
      res["group"] = boost::any(*group);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("group") != m.end() && !m["group"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["group"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["group"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      group = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesGroups() = default;
};
class ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesIps : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ip{};

  ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesIps() {}

  explicit ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesIps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["ip"] = boost::any(*ip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ip") != m.end() && !m["ip"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ip"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ip"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ip = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesIps() = default;
};
class ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices : public Darabonba::Model {
public:
  shared_ptr<bool> dockerApplication{};
  shared_ptr<string> type{};
  shared_ptr<ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesGroups> groups{};
  shared_ptr<string> version{};
  shared_ptr<string> appId{};
  shared_ptr<string> group2Ip{};
  shared_ptr<ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesIps> ips{};
  shared_ptr<string> name{};

  ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices() {}

  explicit ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dockerApplication) {
      res["DockerApplication"] = boost::any(*dockerApplication);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (groups) {
      res["Groups"] = groups ? boost::any(groups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (group2Ip) {
      res["Group2Ip"] = boost::any(*group2Ip);
    }
    if (ips) {
      res["Ips"] = ips ? boost::any(ips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DockerApplication") != m.end() && !m["DockerApplication"].empty()) {
      dockerApplication = make_shared<bool>(boost::any_cast<bool>(m["DockerApplication"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      if (typeid(map<string, boost::any>) == m["Groups"].type()) {
        ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Groups"]));
        groups = make_shared<ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesGroups>(model1);
      }
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Group2Ip") != m.end() && !m["Group2Ip"].empty()) {
      group2Ip = make_shared<string>(boost::any_cast<string>(m["Group2Ip"]));
    }
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ips"].type()) {
        ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesIps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ips"]));
        ips = make_shared<ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesIps>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices() = default;
};
class ListPublishedServicesResponseBodyPublishedServicesList : public Darabonba::Model {
public:
  shared_ptr<vector<ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices>> listPublishedServices{};

  ListPublishedServicesResponseBodyPublishedServicesList() {}

  explicit ListPublishedServicesResponseBodyPublishedServicesList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listPublishedServices) {
      vector<boost::any> temp1;
      for(auto item1:*listPublishedServices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ListPublishedServices"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListPublishedServices") != m.end() && !m["ListPublishedServices"].empty()) {
      if (typeid(vector<boost::any>) == m["ListPublishedServices"].type()) {
        vector<ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ListPublishedServices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        listPublishedServices = make_shared<vector<ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices>>(expect1);
      }
    }
  }


  virtual ~ListPublishedServicesResponseBodyPublishedServicesList() = default;
};
class ListPublishedServicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListPublishedServicesResponseBodyPublishedServicesList> publishedServicesList{};
  shared_ptr<long> code{};

  ListPublishedServicesResponseBody() {}

  explicit ListPublishedServicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (publishedServicesList) {
      res["PublishedServicesList"] = publishedServicesList ? boost::any(publishedServicesList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PublishedServicesList") != m.end() && !m["PublishedServicesList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PublishedServicesList"].type()) {
        ListPublishedServicesResponseBodyPublishedServicesList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PublishedServicesList"]));
        publishedServicesList = make_shared<ListPublishedServicesResponseBodyPublishedServicesList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListPublishedServicesResponseBody() = default;
};
class ListPublishedServicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListPublishedServicesResponseBody> body{};

  ListPublishedServicesResponse() {}

  explicit ListPublishedServicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPublishedServicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPublishedServicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListPublishedServicesResponse() = default;
};
class ListRecentChangeOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  ListRecentChangeOrderRequest() {}

  explicit ListRecentChangeOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~ListRecentChangeOrderRequest() = default;
};
class ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> createTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> changeOrderDescription{};
  shared_ptr<string> source{};
  shared_ptr<string> createUserId{};
  shared_ptr<long> batchCount{};
  shared_ptr<string> coTypeCode{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<string> batchType{};
  shared_ptr<string> groupId{};
  shared_ptr<string> coType{};
  shared_ptr<string> appId{};

  ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder() {}

  explicit ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (changeOrderDescription) {
      res["ChangeOrderDescription"] = boost::any(*changeOrderDescription);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (createUserId) {
      res["CreateUserId"] = boost::any(*createUserId);
    }
    if (batchCount) {
      res["BatchCount"] = boost::any(*batchCount);
    }
    if (coTypeCode) {
      res["CoTypeCode"] = boost::any(*coTypeCode);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (batchType) {
      res["BatchType"] = boost::any(*batchType);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (coType) {
      res["CoType"] = boost::any(*coType);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("ChangeOrderDescription") != m.end() && !m["ChangeOrderDescription"].empty()) {
      changeOrderDescription = make_shared<string>(boost::any_cast<string>(m["ChangeOrderDescription"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("CreateUserId") != m.end() && !m["CreateUserId"].empty()) {
      createUserId = make_shared<string>(boost::any_cast<string>(m["CreateUserId"]));
    }
    if (m.find("BatchCount") != m.end() && !m["BatchCount"].empty()) {
      batchCount = make_shared<long>(boost::any_cast<long>(m["BatchCount"]));
    }
    if (m.find("CoTypeCode") != m.end() && !m["CoTypeCode"].empty()) {
      coTypeCode = make_shared<string>(boost::any_cast<string>(m["CoTypeCode"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("BatchType") != m.end() && !m["BatchType"].empty()) {
      batchType = make_shared<string>(boost::any_cast<string>(m["BatchType"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("CoType") != m.end() && !m["CoType"].empty()) {
      coType = make_shared<string>(boost::any_cast<string>(m["CoType"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder() = default;
};
class ListRecentChangeOrderResponseBodyChangeOrderList : public Darabonba::Model {
public:
  shared_ptr<vector<ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder>> changeOrder{};

  ListRecentChangeOrderResponseBodyChangeOrderList() {}

  explicit ListRecentChangeOrderResponseBodyChangeOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrder) {
      vector<boost::any> temp1;
      for(auto item1:*changeOrder){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChangeOrder"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrder") != m.end() && !m["ChangeOrder"].empty()) {
      if (typeid(vector<boost::any>) == m["ChangeOrder"].type()) {
        vector<ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChangeOrder"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        changeOrder = make_shared<vector<ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder>>(expect1);
      }
    }
  }


  virtual ~ListRecentChangeOrderResponseBodyChangeOrderList() = default;
};
class ListRecentChangeOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListRecentChangeOrderResponseBodyChangeOrderList> changeOrderList{};
  shared_ptr<long> code{};

  ListRecentChangeOrderResponseBody() {}

  explicit ListRecentChangeOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderList) {
      res["ChangeOrderList"] = changeOrderList ? boost::any(changeOrderList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderList") != m.end() && !m["ChangeOrderList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ChangeOrderList"].type()) {
        ListRecentChangeOrderResponseBodyChangeOrderList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ChangeOrderList"]));
        changeOrderList = make_shared<ListRecentChangeOrderResponseBodyChangeOrderList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListRecentChangeOrderResponseBody() = default;
};
class ListRecentChangeOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListRecentChangeOrderResponseBody> body{};

  ListRecentChangeOrderResponse() {}

  explicit ListRecentChangeOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRecentChangeOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRecentChangeOrderResponseBody>(model1);
      }
    }
  }


  virtual ~ListRecentChangeOrderResponse() = default;
};
class ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity : public Darabonba::Model {
public:
  shared_ptr<string> ecuId{};
  shared_ptr<bool> online{};
  shared_ptr<bool> dockerEnv{};
  shared_ptr<long> createTime{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> ipAddr{};
  shared_ptr<long> heartbeatTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> name{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> vpcId{};
  shared_ptr<long> availableCpu{};
  shared_ptr<long> availableMem{};
  shared_ptr<long> cpu{};
  shared_ptr<long> mem{};

  ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity() {}

  explicit ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecuId) {
      res["EcuId"] = boost::any(*ecuId);
    }
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (dockerEnv) {
      res["DockerEnv"] = boost::any(*dockerEnv);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (ipAddr) {
      res["IpAddr"] = boost::any(*ipAddr);
    }
    if (heartbeatTime) {
      res["HeartbeatTime"] = boost::any(*heartbeatTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (availableCpu) {
      res["AvailableCpu"] = boost::any(*availableCpu);
    }
    if (availableMem) {
      res["AvailableMem"] = boost::any(*availableMem);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcuId") != m.end() && !m["EcuId"].empty()) {
      ecuId = make_shared<string>(boost::any_cast<string>(m["EcuId"]));
    }
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<bool>(boost::any_cast<bool>(m["Online"]));
    }
    if (m.find("DockerEnv") != m.end() && !m["DockerEnv"].empty()) {
      dockerEnv = make_shared<bool>(boost::any_cast<bool>(m["DockerEnv"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("IpAddr") != m.end() && !m["IpAddr"].empty()) {
      ipAddr = make_shared<string>(boost::any_cast<string>(m["IpAddr"]));
    }
    if (m.find("HeartbeatTime") != m.end() && !m["HeartbeatTime"].empty()) {
      heartbeatTime = make_shared<long>(boost::any_cast<long>(m["HeartbeatTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("AvailableCpu") != m.end() && !m["AvailableCpu"].empty()) {
      availableCpu = make_shared<long>(boost::any_cast<long>(m["AvailableCpu"]));
    }
    if (m.find("AvailableMem") != m.end() && !m["AvailableMem"].empty()) {
      availableMem = make_shared<long>(boost::any_cast<long>(m["AvailableMem"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
  }


  virtual ~ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity() = default;
};
class ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userId{};
  shared_ptr<string> cidrblock{};
  shared_ptr<string> status{};
  shared_ptr<string> description{};
  shared_ptr<bool> expired{};
  shared_ptr<long> ecsNum{};

  ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity() {}

  explicit ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (cidrblock) {
      res["Cidrblock"] = boost::any(*cidrblock);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (expired) {
      res["Expired"] = boost::any(*expired);
    }
    if (ecsNum) {
      res["EcsNum"] = boost::any(*ecsNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Cidrblock") != m.end() && !m["Cidrblock"].empty()) {
      cidrblock = make_shared<string>(boost::any_cast<string>(m["Cidrblock"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Expired") != m.end() && !m["Expired"].empty()) {
      expired = make_shared<bool>(boost::any_cast<bool>(m["Expired"]));
    }
    if (m.find("EcsNum") != m.end() && !m["EcsNum"].empty()) {
      ecsNum = make_shared<long>(boost::any_cast<long>(m["EcsNum"]));
    }
  }


  virtual ~ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity() = default;
};
class ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> hostName{};
  shared_ptr<string> description{};
  shared_ptr<string> status{};
  shared_ptr<string> publicIp{};
  shared_ptr<string> innerIp{};
  shared_ptr<string> privateIp{};
  shared_ptr<string> eip{};
  shared_ptr<string> serialNum{};
  shared_ptr<string> userId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> expired{};
  shared_ptr<string> sgId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> groupId{};
  shared_ptr<long> cpu{};
  shared_ptr<long> mem{};
  shared_ptr<ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity> ecuEntity{};
  shared_ptr<ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity> vpcEntity{};

  ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity() {}

  explicit ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (publicIp) {
      res["PublicIp"] = boost::any(*publicIp);
    }
    if (innerIp) {
      res["InnerIp"] = boost::any(*innerIp);
    }
    if (privateIp) {
      res["PrivateIp"] = boost::any(*privateIp);
    }
    if (eip) {
      res["Eip"] = boost::any(*eip);
    }
    if (serialNum) {
      res["SerialNum"] = boost::any(*serialNum);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (expired) {
      res["Expired"] = boost::any(*expired);
    }
    if (sgId) {
      res["SgId"] = boost::any(*sgId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (ecuEntity) {
      res["EcuEntity"] = ecuEntity ? boost::any(ecuEntity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcEntity) {
      res["VpcEntity"] = vpcEntity ? boost::any(vpcEntity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PublicIp") != m.end() && !m["PublicIp"].empty()) {
      publicIp = make_shared<string>(boost::any_cast<string>(m["PublicIp"]));
    }
    if (m.find("InnerIp") != m.end() && !m["InnerIp"].empty()) {
      innerIp = make_shared<string>(boost::any_cast<string>(m["InnerIp"]));
    }
    if (m.find("PrivateIp") != m.end() && !m["PrivateIp"].empty()) {
      privateIp = make_shared<string>(boost::any_cast<string>(m["PrivateIp"]));
    }
    if (m.find("Eip") != m.end() && !m["Eip"].empty()) {
      eip = make_shared<string>(boost::any_cast<string>(m["Eip"]));
    }
    if (m.find("SerialNum") != m.end() && !m["SerialNum"].empty()) {
      serialNum = make_shared<string>(boost::any_cast<string>(m["SerialNum"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Expired") != m.end() && !m["Expired"].empty()) {
      expired = make_shared<bool>(boost::any_cast<bool>(m["Expired"]));
    }
    if (m.find("SgId") != m.end() && !m["SgId"].empty()) {
      sgId = make_shared<string>(boost::any_cast<string>(m["SgId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("EcuEntity") != m.end() && !m["EcuEntity"].empty()) {
      if (typeid(map<string, boost::any>) == m["EcuEntity"].type()) {
        ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EcuEntity"]));
        ecuEntity = make_shared<ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity>(model1);
      }
    }
    if (m.find("VpcEntity") != m.end() && !m["VpcEntity"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpcEntity"].type()) {
        ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpcEntity"]));
        vpcEntity = make_shared<ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity>(model1);
      }
    }
  }


  virtual ~ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity() = default;
};
class ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsList : public Darabonba::Model {
public:
  shared_ptr<vector<ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity>> ecsEntity{};

  ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsList() {}

  explicit ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecsEntity) {
      vector<boost::any> temp1;
      for(auto item1:*ecsEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EcsEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcsEntity") != m.end() && !m["EcsEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["EcsEntity"].type()) {
        vector<ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EcsEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ecsEntity = make_shared<vector<ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity>>(expect1);
      }
    }
  }


  virtual ~ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsList() = default;
};
class ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity : public Darabonba::Model {
public:
  shared_ptr<string> slbId{};
  shared_ptr<string> slbName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userId{};
  shared_ptr<string> address{};
  shared_ptr<string> slbStatus{};
  shared_ptr<string> addressType{};
  shared_ptr<string> vswitchId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> networkType{};
  shared_ptr<long> groupId{};
  shared_ptr<bool> expired{};

  ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity() {}

  explicit ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (slbName) {
      res["SlbName"] = boost::any(*slbName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (slbStatus) {
      res["SlbStatus"] = boost::any(*slbStatus);
    }
    if (addressType) {
      res["AddressType"] = boost::any(*addressType);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (expired) {
      res["Expired"] = boost::any(*expired);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("SlbName") != m.end() && !m["SlbName"].empty()) {
      slbName = make_shared<string>(boost::any_cast<string>(m["SlbName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("SlbStatus") != m.end() && !m["SlbStatus"].empty()) {
      slbStatus = make_shared<string>(boost::any_cast<string>(m["SlbStatus"]));
    }
    if (m.find("AddressType") != m.end() && !m["AddressType"].empty()) {
      addressType = make_shared<string>(boost::any_cast<string>(m["AddressType"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Expired") != m.end() && !m["Expired"].empty()) {
      expired = make_shared<bool>(boost::any_cast<bool>(m["Expired"]));
    }
  }


  virtual ~ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity() = default;
};
class ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbList : public Darabonba::Model {
public:
  shared_ptr<vector<ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity>> slbEntity{};

  ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbList() {}

  explicit ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (slbEntity) {
      vector<boost::any> temp1;
      for(auto item1:*slbEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SlbEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SlbEntity") != m.end() && !m["SlbEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["SlbEntity"].type()) {
        vector<ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SlbEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        slbEntity = make_shared<vector<ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity>>(expect1);
      }
    }
  }


  virtual ~ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbList() = default;
};
class ListResourceGroupResponseBodyResourceGroupListResGroupEntity : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> adminUserId{};
  shared_ptr<long> createTime{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> regionId{};
  shared_ptr<ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsList> ecsList{};
  shared_ptr<ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbList> slbList{};

  ListResourceGroupResponseBodyResourceGroupListResGroupEntity() {}

  explicit ListResourceGroupResponseBodyResourceGroupListResGroupEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (adminUserId) {
      res["AdminUserId"] = boost::any(*adminUserId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ecsList) {
      res["ecsList"] = ecsList ? boost::any(ecsList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (slbList) {
      res["SlbList"] = slbList ? boost::any(slbList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("AdminUserId") != m.end() && !m["AdminUserId"].empty()) {
      adminUserId = make_shared<string>(boost::any_cast<string>(m["AdminUserId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ecsList") != m.end() && !m["ecsList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ecsList"].type()) {
        ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ecsList"]));
        ecsList = make_shared<ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsList>(model1);
      }
    }
    if (m.find("SlbList") != m.end() && !m["SlbList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SlbList"].type()) {
        ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SlbList"]));
        slbList = make_shared<ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbList>(model1);
      }
    }
  }


  virtual ~ListResourceGroupResponseBodyResourceGroupListResGroupEntity() = default;
};
class ListResourceGroupResponseBodyResourceGroupList : public Darabonba::Model {
public:
  shared_ptr<vector<ListResourceGroupResponseBodyResourceGroupListResGroupEntity>> resGroupEntity{};

  ListResourceGroupResponseBodyResourceGroupList() {}

  explicit ListResourceGroupResponseBodyResourceGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resGroupEntity) {
      vector<boost::any> temp1;
      for(auto item1:*resGroupEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResGroupEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResGroupEntity") != m.end() && !m["ResGroupEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["ResGroupEntity"].type()) {
        vector<ListResourceGroupResponseBodyResourceGroupListResGroupEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResGroupEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourceGroupResponseBodyResourceGroupListResGroupEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resGroupEntity = make_shared<vector<ListResourceGroupResponseBodyResourceGroupListResGroupEntity>>(expect1);
      }
    }
  }


  virtual ~ListResourceGroupResponseBodyResourceGroupList() = default;
};
class ListResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListResourceGroupResponseBodyResourceGroupList> resourceGroupList{};

  ListResourceGroupResponseBody() {}

  explicit ListResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupList) {
      res["ResourceGroupList"] = resourceGroupList ? boost::any(resourceGroupList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupList") != m.end() && !m["ResourceGroupList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceGroupList"].type()) {
        ListResourceGroupResponseBodyResourceGroupList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceGroupList"]));
        resourceGroupList = make_shared<ListResourceGroupResponseBodyResourceGroupList>(model1);
      }
    }
  }


  virtual ~ListResourceGroupResponseBody() = default;
};
class ListResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListResourceGroupResponseBody> body{};

  ListResourceGroupResponse() {}

  explicit ListResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListResourceGroupResponse() = default;
};
class ListRoleResponseBodyRoleListRoleItemActionListAction : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> code{};
  shared_ptr<string> name{};

  ListRoleResponseBodyRoleListRoleItemActionListAction() {}

  explicit ListRoleResponseBodyRoleListRoleItemActionListAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListRoleResponseBodyRoleListRoleItemActionListAction() = default;
};
class ListRoleResponseBodyRoleListRoleItemActionList : public Darabonba::Model {
public:
  shared_ptr<vector<ListRoleResponseBodyRoleListRoleItemActionListAction>> action{};

  ListRoleResponseBodyRoleListRoleItemActionList() {}

  explicit ListRoleResponseBodyRoleListRoleItemActionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      vector<boost::any> temp1;
      for(auto item1:*action){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Action"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      if (typeid(vector<boost::any>) == m["Action"].type()) {
        vector<ListRoleResponseBodyRoleListRoleItemActionListAction> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Action"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRoleResponseBodyRoleListRoleItemActionListAction model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        action = make_shared<vector<ListRoleResponseBodyRoleListRoleItemActionListAction>>(expect1);
      }
    }
  }


  virtual ~ListRoleResponseBodyRoleListRoleItemActionList() = default;
};
class ListRoleResponseBodyRoleListRoleItemRole : public Darabonba::Model {
public:
  shared_ptr<long> updateTime{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> adminUserId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};

  ListRoleResponseBodyRoleListRoleItemRole() {}

  explicit ListRoleResponseBodyRoleListRoleItemRole(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (adminUserId) {
      res["AdminUserId"] = boost::any(*adminUserId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("AdminUserId") != m.end() && !m["AdminUserId"].empty()) {
      adminUserId = make_shared<string>(boost::any_cast<string>(m["AdminUserId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~ListRoleResponseBodyRoleListRoleItemRole() = default;
};
class ListRoleResponseBodyRoleListRoleItem : public Darabonba::Model {
public:
  shared_ptr<ListRoleResponseBodyRoleListRoleItemActionList> actionList{};
  shared_ptr<ListRoleResponseBodyRoleListRoleItemRole> role{};

  ListRoleResponseBodyRoleListRoleItem() {}

  explicit ListRoleResponseBodyRoleListRoleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionList) {
      res["ActionList"] = actionList ? boost::any(actionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (role) {
      res["Role"] = role ? boost::any(role->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionList") != m.end() && !m["ActionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ActionList"].type()) {
        ListRoleResponseBodyRoleListRoleItemActionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ActionList"]));
        actionList = make_shared<ListRoleResponseBodyRoleListRoleItemActionList>(model1);
      }
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      if (typeid(map<string, boost::any>) == m["Role"].type()) {
        ListRoleResponseBodyRoleListRoleItemRole model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Role"]));
        role = make_shared<ListRoleResponseBodyRoleListRoleItemRole>(model1);
      }
    }
  }


  virtual ~ListRoleResponseBodyRoleListRoleItem() = default;
};
class ListRoleResponseBodyRoleList : public Darabonba::Model {
public:
  shared_ptr<vector<ListRoleResponseBodyRoleListRoleItem>> roleItem{};

  ListRoleResponseBodyRoleList() {}

  explicit ListRoleResponseBodyRoleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleItem) {
      vector<boost::any> temp1;
      for(auto item1:*roleItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RoleItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleItem") != m.end() && !m["RoleItem"].empty()) {
      if (typeid(vector<boost::any>) == m["RoleItem"].type()) {
        vector<ListRoleResponseBodyRoleListRoleItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RoleItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRoleResponseBodyRoleListRoleItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roleItem = make_shared<vector<ListRoleResponseBodyRoleListRoleItem>>(expect1);
      }
    }
  }


  virtual ~ListRoleResponseBodyRoleList() = default;
};
class ListRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListRoleResponseBodyRoleList> roleList{};
  shared_ptr<long> code{};

  ListRoleResponseBody() {}

  explicit ListRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (roleList) {
      res["RoleList"] = roleList ? boost::any(roleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RoleList") != m.end() && !m["RoleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoleList"].type()) {
        ListRoleResponseBodyRoleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoleList"]));
        roleList = make_shared<ListRoleResponseBodyRoleList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListRoleResponseBody() = default;
};
class ListRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListRoleResponseBody> body{};

  ListRoleResponse() {}

  explicit ListRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRoleResponseBody>(model1);
      }
    }
  }


  virtual ~ListRoleResponse() = default;
};
class ListRootStacksRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  ListRootStacksRequest() {}

  explicit ListRootStacksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListRootStacksRequest() = default;
};
class ListRootStacksResponseBodyDataResultChildren : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> icon{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};

  ListRootStacksResponseBodyDataResultChildren() {}

  explicit ListRootStacksResponseBodyDataResultChildren(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~ListRootStacksResponseBodyDataResultChildren() = default;
};
class ListRootStacksResponseBodyDataResultRoot : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> id{};

  ListRootStacksResponseBodyDataResultRoot() {}

  explicit ListRootStacksResponseBodyDataResultRoot(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~ListRootStacksResponseBodyDataResultRoot() = default;
};
class ListRootStacksResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListRootStacksResponseBodyDataResultChildren>> children{};
  shared_ptr<ListRootStacksResponseBodyDataResultRoot> root{};

  ListRootStacksResponseBodyDataResult() {}

  explicit ListRootStacksResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (children) {
      vector<boost::any> temp1;
      for(auto item1:*children){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Children"] = boost::any(temp1);
    }
    if (root) {
      res["Root"] = root ? boost::any(root->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Children") != m.end() && !m["Children"].empty()) {
      if (typeid(vector<boost::any>) == m["Children"].type()) {
        vector<ListRootStacksResponseBodyDataResultChildren> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Children"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRootStacksResponseBodyDataResultChildren model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        children = make_shared<vector<ListRootStacksResponseBodyDataResultChildren>>(expect1);
      }
    }
    if (m.find("Root") != m.end() && !m["Root"].empty()) {
      if (typeid(map<string, boost::any>) == m["Root"].type()) {
        ListRootStacksResponseBodyDataResultRoot model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Root"]));
        root = make_shared<ListRootStacksResponseBodyDataResultRoot>(model1);
      }
    }
  }


  virtual ~ListRootStacksResponseBodyDataResult() = default;
};
class ListRootStacksResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<ListRootStacksResponseBodyDataResult>> result{};
  shared_ptr<long> totalSize{};
  shared_ptr<long> pageSize{};

  ListRootStacksResponseBodyData() {}

  explicit ListRootStacksResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListRootStacksResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRootStacksResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListRootStacksResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListRootStacksResponseBodyData() = default;
};
class ListRootStacksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListRootStacksResponseBodyData> data{};
  shared_ptr<long> code{};

  ListRootStacksResponseBody() {}

  explicit ListRootStacksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListRootStacksResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListRootStacksResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListRootStacksResponseBody() = default;
};
class ListRootStacksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListRootStacksResponseBody> body{};

  ListRootStacksResponse() {}

  explicit ListRootStacksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRootStacksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRootStacksResponseBody>(model1);
      }
    }
  }


  virtual ~ListRootStacksResponse() = default;
};
class ListScaleOutEcuRequest : public Darabonba::Model {
public:
  shared_ptr<string> logicalRegionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};
  shared_ptr<long> cpu{};
  shared_ptr<long> mem{};
  shared_ptr<long> instanceNum{};

  ListScaleOutEcuRequest() {}

  explicit ListScaleOutEcuRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (instanceNum) {
      res["InstanceNum"] = boost::any(*instanceNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("InstanceNum") != m.end() && !m["InstanceNum"].empty()) {
      instanceNum = make_shared<long>(boost::any_cast<long>(m["InstanceNum"]));
    }
  }


  virtual ~ListScaleOutEcuRequest() = default;
};
class ListScaleOutEcuResponseBodyEcuInfoListEcuInfo : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> ipAddr{};
  shared_ptr<long> availableCpu{};
  shared_ptr<long> createTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ecuId{};
  shared_ptr<bool> dockerEnv{};
  shared_ptr<bool> online{};
  shared_ptr<long> availableMem{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> name{};
  shared_ptr<long> heartbeatTime{};

  ListScaleOutEcuResponseBodyEcuInfoListEcuInfo() {}

  explicit ListScaleOutEcuResponseBodyEcuInfoListEcuInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (ipAddr) {
      res["IpAddr"] = boost::any(*ipAddr);
    }
    if (availableCpu) {
      res["AvailableCpu"] = boost::any(*availableCpu);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ecuId) {
      res["EcuId"] = boost::any(*ecuId);
    }
    if (dockerEnv) {
      res["DockerEnv"] = boost::any(*dockerEnv);
    }
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (availableMem) {
      res["AvailableMem"] = boost::any(*availableMem);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (heartbeatTime) {
      res["HeartbeatTime"] = boost::any(*heartbeatTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("IpAddr") != m.end() && !m["IpAddr"].empty()) {
      ipAddr = make_shared<string>(boost::any_cast<string>(m["IpAddr"]));
    }
    if (m.find("AvailableCpu") != m.end() && !m["AvailableCpu"].empty()) {
      availableCpu = make_shared<long>(boost::any_cast<long>(m["AvailableCpu"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("EcuId") != m.end() && !m["EcuId"].empty()) {
      ecuId = make_shared<string>(boost::any_cast<string>(m["EcuId"]));
    }
    if (m.find("DockerEnv") != m.end() && !m["DockerEnv"].empty()) {
      dockerEnv = make_shared<bool>(boost::any_cast<bool>(m["DockerEnv"]));
    }
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<bool>(boost::any_cast<bool>(m["Online"]));
    }
    if (m.find("AvailableMem") != m.end() && !m["AvailableMem"].empty()) {
      availableMem = make_shared<long>(boost::any_cast<long>(m["AvailableMem"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("HeartbeatTime") != m.end() && !m["HeartbeatTime"].empty()) {
      heartbeatTime = make_shared<long>(boost::any_cast<long>(m["HeartbeatTime"]));
    }
  }


  virtual ~ListScaleOutEcuResponseBodyEcuInfoListEcuInfo() = default;
};
class ListScaleOutEcuResponseBodyEcuInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<ListScaleOutEcuResponseBodyEcuInfoListEcuInfo>> ecuInfo{};

  ListScaleOutEcuResponseBodyEcuInfoList() {}

  explicit ListScaleOutEcuResponseBodyEcuInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecuInfo) {
      vector<boost::any> temp1;
      for(auto item1:*ecuInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EcuInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcuInfo") != m.end() && !m["EcuInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["EcuInfo"].type()) {
        vector<ListScaleOutEcuResponseBodyEcuInfoListEcuInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EcuInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScaleOutEcuResponseBodyEcuInfoListEcuInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ecuInfo = make_shared<vector<ListScaleOutEcuResponseBodyEcuInfoListEcuInfo>>(expect1);
      }
    }
  }


  virtual ~ListScaleOutEcuResponseBodyEcuInfoList() = default;
};
class ListScaleOutEcuResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListScaleOutEcuResponseBodyEcuInfoList> ecuInfoList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  ListScaleOutEcuResponseBody() {}

  explicit ListScaleOutEcuResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecuInfoList) {
      res["EcuInfoList"] = ecuInfoList ? boost::any(ecuInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcuInfoList") != m.end() && !m["EcuInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EcuInfoList"].type()) {
        ListScaleOutEcuResponseBodyEcuInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EcuInfoList"]));
        ecuInfoList = make_shared<ListScaleOutEcuResponseBodyEcuInfoList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListScaleOutEcuResponseBody() = default;
};
class ListScaleOutEcuResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListScaleOutEcuResponseBody> body{};

  ListScaleOutEcuResponse() {}

  explicit ListScaleOutEcuResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListScaleOutEcuResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListScaleOutEcuResponseBody>(model1);
      }
    }
  }


  virtual ~ListScaleOutEcuResponse() = default;
};
class ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> createTime{};

  ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups() {}

  explicit ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
  }


  virtual ~ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups() = default;
};
class ListServiceGroupsResponseBodyServiceGroupsList : public Darabonba::Model {
public:
  shared_ptr<vector<ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups>> listServiceGroups{};

  ListServiceGroupsResponseBodyServiceGroupsList() {}

  explicit ListServiceGroupsResponseBodyServiceGroupsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listServiceGroups) {
      vector<boost::any> temp1;
      for(auto item1:*listServiceGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ListServiceGroups"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListServiceGroups") != m.end() && !m["ListServiceGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["ListServiceGroups"].type()) {
        vector<ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ListServiceGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        listServiceGroups = make_shared<vector<ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups>>(expect1);
      }
    }
  }


  virtual ~ListServiceGroupsResponseBodyServiceGroupsList() = default;
};
class ListServiceGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListServiceGroupsResponseBodyServiceGroupsList> serviceGroupsList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  ListServiceGroupsResponseBody() {}

  explicit ListServiceGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceGroupsList) {
      res["ServiceGroupsList"] = serviceGroupsList ? boost::any(serviceGroupsList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceGroupsList") != m.end() && !m["ServiceGroupsList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceGroupsList"].type()) {
        ListServiceGroupsResponseBodyServiceGroupsList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceGroupsList"]));
        serviceGroupsList = make_shared<ListServiceGroupsResponseBodyServiceGroupsList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListServiceGroupsResponseBody() = default;
};
class ListServiceGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListServiceGroupsResponseBody> body{};

  ListServiceGroupsResponse() {}

  explicit ListServiceGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListServiceGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListServiceGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListServiceGroupsResponse() = default;
};
class ListSlbResponseBodySlbListSlbEntity : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<string> slbId{};
  shared_ptr<string> vswitchId{};
  shared_ptr<bool> expired{};
  shared_ptr<string> userId{};
  shared_ptr<string> addressType{};
  shared_ptr<string> networkType{};
  shared_ptr<string> regionId{};
  shared_ptr<long> groupId{};
  shared_ptr<string> address{};
  shared_ptr<string> slbName{};
  shared_ptr<string> slbStatus{};

  ListSlbResponseBodySlbListSlbEntity() {}

  explicit ListSlbResponseBodySlbListSlbEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    if (expired) {
      res["Expired"] = boost::any(*expired);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (addressType) {
      res["AddressType"] = boost::any(*addressType);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (slbName) {
      res["SlbName"] = boost::any(*slbName);
    }
    if (slbStatus) {
      res["SlbStatus"] = boost::any(*slbStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
    if (m.find("Expired") != m.end() && !m["Expired"].empty()) {
      expired = make_shared<bool>(boost::any_cast<bool>(m["Expired"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("AddressType") != m.end() && !m["AddressType"].empty()) {
      addressType = make_shared<string>(boost::any_cast<string>(m["AddressType"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("SlbName") != m.end() && !m["SlbName"].empty()) {
      slbName = make_shared<string>(boost::any_cast<string>(m["SlbName"]));
    }
    if (m.find("SlbStatus") != m.end() && !m["SlbStatus"].empty()) {
      slbStatus = make_shared<string>(boost::any_cast<string>(m["SlbStatus"]));
    }
  }


  virtual ~ListSlbResponseBodySlbListSlbEntity() = default;
};
class ListSlbResponseBodySlbList : public Darabonba::Model {
public:
  shared_ptr<vector<ListSlbResponseBodySlbListSlbEntity>> slbEntity{};

  ListSlbResponseBodySlbList() {}

  explicit ListSlbResponseBodySlbList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (slbEntity) {
      vector<boost::any> temp1;
      for(auto item1:*slbEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SlbEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SlbEntity") != m.end() && !m["SlbEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["SlbEntity"].type()) {
        vector<ListSlbResponseBodySlbListSlbEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SlbEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSlbResponseBodySlbListSlbEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        slbEntity = make_shared<vector<ListSlbResponseBodySlbListSlbEntity>>(expect1);
      }
    }
  }


  virtual ~ListSlbResponseBodySlbList() = default;
};
class ListSlbResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};
  shared_ptr<ListSlbResponseBodySlbList> slbList{};

  ListSlbResponseBody() {}

  explicit ListSlbResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (slbList) {
      res["SlbList"] = slbList ? boost::any(slbList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("SlbList") != m.end() && !m["SlbList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SlbList"].type()) {
        ListSlbResponseBodySlbList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SlbList"]));
        slbList = make_shared<ListSlbResponseBodySlbList>(model1);
      }
    }
  }


  virtual ~ListSlbResponseBody() = default;
};
class ListSlbResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListSlbResponseBody> body{};

  ListSlbResponse() {}

  explicit ListSlbResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSlbResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSlbResponseBody>(model1);
      }
    }
  }


  virtual ~ListSlbResponse() = default;
};
class ListStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> region{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> source{};
  shared_ptr<string> accountId{};
  shared_ptr<string> appId{};
  shared_ptr<string> ip{};
  shared_ptr<string> podName{};
  shared_ptr<string> status{};

  ListStatusRequest() {}

  explicit ListStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (podName) {
      res["PodName"] = boost::any(*podName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("PodName") != m.end() && !m["PodName"].empty()) {
      podName = make_shared<string>(boost::any_cast<string>(m["PodName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListStatusRequest() = default;
};
class ListStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> podName{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> appId{};
  shared_ptr<string> region{};
  shared_ptr<string> ip{};
  shared_ptr<string> accountId{};
  shared_ptr<string> source{};
  shared_ptr<string> tenantId{};

  ListStatusResponseBodyData() {}

  explicit ListStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (podName) {
      res["PodName"] = boost::any(*podName);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PodName") != m.end() && !m["PodName"].empty()) {
      podName = make_shared<string>(boost::any_cast<string>(m["PodName"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~ListStatusResponseBodyData() = default;
};
class ListStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListStatusResponseBodyData>> data{};
  shared_ptr<long> code{};
  shared_ptr<bool> success{};

  ListStatusResponseBody() {}

  explicit ListStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListStatusResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListStatusResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListStatusResponseBodyData>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListStatusResponseBody() = default;
};
class ListStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListStatusResponseBody> body{};

  ListStatusResponse() {}

  explicit ListStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ListStatusResponse() = default;
};
class ListSubAccountResponseBodySubAccountListSubAccount : public Darabonba::Model {
public:
  shared_ptr<string> subEdasId{};
  shared_ptr<string> subUserId{};
  shared_ptr<string> email{};
  shared_ptr<string> adminUserId{};
  shared_ptr<string> adminUserKp{};
  shared_ptr<string> adminEdasId{};
  shared_ptr<string> subUserKp{};
  shared_ptr<string> phone{};

  ListSubAccountResponseBodySubAccountListSubAccount() {}

  explicit ListSubAccountResponseBodySubAccountListSubAccount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subEdasId) {
      res["SubEdasId"] = boost::any(*subEdasId);
    }
    if (subUserId) {
      res["SubUserId"] = boost::any(*subUserId);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (adminUserId) {
      res["AdminUserId"] = boost::any(*adminUserId);
    }
    if (adminUserKp) {
      res["AdminUserKp"] = boost::any(*adminUserKp);
    }
    if (adminEdasId) {
      res["AdminEdasId"] = boost::any(*adminEdasId);
    }
    if (subUserKp) {
      res["SubUserKp"] = boost::any(*subUserKp);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubEdasId") != m.end() && !m["SubEdasId"].empty()) {
      subEdasId = make_shared<string>(boost::any_cast<string>(m["SubEdasId"]));
    }
    if (m.find("SubUserId") != m.end() && !m["SubUserId"].empty()) {
      subUserId = make_shared<string>(boost::any_cast<string>(m["SubUserId"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("AdminUserId") != m.end() && !m["AdminUserId"].empty()) {
      adminUserId = make_shared<string>(boost::any_cast<string>(m["AdminUserId"]));
    }
    if (m.find("AdminUserKp") != m.end() && !m["AdminUserKp"].empty()) {
      adminUserKp = make_shared<string>(boost::any_cast<string>(m["AdminUserKp"]));
    }
    if (m.find("AdminEdasId") != m.end() && !m["AdminEdasId"].empty()) {
      adminEdasId = make_shared<string>(boost::any_cast<string>(m["AdminEdasId"]));
    }
    if (m.find("SubUserKp") != m.end() && !m["SubUserKp"].empty()) {
      subUserKp = make_shared<string>(boost::any_cast<string>(m["SubUserKp"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
  }


  virtual ~ListSubAccountResponseBodySubAccountListSubAccount() = default;
};
class ListSubAccountResponseBodySubAccountList : public Darabonba::Model {
public:
  shared_ptr<vector<ListSubAccountResponseBodySubAccountListSubAccount>> subAccount{};

  ListSubAccountResponseBodySubAccountList() {}

  explicit ListSubAccountResponseBodySubAccountList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subAccount) {
      vector<boost::any> temp1;
      for(auto item1:*subAccount){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubAccount"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubAccount") != m.end() && !m["SubAccount"].empty()) {
      if (typeid(vector<boost::any>) == m["SubAccount"].type()) {
        vector<ListSubAccountResponseBodySubAccountListSubAccount> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubAccount"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSubAccountResponseBodySubAccountListSubAccount model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subAccount = make_shared<vector<ListSubAccountResponseBodySubAccountListSubAccount>>(expect1);
      }
    }
  }


  virtual ~ListSubAccountResponseBodySubAccountList() = default;
};
class ListSubAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListSubAccountResponseBodySubAccountList> subAccountList{};
  shared_ptr<long> code{};

  ListSubAccountResponseBody() {}

  explicit ListSubAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subAccountList) {
      res["SubAccountList"] = subAccountList ? boost::any(subAccountList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubAccountList") != m.end() && !m["SubAccountList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubAccountList"].type()) {
        ListSubAccountResponseBodySubAccountList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubAccountList"]));
        subAccountList = make_shared<ListSubAccountResponseBodySubAccountList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListSubAccountResponseBody() = default;
};
class ListSubAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListSubAccountResponseBody> body{};

  ListSubAccountResponse() {}

  explicit ListSubAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSubAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSubAccountResponseBody>(model1);
      }
    }
  }


  virtual ~ListSubAccountResponse() = default;
};
class ListSwimmingLaneRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};

  ListSwimmingLaneRequest() {}

  explicit ListSwimmingLaneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
  }


  virtual ~ListSwimmingLaneRequest() = default;
};
class ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> appId{};
  shared_ptr<string> rules{};
  shared_ptr<long> laneId{};

  ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList() {}

  explicit ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (rules) {
      res["Rules"] = boost::any(*rules);
    }
    if (laneId) {
      res["LaneId"] = boost::any(*laneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rules = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
    if (m.find("LaneId") != m.end() && !m["LaneId"].empty()) {
      laneId = make_shared<long>(boost::any_cast<long>(m["LaneId"]));
    }
  }


  virtual ~ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList() = default;
};
class ListSwimmingLaneResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<long> groupId{};
  shared_ptr<string> scenarioSign{};
  shared_ptr<string> entryRule{};
  shared_ptr<string> tag{};
  shared_ptr<bool> enableRules{};
  shared_ptr<string> name{};
  shared_ptr<vector<ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList>> swimmingLaneAppRelationShipList{};
  shared_ptr<long> id{};

  ListSwimmingLaneResponseBodyData() {}

  explicit ListSwimmingLaneResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (scenarioSign) {
      res["ScenarioSign"] = boost::any(*scenarioSign);
    }
    if (entryRule) {
      res["EntryRule"] = boost::any(*entryRule);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (enableRules) {
      res["EnableRules"] = boost::any(*enableRules);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (swimmingLaneAppRelationShipList) {
      vector<boost::any> temp1;
      for(auto item1:*swimmingLaneAppRelationShipList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SwimmingLaneAppRelationShipList"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("ScenarioSign") != m.end() && !m["ScenarioSign"].empty()) {
      scenarioSign = make_shared<string>(boost::any_cast<string>(m["ScenarioSign"]));
    }
    if (m.find("EntryRule") != m.end() && !m["EntryRule"].empty()) {
      entryRule = make_shared<string>(boost::any_cast<string>(m["EntryRule"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("EnableRules") != m.end() && !m["EnableRules"].empty()) {
      enableRules = make_shared<bool>(boost::any_cast<bool>(m["EnableRules"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SwimmingLaneAppRelationShipList") != m.end() && !m["SwimmingLaneAppRelationShipList"].empty()) {
      if (typeid(vector<boost::any>) == m["SwimmingLaneAppRelationShipList"].type()) {
        vector<ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SwimmingLaneAppRelationShipList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        swimmingLaneAppRelationShipList = make_shared<vector<ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~ListSwimmingLaneResponseBodyData() = default;
};
class ListSwimmingLaneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSwimmingLaneResponseBodyData>> data{};
  shared_ptr<long> code{};

  ListSwimmingLaneResponseBody() {}

  explicit ListSwimmingLaneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListSwimmingLaneResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSwimmingLaneResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListSwimmingLaneResponseBodyData>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListSwimmingLaneResponseBody() = default;
};
class ListSwimmingLaneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListSwimmingLaneResponseBody> body{};

  ListSwimmingLaneResponse() {}

  explicit ListSwimmingLaneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSwimmingLaneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSwimmingLaneResponseBody>(model1);
      }
    }
  }


  virtual ~ListSwimmingLaneResponse() = default;
};
class ListSwimmingLaneGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> logicalRegionId{};

  ListSwimmingLaneGroupRequest() {}

  explicit ListSwimmingLaneGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
  }


  virtual ~ListSwimmingLaneGroupRequest() = default;
};
class ListSwimmingLaneGroupResponseBodyDataApplicationList : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> appId{};

  ListSwimmingLaneGroupResponseBodyDataApplicationList() {}

  explicit ListSwimmingLaneGroupResponseBodyDataApplicationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~ListSwimmingLaneGroupResponseBodyDataApplicationList() = default;
};
class ListSwimmingLaneGroupResponseBodyDataEntryApplication : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> appId{};
  shared_ptr<string> source{};

  ListSwimmingLaneGroupResponseBodyDataEntryApplication() {}

  explicit ListSwimmingLaneGroupResponseBodyDataEntryApplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~ListSwimmingLaneGroupResponseBodyDataEntryApplication() = default;
};
class ListSwimmingLaneGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<vector<ListSwimmingLaneGroupResponseBodyDataApplicationList>> applicationList{};
  shared_ptr<ListSwimmingLaneGroupResponseBodyDataEntryApplication> entryApplication{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};

  ListSwimmingLaneGroupResponseBodyData() {}

  explicit ListSwimmingLaneGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (applicationList) {
      vector<boost::any> temp1;
      for(auto item1:*applicationList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApplicationList"] = boost::any(temp1);
    }
    if (entryApplication) {
      res["EntryApplication"] = entryApplication ? boost::any(entryApplication->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("ApplicationList") != m.end() && !m["ApplicationList"].empty()) {
      if (typeid(vector<boost::any>) == m["ApplicationList"].type()) {
        vector<ListSwimmingLaneGroupResponseBodyDataApplicationList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApplicationList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSwimmingLaneGroupResponseBodyDataApplicationList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applicationList = make_shared<vector<ListSwimmingLaneGroupResponseBodyDataApplicationList>>(expect1);
      }
    }
    if (m.find("EntryApplication") != m.end() && !m["EntryApplication"].empty()) {
      if (typeid(map<string, boost::any>) == m["EntryApplication"].type()) {
        ListSwimmingLaneGroupResponseBodyDataEntryApplication model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EntryApplication"]));
        entryApplication = make_shared<ListSwimmingLaneGroupResponseBodyDataEntryApplication>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~ListSwimmingLaneGroupResponseBodyData() = default;
};
class ListSwimmingLaneGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSwimmingLaneGroupResponseBodyData>> data{};
  shared_ptr<long> code{};

  ListSwimmingLaneGroupResponseBody() {}

  explicit ListSwimmingLaneGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListSwimmingLaneGroupResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSwimmingLaneGroupResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListSwimmingLaneGroupResponseBodyData>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListSwimmingLaneGroupResponseBody() = default;
};
class ListSwimmingLaneGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListSwimmingLaneGroupResponseBody> body{};

  ListSwimmingLaneGroupResponse() {}

  explicit ListSwimmingLaneGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSwimmingLaneGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSwimmingLaneGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListSwimmingLaneGroupResponse() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceIds{};
  shared_ptr<string> tags{};
  shared_ptr<string> resourceRegionId{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (resourceRegionId) {
      res["ResourceRegionId"] = boost::any(*resourceRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      resourceIds = make_shared<string>(boost::any_cast<string>(m["ResourceIds"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("ResourceRegionId") != m.end() && !m["ResourceRegionId"].empty()) {
      resourceRegionId = make_shared<string>(boost::any_cast<string>(m["ResourceRegionId"]));
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyTagResourcesTagResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagValue{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> tagKey{};

  ListTagResourcesResponseBodyTagResourcesTagResource() {}

  explicit ListTagResourcesResponseBodyTagResourcesTagResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResourcesTagResource() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<vector<ListTagResourcesResponseBodyTagResourcesTagResource>> tagResource{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagResource) {
      vector<boost::any> temp1;
      for(auto item1:*tagResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagResource") != m.end() && !m["TagResource"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResource"].type()) {
        vector<ListTagResourcesResponseBodyTagResourcesTagResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResourcesTagResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResource = make_shared<vector<ListTagResourcesResponseBodyTagResourcesTagResource>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListTagResourcesResponseBodyTagResources> tagResources{};
  shared_ptr<long> code{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      res["TagResources"] = tagResources ? boost::any(tagResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagResources"].type()) {
        ListTagResourcesResponseBodyTagResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagResources"]));
        tagResources = make_shared<ListTagResourcesResponseBodyTagResources>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ListUserDefineRegionRequest : public Darabonba::Model {
public:
  shared_ptr<bool> debugEnable{};

  ListUserDefineRegionRequest() {}

  explicit ListUserDefineRegionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (debugEnable) {
      res["DebugEnable"] = boost::any(*debugEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DebugEnable") != m.end() && !m["DebugEnable"].empty()) {
      debugEnable = make_shared<bool>(boost::any_cast<bool>(m["DebugEnable"]));
    }
  }


  virtual ~ListUserDefineRegionRequest() = default;
};
class ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity : public Darabonba::Model {
public:
  shared_ptr<string> belongRegion{};
  shared_ptr<string> regionName{};
  shared_ptr<string> description{};
  shared_ptr<bool> debugEnable{};
  shared_ptr<string> userId{};
  shared_ptr<long> id{};
  shared_ptr<string> regionId{};

  ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity() {}

  explicit ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (belongRegion) {
      res["BelongRegion"] = boost::any(*belongRegion);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (debugEnable) {
      res["DebugEnable"] = boost::any(*debugEnable);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BelongRegion") != m.end() && !m["BelongRegion"].empty()) {
      belongRegion = make_shared<string>(boost::any_cast<string>(m["BelongRegion"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DebugEnable") != m.end() && !m["DebugEnable"].empty()) {
      debugEnable = make_shared<bool>(boost::any_cast<bool>(m["DebugEnable"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity() = default;
};
class ListUserDefineRegionResponseBodyUserDefineRegionList : public Darabonba::Model {
public:
  shared_ptr<vector<ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity>> userDefineRegionEntity{};

  ListUserDefineRegionResponseBodyUserDefineRegionList() {}

  explicit ListUserDefineRegionResponseBodyUserDefineRegionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userDefineRegionEntity) {
      vector<boost::any> temp1;
      for(auto item1:*userDefineRegionEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserDefineRegionEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserDefineRegionEntity") != m.end() && !m["UserDefineRegionEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["UserDefineRegionEntity"].type()) {
        vector<ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserDefineRegionEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userDefineRegionEntity = make_shared<vector<ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity>>(expect1);
      }
    }
  }


  virtual ~ListUserDefineRegionResponseBodyUserDefineRegionList() = default;
};
class ListUserDefineRegionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListUserDefineRegionResponseBodyUserDefineRegionList> userDefineRegionList{};
  shared_ptr<long> code{};

  ListUserDefineRegionResponseBody() {}

  explicit ListUserDefineRegionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userDefineRegionList) {
      res["UserDefineRegionList"] = userDefineRegionList ? boost::any(userDefineRegionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserDefineRegionList") != m.end() && !m["UserDefineRegionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserDefineRegionList"].type()) {
        ListUserDefineRegionResponseBodyUserDefineRegionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserDefineRegionList"]));
        userDefineRegionList = make_shared<ListUserDefineRegionResponseBodyUserDefineRegionList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListUserDefineRegionResponseBody() = default;
};
class ListUserDefineRegionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListUserDefineRegionResponseBody> body{};

  ListUserDefineRegionResponse() {}

  explicit ListUserDefineRegionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUserDefineRegionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUserDefineRegionResponseBody>(model1);
      }
    }
  }


  virtual ~ListUserDefineRegionResponse() = default;
};
class ListVpcResponseBodyVpcListVpcEntity : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcName{};
  shared_ptr<bool> expired{};
  shared_ptr<string> userId{};
  shared_ptr<long> ecsNum{};
  shared_ptr<string> regionId{};

  ListVpcResponseBodyVpcListVpcEntity() {}

  explicit ListVpcResponseBodyVpcListVpcEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    if (expired) {
      res["Expired"] = boost::any(*expired);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (ecsNum) {
      res["EcsNum"] = boost::any(*ecsNum);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
    if (m.find("Expired") != m.end() && !m["Expired"].empty()) {
      expired = make_shared<bool>(boost::any_cast<bool>(m["Expired"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("EcsNum") != m.end() && !m["EcsNum"].empty()) {
      ecsNum = make_shared<long>(boost::any_cast<long>(m["EcsNum"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListVpcResponseBodyVpcListVpcEntity() = default;
};
class ListVpcResponseBodyVpcList : public Darabonba::Model {
public:
  shared_ptr<vector<ListVpcResponseBodyVpcListVpcEntity>> vpcEntity{};

  ListVpcResponseBodyVpcList() {}

  explicit ListVpcResponseBodyVpcList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcEntity) {
      vector<boost::any> temp1;
      for(auto item1:*vpcEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VpcEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcEntity") != m.end() && !m["VpcEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["VpcEntity"].type()) {
        vector<ListVpcResponseBodyVpcListVpcEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VpcEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVpcResponseBodyVpcListVpcEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vpcEntity = make_shared<vector<ListVpcResponseBodyVpcListVpcEntity>>(expect1);
      }
    }
  }


  virtual ~ListVpcResponseBodyVpcList() = default;
};
class ListVpcResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListVpcResponseBodyVpcList> vpcList{};
  shared_ptr<long> code{};

  ListVpcResponseBody() {}

  explicit ListVpcResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vpcList) {
      res["VpcList"] = vpcList ? boost::any(vpcList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VpcList") != m.end() && !m["VpcList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpcList"].type()) {
        ListVpcResponseBodyVpcList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpcList"]));
        vpcList = make_shared<ListVpcResponseBodyVpcList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListVpcResponseBody() = default;
};
class ListVpcResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListVpcResponseBody> body{};

  ListVpcResponse() {}

  explicit ListVpcResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListVpcResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListVpcResponseBody>(model1);
      }
    }
  }


  virtual ~ListVpcResponse() = default;
};
class MigrateEcuRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceIds{};
  shared_ptr<string> logicalRegionId{};

  MigrateEcuRequest() {}

  explicit MigrateEcuRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
  }


  virtual ~MigrateEcuRequest() = default;
};
class MigrateEcuResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> data{};
  shared_ptr<long> code{};

  MigrateEcuResponseBody() {}

  explicit MigrateEcuResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~MigrateEcuResponseBody() = default;
};
class MigrateEcuResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<MigrateEcuResponseBody> body{};

  MigrateEcuResponse() {}

  explicit MigrateEcuResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MigrateEcuResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MigrateEcuResponseBody>(model1);
      }
    }
  }


  virtual ~MigrateEcuResponse() = default;
};
class ModifyScalingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> inCondition{};
  shared_ptr<bool> inEnable{};
  shared_ptr<long> inCpu{};
  shared_ptr<long> inDuration{};
  shared_ptr<long> inInstanceNum{};
  shared_ptr<long> inLoad{};
  shared_ptr<long> inRT{};
  shared_ptr<long> inStep{};
  shared_ptr<string> outCondition{};
  shared_ptr<long> outCPU{};
  shared_ptr<long> outDuration{};
  shared_ptr<bool> outEnable{};
  shared_ptr<long> outInstanceNum{};
  shared_ptr<long> outLoad{};
  shared_ptr<long> outRT{};
  shared_ptr<long> outStep{};
  shared_ptr<string> resourceFrom{};
  shared_ptr<string> multiAzPolicy{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vSwitchIds{};
  shared_ptr<string> scalingPolicy{};
  shared_ptr<string> templateInstanceId{};
  shared_ptr<string> templateInstanceName{};
  shared_ptr<string> password{};
  shared_ptr<string> keyPairName{};
  shared_ptr<bool> acceptEULA{};
  shared_ptr<string> templateId{};
  shared_ptr<long> templateVersion{};

  ModifyScalingRuleRequest() {}

  explicit ModifyScalingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (inCondition) {
      res["InCondition"] = boost::any(*inCondition);
    }
    if (inEnable) {
      res["InEnable"] = boost::any(*inEnable);
    }
    if (inCpu) {
      res["InCpu"] = boost::any(*inCpu);
    }
    if (inDuration) {
      res["InDuration"] = boost::any(*inDuration);
    }
    if (inInstanceNum) {
      res["InInstanceNum"] = boost::any(*inInstanceNum);
    }
    if (inLoad) {
      res["InLoad"] = boost::any(*inLoad);
    }
    if (inRT) {
      res["InRT"] = boost::any(*inRT);
    }
    if (inStep) {
      res["InStep"] = boost::any(*inStep);
    }
    if (outCondition) {
      res["OutCondition"] = boost::any(*outCondition);
    }
    if (outCPU) {
      res["OutCPU"] = boost::any(*outCPU);
    }
    if (outDuration) {
      res["OutDuration"] = boost::any(*outDuration);
    }
    if (outEnable) {
      res["OutEnable"] = boost::any(*outEnable);
    }
    if (outInstanceNum) {
      res["OutInstanceNum"] = boost::any(*outInstanceNum);
    }
    if (outLoad) {
      res["OutLoad"] = boost::any(*outLoad);
    }
    if (outRT) {
      res["OutRT"] = boost::any(*outRT);
    }
    if (outStep) {
      res["OutStep"] = boost::any(*outStep);
    }
    if (resourceFrom) {
      res["ResourceFrom"] = boost::any(*resourceFrom);
    }
    if (multiAzPolicy) {
      res["MultiAzPolicy"] = boost::any(*multiAzPolicy);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = boost::any(*vSwitchIds);
    }
    if (scalingPolicy) {
      res["ScalingPolicy"] = boost::any(*scalingPolicy);
    }
    if (templateInstanceId) {
      res["TemplateInstanceId"] = boost::any(*templateInstanceId);
    }
    if (templateInstanceName) {
      res["TemplateInstanceName"] = boost::any(*templateInstanceName);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (acceptEULA) {
      res["AcceptEULA"] = boost::any(*acceptEULA);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateVersion) {
      res["TemplateVersion"] = boost::any(*templateVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("InCondition") != m.end() && !m["InCondition"].empty()) {
      inCondition = make_shared<string>(boost::any_cast<string>(m["InCondition"]));
    }
    if (m.find("InEnable") != m.end() && !m["InEnable"].empty()) {
      inEnable = make_shared<bool>(boost::any_cast<bool>(m["InEnable"]));
    }
    if (m.find("InCpu") != m.end() && !m["InCpu"].empty()) {
      inCpu = make_shared<long>(boost::any_cast<long>(m["InCpu"]));
    }
    if (m.find("InDuration") != m.end() && !m["InDuration"].empty()) {
      inDuration = make_shared<long>(boost::any_cast<long>(m["InDuration"]));
    }
    if (m.find("InInstanceNum") != m.end() && !m["InInstanceNum"].empty()) {
      inInstanceNum = make_shared<long>(boost::any_cast<long>(m["InInstanceNum"]));
    }
    if (m.find("InLoad") != m.end() && !m["InLoad"].empty()) {
      inLoad = make_shared<long>(boost::any_cast<long>(m["InLoad"]));
    }
    if (m.find("InRT") != m.end() && !m["InRT"].empty()) {
      inRT = make_shared<long>(boost::any_cast<long>(m["InRT"]));
    }
    if (m.find("InStep") != m.end() && !m["InStep"].empty()) {
      inStep = make_shared<long>(boost::any_cast<long>(m["InStep"]));
    }
    if (m.find("OutCondition") != m.end() && !m["OutCondition"].empty()) {
      outCondition = make_shared<string>(boost::any_cast<string>(m["OutCondition"]));
    }
    if (m.find("OutCPU") != m.end() && !m["OutCPU"].empty()) {
      outCPU = make_shared<long>(boost::any_cast<long>(m["OutCPU"]));
    }
    if (m.find("OutDuration") != m.end() && !m["OutDuration"].empty()) {
      outDuration = make_shared<long>(boost::any_cast<long>(m["OutDuration"]));
    }
    if (m.find("OutEnable") != m.end() && !m["OutEnable"].empty()) {
      outEnable = make_shared<bool>(boost::any_cast<bool>(m["OutEnable"]));
    }
    if (m.find("OutInstanceNum") != m.end() && !m["OutInstanceNum"].empty()) {
      outInstanceNum = make_shared<long>(boost::any_cast<long>(m["OutInstanceNum"]));
    }
    if (m.find("OutLoad") != m.end() && !m["OutLoad"].empty()) {
      outLoad = make_shared<long>(boost::any_cast<long>(m["OutLoad"]));
    }
    if (m.find("OutRT") != m.end() && !m["OutRT"].empty()) {
      outRT = make_shared<long>(boost::any_cast<long>(m["OutRT"]));
    }
    if (m.find("OutStep") != m.end() && !m["OutStep"].empty()) {
      outStep = make_shared<long>(boost::any_cast<long>(m["OutStep"]));
    }
    if (m.find("ResourceFrom") != m.end() && !m["ResourceFrom"].empty()) {
      resourceFrom = make_shared<string>(boost::any_cast<string>(m["ResourceFrom"]));
    }
    if (m.find("MultiAzPolicy") != m.end() && !m["MultiAzPolicy"].empty()) {
      multiAzPolicy = make_shared<string>(boost::any_cast<string>(m["MultiAzPolicy"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      vSwitchIds = make_shared<string>(boost::any_cast<string>(m["VSwitchIds"]));
    }
    if (m.find("ScalingPolicy") != m.end() && !m["ScalingPolicy"].empty()) {
      scalingPolicy = make_shared<string>(boost::any_cast<string>(m["ScalingPolicy"]));
    }
    if (m.find("TemplateInstanceId") != m.end() && !m["TemplateInstanceId"].empty()) {
      templateInstanceId = make_shared<string>(boost::any_cast<string>(m["TemplateInstanceId"]));
    }
    if (m.find("TemplateInstanceName") != m.end() && !m["TemplateInstanceName"].empty()) {
      templateInstanceName = make_shared<string>(boost::any_cast<string>(m["TemplateInstanceName"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("AcceptEULA") != m.end() && !m["AcceptEULA"].empty()) {
      acceptEULA = make_shared<bool>(boost::any_cast<bool>(m["AcceptEULA"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateVersion") != m.end() && !m["TemplateVersion"].empty()) {
      templateVersion = make_shared<long>(boost::any_cast<long>(m["TemplateVersion"]));
    }
  }


  virtual ~ModifyScalingRuleRequest() = default;
};
class ModifyScalingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  ModifyScalingRuleResponseBody() {}

  explicit ModifyScalingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ModifyScalingRuleResponseBody() = default;
};
class ModifyScalingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyScalingRuleResponseBody> body{};

  ModifyScalingRuleResponse() {}

  explicit ModifyScalingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyScalingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyScalingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyScalingRuleResponse() = default;
};
class QueryApplicationStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  QueryApplicationStatusRequest() {}

  explicit QueryApplicationStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~QueryApplicationStatusRequest() = default;
};
class QueryApplicationStatusResponseBodyAppInfoEcuListEcu : public Darabonba::Model {
public:
  shared_ptr<string> ecuId{};
  shared_ptr<bool> online{};
  shared_ptr<bool> dockerEnv{};
  shared_ptr<long> createTime{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> ipAddr{};
  shared_ptr<long> heartbeatTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> name{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> vpcId{};
  shared_ptr<long> availableCpu{};
  shared_ptr<long> availableMem{};

  QueryApplicationStatusResponseBodyAppInfoEcuListEcu() {}

  explicit QueryApplicationStatusResponseBodyAppInfoEcuListEcu(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecuId) {
      res["EcuId"] = boost::any(*ecuId);
    }
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (dockerEnv) {
      res["DockerEnv"] = boost::any(*dockerEnv);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (ipAddr) {
      res["IpAddr"] = boost::any(*ipAddr);
    }
    if (heartbeatTime) {
      res["HeartbeatTime"] = boost::any(*heartbeatTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (availableCpu) {
      res["AvailableCpu"] = boost::any(*availableCpu);
    }
    if (availableMem) {
      res["AvailableMem"] = boost::any(*availableMem);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcuId") != m.end() && !m["EcuId"].empty()) {
      ecuId = make_shared<string>(boost::any_cast<string>(m["EcuId"]));
    }
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<bool>(boost::any_cast<bool>(m["Online"]));
    }
    if (m.find("DockerEnv") != m.end() && !m["DockerEnv"].empty()) {
      dockerEnv = make_shared<bool>(boost::any_cast<bool>(m["DockerEnv"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("IpAddr") != m.end() && !m["IpAddr"].empty()) {
      ipAddr = make_shared<string>(boost::any_cast<string>(m["IpAddr"]));
    }
    if (m.find("HeartbeatTime") != m.end() && !m["HeartbeatTime"].empty()) {
      heartbeatTime = make_shared<long>(boost::any_cast<long>(m["HeartbeatTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("AvailableCpu") != m.end() && !m["AvailableCpu"].empty()) {
      availableCpu = make_shared<long>(boost::any_cast<long>(m["AvailableCpu"]));
    }
    if (m.find("AvailableMem") != m.end() && !m["AvailableMem"].empty()) {
      availableMem = make_shared<long>(boost::any_cast<long>(m["AvailableMem"]));
    }
  }


  virtual ~QueryApplicationStatusResponseBodyAppInfoEcuListEcu() = default;
};
class QueryApplicationStatusResponseBodyAppInfoEcuList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryApplicationStatusResponseBodyAppInfoEcuListEcu>> ecu{};

  QueryApplicationStatusResponseBodyAppInfoEcuList() {}

  explicit QueryApplicationStatusResponseBodyAppInfoEcuList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecu) {
      vector<boost::any> temp1;
      for(auto item1:*ecu){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ecu"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ecu") != m.end() && !m["Ecu"].empty()) {
      if (typeid(vector<boost::any>) == m["Ecu"].type()) {
        vector<QueryApplicationStatusResponseBodyAppInfoEcuListEcu> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ecu"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryApplicationStatusResponseBodyAppInfoEcuListEcu model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ecu = make_shared<vector<QueryApplicationStatusResponseBodyAppInfoEcuListEcu>>(expect1);
      }
    }
  }


  virtual ~QueryApplicationStatusResponseBodyAppInfoEcuList() = default;
};
class QueryApplicationStatusResponseBodyAppInfoEccListEcc : public Darabonba::Model {
public:
  shared_ptr<string> eccId{};
  shared_ptr<string> ecuId{};
  shared_ptr<string> appId{};
  shared_ptr<long> appState{};
  shared_ptr<long> taskState{};
  shared_ptr<long> createTime{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> ip{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> containerStatus{};

  QueryApplicationStatusResponseBodyAppInfoEccListEcc() {}

  explicit QueryApplicationStatusResponseBodyAppInfoEccListEcc(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eccId) {
      res["EccId"] = boost::any(*eccId);
    }
    if (ecuId) {
      res["EcuId"] = boost::any(*ecuId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appState) {
      res["AppState"] = boost::any(*appState);
    }
    if (taskState) {
      res["TaskState"] = boost::any(*taskState);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (containerStatus) {
      res["ContainerStatus"] = boost::any(*containerStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EccId") != m.end() && !m["EccId"].empty()) {
      eccId = make_shared<string>(boost::any_cast<string>(m["EccId"]));
    }
    if (m.find("EcuId") != m.end() && !m["EcuId"].empty()) {
      ecuId = make_shared<string>(boost::any_cast<string>(m["EcuId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppState") != m.end() && !m["AppState"].empty()) {
      appState = make_shared<long>(boost::any_cast<long>(m["AppState"]));
    }
    if (m.find("TaskState") != m.end() && !m["TaskState"].empty()) {
      taskState = make_shared<long>(boost::any_cast<long>(m["TaskState"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ContainerStatus") != m.end() && !m["ContainerStatus"].empty()) {
      containerStatus = make_shared<string>(boost::any_cast<string>(m["ContainerStatus"]));
    }
  }


  virtual ~QueryApplicationStatusResponseBodyAppInfoEccListEcc() = default;
};
class QueryApplicationStatusResponseBodyAppInfoEccList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryApplicationStatusResponseBodyAppInfoEccListEcc>> ecc{};

  QueryApplicationStatusResponseBodyAppInfoEccList() {}

  explicit QueryApplicationStatusResponseBodyAppInfoEccList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecc) {
      vector<boost::any> temp1;
      for(auto item1:*ecc){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ecc"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ecc") != m.end() && !m["Ecc"].empty()) {
      if (typeid(vector<boost::any>) == m["Ecc"].type()) {
        vector<QueryApplicationStatusResponseBodyAppInfoEccListEcc> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ecc"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryApplicationStatusResponseBodyAppInfoEccListEcc model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ecc = make_shared<vector<QueryApplicationStatusResponseBodyAppInfoEccListEcc>>(expect1);
      }
    }
  }


  virtual ~QueryApplicationStatusResponseBodyAppInfoEccList() = default;
};
class QueryApplicationStatusResponseBodyAppInfoGroupListGroup : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> appId{};
  shared_ptr<string> packageVersionId{};
  shared_ptr<string> appVersionId{};
  shared_ptr<long> groupType{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> createTime{};
  shared_ptr<long> updateTime{};

  QueryApplicationStatusResponseBodyAppInfoGroupListGroup() {}

  explicit QueryApplicationStatusResponseBodyAppInfoGroupListGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (packageVersionId) {
      res["PackageVersionId"] = boost::any(*packageVersionId);
    }
    if (appVersionId) {
      res["AppVersionId"] = boost::any(*appVersionId);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("PackageVersionId") != m.end() && !m["PackageVersionId"].empty()) {
      packageVersionId = make_shared<string>(boost::any_cast<string>(m["PackageVersionId"]));
    }
    if (m.find("AppVersionId") != m.end() && !m["AppVersionId"].empty()) {
      appVersionId = make_shared<string>(boost::any_cast<string>(m["AppVersionId"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<long>(boost::any_cast<long>(m["GroupType"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~QueryApplicationStatusResponseBodyAppInfoGroupListGroup() = default;
};
class QueryApplicationStatusResponseBodyAppInfoGroupList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryApplicationStatusResponseBodyAppInfoGroupListGroup>> group{};

  QueryApplicationStatusResponseBodyAppInfoGroupList() {}

  explicit QueryApplicationStatusResponseBodyAppInfoGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (group) {
      vector<boost::any> temp1;
      for(auto item1:*group){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Group"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      if (typeid(vector<boost::any>) == m["Group"].type()) {
        vector<QueryApplicationStatusResponseBodyAppInfoGroupListGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Group"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryApplicationStatusResponseBodyAppInfoGroupListGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        group = make_shared<vector<QueryApplicationStatusResponseBodyAppInfoGroupListGroup>>(expect1);
      }
    }
  }


  virtual ~QueryApplicationStatusResponseBodyAppInfoGroupList() = default;
};
class QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord : public Darabonba::Model {
public:
  shared_ptr<string> deployRecordId{};
  shared_ptr<string> eccId{};
  shared_ptr<string> ecuId{};
  shared_ptr<string> packageVersionId{};
  shared_ptr<string> packageMd5{};
  shared_ptr<long> createTime{};

  QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord() {}

  explicit QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployRecordId) {
      res["DeployRecordId"] = boost::any(*deployRecordId);
    }
    if (eccId) {
      res["EccId"] = boost::any(*eccId);
    }
    if (ecuId) {
      res["EcuId"] = boost::any(*ecuId);
    }
    if (packageVersionId) {
      res["PackageVersionId"] = boost::any(*packageVersionId);
    }
    if (packageMd5) {
      res["PackageMd5"] = boost::any(*packageMd5);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployRecordId") != m.end() && !m["DeployRecordId"].empty()) {
      deployRecordId = make_shared<string>(boost::any_cast<string>(m["DeployRecordId"]));
    }
    if (m.find("EccId") != m.end() && !m["EccId"].empty()) {
      eccId = make_shared<string>(boost::any_cast<string>(m["EccId"]));
    }
    if (m.find("EcuId") != m.end() && !m["EcuId"].empty()) {
      ecuId = make_shared<string>(boost::any_cast<string>(m["EcuId"]));
    }
    if (m.find("PackageVersionId") != m.end() && !m["PackageVersionId"].empty()) {
      packageVersionId = make_shared<string>(boost::any_cast<string>(m["PackageVersionId"]));
    }
    if (m.find("PackageMd5") != m.end() && !m["PackageMd5"].empty()) {
      packageMd5 = make_shared<string>(boost::any_cast<string>(m["PackageMd5"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
  }


  virtual ~QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord() = default;
};
class QueryApplicationStatusResponseBodyAppInfoDeployRecordList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord>> deployRecord{};

  QueryApplicationStatusResponseBodyAppInfoDeployRecordList() {}

  explicit QueryApplicationStatusResponseBodyAppInfoDeployRecordList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployRecord) {
      vector<boost::any> temp1;
      for(auto item1:*deployRecord){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeployRecord"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployRecord") != m.end() && !m["DeployRecord"].empty()) {
      if (typeid(vector<boost::any>) == m["DeployRecord"].type()) {
        vector<QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeployRecord"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deployRecord = make_shared<vector<QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord>>(expect1);
      }
    }
  }


  virtual ~QueryApplicationStatusResponseBodyAppInfoDeployRecordList() = default;
};
class QueryApplicationStatusResponseBodyAppInfoApplication : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<long> buildPackageId{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> cpu{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> dockerize{};
  shared_ptr<string> email{};
  shared_ptr<string> healthCheckUrl{};
  shared_ptr<long> instanceCount{};
  shared_ptr<long> launchTime{};
  shared_ptr<long> memory{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<string> phone{};
  shared_ptr<long> port{};
  shared_ptr<string> regionId{};
  shared_ptr<long> runningInstanceCount{};
  shared_ptr<string> userId{};

  QueryApplicationStatusResponseBodyAppInfoApplication() {}

  explicit QueryApplicationStatusResponseBodyAppInfoApplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (buildPackageId) {
      res["BuildPackageId"] = boost::any(*buildPackageId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dockerize) {
      res["Dockerize"] = boost::any(*dockerize);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (healthCheckUrl) {
      res["HealthCheckUrl"] = boost::any(*healthCheckUrl);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (launchTime) {
      res["LaunchTime"] = boost::any(*launchTime);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (runningInstanceCount) {
      res["RunningInstanceCount"] = boost::any(*runningInstanceCount);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("BuildPackageId") != m.end() && !m["BuildPackageId"].empty()) {
      buildPackageId = make_shared<long>(boost::any_cast<long>(m["BuildPackageId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Dockerize") != m.end() && !m["Dockerize"].empty()) {
      dockerize = make_shared<bool>(boost::any_cast<bool>(m["Dockerize"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("HealthCheckUrl") != m.end() && !m["HealthCheckUrl"].empty()) {
      healthCheckUrl = make_shared<string>(boost::any_cast<string>(m["HealthCheckUrl"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("LaunchTime") != m.end() && !m["LaunchTime"].empty()) {
      launchTime = make_shared<long>(boost::any_cast<long>(m["LaunchTime"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RunningInstanceCount") != m.end() && !m["RunningInstanceCount"].empty()) {
      runningInstanceCount = make_shared<long>(boost::any_cast<long>(m["RunningInstanceCount"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryApplicationStatusResponseBodyAppInfoApplication() = default;
};
class QueryApplicationStatusResponseBodyAppInfo : public Darabonba::Model {
public:
  shared_ptr<QueryApplicationStatusResponseBodyAppInfoEcuList> ecuList{};
  shared_ptr<QueryApplicationStatusResponseBodyAppInfoEccList> eccList{};
  shared_ptr<QueryApplicationStatusResponseBodyAppInfoGroupList> groupList{};
  shared_ptr<QueryApplicationStatusResponseBodyAppInfoDeployRecordList> deployRecordList{};
  shared_ptr<QueryApplicationStatusResponseBodyAppInfoApplication> application{};

  QueryApplicationStatusResponseBodyAppInfo() {}

  explicit QueryApplicationStatusResponseBodyAppInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecuList) {
      res["EcuList"] = ecuList ? boost::any(ecuList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (eccList) {
      res["EccList"] = eccList ? boost::any(eccList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupList) {
      res["GroupList"] = groupList ? boost::any(groupList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deployRecordList) {
      res["DeployRecordList"] = deployRecordList ? boost::any(deployRecordList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (application) {
      res["Application"] = application ? boost::any(application->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcuList") != m.end() && !m["EcuList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EcuList"].type()) {
        QueryApplicationStatusResponseBodyAppInfoEcuList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EcuList"]));
        ecuList = make_shared<QueryApplicationStatusResponseBodyAppInfoEcuList>(model1);
      }
    }
    if (m.find("EccList") != m.end() && !m["EccList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EccList"].type()) {
        QueryApplicationStatusResponseBodyAppInfoEccList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EccList"]));
        eccList = make_shared<QueryApplicationStatusResponseBodyAppInfoEccList>(model1);
      }
    }
    if (m.find("GroupList") != m.end() && !m["GroupList"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupList"].type()) {
        QueryApplicationStatusResponseBodyAppInfoGroupList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupList"]));
        groupList = make_shared<QueryApplicationStatusResponseBodyAppInfoGroupList>(model1);
      }
    }
    if (m.find("DeployRecordList") != m.end() && !m["DeployRecordList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeployRecordList"].type()) {
        QueryApplicationStatusResponseBodyAppInfoDeployRecordList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeployRecordList"]));
        deployRecordList = make_shared<QueryApplicationStatusResponseBodyAppInfoDeployRecordList>(model1);
      }
    }
    if (m.find("Application") != m.end() && !m["Application"].empty()) {
      if (typeid(map<string, boost::any>) == m["Application"].type()) {
        QueryApplicationStatusResponseBodyAppInfoApplication model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Application"]));
        application = make_shared<QueryApplicationStatusResponseBodyAppInfoApplication>(model1);
      }
    }
  }


  virtual ~QueryApplicationStatusResponseBodyAppInfo() = default;
};
class QueryApplicationStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryApplicationStatusResponseBodyAppInfo> appInfo{};

  QueryApplicationStatusResponseBody() {}

  explicit QueryApplicationStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (appInfo) {
      res["AppInfo"] = appInfo ? boost::any(appInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("AppInfo") != m.end() && !m["AppInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppInfo"].type()) {
        QueryApplicationStatusResponseBodyAppInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppInfo"]));
        appInfo = make_shared<QueryApplicationStatusResponseBodyAppInfo>(model1);
      }
    }
  }


  virtual ~QueryApplicationStatusResponseBody() = default;
};
class QueryApplicationStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryApplicationStatusResponseBody> body{};

  QueryApplicationStatusResponse() {}

  explicit QueryApplicationStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryApplicationStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryApplicationStatusResponseBody>(model1);
      }
    }
  }


  virtual ~QueryApplicationStatusResponse() = default;
};
class QueryConfigCenterRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataId{};
  shared_ptr<string> group{};
  shared_ptr<string> logicalRegionId{};

  QueryConfigCenterRequest() {}

  explicit QueryConfigCenterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
  }


  virtual ~QueryConfigCenterRequest() = default;
};
class QueryConfigCenterResponseBodyConfigCenterInfo : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> dataId{};
  shared_ptr<string> content{};
  shared_ptr<string> id{};
  shared_ptr<string> group{};

  QueryConfigCenterResponseBodyConfigCenterInfo() {}

  explicit QueryConfigCenterResponseBodyConfigCenterInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
  }


  virtual ~QueryConfigCenterResponseBodyConfigCenterInfo() = default;
};
class QueryConfigCenterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryConfigCenterResponseBodyConfigCenterInfo> configCenterInfo{};
  shared_ptr<long> code{};

  QueryConfigCenterResponseBody() {}

  explicit QueryConfigCenterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (configCenterInfo) {
      res["configCenterInfo"] = configCenterInfo ? boost::any(configCenterInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("configCenterInfo") != m.end() && !m["configCenterInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["configCenterInfo"].type()) {
        QueryConfigCenterResponseBodyConfigCenterInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["configCenterInfo"]));
        configCenterInfo = make_shared<QueryConfigCenterResponseBodyConfigCenterInfo>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~QueryConfigCenterResponseBody() = default;
};
class QueryConfigCenterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryConfigCenterResponseBody> body{};

  QueryConfigCenterResponse() {}

  explicit QueryConfigCenterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryConfigCenterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryConfigCenterResponseBody>(model1);
      }
    }
  }


  virtual ~QueryConfigCenterResponse() = default;
};
class QueryEccInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> eccId{};

  QueryEccInfoRequest() {}

  explicit QueryEccInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eccId) {
      res["EccId"] = boost::any(*eccId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EccId") != m.end() && !m["EccId"].empty()) {
      eccId = make_shared<string>(boost::any_cast<string>(m["EccId"]));
    }
  }


  virtual ~QueryEccInfoRequest() = default;
};
class QueryEccInfoResponseBodyEccInfo : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<string> eccId{};
  shared_ptr<string> ecuId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> packageMd5{};
  shared_ptr<string> appId{};
  shared_ptr<string> packageVersion{};

  QueryEccInfoResponseBodyEccInfo() {}

  explicit QueryEccInfoResponseBodyEccInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (eccId) {
      res["EccId"] = boost::any(*eccId);
    }
    if (ecuId) {
      res["EcuId"] = boost::any(*ecuId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (packageMd5) {
      res["PackageMd5"] = boost::any(*packageMd5);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("EccId") != m.end() && !m["EccId"].empty()) {
      eccId = make_shared<string>(boost::any_cast<string>(m["EccId"]));
    }
    if (m.find("EcuId") != m.end() && !m["EcuId"].empty()) {
      ecuId = make_shared<string>(boost::any_cast<string>(m["EcuId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("PackageMd5") != m.end() && !m["PackageMd5"].empty()) {
      packageMd5 = make_shared<string>(boost::any_cast<string>(m["PackageMd5"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
  }


  virtual ~QueryEccInfoResponseBodyEccInfo() = default;
};
class QueryEccInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryEccInfoResponseBodyEccInfo> eccInfo{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  QueryEccInfoResponseBody() {}

  explicit QueryEccInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eccInfo) {
      res["EccInfo"] = eccInfo ? boost::any(eccInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EccInfo") != m.end() && !m["EccInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["EccInfo"].type()) {
        QueryEccInfoResponseBodyEccInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EccInfo"]));
        eccInfo = make_shared<QueryEccInfoResponseBodyEccInfo>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~QueryEccInfoResponseBody() = default;
};
class QueryEccInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryEccInfoResponseBody> body{};

  QueryEccInfoResponse() {}

  explicit QueryEccInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEccInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEccInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEccInfoResponse() = default;
};
class QueryK8sClusterLogProjectInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};

  QueryK8sClusterLogProjectInfoRequest() {}

  explicit QueryK8sClusterLogProjectInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~QueryK8sClusterLogProjectInfoRequest() = default;
};
class QueryK8sClusterLogProjectInfoResponseBodyProjectInfo : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};

  QueryK8sClusterLogProjectInfoResponseBodyProjectInfo() {}

  explicit QueryK8sClusterLogProjectInfoResponseBodyProjectInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~QueryK8sClusterLogProjectInfoResponseBodyProjectInfo() = default;
};
class QueryK8sClusterLogProjectInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryK8sClusterLogProjectInfoResponseBodyProjectInfo> projectInfo{};
  shared_ptr<long> code{};

  QueryK8sClusterLogProjectInfoResponseBody() {}

  explicit QueryK8sClusterLogProjectInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (projectInfo) {
      res["ProjectInfo"] = projectInfo ? boost::any(projectInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ProjectInfo") != m.end() && !m["ProjectInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProjectInfo"].type()) {
        QueryK8sClusterLogProjectInfoResponseBodyProjectInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProjectInfo"]));
        projectInfo = make_shared<QueryK8sClusterLogProjectInfoResponseBodyProjectInfo>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~QueryK8sClusterLogProjectInfoResponseBody() = default;
};
class QueryK8sClusterLogProjectInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryK8sClusterLogProjectInfoResponseBody> body{};

  QueryK8sClusterLogProjectInfoResponse() {}

  explicit QueryK8sClusterLogProjectInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryK8sClusterLogProjectInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryK8sClusterLogProjectInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryK8sClusterLogProjectInfoResponse() = default;
};
class QueryMigrateEcuListRequest : public Darabonba::Model {
public:
  shared_ptr<string> logicalRegionId{};

  QueryMigrateEcuListRequest() {}

  explicit QueryMigrateEcuListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
  }


  virtual ~QueryMigrateEcuListRequest() = default;
};
class QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> ipAddr{};
  shared_ptr<long> availableCpu{};
  shared_ptr<long> createTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> mem{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ecuId{};
  shared_ptr<long> cpu{};
  shared_ptr<bool> dockerEnv{};
  shared_ptr<bool> online{};
  shared_ptr<long> availableMem{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> name{};
  shared_ptr<long> heartbeatTime{};

  QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity() {}

  explicit QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (ipAddr) {
      res["IpAddr"] = boost::any(*ipAddr);
    }
    if (availableCpu) {
      res["AvailableCpu"] = boost::any(*availableCpu);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ecuId) {
      res["EcuId"] = boost::any(*ecuId);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (dockerEnv) {
      res["DockerEnv"] = boost::any(*dockerEnv);
    }
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (availableMem) {
      res["AvailableMem"] = boost::any(*availableMem);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (heartbeatTime) {
      res["HeartbeatTime"] = boost::any(*heartbeatTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("IpAddr") != m.end() && !m["IpAddr"].empty()) {
      ipAddr = make_shared<string>(boost::any_cast<string>(m["IpAddr"]));
    }
    if (m.find("AvailableCpu") != m.end() && !m["AvailableCpu"].empty()) {
      availableCpu = make_shared<long>(boost::any_cast<long>(m["AvailableCpu"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("EcuId") != m.end() && !m["EcuId"].empty()) {
      ecuId = make_shared<string>(boost::any_cast<string>(m["EcuId"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("DockerEnv") != m.end() && !m["DockerEnv"].empty()) {
      dockerEnv = make_shared<bool>(boost::any_cast<bool>(m["DockerEnv"]));
    }
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<bool>(boost::any_cast<bool>(m["Online"]));
    }
    if (m.find("AvailableMem") != m.end() && !m["AvailableMem"].empty()) {
      availableMem = make_shared<long>(boost::any_cast<long>(m["AvailableMem"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("HeartbeatTime") != m.end() && !m["HeartbeatTime"].empty()) {
      heartbeatTime = make_shared<long>(boost::any_cast<long>(m["HeartbeatTime"]));
    }
  }


  virtual ~QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity() = default;
};
class QueryMigrateEcuListResponseBodyEcuEntityList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity>> ecuEntity{};

  QueryMigrateEcuListResponseBodyEcuEntityList() {}

  explicit QueryMigrateEcuListResponseBodyEcuEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecuEntity) {
      vector<boost::any> temp1;
      for(auto item1:*ecuEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EcuEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcuEntity") != m.end() && !m["EcuEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["EcuEntity"].type()) {
        vector<QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EcuEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ecuEntity = make_shared<vector<QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity>>(expect1);
      }
    }
  }


  virtual ~QueryMigrateEcuListResponseBodyEcuEntityList() = default;
};
class QueryMigrateEcuListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryMigrateEcuListResponseBodyEcuEntityList> ecuEntityList{};
  shared_ptr<long> code{};

  QueryMigrateEcuListResponseBody() {}

  explicit QueryMigrateEcuListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ecuEntityList) {
      res["EcuEntityList"] = ecuEntityList ? boost::any(ecuEntityList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("EcuEntityList") != m.end() && !m["EcuEntityList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EcuEntityList"].type()) {
        QueryMigrateEcuListResponseBodyEcuEntityList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EcuEntityList"]));
        ecuEntityList = make_shared<QueryMigrateEcuListResponseBodyEcuEntityList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~QueryMigrateEcuListResponseBody() = default;
};
class QueryMigrateEcuListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryMigrateEcuListResponseBody> body{};

  QueryMigrateEcuListResponse() {}

  explicit QueryMigrateEcuListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMigrateEcuListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMigrateEcuListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMigrateEcuListResponse() = default;
};
class QueryMigrateRegionListRequest : public Darabonba::Model {
public:
  shared_ptr<string> logicalRegionId{};

  QueryMigrateRegionListRequest() {}

  explicit QueryMigrateRegionListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logicalRegionId) {
      res["LogicalRegionId"] = boost::any(*logicalRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogicalRegionId") != m.end() && !m["LogicalRegionId"].empty()) {
      logicalRegionId = make_shared<string>(boost::any_cast<string>(m["LogicalRegionId"]));
    }
  }


  virtual ~QueryMigrateRegionListRequest() = default;
};
class QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity : public Darabonba::Model {
public:
  shared_ptr<string> regionName{};
  shared_ptr<string> regionNo{};

  QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity() {}

  explicit QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (regionNo) {
      res["RegionNo"] = boost::any(*regionNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("RegionNo") != m.end() && !m["RegionNo"].empty()) {
      regionNo = make_shared<string>(boost::any_cast<string>(m["RegionNo"]));
    }
  }


  virtual ~QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity() = default;
};
class QueryMigrateRegionListResponseBodyRegionEntityList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity>> regionEntity{};

  QueryMigrateRegionListResponseBodyRegionEntityList() {}

  explicit QueryMigrateRegionListResponseBodyRegionEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionEntity) {
      vector<boost::any> temp1;
      for(auto item1:*regionEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegionEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionEntity") != m.end() && !m["RegionEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["RegionEntity"].type()) {
        vector<QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegionEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regionEntity = make_shared<vector<QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity>>(expect1);
      }
    }
  }


  virtual ~QueryMigrateRegionListResponseBodyRegionEntityList() = default;
};
class QueryMigrateRegionListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};
  shared_ptr<QueryMigrateRegionListResponseBodyRegionEntityList> regionEntityList{};

  QueryMigrateRegionListResponseBody() {}

  explicit QueryMigrateRegionListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (regionEntityList) {
      res["RegionEntityList"] = regionEntityList ? boost::any(regionEntityList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RegionEntityList") != m.end() && !m["RegionEntityList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegionEntityList"].type()) {
        QueryMigrateRegionListResponseBodyRegionEntityList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegionEntityList"]));
        regionEntityList = make_shared<QueryMigrateRegionListResponseBodyRegionEntityList>(model1);
      }
    }
  }


  virtual ~QueryMigrateRegionListResponseBody() = default;
};
class QueryMigrateRegionListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryMigrateRegionListResponseBody> body{};

  QueryMigrateRegionListResponse() {}

  explicit QueryMigrateRegionListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMigrateRegionListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMigrateRegionListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMigrateRegionListResponse() = default;
};
class QueryMonitorInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> start{};
  shared_ptr<long> end{};
  shared_ptr<string> metric{};
  shared_ptr<string> tags{};
  shared_ptr<string> aggregator{};
  shared_ptr<string> interval{};

  QueryMonitorInfoRequest() {}

  explicit QueryMonitorInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (aggregator) {
      res["Aggregator"] = boost::any(*aggregator);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Aggregator") != m.end() && !m["Aggregator"].empty()) {
      aggregator = make_shared<string>(boost::any_cast<string>(m["Aggregator"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
  }


  virtual ~QueryMonitorInfoRequest() = default;
};
class QueryMonitorInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> monitorInfo{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  QueryMonitorInfoResponseBody() {}

  explicit QueryMonitorInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorInfo) {
      res["MonitorInfo"] = boost::any(*monitorInfo);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorInfo") != m.end() && !m["MonitorInfo"].empty()) {
      monitorInfo = make_shared<string>(boost::any_cast<string>(m["MonitorInfo"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~QueryMonitorInfoResponseBody() = default;
};
class QueryMonitorInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryMonitorInfoResponseBody> body{};

  QueryMonitorInfoResponse() {}

  explicit QueryMonitorInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMonitorInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMonitorInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMonitorInfoResponse() = default;
};
class QueryRegionConfigResponseBodyRegionConfigFileServerConfig : public Darabonba::Model {
public:
  shared_ptr<string> internalUrl{};
  shared_ptr<string> publicUrl{};
  shared_ptr<string> vpcUrl{};
  shared_ptr<string> bucket{};

  QueryRegionConfigResponseBodyRegionConfigFileServerConfig() {}

  explicit QueryRegionConfigResponseBodyRegionConfigFileServerConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (internalUrl) {
      res["InternalUrl"] = boost::any(*internalUrl);
    }
    if (publicUrl) {
      res["PublicUrl"] = boost::any(*publicUrl);
    }
    if (vpcUrl) {
      res["VpcUrl"] = boost::any(*vpcUrl);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InternalUrl") != m.end() && !m["InternalUrl"].empty()) {
      internalUrl = make_shared<string>(boost::any_cast<string>(m["InternalUrl"]));
    }
    if (m.find("PublicUrl") != m.end() && !m["PublicUrl"].empty()) {
      publicUrl = make_shared<string>(boost::any_cast<string>(m["PublicUrl"]));
    }
    if (m.find("VpcUrl") != m.end() && !m["VpcUrl"].empty()) {
      vpcUrl = make_shared<string>(boost::any_cast<string>(m["VpcUrl"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryRegionConfigResponseBodyRegionConfigFileServerConfig() = default;
};
class QueryRegionConfigResponseBodyRegionConfig : public Darabonba::Model {
public:
  shared_ptr<long> no{};
  shared_ptr<QueryRegionConfigResponseBodyRegionConfigFileServerConfig> fileServerConfig{};
  shared_ptr<string> addressServerHost{};
  shared_ptr<string> tag{};
  shared_ptr<string> agentInstallScript{};
  shared_ptr<string> fileServerType{};
  shared_ptr<string> name{};
  shared_ptr<string> imageId{};
  shared_ptr<string> id{};

  QueryRegionConfigResponseBodyRegionConfig() {}

  explicit QueryRegionConfigResponseBodyRegionConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (no) {
      res["No"] = boost::any(*no);
    }
    if (fileServerConfig) {
      res["FileServerConfig"] = fileServerConfig ? boost::any(fileServerConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (addressServerHost) {
      res["AddressServerHost"] = boost::any(*addressServerHost);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (agentInstallScript) {
      res["AgentInstallScript"] = boost::any(*agentInstallScript);
    }
    if (fileServerType) {
      res["FileServerType"] = boost::any(*fileServerType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("No") != m.end() && !m["No"].empty()) {
      no = make_shared<long>(boost::any_cast<long>(m["No"]));
    }
    if (m.find("FileServerConfig") != m.end() && !m["FileServerConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileServerConfig"].type()) {
        QueryRegionConfigResponseBodyRegionConfigFileServerConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileServerConfig"]));
        fileServerConfig = make_shared<QueryRegionConfigResponseBodyRegionConfigFileServerConfig>(model1);
      }
    }
    if (m.find("AddressServerHost") != m.end() && !m["AddressServerHost"].empty()) {
      addressServerHost = make_shared<string>(boost::any_cast<string>(m["AddressServerHost"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("AgentInstallScript") != m.end() && !m["AgentInstallScript"].empty()) {
      agentInstallScript = make_shared<string>(boost::any_cast<string>(m["AgentInstallScript"]));
    }
    if (m.find("FileServerType") != m.end() && !m["FileServerType"].empty()) {
      fileServerType = make_shared<string>(boost::any_cast<string>(m["FileServerType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryRegionConfigResponseBodyRegionConfig() = default;
};
class QueryRegionConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryRegionConfigResponseBodyRegionConfig> regionConfig{};
  shared_ptr<long> code{};

  QueryRegionConfigResponseBody() {}

  explicit QueryRegionConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (regionConfig) {
      res["RegionConfig"] = regionConfig ? boost::any(regionConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RegionConfig") != m.end() && !m["RegionConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegionConfig"].type()) {
        QueryRegionConfigResponseBodyRegionConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegionConfig"]));
        regionConfig = make_shared<QueryRegionConfigResponseBodyRegionConfig>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~QueryRegionConfigResponseBody() = default;
};
class QueryRegionConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryRegionConfigResponseBody> body{};

  QueryRegionConfigResponse() {}

  explicit QueryRegionConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryRegionConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryRegionConfigResponseBody>(model1);
      }
    }
  }


  virtual ~QueryRegionConfigResponse() = default;
};
class QueryServiceTimeConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> region{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> appId{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceVersion{};
  shared_ptr<string> serviceGroup{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> source{};

  QueryServiceTimeConfigRequest() {}

  explicit QueryServiceTimeConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (serviceVersion) {
      res["ServiceVersion"] = boost::any(*serviceVersion);
    }
    if (serviceGroup) {
      res["ServiceGroup"] = boost::any(*serviceGroup);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServiceVersion") != m.end() && !m["ServiceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["ServiceVersion"]));
    }
    if (m.find("ServiceGroup") != m.end() && !m["ServiceGroup"].empty()) {
      serviceGroup = make_shared<string>(boost::any_cast<string>(m["ServiceGroup"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~QueryServiceTimeConfigRequest() = default;
};
class QueryServiceTimeConfigResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<string> timeout{};
  shared_ptr<string> consumerAppName{};
  shared_ptr<string> path{};
  shared_ptr<string> consumerAppId{};
  shared_ptr<long> id{};

  QueryServiceTimeConfigResponseBodyDataResult() {}

  explicit QueryServiceTimeConfigResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (consumerAppName) {
      res["ConsumerAppName"] = boost::any(*consumerAppName);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (consumerAppId) {
      res["ConsumerAppId"] = boost::any(*consumerAppId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<string>(boost::any_cast<string>(m["Timeout"]));
    }
    if (m.find("ConsumerAppName") != m.end() && !m["ConsumerAppName"].empty()) {
      consumerAppName = make_shared<string>(boost::any_cast<string>(m["ConsumerAppName"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ConsumerAppId") != m.end() && !m["ConsumerAppId"].empty()) {
      consumerAppId = make_shared<string>(boost::any_cast<string>(m["ConsumerAppId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~QueryServiceTimeConfigResponseBodyDataResult() = default;
};
class QueryServiceTimeConfigResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<QueryServiceTimeConfigResponseBodyDataResult>> result{};
  shared_ptr<long> totalSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  QueryServiceTimeConfigResponseBodyData() {}

  explicit QueryServiceTimeConfigResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<QueryServiceTimeConfigResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryServiceTimeConfigResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<QueryServiceTimeConfigResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryServiceTimeConfigResponseBodyData() = default;
};
class QueryServiceTimeConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<QueryServiceTimeConfigResponseBodyData> data{};
  shared_ptr<long> code{};
  shared_ptr<bool> success{};

  QueryServiceTimeConfigResponseBody() {}

  explicit QueryServiceTimeConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryServiceTimeConfigResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryServiceTimeConfigResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryServiceTimeConfigResponseBody() = default;
};
class QueryServiceTimeConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryServiceTimeConfigResponseBody> body{};

  QueryServiceTimeConfigResponse() {}

  explicit QueryServiceTimeConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryServiceTimeConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryServiceTimeConfigResponseBody>(model1);
      }
    }
  }


  virtual ~QueryServiceTimeConfigResponse() = default;
};
class QuerySlsLogStoreListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> type{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};

  QuerySlsLogStoreListRequest() {}

  explicit QuerySlsLogStoreListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~QuerySlsLogStoreListRequest() = default;
};
class QuerySlsLogStoreListResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> link{};
  shared_ptr<string> createTime{};
  shared_ptr<string> logstore{};
  shared_ptr<string> consumerSide{};
  shared_ptr<string> project{};
  shared_ptr<string> source{};

  QuerySlsLogStoreListResponseBodyResult() {}

  explicit QuerySlsLogStoreListResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (link) {
      res["Link"] = boost::any(*link);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (consumerSide) {
      res["ConsumerSide"] = boost::any(*consumerSide);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Link") != m.end() && !m["Link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["Link"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("ConsumerSide") != m.end() && !m["ConsumerSide"].empty()) {
      consumerSide = make_shared<string>(boost::any_cast<string>(m["ConsumerSide"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~QuerySlsLogStoreListResponseBodyResult() = default;
};
class QuerySlsLogStoreListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalSize{};
  shared_ptr<long> code{};
  shared_ptr<vector<QuerySlsLogStoreListResponseBodyResult>> result{};

  QuerySlsLogStoreListResponseBody() {}

  explicit QuerySlsLogStoreListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<QuerySlsLogStoreListResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySlsLogStoreListResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<QuerySlsLogStoreListResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~QuerySlsLogStoreListResponseBody() = default;
};
class QuerySlsLogStoreListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QuerySlsLogStoreListResponseBody> body{};

  QuerySlsLogStoreListResponse() {}

  explicit QuerySlsLogStoreListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySlsLogStoreListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySlsLogStoreListResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySlsLogStoreListResponse() = default;
};
class RemoveMockRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  RemoveMockRuleRequest() {}

  explicit RemoveMockRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~RemoveMockRuleRequest() = default;
};
class RemoveMockRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<string> scMockItemJson{};
  shared_ptr<string> consumerAppName{};
  shared_ptr<string> consumerAppId{};
  shared_ptr<string> accountId{};
  shared_ptr<string> extraJson{};
  shared_ptr<string> source{};
  shared_ptr<string> region{};
  shared_ptr<string> providerAppId{};
  shared_ptr<string> providerAppName{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};
  shared_ptr<bool> enable{};

  RemoveMockRuleResponseBodyData() {}

  explicit RemoveMockRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (scMockItemJson) {
      res["ScMockItemJson"] = boost::any(*scMockItemJson);
    }
    if (consumerAppName) {
      res["ConsumerAppName"] = boost::any(*consumerAppName);
    }
    if (consumerAppId) {
      res["ConsumerAppId"] = boost::any(*consumerAppId);
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (extraJson) {
      res["ExtraJson"] = boost::any(*extraJson);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (providerAppId) {
      res["ProviderAppId"] = boost::any(*providerAppId);
    }
    if (providerAppName) {
      res["ProviderAppName"] = boost::any(*providerAppName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("ScMockItemJson") != m.end() && !m["ScMockItemJson"].empty()) {
      scMockItemJson = make_shared<string>(boost::any_cast<string>(m["ScMockItemJson"]));
    }
    if (m.find("ConsumerAppName") != m.end() && !m["ConsumerAppName"].empty()) {
      consumerAppName = make_shared<string>(boost::any_cast<string>(m["ConsumerAppName"]));
    }
    if (m.find("ConsumerAppId") != m.end() && !m["ConsumerAppId"].empty()) {
      consumerAppId = make_shared<string>(boost::any_cast<string>(m["ConsumerAppId"]));
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ExtraJson") != m.end() && !m["ExtraJson"].empty()) {
      extraJson = make_shared<string>(boost::any_cast<string>(m["ExtraJson"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ProviderAppId") != m.end() && !m["ProviderAppId"].empty()) {
      providerAppId = make_shared<string>(boost::any_cast<string>(m["ProviderAppId"]));
    }
    if (m.find("ProviderAppName") != m.end() && !m["ProviderAppName"].empty()) {
      providerAppName = make_shared<string>(boost::any_cast<string>(m["ProviderAppName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
  }


  virtual ~RemoveMockRuleResponseBodyData() = default;
};
class RemoveMockRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<RemoveMockRuleResponseBodyData> data{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  RemoveMockRuleResponseBody() {}

  explicit RemoveMockRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        RemoveMockRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<RemoveMockRuleResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RemoveMockRuleResponseBody() = default;
};
class RemoveMockRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RemoveMockRuleResponseBody> body{};

  RemoveMockRuleResponse() {}

  explicit RemoveMockRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveMockRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveMockRuleResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveMockRuleResponse() = default;
};
class ResetApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> eccInfo{};

  ResetApplicationRequest() {}

  explicit ResetApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (eccInfo) {
      res["EccInfo"] = boost::any(*eccInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EccInfo") != m.end() && !m["EccInfo"].empty()) {
      eccInfo = make_shared<string>(boost::any_cast<string>(m["EccInfo"]));
    }
  }


  virtual ~ResetApplicationRequest() = default;
};
class ResetApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  ResetApplicationResponseBody() {}

  explicit ResetApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ResetApplicationResponseBody() = default;
};
class ResetApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ResetApplicationResponseBody> body{};

  ResetApplicationResponse() {}

  explicit ResetApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~ResetApplicationResponse() = default;
};
class RestartApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> eccInfo{};

  RestartApplicationRequest() {}

  explicit RestartApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (eccInfo) {
      res["EccInfo"] = boost::any(*eccInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EccInfo") != m.end() && !m["EccInfo"].empty()) {
      eccInfo = make_shared<string>(boost::any_cast<string>(m["EccInfo"]));
    }
  }


  virtual ~RestartApplicationRequest() = default;
};
class RestartApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  RestartApplicationResponseBody() {}

  explicit RestartApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~RestartApplicationResponseBody() = default;
};
class RestartApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RestartApplicationResponseBody> body{};

  RestartApplicationResponse() {}

  explicit RestartApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestartApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestartApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~RestartApplicationResponse() = default;
};
class RestartK8sApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> timeout{};

  RestartK8sApplicationRequest() {}

  explicit RestartK8sApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~RestartK8sApplicationRequest() = default;
};
class RestartK8sApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  RestartK8sApplicationResponseBody() {}

  explicit RestartK8sApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~RestartK8sApplicationResponseBody() = default;
};
class RestartK8sApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RestartK8sApplicationResponseBody> body{};

  RestartK8sApplicationResponse() {}

  explicit RestartK8sApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestartK8sApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestartK8sApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~RestartK8sApplicationResponse() = default;
};
class RollbackApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> historyVersion{};
  shared_ptr<string> groupId{};
  shared_ptr<long> batch{};
  shared_ptr<long> batchWaitTime{};

  RollbackApplicationRequest() {}

  explicit RollbackApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (historyVersion) {
      res["HistoryVersion"] = boost::any(*historyVersion);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (batch) {
      res["Batch"] = boost::any(*batch);
    }
    if (batchWaitTime) {
      res["BatchWaitTime"] = boost::any(*batchWaitTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("HistoryVersion") != m.end() && !m["HistoryVersion"].empty()) {
      historyVersion = make_shared<string>(boost::any_cast<string>(m["HistoryVersion"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Batch") != m.end() && !m["Batch"].empty()) {
      batch = make_shared<long>(boost::any_cast<long>(m["Batch"]));
    }
    if (m.find("BatchWaitTime") != m.end() && !m["BatchWaitTime"].empty()) {
      batchWaitTime = make_shared<long>(boost::any_cast<long>(m["BatchWaitTime"]));
    }
  }


  virtual ~RollbackApplicationRequest() = default;
};
class RollbackApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  RollbackApplicationResponseBody() {}

  explicit RollbackApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~RollbackApplicationResponseBody() = default;
};
class RollbackApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RollbackApplicationResponseBody> body{};

  RollbackApplicationResponse() {}

  explicit RollbackApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RollbackApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RollbackApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~RollbackApplicationResponse() = default;
};
class RollbackChangeOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  RollbackChangeOrderRequest() {}

  explicit RollbackChangeOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~RollbackChangeOrderRequest() = default;
};
class RollbackChangeOrderResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  RollbackChangeOrderResponseBodyData() {}

  explicit RollbackChangeOrderResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~RollbackChangeOrderResponseBodyData() = default;
};
class RollbackChangeOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> traceId{};
  shared_ptr<RollbackChangeOrderResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> code{};

  RollbackChangeOrderResponseBody() {}

  explicit RollbackChangeOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        RollbackChangeOrderResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<RollbackChangeOrderResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~RollbackChangeOrderResponseBody() = default;
};
class RollbackChangeOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RollbackChangeOrderResponseBody> body{};

  RollbackChangeOrderResponse() {}

  explicit RollbackChangeOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RollbackChangeOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RollbackChangeOrderResponseBody>(model1);
      }
    }
  }


  virtual ~RollbackChangeOrderResponse() = default;
};
class ScaleInApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> eccInfo{};
  shared_ptr<bool> forceStatus{};

  ScaleInApplicationRequest() {}

  explicit ScaleInApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (eccInfo) {
      res["EccInfo"] = boost::any(*eccInfo);
    }
    if (forceStatus) {
      res["ForceStatus"] = boost::any(*forceStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EccInfo") != m.end() && !m["EccInfo"].empty()) {
      eccInfo = make_shared<string>(boost::any_cast<string>(m["EccInfo"]));
    }
    if (m.find("ForceStatus") != m.end() && !m["ForceStatus"].empty()) {
      forceStatus = make_shared<bool>(boost::any_cast<bool>(m["ForceStatus"]));
    }
  }


  virtual ~ScaleInApplicationRequest() = default;
};
class ScaleInApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  ScaleInApplicationResponseBody() {}

  explicit ScaleInApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ScaleInApplicationResponseBody() = default;
};
class ScaleInApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ScaleInApplicationResponseBody> body{};

  ScaleInApplicationResponse() {}

  explicit ScaleInApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ScaleInApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ScaleInApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~ScaleInApplicationResponse() = default;
};
class ScaleK8sApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> replicas{};
  shared_ptr<long> timeout{};

  ScaleK8sApplicationRequest() {}

  explicit ScaleK8sApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (replicas) {
      res["Replicas"] = boost::any(*replicas);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Replicas") != m.end() && !m["Replicas"].empty()) {
      replicas = make_shared<long>(boost::any_cast<long>(m["Replicas"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~ScaleK8sApplicationRequest() = default;
};
class ScaleK8sApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  ScaleK8sApplicationResponseBody() {}

  explicit ScaleK8sApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ScaleK8sApplicationResponseBody() = default;
};
class ScaleK8sApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ScaleK8sApplicationResponseBody> body{};

  ScaleK8sApplicationResponse() {}

  explicit ScaleK8sApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ScaleK8sApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ScaleK8sApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~ScaleK8sApplicationResponse() = default;
};
class ScaleOutApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> ecuInfo{};
  shared_ptr<string> deployGroup{};

  ScaleOutApplicationRequest() {}

  explicit ScaleOutApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (ecuInfo) {
      res["EcuInfo"] = boost::any(*ecuInfo);
    }
    if (deployGroup) {
      res["DeployGroup"] = boost::any(*deployGroup);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EcuInfo") != m.end() && !m["EcuInfo"].empty()) {
      ecuInfo = make_shared<string>(boost::any_cast<string>(m["EcuInfo"]));
    }
    if (m.find("DeployGroup") != m.end() && !m["DeployGroup"].empty()) {
      deployGroup = make_shared<string>(boost::any_cast<string>(m["DeployGroup"]));
    }
  }


  virtual ~ScaleOutApplicationRequest() = default;
};
class ScaleOutApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  ScaleOutApplicationResponseBody() {}

  explicit ScaleOutApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ScaleOutApplicationResponseBody() = default;
};
class ScaleOutApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ScaleOutApplicationResponseBody> body{};

  ScaleOutApplicationResponse() {}

  explicit ScaleOutApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ScaleOutApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ScaleOutApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~ScaleOutApplicationResponse() = default;
};
class ScaleoutApplicationWithNewInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};
  shared_ptr<long> scalingNum{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateVersion{};
  shared_ptr<string> scalingPolicy{};
  shared_ptr<string> templateInstanceId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> instanceChargePeriodUnit{};
  shared_ptr<long> instanceChargePeriod{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewPeriod{};

  ScaleoutApplicationWithNewInstancesRequest() {}

  explicit ScaleoutApplicationWithNewInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (scalingNum) {
      res["ScalingNum"] = boost::any(*scalingNum);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateVersion) {
      res["TemplateVersion"] = boost::any(*templateVersion);
    }
    if (scalingPolicy) {
      res["ScalingPolicy"] = boost::any(*scalingPolicy);
    }
    if (templateInstanceId) {
      res["TemplateInstanceId"] = boost::any(*templateInstanceId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceChargePeriodUnit) {
      res["InstanceChargePeriodUnit"] = boost::any(*instanceChargePeriodUnit);
    }
    if (instanceChargePeriod) {
      res["InstanceChargePeriod"] = boost::any(*instanceChargePeriod);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoRenewPeriod) {
      res["AutoRenewPeriod"] = boost::any(*autoRenewPeriod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ScalingNum") != m.end() && !m["ScalingNum"].empty()) {
      scalingNum = make_shared<long>(boost::any_cast<long>(m["ScalingNum"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateVersion") != m.end() && !m["TemplateVersion"].empty()) {
      templateVersion = make_shared<string>(boost::any_cast<string>(m["TemplateVersion"]));
    }
    if (m.find("ScalingPolicy") != m.end() && !m["ScalingPolicy"].empty()) {
      scalingPolicy = make_shared<string>(boost::any_cast<string>(m["ScalingPolicy"]));
    }
    if (m.find("TemplateInstanceId") != m.end() && !m["TemplateInstanceId"].empty()) {
      templateInstanceId = make_shared<string>(boost::any_cast<string>(m["TemplateInstanceId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceChargePeriodUnit") != m.end() && !m["InstanceChargePeriodUnit"].empty()) {
      instanceChargePeriodUnit = make_shared<string>(boost::any_cast<string>(m["InstanceChargePeriodUnit"]));
    }
    if (m.find("InstanceChargePeriod") != m.end() && !m["InstanceChargePeriod"].empty()) {
      instanceChargePeriod = make_shared<long>(boost::any_cast<long>(m["InstanceChargePeriod"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("AutoRenewPeriod") != m.end() && !m["AutoRenewPeriod"].empty()) {
      autoRenewPeriod = make_shared<long>(boost::any_cast<long>(m["AutoRenewPeriod"]));
    }
  }


  virtual ~ScaleoutApplicationWithNewInstancesRequest() = default;
};
class ScaleoutApplicationWithNewInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<long> code{};

  ScaleoutApplicationWithNewInstancesResponseBody() {}

  explicit ScaleoutApplicationWithNewInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ScaleoutApplicationWithNewInstancesResponseBody() = default;
};
class ScaleoutApplicationWithNewInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ScaleoutApplicationWithNewInstancesResponseBody> body{};

  ScaleoutApplicationWithNewInstancesResponse() {}

  explicit ScaleoutApplicationWithNewInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ScaleoutApplicationWithNewInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ScaleoutApplicationWithNewInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ScaleoutApplicationWithNewInstancesResponse() = default;
};
class StartApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> eccInfo{};

  StartApplicationRequest() {}

  explicit StartApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (eccInfo) {
      res["EccInfo"] = boost::any(*eccInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EccInfo") != m.end() && !m["EccInfo"].empty()) {
      eccInfo = make_shared<string>(boost::any_cast<string>(m["EccInfo"]));
    }
  }


  virtual ~StartApplicationRequest() = default;
};
class StartApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  StartApplicationResponseBody() {}

  explicit StartApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~StartApplicationResponseBody() = default;
};
class StartApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StartApplicationResponseBody> body{};

  StartApplicationResponse() {}

  explicit StartApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~StartApplicationResponse() = default;
};
class StartK8sApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<long> replicas{};
  shared_ptr<long> timeout{};
  shared_ptr<string> appId{};

  StartK8sApplicationRequest() {}

  explicit StartK8sApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (replicas) {
      res["Replicas"] = boost::any(*replicas);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Replicas") != m.end() && !m["Replicas"].empty()) {
      replicas = make_shared<long>(boost::any_cast<long>(m["Replicas"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~StartK8sApplicationRequest() = default;
};
class StartK8sApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  StartK8sApplicationResponseBody() {}

  explicit StartK8sApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~StartK8sApplicationResponseBody() = default;
};
class StartK8sApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StartK8sApplicationResponseBody> body{};

  StartK8sApplicationResponse() {}

  explicit StartK8sApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartK8sApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartK8sApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~StartK8sApplicationResponse() = default;
};
class StopApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> eccInfo{};

  StopApplicationRequest() {}

  explicit StopApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (eccInfo) {
      res["EccInfo"] = boost::any(*eccInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EccInfo") != m.end() && !m["EccInfo"].empty()) {
      eccInfo = make_shared<string>(boost::any_cast<string>(m["EccInfo"]));
    }
  }


  virtual ~StopApplicationRequest() = default;
};
class StopApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  StopApplicationResponseBody() {}

  explicit StopApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~StopApplicationResponseBody() = default;
};
class StopApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StopApplicationResponseBody> body{};

  StopApplicationResponse() {}

  explicit StopApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~StopApplicationResponse() = default;
};
class StopK8sApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> timeout{};

  StopK8sApplicationRequest() {}

  explicit StopK8sApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~StopK8sApplicationRequest() = default;
};
class StopK8sApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  StopK8sApplicationResponseBody() {}

  explicit StopK8sApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~StopK8sApplicationResponseBody() = default;
};
class StopK8sApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StopK8sApplicationResponseBody> body{};

  StopK8sApplicationResponse() {}

  explicit StopK8sApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopK8sApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopK8sApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~StopK8sApplicationResponse() = default;
};
class SwitchAdvancedMonitoringRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> enableAdvancedMonitoring{};

  SwitchAdvancedMonitoringRequest() {}

  explicit SwitchAdvancedMonitoringRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (enableAdvancedMonitoring) {
      res["EnableAdvancedMonitoring"] = boost::any(*enableAdvancedMonitoring);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EnableAdvancedMonitoring") != m.end() && !m["EnableAdvancedMonitoring"].empty()) {
      enableAdvancedMonitoring = make_shared<bool>(boost::any_cast<bool>(m["EnableAdvancedMonitoring"]));
    }
  }


  virtual ~SwitchAdvancedMonitoringRequest() = default;
};
class SwitchAdvancedMonitoringResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> advancedMonitoringEnabled{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  SwitchAdvancedMonitoringResponseBody() {}

  explicit SwitchAdvancedMonitoringResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advancedMonitoringEnabled) {
      res["AdvancedMonitoringEnabled"] = boost::any(*advancedMonitoringEnabled);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdvancedMonitoringEnabled") != m.end() && !m["AdvancedMonitoringEnabled"].empty()) {
      advancedMonitoringEnabled = make_shared<bool>(boost::any_cast<bool>(m["AdvancedMonitoringEnabled"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~SwitchAdvancedMonitoringResponseBody() = default;
};
class SwitchAdvancedMonitoringResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SwitchAdvancedMonitoringResponseBody> body{};

  SwitchAdvancedMonitoringResponse() {}

  explicit SwitchAdvancedMonitoringResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SwitchAdvancedMonitoringResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SwitchAdvancedMonitoringResponseBody>(model1);
      }
    }
  }


  virtual ~SwitchAdvancedMonitoringResponse() = default;
};
class SynchronizeResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> resourceIds{};

  SynchronizeResourceRequest() {}

  explicit SynchronizeResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      resourceIds = make_shared<string>(boost::any_cast<string>(m["ResourceIds"]));
    }
  }


  virtual ~SynchronizeResourceRequest() = default;
};
class SynchronizeResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> data{};
  shared_ptr<long> code{};
  shared_ptr<bool> success{};

  SynchronizeResourceResponseBody() {}

  explicit SynchronizeResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SynchronizeResourceResponseBody() = default;
};
class SynchronizeResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SynchronizeResourceResponseBody> body{};

  SynchronizeResourceResponse() {}

  explicit SynchronizeResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SynchronizeResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SynchronizeResourceResponseBody>(model1);
      }
    }
  }


  virtual ~SynchronizeResourceResponse() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceIds{};
  shared_ptr<string> tags{};
  shared_ptr<string> resourceRegionId{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (resourceRegionId) {
      res["ResourceRegionId"] = boost::any(*resourceRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      resourceIds = make_shared<string>(boost::any_cast<string>(m["ResourceIds"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("ResourceRegionId") != m.end() && !m["ResourceRegionId"].empty()) {
      resourceRegionId = make_shared<string>(boost::any_cast<string>(m["ResourceRegionId"]));
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class TransformClusterMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceIds{};
  shared_ptr<string> targetClusterId{};
  shared_ptr<string> password{};

  TransformClusterMemberRequest() {}

  explicit TransformClusterMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (targetClusterId) {
      res["TargetClusterId"] = boost::any(*targetClusterId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("TargetClusterId") != m.end() && !m["TargetClusterId"].empty()) {
      targetClusterId = make_shared<string>(boost::any_cast<string>(m["TargetClusterId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
  }


  virtual ~TransformClusterMemberRequest() = default;
};
class TransformClusterMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> data{};
  shared_ptr<long> code{};

  TransformClusterMemberResponseBody() {}

  explicit TransformClusterMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~TransformClusterMemberResponseBody() = default;
};
class TransformClusterMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<TransformClusterMemberResponseBody> body{};

  TransformClusterMemberResponse() {}

  explicit TransformClusterMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TransformClusterMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TransformClusterMemberResponseBody>(model1);
      }
    }
  }


  virtual ~TransformClusterMemberResponse() = default;
};
class UnbindK8sSlbRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> type{};
  shared_ptr<string> slbName{};

  UnbindK8sSlbRequest() {}

  explicit UnbindK8sSlbRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (slbName) {
      res["SlbName"] = boost::any(*slbName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("SlbName") != m.end() && !m["SlbName"].empty()) {
      slbName = make_shared<string>(boost::any_cast<string>(m["SlbName"]));
    }
  }


  virtual ~UnbindK8sSlbRequest() = default;
};
class UnbindK8sSlbResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  UnbindK8sSlbResponseBody() {}

  explicit UnbindK8sSlbResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~UnbindK8sSlbResponseBody() = default;
};
class UnbindK8sSlbResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UnbindK8sSlbResponseBody> body{};

  UnbindK8sSlbResponse() {}

  explicit UnbindK8sSlbResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindK8sSlbResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindK8sSlbResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindK8sSlbResponse() = default;
};
class UnbindSlbRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> slbId{};
  shared_ptr<string> type{};

  UnbindSlbRequest() {}

  explicit UnbindSlbRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UnbindSlbRequest() = default;
};
class UnbindSlbResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> data{};
  shared_ptr<long> code{};

  UnbindSlbResponseBody() {}

  explicit UnbindSlbResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~UnbindSlbResponseBody() = default;
};
class UnbindSlbResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UnbindSlbResponseBody> body{};

  UnbindSlbResponse() {}

  explicit UnbindSlbResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindSlbResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindSlbResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindSlbResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceRegionId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceIds{};
  shared_ptr<string> tagKeys{};
  shared_ptr<bool> deleteAll{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceRegionId) {
      res["ResourceRegionId"] = boost::any(*resourceRegionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (tagKeys) {
      res["TagKeys"] = boost::any(*tagKeys);
    }
    if (deleteAll) {
      res["DeleteAll"] = boost::any(*deleteAll);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceRegionId") != m.end() && !m["ResourceRegionId"].empty()) {
      resourceRegionId = make_shared<string>(boost::any_cast<string>(m["ResourceRegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      resourceIds = make_shared<string>(boost::any_cast<string>(m["ResourceIds"]));
    }
    if (m.find("TagKeys") != m.end() && !m["TagKeys"].empty()) {
      tagKeys = make_shared<string>(boost::any_cast<string>(m["TagKeys"]));
    }
    if (m.find("DeleteAll") != m.end() && !m["DeleteAll"].empty()) {
      deleteAll = make_shared<bool>(boost::any_cast<bool>(m["DeleteAll"]));
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class UpdateAccountInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> telephone{};
  shared_ptr<string> email{};

  UpdateAccountInfoRequest() {}

  explicit UpdateAccountInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (telephone) {
      res["Telephone"] = boost::any(*telephone);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Telephone") != m.end() && !m["Telephone"].empty()) {
      telephone = make_shared<string>(boost::any_cast<string>(m["Telephone"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
  }


  virtual ~UpdateAccountInfoRequest() = default;
};
class UpdateAccountInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  UpdateAccountInfoResponseBody() {}

  explicit UpdateAccountInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~UpdateAccountInfoResponseBody() = default;
};
class UpdateAccountInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateAccountInfoResponseBody> body{};

  UpdateAccountInfoResponse() {}

  explicit UpdateAccountInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAccountInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAccountInfoResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAccountInfoResponse() = default;
};
class UpdateApplicationBaseInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> desc{};
  shared_ptr<string> owner{};

  UpdateApplicationBaseInfoRequest() {}

  explicit UpdateApplicationBaseInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
  }


  virtual ~UpdateApplicationBaseInfoRequest() = default;
};
class UpdateApplicationBaseInfoResponseBodyApplcation : public Darabonba::Model {
public:
  shared_ptr<string> extSlbIp{};
  shared_ptr<string> owner{};
  shared_ptr<long> slbPort{};
  shared_ptr<string> extSlbName{};
  shared_ptr<long> createTime{};
  shared_ptr<string> userId{};
  shared_ptr<long> port{};
  shared_ptr<long> runningInstanceCount{};
  shared_ptr<string> slbIp{};
  shared_ptr<bool> dockerize{};
  shared_ptr<string> description{};
  shared_ptr<long> instanceCount{};
  shared_ptr<string> appId{};
  shared_ptr<long> memory{};
  shared_ptr<string> name{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> healthCheckUrl{};
  shared_ptr<string> slbId{};
  shared_ptr<string> applicationType{};
  shared_ptr<string> extSlbId{};
  shared_ptr<long> buildPackageId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> cpu{};
  shared_ptr<long> clusterType{};
  shared_ptr<string> slbName{};

  UpdateApplicationBaseInfoResponseBodyApplcation() {}

  explicit UpdateApplicationBaseInfoResponseBodyApplcation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSlbIp) {
      res["ExtSlbIp"] = boost::any(*extSlbIp);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (slbPort) {
      res["SlbPort"] = boost::any(*slbPort);
    }
    if (extSlbName) {
      res["ExtSlbName"] = boost::any(*extSlbName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (runningInstanceCount) {
      res["RunningInstanceCount"] = boost::any(*runningInstanceCount);
    }
    if (slbIp) {
      res["SlbIp"] = boost::any(*slbIp);
    }
    if (dockerize) {
      res["Dockerize"] = boost::any(*dockerize);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (healthCheckUrl) {
      res["HealthCheckUrl"] = boost::any(*healthCheckUrl);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (applicationType) {
      res["ApplicationType"] = boost::any(*applicationType);
    }
    if (extSlbId) {
      res["ExtSlbId"] = boost::any(*extSlbId);
    }
    if (buildPackageId) {
      res["BuildPackageId"] = boost::any(*buildPackageId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (slbName) {
      res["SlbName"] = boost::any(*slbName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSlbIp") != m.end() && !m["ExtSlbIp"].empty()) {
      extSlbIp = make_shared<string>(boost::any_cast<string>(m["ExtSlbIp"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("SlbPort") != m.end() && !m["SlbPort"].empty()) {
      slbPort = make_shared<long>(boost::any_cast<long>(m["SlbPort"]));
    }
    if (m.find("ExtSlbName") != m.end() && !m["ExtSlbName"].empty()) {
      extSlbName = make_shared<string>(boost::any_cast<string>(m["ExtSlbName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("RunningInstanceCount") != m.end() && !m["RunningInstanceCount"].empty()) {
      runningInstanceCount = make_shared<long>(boost::any_cast<long>(m["RunningInstanceCount"]));
    }
    if (m.find("SlbIp") != m.end() && !m["SlbIp"].empty()) {
      slbIp = make_shared<string>(boost::any_cast<string>(m["SlbIp"]));
    }
    if (m.find("Dockerize") != m.end() && !m["Dockerize"].empty()) {
      dockerize = make_shared<bool>(boost::any_cast<bool>(m["Dockerize"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("HealthCheckUrl") != m.end() && !m["HealthCheckUrl"].empty()) {
      healthCheckUrl = make_shared<string>(boost::any_cast<string>(m["HealthCheckUrl"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("ApplicationType") != m.end() && !m["ApplicationType"].empty()) {
      applicationType = make_shared<string>(boost::any_cast<string>(m["ApplicationType"]));
    }
    if (m.find("ExtSlbId") != m.end() && !m["ExtSlbId"].empty()) {
      extSlbId = make_shared<string>(boost::any_cast<string>(m["ExtSlbId"]));
    }
    if (m.find("BuildPackageId") != m.end() && !m["BuildPackageId"].empty()) {
      buildPackageId = make_shared<long>(boost::any_cast<long>(m["BuildPackageId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<long>(boost::any_cast<long>(m["ClusterType"]));
    }
    if (m.find("SlbName") != m.end() && !m["SlbName"].empty()) {
      slbName = make_shared<string>(boost::any_cast<string>(m["SlbName"]));
    }
  }


  virtual ~UpdateApplicationBaseInfoResponseBodyApplcation() = default;
};
class UpdateApplicationBaseInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<UpdateApplicationBaseInfoResponseBodyApplcation> applcation{};
  shared_ptr<long> code{};

  UpdateApplicationBaseInfoResponseBody() {}

  explicit UpdateApplicationBaseInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (applcation) {
      res["Applcation"] = applcation ? boost::any(applcation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Applcation") != m.end() && !m["Applcation"].empty()) {
      if (typeid(map<string, boost::any>) == m["Applcation"].type()) {
        UpdateApplicationBaseInfoResponseBodyApplcation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Applcation"]));
        applcation = make_shared<UpdateApplicationBaseInfoResponseBodyApplcation>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~UpdateApplicationBaseInfoResponseBody() = default;
};
class UpdateApplicationBaseInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateApplicationBaseInfoResponseBody> body{};

  UpdateApplicationBaseInfoResponse() {}

  explicit UpdateApplicationBaseInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateApplicationBaseInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateApplicationBaseInfoResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateApplicationBaseInfoResponse() = default;
};
class UpdateContainerRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> buildPackId{};

  UpdateContainerRequest() {}

  explicit UpdateContainerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (buildPackId) {
      res["BuildPackId"] = boost::any(*buildPackId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BuildPackId") != m.end() && !m["BuildPackId"].empty()) {
      buildPackId = make_shared<long>(boost::any_cast<long>(m["BuildPackId"]));
    }
  }


  virtual ~UpdateContainerRequest() = default;
};
class UpdateContainerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  UpdateContainerResponseBody() {}

  explicit UpdateContainerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~UpdateContainerResponseBody() = default;
};
class UpdateContainerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateContainerResponseBody> body{};

  UpdateContainerResponse() {}

  explicit UpdateContainerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateContainerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateContainerResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateContainerResponse() = default;
};
class UpdateContainerConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> contextPath{};
  shared_ptr<long> httpPort{};
  shared_ptr<long> maxThreads{};
  shared_ptr<string> URIEncoding{};
  shared_ptr<bool> useBodyEncoding{};

  UpdateContainerConfigurationRequest() {}

  explicit UpdateContainerConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (contextPath) {
      res["ContextPath"] = boost::any(*contextPath);
    }
    if (httpPort) {
      res["HttpPort"] = boost::any(*httpPort);
    }
    if (maxThreads) {
      res["MaxThreads"] = boost::any(*maxThreads);
    }
    if (URIEncoding) {
      res["URIEncoding"] = boost::any(*URIEncoding);
    }
    if (useBodyEncoding) {
      res["UseBodyEncoding"] = boost::any(*useBodyEncoding);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ContextPath") != m.end() && !m["ContextPath"].empty()) {
      contextPath = make_shared<string>(boost::any_cast<string>(m["ContextPath"]));
    }
    if (m.find("HttpPort") != m.end() && !m["HttpPort"].empty()) {
      httpPort = make_shared<long>(boost::any_cast<long>(m["HttpPort"]));
    }
    if (m.find("MaxThreads") != m.end() && !m["MaxThreads"].empty()) {
      maxThreads = make_shared<long>(boost::any_cast<long>(m["MaxThreads"]));
    }
    if (m.find("URIEncoding") != m.end() && !m["URIEncoding"].empty()) {
      URIEncoding = make_shared<string>(boost::any_cast<string>(m["URIEncoding"]));
    }
    if (m.find("UseBodyEncoding") != m.end() && !m["UseBodyEncoding"].empty()) {
      useBodyEncoding = make_shared<bool>(boost::any_cast<bool>(m["UseBodyEncoding"]));
    }
  }


  virtual ~UpdateContainerConfigurationRequest() = default;
};
class UpdateContainerConfigurationResponseBodyContainerConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> contextPath{};
  shared_ptr<string> URIEncoding{};
  shared_ptr<long> httpPort{};
  shared_ptr<bool> useBodyEncoding{};
  shared_ptr<long> maxThreads{};

  UpdateContainerConfigurationResponseBodyContainerConfiguration() {}

  explicit UpdateContainerConfigurationResponseBodyContainerConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contextPath) {
      res["ContextPath"] = boost::any(*contextPath);
    }
    if (URIEncoding) {
      res["URIEncoding"] = boost::any(*URIEncoding);
    }
    if (httpPort) {
      res["HttpPort"] = boost::any(*httpPort);
    }
    if (useBodyEncoding) {
      res["UseBodyEncoding"] = boost::any(*useBodyEncoding);
    }
    if (maxThreads) {
      res["MaxThreads"] = boost::any(*maxThreads);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContextPath") != m.end() && !m["ContextPath"].empty()) {
      contextPath = make_shared<string>(boost::any_cast<string>(m["ContextPath"]));
    }
    if (m.find("URIEncoding") != m.end() && !m["URIEncoding"].empty()) {
      URIEncoding = make_shared<string>(boost::any_cast<string>(m["URIEncoding"]));
    }
    if (m.find("HttpPort") != m.end() && !m["HttpPort"].empty()) {
      httpPort = make_shared<long>(boost::any_cast<long>(m["HttpPort"]));
    }
    if (m.find("UseBodyEncoding") != m.end() && !m["UseBodyEncoding"].empty()) {
      useBodyEncoding = make_shared<bool>(boost::any_cast<bool>(m["UseBodyEncoding"]));
    }
    if (m.find("MaxThreads") != m.end() && !m["MaxThreads"].empty()) {
      maxThreads = make_shared<long>(boost::any_cast<long>(m["MaxThreads"]));
    }
  }


  virtual ~UpdateContainerConfigurationResponseBodyContainerConfiguration() = default;
};
class UpdateContainerConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};
  shared_ptr<UpdateContainerConfigurationResponseBodyContainerConfiguration> containerConfiguration{};

  UpdateContainerConfigurationResponseBody() {}

  explicit UpdateContainerConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (containerConfiguration) {
      res["ContainerConfiguration"] = containerConfiguration ? boost::any(containerConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("ContainerConfiguration") != m.end() && !m["ContainerConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContainerConfiguration"].type()) {
        UpdateContainerConfigurationResponseBodyContainerConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContainerConfiguration"]));
        containerConfiguration = make_shared<UpdateContainerConfigurationResponseBodyContainerConfiguration>(model1);
      }
    }
  }


  virtual ~UpdateContainerConfigurationResponseBody() = default;
};
class UpdateContainerConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateContainerConfigurationResponseBody> body{};

  UpdateContainerConfigurationResponse() {}

  explicit UpdateContainerConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateContainerConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateContainerConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateContainerConfigurationResponse() = default;
};
class UpdateDegradeControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> ruleId{};
  shared_ptr<long> duration{};
  shared_ptr<string> methodName{};
  shared_ptr<long> rtThreshold{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> urlVar{};
  shared_ptr<string> ruleType{};

  UpdateDegradeControlRequest() {}

  explicit UpdateDegradeControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (rtThreshold) {
      res["RtThreshold"] = boost::any(*rtThreshold);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (urlVar) {
      res["UrlVar"] = boost::any(*urlVar);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("RtThreshold") != m.end() && !m["RtThreshold"].empty()) {
      rtThreshold = make_shared<long>(boost::any_cast<long>(m["RtThreshold"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("UrlVar") != m.end() && !m["UrlVar"].empty()) {
      urlVar = make_shared<string>(boost::any_cast<string>(m["UrlVar"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
  }


  virtual ~UpdateDegradeControlRequest() = default;
};
class UpdateDegradeControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  UpdateDegradeControlResponseBody() {}

  explicit UpdateDegradeControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~UpdateDegradeControlResponseBody() = default;
};
class UpdateDegradeControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateDegradeControlResponseBody> body{};

  UpdateDegradeControlResponse() {}

  explicit UpdateDegradeControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDegradeControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDegradeControlResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDegradeControlResponse() = default;
};
class UpdateFlowControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> consumerAppId{};
  shared_ptr<string> granularity{};
  shared_ptr<string> methodName{};
  shared_ptr<string> ruleType{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> strategy{};
  shared_ptr<long> threshold{};
  shared_ptr<string> urlVar{};

  UpdateFlowControlRequest() {}

  explicit UpdateFlowControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (consumerAppId) {
      res["ConsumerAppId"] = boost::any(*consumerAppId);
    }
    if (granularity) {
      res["Granularity"] = boost::any(*granularity);
    }
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (strategy) {
      res["Strategy"] = boost::any(*strategy);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (urlVar) {
      res["UrlVar"] = boost::any(*urlVar);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("ConsumerAppId") != m.end() && !m["ConsumerAppId"].empty()) {
      consumerAppId = make_shared<string>(boost::any_cast<string>(m["ConsumerAppId"]));
    }
    if (m.find("Granularity") != m.end() && !m["Granularity"].empty()) {
      granularity = make_shared<string>(boost::any_cast<string>(m["Granularity"]));
    }
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      strategy = make_shared<string>(boost::any_cast<string>(m["Strategy"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<long>(boost::any_cast<long>(m["Threshold"]));
    }
    if (m.find("UrlVar") != m.end() && !m["UrlVar"].empty()) {
      urlVar = make_shared<string>(boost::any_cast<string>(m["UrlVar"]));
    }
  }


  virtual ~UpdateFlowControlRequest() = default;
};
class UpdateFlowControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  UpdateFlowControlResponseBody() {}

  explicit UpdateFlowControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~UpdateFlowControlResponseBody() = default;
};
class UpdateFlowControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateFlowControlResponseBody> body{};

  UpdateFlowControlResponse() {}

  explicit UpdateFlowControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateFlowControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateFlowControlResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateFlowControlResponse() = default;
};
class UpdateHealthCheckUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> hcURL{};

  UpdateHealthCheckUrlRequest() {}

  explicit UpdateHealthCheckUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (hcURL) {
      res["hcURL"] = boost::any(*hcURL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("hcURL") != m.end() && !m["hcURL"].empty()) {
      hcURL = make_shared<string>(boost::any_cast<string>(m["hcURL"]));
    }
  }


  virtual ~UpdateHealthCheckUrlRequest() = default;
};
class UpdateHealthCheckUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> healthCheckURL{};
  shared_ptr<long> code{};

  UpdateHealthCheckUrlResponseBody() {}

  explicit UpdateHealthCheckUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (healthCheckURL) {
      res["HealthCheckURL"] = boost::any(*healthCheckURL);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HealthCheckURL") != m.end() && !m["HealthCheckURL"].empty()) {
      healthCheckURL = make_shared<string>(boost::any_cast<string>(m["HealthCheckURL"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~UpdateHealthCheckUrlResponseBody() = default;
};
class UpdateHealthCheckUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateHealthCheckUrlResponseBody> body{};

  UpdateHealthCheckUrlResponse() {}

  explicit UpdateHealthCheckUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateHealthCheckUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateHealthCheckUrlResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateHealthCheckUrlResponse() = default;
};
class UpdateHookConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> hooks{};

  UpdateHookConfigurationRequest() {}

  explicit UpdateHookConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (hooks) {
      res["Hooks"] = boost::any(*hooks);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Hooks") != m.end() && !m["Hooks"].empty()) {
      hooks = make_shared<string>(boost::any_cast<string>(m["Hooks"]));
    }
  }


  virtual ~UpdateHookConfigurationRequest() = default;
};
class UpdateHookConfigurationResponseBodyHooksConfiguration : public Darabonba::Model {
public:
  shared_ptr<bool> ignoreFail{};
  shared_ptr<string> name{};
  shared_ptr<string> script{};

  UpdateHookConfigurationResponseBodyHooksConfiguration() {}

  explicit UpdateHookConfigurationResponseBodyHooksConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ignoreFail) {
      res["IgnoreFail"] = boost::any(*ignoreFail);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (script) {
      res["Script"] = boost::any(*script);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IgnoreFail") != m.end() && !m["IgnoreFail"].empty()) {
      ignoreFail = make_shared<bool>(boost::any_cast<bool>(m["IgnoreFail"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
  }


  virtual ~UpdateHookConfigurationResponseBodyHooksConfiguration() = default;
};
class UpdateHookConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateHookConfigurationResponseBodyHooksConfiguration>> hooksConfiguration{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  UpdateHookConfigurationResponseBody() {}

  explicit UpdateHookConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hooksConfiguration) {
      vector<boost::any> temp1;
      for(auto item1:*hooksConfiguration){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HooksConfiguration"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HooksConfiguration") != m.end() && !m["HooksConfiguration"].empty()) {
      if (typeid(vector<boost::any>) == m["HooksConfiguration"].type()) {
        vector<UpdateHookConfigurationResponseBodyHooksConfiguration> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HooksConfiguration"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateHookConfigurationResponseBodyHooksConfiguration model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hooksConfiguration = make_shared<vector<UpdateHookConfigurationResponseBodyHooksConfiguration>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~UpdateHookConfigurationResponseBody() = default;
};
class UpdateHookConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateHookConfigurationResponseBody> body{};

  UpdateHookConfigurationResponse() {}

  explicit UpdateHookConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateHookConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateHookConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateHookConfigurationResponse() = default;
};
class UpdateJvmConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> options{};
  shared_ptr<long> minHeapSize{};
  shared_ptr<long> maxPermSize{};
  shared_ptr<long> maxHeapSize{};

  UpdateJvmConfigurationRequest() {}

  explicit UpdateJvmConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (options) {
      res["Options"] = boost::any(*options);
    }
    if (minHeapSize) {
      res["MinHeapSize"] = boost::any(*minHeapSize);
    }
    if (maxPermSize) {
      res["MaxPermSize"] = boost::any(*maxPermSize);
    }
    if (maxHeapSize) {
      res["MaxHeapSize"] = boost::any(*maxHeapSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Options") != m.end() && !m["Options"].empty()) {
      options = make_shared<string>(boost::any_cast<string>(m["Options"]));
    }
    if (m.find("MinHeapSize") != m.end() && !m["MinHeapSize"].empty()) {
      minHeapSize = make_shared<long>(boost::any_cast<long>(m["MinHeapSize"]));
    }
    if (m.find("MaxPermSize") != m.end() && !m["MaxPermSize"].empty()) {
      maxPermSize = make_shared<long>(boost::any_cast<long>(m["MaxPermSize"]));
    }
    if (m.find("MaxHeapSize") != m.end() && !m["MaxHeapSize"].empty()) {
      maxHeapSize = make_shared<long>(boost::any_cast<long>(m["MaxHeapSize"]));
    }
  }


  virtual ~UpdateJvmConfigurationRequest() = default;
};
class UpdateJvmConfigurationResponseBodyJvmConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> maxPermSize{};
  shared_ptr<string> options{};
  shared_ptr<long> maxHeapSize{};
  shared_ptr<long> minHeapSize{};

  UpdateJvmConfigurationResponseBodyJvmConfiguration() {}

  explicit UpdateJvmConfigurationResponseBodyJvmConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxPermSize) {
      res["MaxPermSize"] = boost::any(*maxPermSize);
    }
    if (options) {
      res["Options"] = boost::any(*options);
    }
    if (maxHeapSize) {
      res["MaxHeapSize"] = boost::any(*maxHeapSize);
    }
    if (minHeapSize) {
      res["MinHeapSize"] = boost::any(*minHeapSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxPermSize") != m.end() && !m["MaxPermSize"].empty()) {
      maxPermSize = make_shared<long>(boost::any_cast<long>(m["MaxPermSize"]));
    }
    if (m.find("Options") != m.end() && !m["Options"].empty()) {
      options = make_shared<string>(boost::any_cast<string>(m["Options"]));
    }
    if (m.find("MaxHeapSize") != m.end() && !m["MaxHeapSize"].empty()) {
      maxHeapSize = make_shared<long>(boost::any_cast<long>(m["MaxHeapSize"]));
    }
    if (m.find("MinHeapSize") != m.end() && !m["MinHeapSize"].empty()) {
      minHeapSize = make_shared<long>(boost::any_cast<long>(m["MinHeapSize"]));
    }
  }


  virtual ~UpdateJvmConfigurationResponseBodyJvmConfiguration() = default;
};
class UpdateJvmConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<UpdateJvmConfigurationResponseBodyJvmConfiguration> jvmConfiguration{};
  shared_ptr<long> code{};

  UpdateJvmConfigurationResponseBody() {}

  explicit UpdateJvmConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jvmConfiguration) {
      res["JvmConfiguration"] = jvmConfiguration ? boost::any(jvmConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JvmConfiguration") != m.end() && !m["JvmConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["JvmConfiguration"].type()) {
        UpdateJvmConfigurationResponseBodyJvmConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JvmConfiguration"]));
        jvmConfiguration = make_shared<UpdateJvmConfigurationResponseBodyJvmConfiguration>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~UpdateJvmConfigurationResponseBody() = default;
};
class UpdateJvmConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateJvmConfigurationResponseBody> body{};

  UpdateJvmConfigurationResponse() {}

  explicit UpdateJvmConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateJvmConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateJvmConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateJvmConfigurationResponse() = default;
};
class UpdateK8sApplicationBaseInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> description{};
  shared_ptr<string> owner{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> email{};

  UpdateK8sApplicationBaseInfoRequest() {}

  explicit UpdateK8sApplicationBaseInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
  }


  virtual ~UpdateK8sApplicationBaseInfoRequest() = default;
};
class UpdateK8sApplicationBaseInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};
  shared_ptr<string> result{};

  UpdateK8sApplicationBaseInfoResponseBody() {}

  explicit UpdateK8sApplicationBaseInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~UpdateK8sApplicationBaseInfoResponseBody() = default;
};
class UpdateK8sApplicationBaseInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateK8sApplicationBaseInfoResponseBody> body{};

  UpdateK8sApplicationBaseInfoResponse() {}

  explicit UpdateK8sApplicationBaseInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateK8sApplicationBaseInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateK8sApplicationBaseInfoResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateK8sApplicationBaseInfoResponse() = default;
};
class UpdateK8sApplicationConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> cpuLimit{};
  shared_ptr<string> memoryLimit{};
  shared_ptr<string> mcpuLimit{};
  shared_ptr<string> cpuRequest{};
  shared_ptr<string> mcpuRequest{};
  shared_ptr<string> memoryRequest{};
  shared_ptr<long> timeout{};

  UpdateK8sApplicationConfigRequest() {}

  explicit UpdateK8sApplicationConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (cpuLimit) {
      res["CpuLimit"] = boost::any(*cpuLimit);
    }
    if (memoryLimit) {
      res["MemoryLimit"] = boost::any(*memoryLimit);
    }
    if (mcpuLimit) {
      res["McpuLimit"] = boost::any(*mcpuLimit);
    }
    if (cpuRequest) {
      res["CpuRequest"] = boost::any(*cpuRequest);
    }
    if (mcpuRequest) {
      res["McpuRequest"] = boost::any(*mcpuRequest);
    }
    if (memoryRequest) {
      res["MemoryRequest"] = boost::any(*memoryRequest);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CpuLimit") != m.end() && !m["CpuLimit"].empty()) {
      cpuLimit = make_shared<string>(boost::any_cast<string>(m["CpuLimit"]));
    }
    if (m.find("MemoryLimit") != m.end() && !m["MemoryLimit"].empty()) {
      memoryLimit = make_shared<string>(boost::any_cast<string>(m["MemoryLimit"]));
    }
    if (m.find("McpuLimit") != m.end() && !m["McpuLimit"].empty()) {
      mcpuLimit = make_shared<string>(boost::any_cast<string>(m["McpuLimit"]));
    }
    if (m.find("CpuRequest") != m.end() && !m["CpuRequest"].empty()) {
      cpuRequest = make_shared<string>(boost::any_cast<string>(m["CpuRequest"]));
    }
    if (m.find("McpuRequest") != m.end() && !m["McpuRequest"].empty()) {
      mcpuRequest = make_shared<string>(boost::any_cast<string>(m["McpuRequest"]));
    }
    if (m.find("MemoryRequest") != m.end() && !m["MemoryRequest"].empty()) {
      memoryRequest = make_shared<string>(boost::any_cast<string>(m["MemoryRequest"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~UpdateK8sApplicationConfigRequest() = default;
};
class UpdateK8sApplicationConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  UpdateK8sApplicationConfigResponseBody() {}

  explicit UpdateK8sApplicationConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~UpdateK8sApplicationConfigResponseBody() = default;
};
class UpdateK8sApplicationConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateK8sApplicationConfigResponseBody> body{};

  UpdateK8sApplicationConfigResponse() {}

  explicit UpdateK8sApplicationConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateK8sApplicationConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateK8sApplicationConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateK8sApplicationConfigResponse() = default;
};
class UpdateK8sIngressRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> name{};
  shared_ptr<string> rules{};

  UpdateK8sIngressRuleRequest() {}

  explicit UpdateK8sIngressRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (rules) {
      res["Rules"] = boost::any(*rules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rules = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
  }


  virtual ~UpdateK8sIngressRuleRequest() = default;
};
class UpdateK8sIngressRuleResponseBodyChangeOrderIds : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<string> appId{};

  UpdateK8sIngressRuleResponseBodyChangeOrderIds() {}

  explicit UpdateK8sIngressRuleResponseBodyChangeOrderIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~UpdateK8sIngressRuleResponseBodyChangeOrderIds() = default;
};
class UpdateK8sIngressRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<vector<UpdateK8sIngressRuleResponseBodyChangeOrderIds>> changeOrderIds{};
  shared_ptr<long> code{};

  UpdateK8sIngressRuleResponseBody() {}

  explicit UpdateK8sIngressRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (changeOrderIds) {
      vector<boost::any> temp1;
      for(auto item1:*changeOrderIds){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChangeOrderIds"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ChangeOrderIds") != m.end() && !m["ChangeOrderIds"].empty()) {
      if (typeid(vector<boost::any>) == m["ChangeOrderIds"].type()) {
        vector<UpdateK8sIngressRuleResponseBodyChangeOrderIds> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChangeOrderIds"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateK8sIngressRuleResponseBodyChangeOrderIds model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        changeOrderIds = make_shared<vector<UpdateK8sIngressRuleResponseBodyChangeOrderIds>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~UpdateK8sIngressRuleResponseBody() = default;
};
class UpdateK8sIngressRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateK8sIngressRuleResponseBody> body{};

  UpdateK8sIngressRuleResponse() {}

  explicit UpdateK8sIngressRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateK8sIngressRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateK8sIngressRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateK8sIngressRuleResponse() = default;
};
class UpdateK8sResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> resourceContent{};

  UpdateK8sResourceRequest() {}

  explicit UpdateK8sResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (resourceContent) {
      res["ResourceContent"] = boost::any(*resourceContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("ResourceContent") != m.end() && !m["ResourceContent"].empty()) {
      resourceContent = make_shared<string>(boost::any_cast<string>(m["ResourceContent"]));
    }
  }


  virtual ~UpdateK8sResourceRequest() = default;
};
class UpdateK8sResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  UpdateK8sResourceResponseBody() {}

  explicit UpdateK8sResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~UpdateK8sResourceResponseBody() = default;
};
class UpdateK8sResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateK8sResourceResponseBody> body{};

  UpdateK8sResourceResponse() {}

  explicit UpdateK8sResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateK8sResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateK8sResourceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateK8sResourceResponse() = default;
};
class UpdateK8sServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> servicePorts{};

  UpdateK8sServiceRequest() {}

  explicit UpdateK8sServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (servicePorts) {
      res["ServicePorts"] = boost::any(*servicePorts);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ServicePorts") != m.end() && !m["ServicePorts"].empty()) {
      servicePorts = make_shared<string>(boost::any_cast<string>(m["ServicePorts"]));
    }
  }


  virtual ~UpdateK8sServiceRequest() = default;
};
class UpdateK8sServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  UpdateK8sServiceResponseBody() {}

  explicit UpdateK8sServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~UpdateK8sServiceResponseBody() = default;
};
class UpdateK8sServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateK8sServiceResponseBody> body{};

  UpdateK8sServiceResponse() {}

  explicit UpdateK8sServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateK8sServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateK8sServiceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateK8sServiceResponse() = default;
};
class UpdateK8sSlbRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> type{};
  shared_ptr<string> slbProtocol{};
  shared_ptr<string> targetPort{};
  shared_ptr<string> port{};
  shared_ptr<string> servicePortInfos{};
  shared_ptr<string> specification{};
  shared_ptr<string> scheduler{};
  shared_ptr<string> slbName{};

  UpdateK8sSlbRequest() {}

  explicit UpdateK8sSlbRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (slbProtocol) {
      res["SlbProtocol"] = boost::any(*slbProtocol);
    }
    if (targetPort) {
      res["TargetPort"] = boost::any(*targetPort);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (servicePortInfos) {
      res["ServicePortInfos"] = boost::any(*servicePortInfos);
    }
    if (specification) {
      res["Specification"] = boost::any(*specification);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (slbName) {
      res["SlbName"] = boost::any(*slbName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("SlbProtocol") != m.end() && !m["SlbProtocol"].empty()) {
      slbProtocol = make_shared<string>(boost::any_cast<string>(m["SlbProtocol"]));
    }
    if (m.find("TargetPort") != m.end() && !m["TargetPort"].empty()) {
      targetPort = make_shared<string>(boost::any_cast<string>(m["TargetPort"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("ServicePortInfos") != m.end() && !m["ServicePortInfos"].empty()) {
      servicePortInfos = make_shared<string>(boost::any_cast<string>(m["ServicePortInfos"]));
    }
    if (m.find("Specification") != m.end() && !m["Specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["Specification"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("SlbName") != m.end() && !m["SlbName"].empty()) {
      slbName = make_shared<string>(boost::any_cast<string>(m["SlbName"]));
    }
  }


  virtual ~UpdateK8sSlbRequest() = default;
};
class UpdateK8sSlbResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> code{};

  UpdateK8sSlbResponseBody() {}

  explicit UpdateK8sSlbResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~UpdateK8sSlbResponseBody() = default;
};
class UpdateK8sSlbResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateK8sSlbResponseBody> body{};

  UpdateK8sSlbResponse() {}

  explicit UpdateK8sSlbResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateK8sSlbResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateK8sSlbResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateK8sSlbResponse() = default;
};
class UpdateMockRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> region{};
  shared_ptr<string> extraJson{};
  shared_ptr<string> scMockItemJson{};
  shared_ptr<string> dubboMockItemJson{};
  shared_ptr<string> id{};

  UpdateMockRuleRequest() {}

  explicit UpdateMockRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (extraJson) {
      res["ExtraJson"] = boost::any(*extraJson);
    }
    if (scMockItemJson) {
      res["ScMockItemJson"] = boost::any(*scMockItemJson);
    }
    if (dubboMockItemJson) {
      res["DubboMockItemJson"] = boost::any(*dubboMockItemJson);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ExtraJson") != m.end() && !m["ExtraJson"].empty()) {
      extraJson = make_shared<string>(boost::any_cast<string>(m["ExtraJson"]));
    }
    if (m.find("ScMockItemJson") != m.end() && !m["ScMockItemJson"].empty()) {
      scMockItemJson = make_shared<string>(boost::any_cast<string>(m["ScMockItemJson"]));
    }
    if (m.find("DubboMockItemJson") != m.end() && !m["DubboMockItemJson"].empty()) {
      dubboMockItemJson = make_shared<string>(boost::any_cast<string>(m["DubboMockItemJson"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~UpdateMockRuleRequest() = default;
};
class UpdateMockRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<string> scMockItemJson{};
  shared_ptr<string> consumerAppName{};
  shared_ptr<string> consumerAppId{};
  shared_ptr<string> accountId{};
  shared_ptr<string> extraJson{};
  shared_ptr<string> source{};
  shared_ptr<string> region{};
  shared_ptr<string> providerAppId{};
  shared_ptr<string> dubboMockItemJson{};
  shared_ptr<string> providerAppName{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};
  shared_ptr<bool> enable{};

  UpdateMockRuleResponseBodyData() {}

  explicit UpdateMockRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (scMockItemJson) {
      res["ScMockItemJson"] = boost::any(*scMockItemJson);
    }
    if (consumerAppName) {
      res["ConsumerAppName"] = boost::any(*consumerAppName);
    }
    if (consumerAppId) {
      res["ConsumerAppId"] = boost::any(*consumerAppId);
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (extraJson) {
      res["ExtraJson"] = boost::any(*extraJson);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (providerAppId) {
      res["ProviderAppId"] = boost::any(*providerAppId);
    }
    if (dubboMockItemJson) {
      res["DubboMockItemJson"] = boost::any(*dubboMockItemJson);
    }
    if (providerAppName) {
      res["ProviderAppName"] = boost::any(*providerAppName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("ScMockItemJson") != m.end() && !m["ScMockItemJson"].empty()) {
      scMockItemJson = make_shared<string>(boost::any_cast<string>(m["ScMockItemJson"]));
    }
    if (m.find("ConsumerAppName") != m.end() && !m["ConsumerAppName"].empty()) {
      consumerAppName = make_shared<string>(boost::any_cast<string>(m["ConsumerAppName"]));
    }
    if (m.find("ConsumerAppId") != m.end() && !m["ConsumerAppId"].empty()) {
      consumerAppId = make_shared<string>(boost::any_cast<string>(m["ConsumerAppId"]));
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ExtraJson") != m.end() && !m["ExtraJson"].empty()) {
      extraJson = make_shared<string>(boost::any_cast<string>(m["ExtraJson"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ProviderAppId") != m.end() && !m["ProviderAppId"].empty()) {
      providerAppId = make_shared<string>(boost::any_cast<string>(m["ProviderAppId"]));
    }
    if (m.find("DubboMockItemJson") != m.end() && !m["DubboMockItemJson"].empty()) {
      dubboMockItemJson = make_shared<string>(boost::any_cast<string>(m["DubboMockItemJson"]));
    }
    if (m.find("ProviderAppName") != m.end() && !m["ProviderAppName"].empty()) {
      providerAppName = make_shared<string>(boost::any_cast<string>(m["ProviderAppName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
  }


  virtual ~UpdateMockRuleResponseBodyData() = default;
};
class UpdateMockRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<UpdateMockRuleResponseBodyData> data{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  UpdateMockRuleResponseBody() {}

  explicit UpdateMockRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateMockRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateMockRuleResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateMockRuleResponseBody() = default;
};
class UpdateMockRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateMockRuleResponseBody> body{};

  UpdateMockRuleResponse() {}

  explicit UpdateMockRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMockRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMockRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMockRuleResponse() = default;
};
class UpdateRoleRequest : public Darabonba::Model {
public:
  shared_ptr<long> roleId{};
  shared_ptr<string> actionData{};

  UpdateRoleRequest() {}

  explicit UpdateRoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (actionData) {
      res["ActionData"] = boost::any(*actionData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<long>(boost::any_cast<long>(m["RoleId"]));
    }
    if (m.find("ActionData") != m.end() && !m["ActionData"].empty()) {
      actionData = make_shared<string>(boost::any_cast<string>(m["ActionData"]));
    }
  }


  virtual ~UpdateRoleRequest() = default;
};
class UpdateRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  UpdateRoleResponseBody() {}

  explicit UpdateRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~UpdateRoleResponseBody() = default;
};
class UpdateRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateRoleResponseBody> body{};

  UpdateRoleResponse() {}

  explicit UpdateRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRoleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRoleResponse() = default;
};
class UpdateSlsLogStoreRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> configs{};

  UpdateSlsLogStoreRequest() {}

  explicit UpdateSlsLogStoreRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (configs) {
      res["Configs"] = boost::any(*configs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      configs = make_shared<string>(boost::any_cast<string>(m["Configs"]));
    }
  }


  virtual ~UpdateSlsLogStoreRequest() = default;
};
class UpdateSlsLogStoreResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> code{};

  UpdateSlsLogStoreResponseBody() {}

  explicit UpdateSlsLogStoreResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~UpdateSlsLogStoreResponseBody() = default;
};
class UpdateSlsLogStoreResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateSlsLogStoreResponseBody> body{};

  UpdateSlsLogStoreResponse() {}

  explicit UpdateSlsLogStoreResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSlsLogStoreResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSlsLogStoreResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSlsLogStoreResponse() = default;
};
class UpdateSwimmingLaneRequest : public Darabonba::Model {
public:
  shared_ptr<long> laneId{};
  shared_ptr<string> name{};
  shared_ptr<bool> enableRules{};
  shared_ptr<string> appInfos{};
  shared_ptr<string> entryRules{};

  UpdateSwimmingLaneRequest() {}

  explicit UpdateSwimmingLaneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (laneId) {
      res["LaneId"] = boost::any(*laneId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (enableRules) {
      res["EnableRules"] = boost::any(*enableRules);
    }
    if (appInfos) {
      res["AppInfos"] = boost::any(*appInfos);
    }
    if (entryRules) {
      res["EntryRules"] = boost::any(*entryRules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LaneId") != m.end() && !m["LaneId"].empty()) {
      laneId = make_shared<long>(boost::any_cast<long>(m["LaneId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("EnableRules") != m.end() && !m["EnableRules"].empty()) {
      enableRules = make_shared<bool>(boost::any_cast<bool>(m["EnableRules"]));
    }
    if (m.find("AppInfos") != m.end() && !m["AppInfos"].empty()) {
      appInfos = make_shared<string>(boost::any_cast<string>(m["AppInfos"]));
    }
    if (m.find("EntryRules") != m.end() && !m["EntryRules"].empty()) {
      entryRules = make_shared<string>(boost::any_cast<string>(m["EntryRules"]));
    }
  }


  virtual ~UpdateSwimmingLaneRequest() = default;
};
class UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> appId{};
  shared_ptr<string> rules{};
  shared_ptr<long> laneId{};

  UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList() {}

  explicit UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (rules) {
      res["Rules"] = boost::any(*rules);
    }
    if (laneId) {
      res["LaneId"] = boost::any(*laneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rules = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
    if (m.find("LaneId") != m.end() && !m["LaneId"].empty()) {
      laneId = make_shared<long>(boost::any_cast<long>(m["LaneId"]));
    }
  }


  virtual ~UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList() = default;
};
class UpdateSwimmingLaneResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<long> groupId{};
  shared_ptr<string> entryRule{};
  shared_ptr<string> tag{};
  shared_ptr<string> name{};
  shared_ptr<vector<UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList>> swimmingLaneAppRelationShipList{};
  shared_ptr<long> id{};

  UpdateSwimmingLaneResponseBodyData() {}

  explicit UpdateSwimmingLaneResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (entryRule) {
      res["EntryRule"] = boost::any(*entryRule);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (swimmingLaneAppRelationShipList) {
      vector<boost::any> temp1;
      for(auto item1:*swimmingLaneAppRelationShipList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SwimmingLaneAppRelationShipList"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("EntryRule") != m.end() && !m["EntryRule"].empty()) {
      entryRule = make_shared<string>(boost::any_cast<string>(m["EntryRule"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SwimmingLaneAppRelationShipList") != m.end() && !m["SwimmingLaneAppRelationShipList"].empty()) {
      if (typeid(vector<boost::any>) == m["SwimmingLaneAppRelationShipList"].type()) {
        vector<UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SwimmingLaneAppRelationShipList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        swimmingLaneAppRelationShipList = make_shared<vector<UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~UpdateSwimmingLaneResponseBodyData() = default;
};
class UpdateSwimmingLaneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<UpdateSwimmingLaneResponseBodyData> data{};
  shared_ptr<long> code{};

  UpdateSwimmingLaneResponseBody() {}

  explicit UpdateSwimmingLaneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateSwimmingLaneResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateSwimmingLaneResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~UpdateSwimmingLaneResponseBody() = default;
};
class UpdateSwimmingLaneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateSwimmingLaneResponseBody> body{};

  UpdateSwimmingLaneResponse() {}

  explicit UpdateSwimmingLaneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSwimmingLaneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSwimmingLaneResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSwimmingLaneResponse() = default;
};
class UpdateSwimmingLaneGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> name{};
  shared_ptr<string> entryApp{};
  shared_ptr<string> appIds{};

  UpdateSwimmingLaneGroupRequest() {}

  explicit UpdateSwimmingLaneGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (entryApp) {
      res["EntryApp"] = boost::any(*entryApp);
    }
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("EntryApp") != m.end() && !m["EntryApp"].empty()) {
      entryApp = make_shared<string>(boost::any_cast<string>(m["EntryApp"]));
    }
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      appIds = make_shared<string>(boost::any_cast<string>(m["AppIds"]));
    }
  }


  virtual ~UpdateSwimmingLaneGroupRequest() = default;
};
class UpdateSwimmingLaneGroupResponseBodyDataApplicationList : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> appId{};

  UpdateSwimmingLaneGroupResponseBodyDataApplicationList() {}

  explicit UpdateSwimmingLaneGroupResponseBodyDataApplicationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~UpdateSwimmingLaneGroupResponseBodyDataApplicationList() = default;
};
class UpdateSwimmingLaneGroupResponseBodyDataEntryApplication : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> appId{};

  UpdateSwimmingLaneGroupResponseBodyDataEntryApplication() {}

  explicit UpdateSwimmingLaneGroupResponseBodyDataEntryApplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~UpdateSwimmingLaneGroupResponseBodyDataEntryApplication() = default;
};
class UpdateSwimmingLaneGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<vector<UpdateSwimmingLaneGroupResponseBodyDataApplicationList>> applicationList{};
  shared_ptr<UpdateSwimmingLaneGroupResponseBodyDataEntryApplication> entryApplication{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};

  UpdateSwimmingLaneGroupResponseBodyData() {}

  explicit UpdateSwimmingLaneGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (applicationList) {
      vector<boost::any> temp1;
      for(auto item1:*applicationList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApplicationList"] = boost::any(temp1);
    }
    if (entryApplication) {
      res["EntryApplication"] = entryApplication ? boost::any(entryApplication->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("ApplicationList") != m.end() && !m["ApplicationList"].empty()) {
      if (typeid(vector<boost::any>) == m["ApplicationList"].type()) {
        vector<UpdateSwimmingLaneGroupResponseBodyDataApplicationList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApplicationList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSwimmingLaneGroupResponseBodyDataApplicationList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applicationList = make_shared<vector<UpdateSwimmingLaneGroupResponseBodyDataApplicationList>>(expect1);
      }
    }
    if (m.find("EntryApplication") != m.end() && !m["EntryApplication"].empty()) {
      if (typeid(map<string, boost::any>) == m["EntryApplication"].type()) {
        UpdateSwimmingLaneGroupResponseBodyDataEntryApplication model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EntryApplication"]));
        entryApplication = make_shared<UpdateSwimmingLaneGroupResponseBodyDataEntryApplication>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~UpdateSwimmingLaneGroupResponseBodyData() = default;
};
class UpdateSwimmingLaneGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<UpdateSwimmingLaneGroupResponseBodyData> data{};
  shared_ptr<long> code{};

  UpdateSwimmingLaneGroupResponseBody() {}

  explicit UpdateSwimmingLaneGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateSwimmingLaneGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateSwimmingLaneGroupResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~UpdateSwimmingLaneGroupResponseBody() = default;
};
class UpdateSwimmingLaneGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateSwimmingLaneGroupResponseBody> body{};

  UpdateSwimmingLaneGroupResponse() {}

  explicit UpdateSwimmingLaneGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSwimmingLaneGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSwimmingLaneGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSwimmingLaneGroupResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AbortAndRollbackChangeOrderResponse abortAndRollbackChangeOrder(shared_ptr<AbortAndRollbackChangeOrderRequest> request);
  AbortAndRollbackChangeOrderResponse abortAndRollbackChangeOrderWithOptions(shared_ptr<AbortAndRollbackChangeOrderRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AbortChangeOrderResponse abortChangeOrder(shared_ptr<AbortChangeOrderRequest> request);
  AbortChangeOrderResponse abortChangeOrderWithOptions(shared_ptr<AbortChangeOrderRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLogPathResponse addLogPath(shared_ptr<AddLogPathRequest> request);
  AddLogPathResponse addLogPathWithOptions(shared_ptr<AddLogPathRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddMockRuleResponse addMockRule(shared_ptr<AddMockRuleRequest> request);
  AddMockRuleResponse addMockRuleWithOptions(shared_ptr<AddMockRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddServiceTimeConfigResponse addServiceTimeConfig(shared_ptr<AddServiceTimeConfigRequest> request);
  AddServiceTimeConfigResponse addServiceTimeConfigWithOptions(shared_ptr<AddServiceTimeConfigRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AuthorizeApplicationResponse authorizeApplication(shared_ptr<AuthorizeApplicationRequest> request);
  AuthorizeApplicationResponse authorizeApplicationWithOptions(shared_ptr<AuthorizeApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AuthorizeResourceGroupResponse authorizeResourceGroup(shared_ptr<AuthorizeResourceGroupRequest> request);
  AuthorizeResourceGroupResponse authorizeResourceGroupWithOptions(shared_ptr<AuthorizeResourceGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AuthorizeRoleResponse authorizeRole(shared_ptr<AuthorizeRoleRequest> request);
  AuthorizeRoleResponse authorizeRoleWithOptions(shared_ptr<AuthorizeRoleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindEcsSlbResponse bindEcsSlb(shared_ptr<BindEcsSlbRequest> request);
  BindEcsSlbResponse bindEcsSlbWithOptions(shared_ptr<BindEcsSlbRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindK8sSlbResponse bindK8sSlb(shared_ptr<BindK8sSlbRequest> request);
  BindK8sSlbResponse bindK8sSlbWithOptions(shared_ptr<BindK8sSlbRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindSlbResponse bindSlb(shared_ptr<BindSlbRequest> request);
  BindSlbResponse bindSlbWithOptions(shared_ptr<BindSlbRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeDeployGroupResponse changeDeployGroup(shared_ptr<ChangeDeployGroupRequest> request);
  ChangeDeployGroupResponse changeDeployGroupWithOptions(shared_ptr<ChangeDeployGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ContinuePipelineResponse continuePipeline(shared_ptr<ContinuePipelineRequest> request);
  ContinuePipelineResponse continuePipelineWithOptions(shared_ptr<ContinuePipelineRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConvertK8sResourceResponse convertK8sResource(shared_ptr<ConvertK8sResourceRequest> request);
  ConvertK8sResourceResponse convertK8sResourceWithOptions(shared_ptr<ConvertK8sResourceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIDCImportCommandResponse createIDCImportCommand(shared_ptr<CreateIDCImportCommandRequest> request);
  CreateIDCImportCommandResponse createIDCImportCommandWithOptions(shared_ptr<CreateIDCImportCommandRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateK8sIngressRuleResponse createK8sIngressRule(shared_ptr<CreateK8sIngressRuleRequest> request);
  CreateK8sIngressRuleResponse createK8sIngressRuleWithOptions(shared_ptr<CreateK8sIngressRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateK8sServiceResponse createK8sService(shared_ptr<CreateK8sServiceRequest> request);
  CreateK8sServiceResponse createK8sServiceWithOptions(shared_ptr<CreateK8sServiceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DelegateAdminRoleResponse delegateAdminRole(shared_ptr<DelegateAdminRoleRequest> request);
  DelegateAdminRoleResponse delegateAdminRoleWithOptions(shared_ptr<DelegateAdminRoleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteApplicationResponse deleteApplication(shared_ptr<DeleteApplicationRequest> request);
  DeleteApplicationResponse deleteApplicationWithOptions(shared_ptr<DeleteApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteClusterResponse deleteCluster(shared_ptr<DeleteClusterRequest> request);
  DeleteClusterResponse deleteClusterWithOptions(shared_ptr<DeleteClusterRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteClusterMemberResponse deleteClusterMember(shared_ptr<DeleteClusterMemberRequest> request);
  DeleteClusterMemberResponse deleteClusterMemberWithOptions(shared_ptr<DeleteClusterMemberRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteConfigCenterResponse deleteConfigCenter(shared_ptr<DeleteConfigCenterRequest> request);
  DeleteConfigCenterResponse deleteConfigCenterWithOptions(shared_ptr<DeleteConfigCenterRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDegradeControlResponse deleteDegradeControl(shared_ptr<DeleteDegradeControlRequest> request);
  DeleteDegradeControlResponse deleteDegradeControlWithOptions(shared_ptr<DeleteDegradeControlRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeployGroupResponse deleteDeployGroup(shared_ptr<DeleteDeployGroupRequest> request);
  DeleteDeployGroupResponse deleteDeployGroupWithOptions(shared_ptr<DeleteDeployGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEcuResponse deleteEcu(shared_ptr<DeleteEcuRequest> request);
  DeleteEcuResponse deleteEcuWithOptions(shared_ptr<DeleteEcuRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFlowControlResponse deleteFlowControl(shared_ptr<DeleteFlowControlRequest> request);
  DeleteFlowControlResponse deleteFlowControlWithOptions(shared_ptr<DeleteFlowControlRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteK8sApplicationResponse deleteK8sApplication(shared_ptr<DeleteK8sApplicationRequest> request);
  DeleteK8sApplicationResponse deleteK8sApplicationWithOptions(shared_ptr<DeleteK8sApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteK8sIngressRuleResponse deleteK8sIngressRule(shared_ptr<DeleteK8sIngressRuleRequest> request);
  DeleteK8sIngressRuleResponse deleteK8sIngressRuleWithOptions(shared_ptr<DeleteK8sIngressRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteK8sServiceResponse deleteK8sService(shared_ptr<DeleteK8sServiceRequest> request);
  DeleteK8sServiceResponse deleteK8sServiceWithOptions(shared_ptr<DeleteK8sServiceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLogPathResponse deleteLogPath(shared_ptr<DeleteLogPathRequest> request);
  DeleteLogPathResponse deleteLogPathWithOptions(shared_ptr<DeleteLogPathRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRoleResponse deleteRole(shared_ptr<DeleteRoleRequest> request);
  DeleteRoleResponse deleteRoleWithOptions(shared_ptr<DeleteRoleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteServiceGroupResponse deleteServiceGroup(shared_ptr<DeleteServiceGroupRequest> request);
  DeleteServiceGroupResponse deleteServiceGroupWithOptions(shared_ptr<DeleteServiceGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteServiceTimeConfigResponse deleteServiceTimeConfig(shared_ptr<DeleteServiceTimeConfigRequest> request);
  DeleteServiceTimeConfigResponse deleteServiceTimeConfigWithOptions(shared_ptr<DeleteServiceTimeConfigRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSwimmingLaneResponse deleteSwimmingLane(shared_ptr<DeleteSwimmingLaneRequest> request);
  DeleteSwimmingLaneResponse deleteSwimmingLaneWithOptions(shared_ptr<DeleteSwimmingLaneRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSwimmingLaneGroupResponse deleteSwimmingLaneGroup(shared_ptr<DeleteSwimmingLaneGroupRequest> request);
  DeleteSwimmingLaneGroupResponse deleteSwimmingLaneGroupWithOptions(shared_ptr<DeleteSwimmingLaneGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteUserDefineRegionResponse deleteUserDefineRegion(shared_ptr<DeleteUserDefineRegionRequest> request);
  DeleteUserDefineRegionResponse deleteUserDefineRegionWithOptions(shared_ptr<DeleteUserDefineRegionRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeployApplicationResponse deployApplication(shared_ptr<DeployApplicationRequest> request);
  DeployApplicationResponse deployApplicationWithOptions(shared_ptr<DeployApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeployK8sApplicationResponse deployK8sApplication(shared_ptr<DeployK8sApplicationRequest> request);
  DeployK8sApplicationResponse deployK8sApplicationWithOptions(shared_ptr<DeployK8sApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableDegradeControlResponse disableDegradeControl(shared_ptr<DisableDegradeControlRequest> request);
  DisableDegradeControlResponse disableDegradeControlWithOptions(shared_ptr<DisableDegradeControlRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableFlowControlResponse disableFlowControl(shared_ptr<DisableFlowControlRequest> request);
  DisableFlowControlResponse disableFlowControlWithOptions(shared_ptr<DisableFlowControlRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableMockRuleResponse disableMockRule(shared_ptr<DisableMockRuleRequest> request);
  DisableMockRuleResponse disableMockRuleWithOptions(shared_ptr<DisableMockRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableDegradeControlResponse enableDegradeControl(shared_ptr<EnableDegradeControlRequest> request);
  EnableDegradeControlResponse enableDegradeControlWithOptions(shared_ptr<EnableDegradeControlRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableFlowControlResponse enableFlowControl(shared_ptr<EnableFlowControlRequest> request);
  EnableFlowControlResponse enableFlowControlWithOptions(shared_ptr<EnableFlowControlRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableMockRuleResponse enableMockRule(shared_ptr<EnableMockRuleRequest> request);
  EnableMockRuleResponse enableMockRuleWithOptions(shared_ptr<EnableMockRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExecuteStatusResponse executeStatus(shared_ptr<ExecuteStatusRequest> request);
  ExecuteStatusResponse executeStatusWithOptions(shared_ptr<ExecuteStatusRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAccountMockRuleResponse getAccountMockRule(shared_ptr<GetAccountMockRuleRequest> request);
  GetAccountMockRuleResponse getAccountMockRuleWithOptions(shared_ptr<GetAccountMockRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetApplicationResponse getApplication(shared_ptr<GetApplicationRequest> request);
  GetApplicationResponse getApplicationWithOptions(shared_ptr<GetApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetChangeOrderInfoResponse getChangeOrderInfo(shared_ptr<GetChangeOrderInfoRequest> request);
  GetChangeOrderInfoResponse getChangeOrderInfoWithOptions(shared_ptr<GetChangeOrderInfoRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetClusterResponse getCluster(shared_ptr<GetClusterRequest> request);
  GetClusterResponse getClusterWithOptions(shared_ptr<GetClusterRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetContainerConfigurationResponse getContainerConfiguration(shared_ptr<GetContainerConfigurationRequest> request);
  GetContainerConfigurationResponse getContainerConfigurationWithOptions(shared_ptr<GetContainerConfigurationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetJvmConfigurationResponse getJvmConfiguration(shared_ptr<GetJvmConfigurationRequest> request);
  GetJvmConfigurationResponse getJvmConfigurationWithOptions(shared_ptr<GetJvmConfigurationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetK8sApplicationResponse getK8sApplication(shared_ptr<GetK8sApplicationRequest> request);
  GetK8sApplicationResponse getK8sApplicationWithOptions(shared_ptr<GetK8sApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetK8sClusterResponse getK8sCluster(shared_ptr<GetK8sClusterRequest> request);
  GetK8sClusterResponse getK8sClusterWithOptions(shared_ptr<GetK8sClusterRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetK8sServicesResponse getK8sServices(shared_ptr<GetK8sServicesRequest> request);
  GetK8sServicesResponse getK8sServicesWithOptions(shared_ptr<GetK8sServicesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMockRuleByConsumerAppIdResponse getMockRuleByConsumerAppId(shared_ptr<GetMockRuleByConsumerAppIdRequest> request);
  GetMockRuleByConsumerAppIdResponse getMockRuleByConsumerAppIdWithOptions(shared_ptr<GetMockRuleByConsumerAppIdRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMockRuleByIdResponse getMockRuleById(shared_ptr<GetMockRuleByIdRequest> request);
  GetMockRuleByIdResponse getMockRuleByIdWithOptions(shared_ptr<GetMockRuleByIdRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMockRuleByProviderAppIdResponse getMockRuleByProviderAppId(shared_ptr<GetMockRuleByProviderAppIdRequest> request);
  GetMockRuleByProviderAppIdResponse getMockRuleByProviderAppIdWithOptions(shared_ptr<GetMockRuleByProviderAppIdRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPackageStorageCredentialResponse getPackageStorageCredential();
  GetPackageStorageCredentialResponse getPackageStorageCredentialWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetScalingRulesResponse getScalingRules(shared_ptr<GetScalingRulesRequest> request);
  GetScalingRulesResponse getScalingRulesWithOptions(shared_ptr<GetScalingRulesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSecureTokenResponse getSecureToken(shared_ptr<GetSecureTokenRequest> request);
  GetSecureTokenResponse getSecureTokenWithOptions(shared_ptr<GetSecureTokenRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetServiceConsumersPageResponse getServiceConsumersPage(shared_ptr<GetServiceConsumersPageRequest> request);
  GetServiceConsumersPageResponse getServiceConsumersPageWithOptions(shared_ptr<GetServiceConsumersPageRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetServiceDetailResponse getServiceDetail(shared_ptr<GetServiceDetailRequest> request);
  GetServiceDetailResponse getServiceDetailWithOptions(shared_ptr<GetServiceDetailRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetServiceListResponse getServiceList(shared_ptr<GetServiceListRequest> request);
  GetServiceListResponse getServiceListWithOptions(shared_ptr<GetServiceListRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetServiceListPageResponse getServiceListPage(shared_ptr<GetServiceListPageRequest> request);
  GetServiceListPageResponse getServiceListPageWithOptions(shared_ptr<GetServiceListPageRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetServiceMethodPageResponse getServiceMethodPage(shared_ptr<GetServiceMethodPageRequest> request);
  GetServiceMethodPageResponse getServiceMethodPageWithOptions(shared_ptr<GetServiceMethodPageRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetServiceProvidersPageResponse getServiceProvidersPage(shared_ptr<GetServiceProvidersPageRequest> request);
  GetServiceProvidersPageResponse getServiceProvidersPageWithOptions(shared_ptr<GetServiceProvidersPageRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSubAccountInfoResponse getSubAccountInfo(shared_ptr<GetSubAccountInfoRequest> request);
  GetSubAccountInfoResponse getSubAccountInfoWithOptions(shared_ptr<GetSubAccountInfoRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSwimmingLaneResponse getSwimmingLane(shared_ptr<GetSwimmingLaneRequest> request);
  GetSwimmingLaneResponse getSwimmingLaneWithOptions(shared_ptr<GetSwimmingLaneRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportK8sClusterResponse importK8sCluster(shared_ptr<ImportK8sClusterRequest> request);
  ImportK8sClusterResponse importK8sClusterWithOptions(shared_ptr<ImportK8sClusterRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertApplicationResponse insertApplication(shared_ptr<InsertApplicationRequest> request);
  InsertApplicationResponse insertApplicationWithOptions(shared_ptr<InsertApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertClusterResponse insertCluster(shared_ptr<InsertClusterRequest> request);
  InsertClusterResponse insertClusterWithOptions(shared_ptr<InsertClusterRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertClusterMemberResponse insertClusterMember(shared_ptr<InsertClusterMemberRequest> request);
  InsertClusterMemberResponse insertClusterMemberWithOptions(shared_ptr<InsertClusterMemberRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertConfigCenterResponse insertConfigCenter(shared_ptr<InsertConfigCenterRequest> request);
  InsertConfigCenterResponse insertConfigCenterWithOptions(shared_ptr<InsertConfigCenterRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertDegradeControlResponse insertDegradeControl(shared_ptr<InsertDegradeControlRequest> request);
  InsertDegradeControlResponse insertDegradeControlWithOptions(shared_ptr<InsertDegradeControlRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertDeployGroupResponse insertDeployGroup(shared_ptr<InsertDeployGroupRequest> request);
  InsertDeployGroupResponse insertDeployGroupWithOptions(shared_ptr<InsertDeployGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertFlowControlResponse insertFlowControl(shared_ptr<InsertFlowControlRequest> request);
  InsertFlowControlResponse insertFlowControlWithOptions(shared_ptr<InsertFlowControlRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertK8sApplicationResponse insertK8sApplication(shared_ptr<InsertK8sApplicationRequest> request);
  InsertK8sApplicationResponse insertK8sApplicationWithOptions(shared_ptr<InsertK8sApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertOrUpdateRegionResponse insertOrUpdateRegion(shared_ptr<InsertOrUpdateRegionRequest> request);
  InsertOrUpdateRegionResponse insertOrUpdateRegionWithOptions(shared_ptr<InsertOrUpdateRegionRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertRoleResponse insertRole(shared_ptr<InsertRoleRequest> request);
  InsertRoleResponse insertRoleWithOptions(shared_ptr<InsertRoleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertServiceGroupResponse insertServiceGroup(shared_ptr<InsertServiceGroupRequest> request);
  InsertServiceGroupResponse insertServiceGroupWithOptions(shared_ptr<InsertServiceGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertSwimmingLaneResponse insertSwimmingLane(shared_ptr<InsertSwimmingLaneRequest> request);
  InsertSwimmingLaneResponse insertSwimmingLaneWithOptions(shared_ptr<InsertSwimmingLaneRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertSwimmingLaneGroupResponse insertSwimmingLaneGroup(shared_ptr<InsertSwimmingLaneGroupRequest> request);
  InsertSwimmingLaneGroupResponse insertSwimmingLaneGroupWithOptions(shared_ptr<InsertSwimmingLaneGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallAgentResponse installAgent(shared_ptr<InstallAgentRequest> request);
  InstallAgentResponse installAgentWithOptions(shared_ptr<InstallAgentRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAliyunRegionResponse listAliyunRegion();
  ListAliyunRegionResponse listAliyunRegionWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApplicationResponse listApplication(shared_ptr<ListApplicationRequest> request);
  ListApplicationResponse listApplicationWithOptions(shared_ptr<ListApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApplicationEcuResponse listApplicationEcu(shared_ptr<ListApplicationEcuRequest> request);
  ListApplicationEcuResponse listApplicationEcuWithOptions(shared_ptr<ListApplicationEcuRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAuthorityResponse listAuthority();
  ListAuthorityResponse listAuthorityWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBuildPackResponse listBuildPack();
  ListBuildPackResponse listBuildPackWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListChildrenStacksResponse listChildrenStacks(shared_ptr<ListChildrenStacksRequest> request);
  ListChildrenStacksResponse listChildrenStacksWithOptions(shared_ptr<ListChildrenStacksRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterResponse listCluster(shared_ptr<ListClusterRequest> request);
  ListClusterResponse listClusterWithOptions(shared_ptr<ListClusterRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterMembersResponse listClusterMembers(shared_ptr<ListClusterMembersRequest> request);
  ListClusterMembersResponse listClusterMembersWithOptions(shared_ptr<ListClusterMembersRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListComponentsResponse listComponents();
  ListComponentsResponse listComponentsWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConfigCentersResponse listConfigCenters(shared_ptr<ListConfigCentersRequest> request);
  ListConfigCentersResponse listConfigCentersWithOptions(shared_ptr<ListConfigCentersRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConsumedServicesResponse listConsumedServices(shared_ptr<ListConsumedServicesRequest> request);
  ListConsumedServicesResponse listConsumedServicesWithOptions(shared_ptr<ListConsumedServicesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConvertableEcuResponse listConvertableEcu(shared_ptr<ListConvertableEcuRequest> request);
  ListConvertableEcuResponse listConvertableEcuWithOptions(shared_ptr<ListConvertableEcuRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCSBGatewayResponse listCSBGateway(shared_ptr<ListCSBGatewayRequest> request);
  ListCSBGatewayResponse listCSBGatewayWithOptions(shared_ptr<ListCSBGatewayRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDegradeControlsResponse listDegradeControls(shared_ptr<ListDegradeControlsRequest> request);
  ListDegradeControlsResponse listDegradeControlsWithOptions(shared_ptr<ListDegradeControlsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDeployGroupResponse listDeployGroup(shared_ptr<ListDeployGroupRequest> request);
  ListDeployGroupResponse listDeployGroupWithOptions(shared_ptr<ListDeployGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEcsNotInClusterResponse listEcsNotInCluster(shared_ptr<ListEcsNotInClusterRequest> request);
  ListEcsNotInClusterResponse listEcsNotInClusterWithOptions(shared_ptr<ListEcsNotInClusterRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEcuByRegionResponse listEcuByRegion(shared_ptr<ListEcuByRegionRequest> request);
  ListEcuByRegionResponse listEcuByRegionWithOptions(shared_ptr<ListEcuByRegionRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowControlsResponse listFlowControls(shared_ptr<ListFlowControlsRequest> request);
  ListFlowControlsResponse listFlowControlsWithOptions(shared_ptr<ListFlowControlsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHistoryDeployVersionResponse listHistoryDeployVersion(shared_ptr<ListHistoryDeployVersionRequest> request);
  ListHistoryDeployVersionResponse listHistoryDeployVersionWithOptions(shared_ptr<ListHistoryDeployVersionRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListK8sIngressRulesResponse listK8sIngressRules(shared_ptr<ListK8sIngressRulesRequest> request);
  ListK8sIngressRulesResponse listK8sIngressRulesWithOptions(shared_ptr<ListK8sIngressRulesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMethodsResponse listMethods(shared_ptr<ListMethodsRequest> request);
  ListMethodsResponse listMethodsWithOptions(shared_ptr<ListMethodsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOperationLogsResponse listOperationLogs(shared_ptr<ListOperationLogsRequest> request);
  ListOperationLogsResponse listOperationLogsWithOptions(shared_ptr<ListOperationLogsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPublishedServicesResponse listPublishedServices(shared_ptr<ListPublishedServicesRequest> request);
  ListPublishedServicesResponse listPublishedServicesWithOptions(shared_ptr<ListPublishedServicesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRecentChangeOrderResponse listRecentChangeOrder(shared_ptr<ListRecentChangeOrderRequest> request);
  ListRecentChangeOrderResponse listRecentChangeOrderWithOptions(shared_ptr<ListRecentChangeOrderRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListResourceGroupResponse listResourceGroup();
  ListResourceGroupResponse listResourceGroupWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRoleResponse listRole();
  ListRoleResponse listRoleWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRootStacksResponse listRootStacks(shared_ptr<ListRootStacksRequest> request);
  ListRootStacksResponse listRootStacksWithOptions(shared_ptr<ListRootStacksRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListScaleOutEcuResponse listScaleOutEcu(shared_ptr<ListScaleOutEcuRequest> request);
  ListScaleOutEcuResponse listScaleOutEcuWithOptions(shared_ptr<ListScaleOutEcuRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListServiceGroupsResponse listServiceGroups();
  ListServiceGroupsResponse listServiceGroupsWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSlbResponse listSlb();
  ListSlbResponse listSlbWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListStatusResponse listStatus(shared_ptr<ListStatusRequest> request);
  ListStatusResponse listStatusWithOptions(shared_ptr<ListStatusRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSubAccountResponse listSubAccount();
  ListSubAccountResponse listSubAccountWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSwimmingLaneResponse listSwimmingLane(shared_ptr<ListSwimmingLaneRequest> request);
  ListSwimmingLaneResponse listSwimmingLaneWithOptions(shared_ptr<ListSwimmingLaneRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSwimmingLaneGroupResponse listSwimmingLaneGroup(shared_ptr<ListSwimmingLaneGroupRequest> request);
  ListSwimmingLaneGroupResponse listSwimmingLaneGroupWithOptions(shared_ptr<ListSwimmingLaneGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUserDefineRegionResponse listUserDefineRegion(shared_ptr<ListUserDefineRegionRequest> request);
  ListUserDefineRegionResponse listUserDefineRegionWithOptions(shared_ptr<ListUserDefineRegionRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListVpcResponse listVpc();
  ListVpcResponse listVpcWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MigrateEcuResponse migrateEcu(shared_ptr<MigrateEcuRequest> request);
  MigrateEcuResponse migrateEcuWithOptions(shared_ptr<MigrateEcuRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyScalingRuleResponse modifyScalingRule(shared_ptr<ModifyScalingRuleRequest> request);
  ModifyScalingRuleResponse modifyScalingRuleWithOptions(shared_ptr<ModifyScalingRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryApplicationStatusResponse queryApplicationStatus(shared_ptr<QueryApplicationStatusRequest> request);
  QueryApplicationStatusResponse queryApplicationStatusWithOptions(shared_ptr<QueryApplicationStatusRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryConfigCenterResponse queryConfigCenter(shared_ptr<QueryConfigCenterRequest> request);
  QueryConfigCenterResponse queryConfigCenterWithOptions(shared_ptr<QueryConfigCenterRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEccInfoResponse queryEccInfo(shared_ptr<QueryEccInfoRequest> request);
  QueryEccInfoResponse queryEccInfoWithOptions(shared_ptr<QueryEccInfoRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryK8sClusterLogProjectInfoResponse queryK8sClusterLogProjectInfo(shared_ptr<QueryK8sClusterLogProjectInfoRequest> request);
  QueryK8sClusterLogProjectInfoResponse queryK8sClusterLogProjectInfoWithOptions(shared_ptr<QueryK8sClusterLogProjectInfoRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMigrateEcuListResponse queryMigrateEcuList(shared_ptr<QueryMigrateEcuListRequest> request);
  QueryMigrateEcuListResponse queryMigrateEcuListWithOptions(shared_ptr<QueryMigrateEcuListRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMigrateRegionListResponse queryMigrateRegionList(shared_ptr<QueryMigrateRegionListRequest> request);
  QueryMigrateRegionListResponse queryMigrateRegionListWithOptions(shared_ptr<QueryMigrateRegionListRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMonitorInfoResponse queryMonitorInfo(shared_ptr<QueryMonitorInfoRequest> request);
  QueryMonitorInfoResponse queryMonitorInfoWithOptions(shared_ptr<QueryMonitorInfoRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryRegionConfigResponse queryRegionConfig();
  QueryRegionConfigResponse queryRegionConfigWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryServiceTimeConfigResponse queryServiceTimeConfig(shared_ptr<QueryServiceTimeConfigRequest> request);
  QueryServiceTimeConfigResponse queryServiceTimeConfigWithOptions(shared_ptr<QueryServiceTimeConfigRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySlsLogStoreListResponse querySlsLogStoreList(shared_ptr<QuerySlsLogStoreListRequest> request);
  QuerySlsLogStoreListResponse querySlsLogStoreListWithOptions(shared_ptr<QuerySlsLogStoreListRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveMockRuleResponse removeMockRule(shared_ptr<RemoveMockRuleRequest> request);
  RemoveMockRuleResponse removeMockRuleWithOptions(shared_ptr<RemoveMockRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetApplicationResponse resetApplication(shared_ptr<ResetApplicationRequest> request);
  ResetApplicationResponse resetApplicationWithOptions(shared_ptr<ResetApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestartApplicationResponse restartApplication(shared_ptr<RestartApplicationRequest> request);
  RestartApplicationResponse restartApplicationWithOptions(shared_ptr<RestartApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestartK8sApplicationResponse restartK8sApplication(shared_ptr<RestartK8sApplicationRequest> request);
  RestartK8sApplicationResponse restartK8sApplicationWithOptions(shared_ptr<RestartK8sApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RollbackApplicationResponse rollbackApplication(shared_ptr<RollbackApplicationRequest> request);
  RollbackApplicationResponse rollbackApplicationWithOptions(shared_ptr<RollbackApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RollbackChangeOrderResponse rollbackChangeOrder(shared_ptr<RollbackChangeOrderRequest> request);
  RollbackChangeOrderResponse rollbackChangeOrderWithOptions(shared_ptr<RollbackChangeOrderRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ScaleInApplicationResponse scaleInApplication(shared_ptr<ScaleInApplicationRequest> request);
  ScaleInApplicationResponse scaleInApplicationWithOptions(shared_ptr<ScaleInApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ScaleK8sApplicationResponse scaleK8sApplication(shared_ptr<ScaleK8sApplicationRequest> request);
  ScaleK8sApplicationResponse scaleK8sApplicationWithOptions(shared_ptr<ScaleK8sApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ScaleOutApplicationResponse scaleOutApplication(shared_ptr<ScaleOutApplicationRequest> request);
  ScaleOutApplicationResponse scaleOutApplicationWithOptions(shared_ptr<ScaleOutApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ScaleoutApplicationWithNewInstancesResponse scaleoutApplicationWithNewInstances(shared_ptr<ScaleoutApplicationWithNewInstancesRequest> request);
  ScaleoutApplicationWithNewInstancesResponse scaleoutApplicationWithNewInstancesWithOptions(shared_ptr<ScaleoutApplicationWithNewInstancesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartApplicationResponse startApplication(shared_ptr<StartApplicationRequest> request);
  StartApplicationResponse startApplicationWithOptions(shared_ptr<StartApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartK8sApplicationResponse startK8sApplication(shared_ptr<StartK8sApplicationRequest> request);
  StartK8sApplicationResponse startK8sApplicationWithOptions(shared_ptr<StartK8sApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopApplicationResponse stopApplication(shared_ptr<StopApplicationRequest> request);
  StopApplicationResponse stopApplicationWithOptions(shared_ptr<StopApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopK8sApplicationResponse stopK8sApplication(shared_ptr<StopK8sApplicationRequest> request);
  StopK8sApplicationResponse stopK8sApplicationWithOptions(shared_ptr<StopK8sApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SwitchAdvancedMonitoringResponse switchAdvancedMonitoring(shared_ptr<SwitchAdvancedMonitoringRequest> request);
  SwitchAdvancedMonitoringResponse switchAdvancedMonitoringWithOptions(shared_ptr<SwitchAdvancedMonitoringRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SynchronizeResourceResponse synchronizeResource(shared_ptr<SynchronizeResourceRequest> request);
  SynchronizeResourceResponse synchronizeResourceWithOptions(shared_ptr<SynchronizeResourceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TransformClusterMemberResponse transformClusterMember(shared_ptr<TransformClusterMemberRequest> request);
  TransformClusterMemberResponse transformClusterMemberWithOptions(shared_ptr<TransformClusterMemberRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindK8sSlbResponse unbindK8sSlb(shared_ptr<UnbindK8sSlbRequest> request);
  UnbindK8sSlbResponse unbindK8sSlbWithOptions(shared_ptr<UnbindK8sSlbRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindSlbResponse unbindSlb(shared_ptr<UnbindSlbRequest> request);
  UnbindSlbResponse unbindSlbWithOptions(shared_ptr<UnbindSlbRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAccountInfoResponse updateAccountInfo(shared_ptr<UpdateAccountInfoRequest> request);
  UpdateAccountInfoResponse updateAccountInfoWithOptions(shared_ptr<UpdateAccountInfoRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateApplicationBaseInfoResponse updateApplicationBaseInfo(shared_ptr<UpdateApplicationBaseInfoRequest> request);
  UpdateApplicationBaseInfoResponse updateApplicationBaseInfoWithOptions(shared_ptr<UpdateApplicationBaseInfoRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateContainerResponse updateContainer(shared_ptr<UpdateContainerRequest> request);
  UpdateContainerResponse updateContainerWithOptions(shared_ptr<UpdateContainerRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateContainerConfigurationResponse updateContainerConfiguration(shared_ptr<UpdateContainerConfigurationRequest> request);
  UpdateContainerConfigurationResponse updateContainerConfigurationWithOptions(shared_ptr<UpdateContainerConfigurationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDegradeControlResponse updateDegradeControl(shared_ptr<UpdateDegradeControlRequest> request);
  UpdateDegradeControlResponse updateDegradeControlWithOptions(shared_ptr<UpdateDegradeControlRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateFlowControlResponse updateFlowControl(shared_ptr<UpdateFlowControlRequest> request);
  UpdateFlowControlResponse updateFlowControlWithOptions(shared_ptr<UpdateFlowControlRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateHealthCheckUrlResponse updateHealthCheckUrl(shared_ptr<UpdateHealthCheckUrlRequest> request);
  UpdateHealthCheckUrlResponse updateHealthCheckUrlWithOptions(shared_ptr<UpdateHealthCheckUrlRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateHookConfigurationResponse updateHookConfiguration(shared_ptr<UpdateHookConfigurationRequest> request);
  UpdateHookConfigurationResponse updateHookConfigurationWithOptions(shared_ptr<UpdateHookConfigurationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateJvmConfigurationResponse updateJvmConfiguration(shared_ptr<UpdateJvmConfigurationRequest> request);
  UpdateJvmConfigurationResponse updateJvmConfigurationWithOptions(shared_ptr<UpdateJvmConfigurationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateK8sApplicationBaseInfoResponse updateK8sApplicationBaseInfo(shared_ptr<UpdateK8sApplicationBaseInfoRequest> request);
  UpdateK8sApplicationBaseInfoResponse updateK8sApplicationBaseInfoWithOptions(shared_ptr<UpdateK8sApplicationBaseInfoRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateK8sApplicationConfigResponse updateK8sApplicationConfig(shared_ptr<UpdateK8sApplicationConfigRequest> request);
  UpdateK8sApplicationConfigResponse updateK8sApplicationConfigWithOptions(shared_ptr<UpdateK8sApplicationConfigRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateK8sIngressRuleResponse updateK8sIngressRule(shared_ptr<UpdateK8sIngressRuleRequest> request);
  UpdateK8sIngressRuleResponse updateK8sIngressRuleWithOptions(shared_ptr<UpdateK8sIngressRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateK8sResourceResponse updateK8sResource(shared_ptr<UpdateK8sResourceRequest> request);
  UpdateK8sResourceResponse updateK8sResourceWithOptions(shared_ptr<UpdateK8sResourceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateK8sServiceResponse updateK8sService(shared_ptr<UpdateK8sServiceRequest> request);
  UpdateK8sServiceResponse updateK8sServiceWithOptions(shared_ptr<UpdateK8sServiceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateK8sSlbResponse updateK8sSlb(shared_ptr<UpdateK8sSlbRequest> request);
  UpdateK8sSlbResponse updateK8sSlbWithOptions(shared_ptr<UpdateK8sSlbRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMockRuleResponse updateMockRule(shared_ptr<UpdateMockRuleRequest> request);
  UpdateMockRuleResponse updateMockRuleWithOptions(shared_ptr<UpdateMockRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRoleResponse updateRole(shared_ptr<UpdateRoleRequest> request);
  UpdateRoleResponse updateRoleWithOptions(shared_ptr<UpdateRoleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSlsLogStoreResponse updateSlsLogStore(shared_ptr<UpdateSlsLogStoreRequest> request);
  UpdateSlsLogStoreResponse updateSlsLogStoreWithOptions(shared_ptr<UpdateSlsLogStoreRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSwimmingLaneResponse updateSwimmingLane(shared_ptr<UpdateSwimmingLaneRequest> request);
  UpdateSwimmingLaneResponse updateSwimmingLaneWithOptions(shared_ptr<UpdateSwimmingLaneRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSwimmingLaneGroupResponse updateSwimmingLaneGroup(shared_ptr<UpdateSwimmingLaneGroupRequest> request);
  UpdateSwimmingLaneGroupResponse updateSwimmingLaneGroupWithOptions(shared_ptr<UpdateSwimmingLaneGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Edas20170801

#endif
