// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_MPAAS20201028_H_
#define ALIBABACLOUD_MPAAS20201028_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_MPaaS20201028 {
class AddMdsMiniConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMappcenterMiniConfigAddJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  AddMdsMiniConfigRequest() {}

  explicit AddMdsMiniConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMappcenterMiniConfigAddJsonStr) {
      res["MpaasMappcenterMiniConfigAddJsonStr"] = boost::any(*mpaasMappcenterMiniConfigAddJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMappcenterMiniConfigAddJsonStr") != m.end() && !m["MpaasMappcenterMiniConfigAddJsonStr"].empty()) {
      mpaasMappcenterMiniConfigAddJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMappcenterMiniConfigAddJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~AddMdsMiniConfigRequest() = default;
};
class AddMdsMiniConfigResponseBodyResultContentData : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  AddMdsMiniConfigResponseBodyResultContentData() {}

  explicit AddMdsMiniConfigResponseBodyResultContentData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddMdsMiniConfigResponseBodyResultContentData() = default;
};
class AddMdsMiniConfigResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<AddMdsMiniConfigResponseBodyResultContentData> data{};
  shared_ptr<string> requestId{};

  AddMdsMiniConfigResponseBodyResultContent() {}

  explicit AddMdsMiniConfigResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AddMdsMiniConfigResponseBodyResultContentData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AddMdsMiniConfigResponseBodyResultContentData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddMdsMiniConfigResponseBodyResultContent() = default;
};
class AddMdsMiniConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<AddMdsMiniConfigResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  AddMdsMiniConfigResponseBody() {}

  explicit AddMdsMiniConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        AddMdsMiniConfigResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<AddMdsMiniConfigResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~AddMdsMiniConfigResponseBody() = default;
};
class AddMdsMiniConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddMdsMiniConfigResponseBody> body{};

  AddMdsMiniConfigResponse() {}

  explicit AddMdsMiniConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddMdsMiniConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddMdsMiniConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddMdsMiniConfigResponse() = default;
};
class CancelPushSchedulerRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> type{};
  shared_ptr<string> uniqueIds{};
  shared_ptr<string> workspaceId{};

  CancelPushSchedulerRequest() {}

  explicit CancelPushSchedulerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uniqueIds) {
      res["UniqueIds"] = boost::any(*uniqueIds);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("UniqueIds") != m.end() && !m["UniqueIds"].empty()) {
      uniqueIds = make_shared<string>(boost::any_cast<string>(m["UniqueIds"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CancelPushSchedulerRequest() = default;
};
class CancelPushSchedulerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultContent{};
  shared_ptr<string> resultMessage{};

  CancelPushSchedulerResponseBody() {}

  explicit CancelPushSchedulerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = boost::any(*resultContent);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      resultContent = make_shared<string>(boost::any_cast<string>(m["ResultContent"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~CancelPushSchedulerResponseBody() = default;
};
class CancelPushSchedulerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelPushSchedulerResponseBody> body{};

  CancelPushSchedulerResponse() {}

  explicit CancelPushSchedulerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelPushSchedulerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelPushSchedulerResponseBody>(model1);
      }
    }
  }


  virtual ~CancelPushSchedulerResponse() = default;
};
class ChangeMcubeMiniTaskStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> bizType{};
  shared_ptr<long> packageId{};
  shared_ptr<long> taskId{};
  shared_ptr<long> taskStatus{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  ChangeMcubeMiniTaskStatusRequest() {}

  explicit ChangeMcubeMiniTaskStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (packageId) {
      res["PackageId"] = boost::any(*packageId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("PackageId") != m.end() && !m["PackageId"].empty()) {
      packageId = make_shared<long>(boost::any_cast<long>(m["PackageId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<long>(boost::any_cast<long>(m["TaskStatus"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ChangeMcubeMiniTaskStatusRequest() = default;
};
class ChangeMcubeMiniTaskStatusResponseBodyChangeMiniTaskStatusResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  ChangeMcubeMiniTaskStatusResponseBodyChangeMiniTaskStatusResult() {}

  explicit ChangeMcubeMiniTaskStatusResponseBodyChangeMiniTaskStatusResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ChangeMcubeMiniTaskStatusResponseBodyChangeMiniTaskStatusResult() = default;
};
class ChangeMcubeMiniTaskStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<ChangeMcubeMiniTaskStatusResponseBodyChangeMiniTaskStatusResult> changeMiniTaskStatusResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  ChangeMcubeMiniTaskStatusResponseBody() {}

  explicit ChangeMcubeMiniTaskStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeMiniTaskStatusResult) {
      res["ChangeMiniTaskStatusResult"] = changeMiniTaskStatusResult ? boost::any(changeMiniTaskStatusResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeMiniTaskStatusResult") != m.end() && !m["ChangeMiniTaskStatusResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ChangeMiniTaskStatusResult"].type()) {
        ChangeMcubeMiniTaskStatusResponseBodyChangeMiniTaskStatusResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ChangeMiniTaskStatusResult"]));
        changeMiniTaskStatusResult = make_shared<ChangeMcubeMiniTaskStatusResponseBodyChangeMiniTaskStatusResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~ChangeMcubeMiniTaskStatusResponseBody() = default;
};
class ChangeMcubeMiniTaskStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeMcubeMiniTaskStatusResponseBody> body{};

  ChangeMcubeMiniTaskStatusResponse() {}

  explicit ChangeMcubeMiniTaskStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeMcubeMiniTaskStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeMcubeMiniTaskStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeMcubeMiniTaskStatusResponse() = default;
};
class ChangeMcubeNebulaTaskStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> bizType{};
  shared_ptr<string> packageId{};
  shared_ptr<string> taskId{};
  shared_ptr<long> taskStatus{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  ChangeMcubeNebulaTaskStatusRequest() {}

  explicit ChangeMcubeNebulaTaskStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (packageId) {
      res["PackageId"] = boost::any(*packageId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("PackageId") != m.end() && !m["PackageId"].empty()) {
      packageId = make_shared<string>(boost::any_cast<string>(m["PackageId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<long>(boost::any_cast<long>(m["TaskStatus"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ChangeMcubeNebulaTaskStatusRequest() = default;
};
class ChangeMcubeNebulaTaskStatusResponseBodyChangeMcubeNebulaTaskStatusResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  ChangeMcubeNebulaTaskStatusResponseBodyChangeMcubeNebulaTaskStatusResult() {}

  explicit ChangeMcubeNebulaTaskStatusResponseBodyChangeMcubeNebulaTaskStatusResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ChangeMcubeNebulaTaskStatusResponseBodyChangeMcubeNebulaTaskStatusResult() = default;
};
class ChangeMcubeNebulaTaskStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<ChangeMcubeNebulaTaskStatusResponseBodyChangeMcubeNebulaTaskStatusResult> changeMcubeNebulaTaskStatusResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  ChangeMcubeNebulaTaskStatusResponseBody() {}

  explicit ChangeMcubeNebulaTaskStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeMcubeNebulaTaskStatusResult) {
      res["ChangeMcubeNebulaTaskStatusResult"] = changeMcubeNebulaTaskStatusResult ? boost::any(changeMcubeNebulaTaskStatusResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeMcubeNebulaTaskStatusResult") != m.end() && !m["ChangeMcubeNebulaTaskStatusResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ChangeMcubeNebulaTaskStatusResult"].type()) {
        ChangeMcubeNebulaTaskStatusResponseBodyChangeMcubeNebulaTaskStatusResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ChangeMcubeNebulaTaskStatusResult"]));
        changeMcubeNebulaTaskStatusResult = make_shared<ChangeMcubeNebulaTaskStatusResponseBodyChangeMcubeNebulaTaskStatusResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~ChangeMcubeNebulaTaskStatusResponseBody() = default;
};
class ChangeMcubeNebulaTaskStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeMcubeNebulaTaskStatusResponseBody> body{};

  ChangeMcubeNebulaTaskStatusResponse() {}

  explicit ChangeMcubeNebulaTaskStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeMcubeNebulaTaskStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeMcubeNebulaTaskStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeMcubeNebulaTaskStatusResponse() = default;
};
class ChangeMcubePublicTaskStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  ChangeMcubePublicTaskStatusRequest() {}

  explicit ChangeMcubePublicTaskStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ChangeMcubePublicTaskStatusRequest() = default;
};
class ChangeMcubePublicTaskStatusResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  ChangeMcubePublicTaskStatusResponseBodyResultContent() {}

  explicit ChangeMcubePublicTaskStatusResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ChangeMcubePublicTaskStatusResponseBodyResultContent() = default;
};
class ChangeMcubePublicTaskStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<ChangeMcubePublicTaskStatusResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  ChangeMcubePublicTaskStatusResponseBody() {}

  explicit ChangeMcubePublicTaskStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        ChangeMcubePublicTaskStatusResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<ChangeMcubePublicTaskStatusResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~ChangeMcubePublicTaskStatusResponseBody() = default;
};
class ChangeMcubePublicTaskStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeMcubePublicTaskStatusResponseBody> body{};

  ChangeMcubePublicTaskStatusResponse() {}

  explicit ChangeMcubePublicTaskStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeMcubePublicTaskStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeMcubePublicTaskStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeMcubePublicTaskStatusResponse() = default;
};
class CopyMcdpGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMappcenterMcdpGroupCopyJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  CopyMcdpGroupRequest() {}

  explicit CopyMcdpGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMappcenterMcdpGroupCopyJsonStr) {
      res["MpaasMappcenterMcdpGroupCopyJsonStr"] = boost::any(*mpaasMappcenterMcdpGroupCopyJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMappcenterMcdpGroupCopyJsonStr") != m.end() && !m["MpaasMappcenterMcdpGroupCopyJsonStr"].empty()) {
      mpaasMappcenterMcdpGroupCopyJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMappcenterMcdpGroupCopyJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CopyMcdpGroupRequest() = default;
};
class CopyMcdpGroupResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  CopyMcdpGroupResponseBodyResultContent() {}

  explicit CopyMcdpGroupResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CopyMcdpGroupResponseBodyResultContent() = default;
};
class CopyMcdpGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<CopyMcdpGroupResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  CopyMcdpGroupResponseBody() {}

  explicit CopyMcdpGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        CopyMcdpGroupResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<CopyMcdpGroupResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~CopyMcdpGroupResponseBody() = default;
};
class CopyMcdpGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CopyMcdpGroupResponseBody> body{};

  CopyMcdpGroupResponse() {}

  explicit CopyMcdpGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CopyMcdpGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CopyMcdpGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CopyMcdpGroupResponse() = default;
};
class CreateMasCrowdRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMappcenterMcdpMasCrowdCreateJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  CreateMasCrowdRequest() {}

  explicit CreateMasCrowdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMappcenterMcdpMasCrowdCreateJsonStr) {
      res["MpaasMappcenterMcdpMasCrowdCreateJsonStr"] = boost::any(*mpaasMappcenterMcdpMasCrowdCreateJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMappcenterMcdpMasCrowdCreateJsonStr") != m.end() && !m["MpaasMappcenterMcdpMasCrowdCreateJsonStr"].empty()) {
      mpaasMappcenterMcdpMasCrowdCreateJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMappcenterMcdpMasCrowdCreateJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateMasCrowdRequest() = default;
};
class CreateMasCrowdResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  CreateMasCrowdResponseBodyResultContent() {}

  explicit CreateMasCrowdResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMasCrowdResponseBodyResultContent() = default;
};
class CreateMasCrowdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<CreateMasCrowdResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  CreateMasCrowdResponseBody() {}

  explicit CreateMasCrowdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        CreateMasCrowdResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<CreateMasCrowdResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~CreateMasCrowdResponseBody() = default;
};
class CreateMasCrowdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMasCrowdResponseBody> body{};

  CreateMasCrowdResponse() {}

  explicit CreateMasCrowdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMasCrowdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMasCrowdResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMasCrowdResponse() = default;
};
class CreateMasFunnelRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMappcenterMcdpMasFunnelCreateJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  CreateMasFunnelRequest() {}

  explicit CreateMasFunnelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMappcenterMcdpMasFunnelCreateJsonStr) {
      res["MpaasMappcenterMcdpMasFunnelCreateJsonStr"] = boost::any(*mpaasMappcenterMcdpMasFunnelCreateJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMappcenterMcdpMasFunnelCreateJsonStr") != m.end() && !m["MpaasMappcenterMcdpMasFunnelCreateJsonStr"].empty()) {
      mpaasMappcenterMcdpMasFunnelCreateJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMappcenterMcdpMasFunnelCreateJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateMasFunnelRequest() = default;
};
class CreateMasFunnelResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  CreateMasFunnelResponseBodyResultContent() {}

  explicit CreateMasFunnelResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMasFunnelResponseBodyResultContent() = default;
};
class CreateMasFunnelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<CreateMasFunnelResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  CreateMasFunnelResponseBody() {}

  explicit CreateMasFunnelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        CreateMasFunnelResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<CreateMasFunnelResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~CreateMasFunnelResponseBody() = default;
};
class CreateMasFunnelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMasFunnelResponseBody> body{};

  CreateMasFunnelResponse() {}

  explicit CreateMasFunnelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMasFunnelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMasFunnelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMasFunnelResponse() = default;
};
class CreateMcdpEventRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMappcenterMcdpEventCreateJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  CreateMcdpEventRequest() {}

  explicit CreateMcdpEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMappcenterMcdpEventCreateJsonStr) {
      res["MpaasMappcenterMcdpEventCreateJsonStr"] = boost::any(*mpaasMappcenterMcdpEventCreateJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMappcenterMcdpEventCreateJsonStr") != m.end() && !m["MpaasMappcenterMcdpEventCreateJsonStr"].empty()) {
      mpaasMappcenterMcdpEventCreateJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMappcenterMcdpEventCreateJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateMcdpEventRequest() = default;
};
class CreateMcdpEventResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  CreateMcdpEventResponseBodyResultContent() {}

  explicit CreateMcdpEventResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMcdpEventResponseBodyResultContent() = default;
};
class CreateMcdpEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<CreateMcdpEventResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  CreateMcdpEventResponseBody() {}

  explicit CreateMcdpEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        CreateMcdpEventResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<CreateMcdpEventResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~CreateMcdpEventResponseBody() = default;
};
class CreateMcdpEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMcdpEventResponseBody> body{};

  CreateMcdpEventResponse() {}

  explicit CreateMcdpEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMcdpEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMcdpEventResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMcdpEventResponse() = default;
};
class CreateMcdpEventAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMappcenterMcdpEventAttributeCreateJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  CreateMcdpEventAttributeRequest() {}

  explicit CreateMcdpEventAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMappcenterMcdpEventAttributeCreateJsonStr) {
      res["MpaasMappcenterMcdpEventAttributeCreateJsonStr"] = boost::any(*mpaasMappcenterMcdpEventAttributeCreateJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMappcenterMcdpEventAttributeCreateJsonStr") != m.end() && !m["MpaasMappcenterMcdpEventAttributeCreateJsonStr"].empty()) {
      mpaasMappcenterMcdpEventAttributeCreateJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMappcenterMcdpEventAttributeCreateJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateMcdpEventAttributeRequest() = default;
};
class CreateMcdpEventAttributeResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  CreateMcdpEventAttributeResponseBodyResultContent() {}

  explicit CreateMcdpEventAttributeResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMcdpEventAttributeResponseBodyResultContent() = default;
};
class CreateMcdpEventAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<CreateMcdpEventAttributeResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  CreateMcdpEventAttributeResponseBody() {}

  explicit CreateMcdpEventAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        CreateMcdpEventAttributeResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<CreateMcdpEventAttributeResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~CreateMcdpEventAttributeResponseBody() = default;
};
class CreateMcdpEventAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMcdpEventAttributeResponseBody> body{};

  CreateMcdpEventAttributeResponse() {}

  explicit CreateMcdpEventAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMcdpEventAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMcdpEventAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMcdpEventAttributeResponse() = default;
};
class CreateMcdpGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMappcenterMcdpGroupCreateJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  CreateMcdpGroupRequest() {}

  explicit CreateMcdpGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMappcenterMcdpGroupCreateJsonStr) {
      res["MpaasMappcenterMcdpGroupCreateJsonStr"] = boost::any(*mpaasMappcenterMcdpGroupCreateJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMappcenterMcdpGroupCreateJsonStr") != m.end() && !m["MpaasMappcenterMcdpGroupCreateJsonStr"].empty()) {
      mpaasMappcenterMcdpGroupCreateJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMappcenterMcdpGroupCreateJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateMcdpGroupRequest() = default;
};
class CreateMcdpGroupResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  CreateMcdpGroupResponseBodyResultContent() {}

  explicit CreateMcdpGroupResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMcdpGroupResponseBodyResultContent() = default;
};
class CreateMcdpGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<CreateMcdpGroupResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  CreateMcdpGroupResponseBody() {}

  explicit CreateMcdpGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        CreateMcdpGroupResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<CreateMcdpGroupResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~CreateMcdpGroupResponseBody() = default;
};
class CreateMcdpGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMcdpGroupResponseBody> body{};

  CreateMcdpGroupResponse() {}

  explicit CreateMcdpGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMcdpGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMcdpGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMcdpGroupResponse() = default;
};
class CreateMcdpMaterialRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMappcenterMcdpMaterialCreateJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  CreateMcdpMaterialRequest() {}

  explicit CreateMcdpMaterialRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMappcenterMcdpMaterialCreateJsonStr) {
      res["MpaasMappcenterMcdpMaterialCreateJsonStr"] = boost::any(*mpaasMappcenterMcdpMaterialCreateJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMappcenterMcdpMaterialCreateJsonStr") != m.end() && !m["MpaasMappcenterMcdpMaterialCreateJsonStr"].empty()) {
      mpaasMappcenterMcdpMaterialCreateJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMappcenterMcdpMaterialCreateJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateMcdpMaterialRequest() = default;
};
class CreateMcdpMaterialResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  CreateMcdpMaterialResponseBodyResultContent() {}

  explicit CreateMcdpMaterialResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMcdpMaterialResponseBodyResultContent() = default;
};
class CreateMcdpMaterialResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<CreateMcdpMaterialResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  CreateMcdpMaterialResponseBody() {}

  explicit CreateMcdpMaterialResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        CreateMcdpMaterialResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<CreateMcdpMaterialResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~CreateMcdpMaterialResponseBody() = default;
};
class CreateMcdpMaterialResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMcdpMaterialResponseBody> body{};

  CreateMcdpMaterialResponse() {}

  explicit CreateMcdpMaterialResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMcdpMaterialResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMcdpMaterialResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMcdpMaterialResponse() = default;
};
class CreateMcdpZoneRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMappcenterMcdpZoneCreateJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  CreateMcdpZoneRequest() {}

  explicit CreateMcdpZoneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMappcenterMcdpZoneCreateJsonStr) {
      res["MpaasMappcenterMcdpZoneCreateJsonStr"] = boost::any(*mpaasMappcenterMcdpZoneCreateJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMappcenterMcdpZoneCreateJsonStr") != m.end() && !m["MpaasMappcenterMcdpZoneCreateJsonStr"].empty()) {
      mpaasMappcenterMcdpZoneCreateJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMappcenterMcdpZoneCreateJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateMcdpZoneRequest() = default;
};
class CreateMcdpZoneResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  CreateMcdpZoneResponseBodyResultContent() {}

  explicit CreateMcdpZoneResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMcdpZoneResponseBodyResultContent() = default;
};
class CreateMcdpZoneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<CreateMcdpZoneResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  CreateMcdpZoneResponseBody() {}

  explicit CreateMcdpZoneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        CreateMcdpZoneResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<CreateMcdpZoneResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~CreateMcdpZoneResponseBody() = default;
};
class CreateMcdpZoneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMcdpZoneResponseBody> body{};

  CreateMcdpZoneResponse() {}

  explicit CreateMcdpZoneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMcdpZoneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMcdpZoneResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMcdpZoneResponse() = default;
};
class CreateMcubeMiniAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> h5Id{};
  shared_ptr<string> h5Name{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  CreateMcubeMiniAppRequest() {}

  explicit CreateMcubeMiniAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (h5Id) {
      res["H5Id"] = boost::any(*h5Id);
    }
    if (h5Name) {
      res["H5Name"] = boost::any(*h5Name);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("H5Id") != m.end() && !m["H5Id"].empty()) {
      h5Id = make_shared<string>(boost::any_cast<string>(m["H5Id"]));
    }
    if (m.find("H5Name") != m.end() && !m["H5Name"].empty()) {
      h5Name = make_shared<string>(boost::any_cast<string>(m["H5Name"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateMcubeMiniAppRequest() = default;
};
class CreateMcubeMiniAppResponseBodyCreateMiniResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  CreateMcubeMiniAppResponseBodyCreateMiniResult() {}

  explicit CreateMcubeMiniAppResponseBodyCreateMiniResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMcubeMiniAppResponseBodyCreateMiniResult() = default;
};
class CreateMcubeMiniAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateMcubeMiniAppResponseBodyCreateMiniResult> createMiniResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  CreateMcubeMiniAppResponseBody() {}

  explicit CreateMcubeMiniAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createMiniResult) {
      res["CreateMiniResult"] = createMiniResult ? boost::any(createMiniResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateMiniResult") != m.end() && !m["CreateMiniResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateMiniResult"].type()) {
        CreateMcubeMiniAppResponseBodyCreateMiniResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateMiniResult"]));
        createMiniResult = make_shared<CreateMcubeMiniAppResponseBodyCreateMiniResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~CreateMcubeMiniAppResponseBody() = default;
};
class CreateMcubeMiniAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMcubeMiniAppResponseBody> body{};

  CreateMcubeMiniAppResponse() {}

  explicit CreateMcubeMiniAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMcubeMiniAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMcubeMiniAppResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMcubeMiniAppResponse() = default;
};
class CreateMcubeMiniTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> greyConfigInfo{};
  shared_ptr<string> greyEndtimeData{};
  shared_ptr<long> greyNum{};
  shared_ptr<string> memo{};
  shared_ptr<long> packageId{};
  shared_ptr<long> publishMode{};
  shared_ptr<long> publishType{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> whitelistIds{};
  shared_ptr<string> workspaceId{};

  CreateMcubeMiniTaskRequest() {}

  explicit CreateMcubeMiniTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (greyConfigInfo) {
      res["GreyConfigInfo"] = boost::any(*greyConfigInfo);
    }
    if (greyEndtimeData) {
      res["GreyEndtimeData"] = boost::any(*greyEndtimeData);
    }
    if (greyNum) {
      res["GreyNum"] = boost::any(*greyNum);
    }
    if (memo) {
      res["Memo"] = boost::any(*memo);
    }
    if (packageId) {
      res["PackageId"] = boost::any(*packageId);
    }
    if (publishMode) {
      res["PublishMode"] = boost::any(*publishMode);
    }
    if (publishType) {
      res["PublishType"] = boost::any(*publishType);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (whitelistIds) {
      res["WhitelistIds"] = boost::any(*whitelistIds);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GreyConfigInfo") != m.end() && !m["GreyConfigInfo"].empty()) {
      greyConfigInfo = make_shared<string>(boost::any_cast<string>(m["GreyConfigInfo"]));
    }
    if (m.find("GreyEndtimeData") != m.end() && !m["GreyEndtimeData"].empty()) {
      greyEndtimeData = make_shared<string>(boost::any_cast<string>(m["GreyEndtimeData"]));
    }
    if (m.find("GreyNum") != m.end() && !m["GreyNum"].empty()) {
      greyNum = make_shared<long>(boost::any_cast<long>(m["GreyNum"]));
    }
    if (m.find("Memo") != m.end() && !m["Memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["Memo"]));
    }
    if (m.find("PackageId") != m.end() && !m["PackageId"].empty()) {
      packageId = make_shared<long>(boost::any_cast<long>(m["PackageId"]));
    }
    if (m.find("PublishMode") != m.end() && !m["PublishMode"].empty()) {
      publishMode = make_shared<long>(boost::any_cast<long>(m["PublishMode"]));
    }
    if (m.find("PublishType") != m.end() && !m["PublishType"].empty()) {
      publishType = make_shared<long>(boost::any_cast<long>(m["PublishType"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WhitelistIds") != m.end() && !m["WhitelistIds"].empty()) {
      whitelistIds = make_shared<string>(boost::any_cast<string>(m["WhitelistIds"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateMcubeMiniTaskRequest() = default;
};
class CreateMcubeMiniTaskResponseBodyCreateMiniTaskResult : public Darabonba::Model {
public:
  shared_ptr<string> miniTaskId{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  CreateMcubeMiniTaskResponseBodyCreateMiniTaskResult() {}

  explicit CreateMcubeMiniTaskResponseBodyCreateMiniTaskResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (miniTaskId) {
      res["MiniTaskId"] = boost::any(*miniTaskId);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MiniTaskId") != m.end() && !m["MiniTaskId"].empty()) {
      miniTaskId = make_shared<string>(boost::any_cast<string>(m["MiniTaskId"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMcubeMiniTaskResponseBodyCreateMiniTaskResult() = default;
};
class CreateMcubeMiniTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateMcubeMiniTaskResponseBodyCreateMiniTaskResult> createMiniTaskResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  CreateMcubeMiniTaskResponseBody() {}

  explicit CreateMcubeMiniTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createMiniTaskResult) {
      res["CreateMiniTaskResult"] = createMiniTaskResult ? boost::any(createMiniTaskResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateMiniTaskResult") != m.end() && !m["CreateMiniTaskResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateMiniTaskResult"].type()) {
        CreateMcubeMiniTaskResponseBodyCreateMiniTaskResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateMiniTaskResult"]));
        createMiniTaskResult = make_shared<CreateMcubeMiniTaskResponseBodyCreateMiniTaskResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~CreateMcubeMiniTaskResponseBody() = default;
};
class CreateMcubeMiniTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMcubeMiniTaskResponseBody> body{};

  CreateMcubeMiniTaskResponse() {}

  explicit CreateMcubeMiniTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMcubeMiniTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMcubeMiniTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMcubeMiniTaskResponse() = default;
};
class CreateMcubeNebulaAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> h5Id{};
  shared_ptr<string> h5Name{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  CreateMcubeNebulaAppRequest() {}

  explicit CreateMcubeNebulaAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (h5Id) {
      res["H5Id"] = boost::any(*h5Id);
    }
    if (h5Name) {
      res["H5Name"] = boost::any(*h5Name);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("H5Id") != m.end() && !m["H5Id"].empty()) {
      h5Id = make_shared<string>(boost::any_cast<string>(m["H5Id"]));
    }
    if (m.find("H5Name") != m.end() && !m["H5Name"].empty()) {
      h5Name = make_shared<string>(boost::any_cast<string>(m["H5Name"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateMcubeNebulaAppRequest() = default;
};
class CreateMcubeNebulaAppResponseBodyCreateNebulaAppResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  CreateMcubeNebulaAppResponseBodyCreateNebulaAppResult() {}

  explicit CreateMcubeNebulaAppResponseBodyCreateNebulaAppResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMcubeNebulaAppResponseBodyCreateNebulaAppResult() = default;
};
class CreateMcubeNebulaAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateMcubeNebulaAppResponseBodyCreateNebulaAppResult> createNebulaAppResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  CreateMcubeNebulaAppResponseBody() {}

  explicit CreateMcubeNebulaAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createNebulaAppResult) {
      res["CreateNebulaAppResult"] = createNebulaAppResult ? boost::any(createNebulaAppResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateNebulaAppResult") != m.end() && !m["CreateNebulaAppResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateNebulaAppResult"].type()) {
        CreateMcubeNebulaAppResponseBodyCreateNebulaAppResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateNebulaAppResult"]));
        createNebulaAppResult = make_shared<CreateMcubeNebulaAppResponseBodyCreateNebulaAppResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~CreateMcubeNebulaAppResponseBody() = default;
};
class CreateMcubeNebulaAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMcubeNebulaAppResponseBody> body{};

  CreateMcubeNebulaAppResponse() {}

  explicit CreateMcubeNebulaAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMcubeNebulaAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMcubeNebulaAppResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMcubeNebulaAppResponse() = default;
};
class CreateMcubeNebulaResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> autoInstall{};
  shared_ptr<string> clientVersionMax{};
  shared_ptr<string> clientVersionMin{};
  shared_ptr<string> customDomainName{};
  shared_ptr<string> extendInfo{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> h5Id{};
  shared_ptr<string> h5Name{};
  shared_ptr<string> h5Version{};
  shared_ptr<long> installType{};
  shared_ptr<string> mainUrl{};
  shared_ptr<bool> onexFlag{};
  shared_ptr<string> platform{};
  shared_ptr<long> repeatNebula{};
  shared_ptr<long> resourceType{};
  shared_ptr<string> subUrl{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> vhost{};
  shared_ptr<string> workspaceId{};

  CreateMcubeNebulaResourceRequest() {}

  explicit CreateMcubeNebulaResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (autoInstall) {
      res["AutoInstall"] = boost::any(*autoInstall);
    }
    if (clientVersionMax) {
      res["ClientVersionMax"] = boost::any(*clientVersionMax);
    }
    if (clientVersionMin) {
      res["ClientVersionMin"] = boost::any(*clientVersionMin);
    }
    if (customDomainName) {
      res["CustomDomainName"] = boost::any(*customDomainName);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (h5Id) {
      res["H5Id"] = boost::any(*h5Id);
    }
    if (h5Name) {
      res["H5Name"] = boost::any(*h5Name);
    }
    if (h5Version) {
      res["H5Version"] = boost::any(*h5Version);
    }
    if (installType) {
      res["InstallType"] = boost::any(*installType);
    }
    if (mainUrl) {
      res["MainUrl"] = boost::any(*mainUrl);
    }
    if (onexFlag) {
      res["OnexFlag"] = boost::any(*onexFlag);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (repeatNebula) {
      res["RepeatNebula"] = boost::any(*repeatNebula);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (subUrl) {
      res["SubUrl"] = boost::any(*subUrl);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (vhost) {
      res["Vhost"] = boost::any(*vhost);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AutoInstall") != m.end() && !m["AutoInstall"].empty()) {
      autoInstall = make_shared<long>(boost::any_cast<long>(m["AutoInstall"]));
    }
    if (m.find("ClientVersionMax") != m.end() && !m["ClientVersionMax"].empty()) {
      clientVersionMax = make_shared<string>(boost::any_cast<string>(m["ClientVersionMax"]));
    }
    if (m.find("ClientVersionMin") != m.end() && !m["ClientVersionMin"].empty()) {
      clientVersionMin = make_shared<string>(boost::any_cast<string>(m["ClientVersionMin"]));
    }
    if (m.find("CustomDomainName") != m.end() && !m["CustomDomainName"].empty()) {
      customDomainName = make_shared<string>(boost::any_cast<string>(m["CustomDomainName"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      extendInfo = make_shared<string>(boost::any_cast<string>(m["ExtendInfo"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("H5Id") != m.end() && !m["H5Id"].empty()) {
      h5Id = make_shared<string>(boost::any_cast<string>(m["H5Id"]));
    }
    if (m.find("H5Name") != m.end() && !m["H5Name"].empty()) {
      h5Name = make_shared<string>(boost::any_cast<string>(m["H5Name"]));
    }
    if (m.find("H5Version") != m.end() && !m["H5Version"].empty()) {
      h5Version = make_shared<string>(boost::any_cast<string>(m["H5Version"]));
    }
    if (m.find("InstallType") != m.end() && !m["InstallType"].empty()) {
      installType = make_shared<long>(boost::any_cast<long>(m["InstallType"]));
    }
    if (m.find("MainUrl") != m.end() && !m["MainUrl"].empty()) {
      mainUrl = make_shared<string>(boost::any_cast<string>(m["MainUrl"]));
    }
    if (m.find("OnexFlag") != m.end() && !m["OnexFlag"].empty()) {
      onexFlag = make_shared<bool>(boost::any_cast<bool>(m["OnexFlag"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("RepeatNebula") != m.end() && !m["RepeatNebula"].empty()) {
      repeatNebula = make_shared<long>(boost::any_cast<long>(m["RepeatNebula"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<long>(boost::any_cast<long>(m["ResourceType"]));
    }
    if (m.find("SubUrl") != m.end() && !m["SubUrl"].empty()) {
      subUrl = make_shared<string>(boost::any_cast<string>(m["SubUrl"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("Vhost") != m.end() && !m["Vhost"].empty()) {
      vhost = make_shared<string>(boost::any_cast<string>(m["Vhost"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateMcubeNebulaResourceRequest() = default;
};
class CreateMcubeNebulaResourceResponseBodyCreateMcubeNebulaResourceReslult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> nebulaResourceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  CreateMcubeNebulaResourceResponseBodyCreateMcubeNebulaResourceReslult() {}

  explicit CreateMcubeNebulaResourceResponseBodyCreateMcubeNebulaResourceReslult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (nebulaResourceId) {
      res["NebulaResourceId"] = boost::any(*nebulaResourceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("NebulaResourceId") != m.end() && !m["NebulaResourceId"].empty()) {
      nebulaResourceId = make_shared<string>(boost::any_cast<string>(m["NebulaResourceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMcubeNebulaResourceResponseBodyCreateMcubeNebulaResourceReslult() = default;
};
class CreateMcubeNebulaResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateMcubeNebulaResourceResponseBodyCreateMcubeNebulaResourceReslult> createMcubeNebulaResourceReslult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  CreateMcubeNebulaResourceResponseBody() {}

  explicit CreateMcubeNebulaResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createMcubeNebulaResourceReslult) {
      res["CreateMcubeNebulaResourceReslult"] = createMcubeNebulaResourceReslult ? boost::any(createMcubeNebulaResourceReslult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateMcubeNebulaResourceReslult") != m.end() && !m["CreateMcubeNebulaResourceReslult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateMcubeNebulaResourceReslult"].type()) {
        CreateMcubeNebulaResourceResponseBodyCreateMcubeNebulaResourceReslult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateMcubeNebulaResourceReslult"]));
        createMcubeNebulaResourceReslult = make_shared<CreateMcubeNebulaResourceResponseBodyCreateMcubeNebulaResourceReslult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~CreateMcubeNebulaResourceResponseBody() = default;
};
class CreateMcubeNebulaResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMcubeNebulaResourceResponseBody> body{};

  CreateMcubeNebulaResourceResponse() {}

  explicit CreateMcubeNebulaResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMcubeNebulaResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMcubeNebulaResourceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMcubeNebulaResourceResponse() = default;
};
class CreateMcubeNebulaTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<string> appId{};
  shared_ptr<string> bizType{};
  shared_ptr<string> creator{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> gmtModifiedStr{};
  shared_ptr<string> greyConfigInfo{};
  shared_ptr<string> greyEndtime{};
  shared_ptr<string> greyEndtimeData{};
  shared_ptr<string> greyEndtimeStr{};
  shared_ptr<long> greyNum{};
  shared_ptr<string> greyUrl{};
  shared_ptr<long> id{};
  shared_ptr<string> memo{};
  shared_ptr<string> modifier{};
  shared_ptr<long> packageId{};
  shared_ptr<long> percent{};
  shared_ptr<string> platform{};
  shared_ptr<string> productId{};
  shared_ptr<string> productVersion{};
  shared_ptr<long> publishMode{};
  shared_ptr<long> publishType{};
  shared_ptr<string> releaseVersion{};
  shared_ptr<string> resIds{};
  shared_ptr<long> serialVersionUID{};
  shared_ptr<long> status{};
  shared_ptr<string> syncMode{};
  shared_ptr<string> syncResult{};
  shared_ptr<string> taskName{};
  shared_ptr<long> taskStatus{};
  shared_ptr<long> taskType{};
  shared_ptr<long> taskVersion{};
  shared_ptr<string> tenantId{};
  shared_ptr<long> upgradeNoticeNum{};
  shared_ptr<string> upgradeProgress{};
  shared_ptr<string> whitelistIds{};
  shared_ptr<string> workspaceId{};

  CreateMcubeNebulaTaskRequest() {}

  explicit CreateMcubeNebulaTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtModifiedStr) {
      res["GmtModifiedStr"] = boost::any(*gmtModifiedStr);
    }
    if (greyConfigInfo) {
      res["GreyConfigInfo"] = boost::any(*greyConfigInfo);
    }
    if (greyEndtime) {
      res["GreyEndtime"] = boost::any(*greyEndtime);
    }
    if (greyEndtimeData) {
      res["GreyEndtimeData"] = boost::any(*greyEndtimeData);
    }
    if (greyEndtimeStr) {
      res["GreyEndtimeStr"] = boost::any(*greyEndtimeStr);
    }
    if (greyNum) {
      res["GreyNum"] = boost::any(*greyNum);
    }
    if (greyUrl) {
      res["GreyUrl"] = boost::any(*greyUrl);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (memo) {
      res["Memo"] = boost::any(*memo);
    }
    if (modifier) {
      res["Modifier"] = boost::any(*modifier);
    }
    if (packageId) {
      res["PackageId"] = boost::any(*packageId);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (productId) {
      res["ProductId"] = boost::any(*productId);
    }
    if (productVersion) {
      res["ProductVersion"] = boost::any(*productVersion);
    }
    if (publishMode) {
      res["PublishMode"] = boost::any(*publishMode);
    }
    if (publishType) {
      res["PublishType"] = boost::any(*publishType);
    }
    if (releaseVersion) {
      res["ReleaseVersion"] = boost::any(*releaseVersion);
    }
    if (resIds) {
      res["ResIds"] = boost::any(*resIds);
    }
    if (serialVersionUID) {
      res["SerialVersionUID"] = boost::any(*serialVersionUID);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (syncMode) {
      res["SyncMode"] = boost::any(*syncMode);
    }
    if (syncResult) {
      res["SyncResult"] = boost::any(*syncResult);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (taskVersion) {
      res["TaskVersion"] = boost::any(*taskVersion);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (upgradeNoticeNum) {
      res["UpgradeNoticeNum"] = boost::any(*upgradeNoticeNum);
    }
    if (upgradeProgress) {
      res["UpgradeProgress"] = boost::any(*upgradeProgress);
    }
    if (whitelistIds) {
      res["WhitelistIds"] = boost::any(*whitelistIds);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtModifiedStr") != m.end() && !m["GmtModifiedStr"].empty()) {
      gmtModifiedStr = make_shared<string>(boost::any_cast<string>(m["GmtModifiedStr"]));
    }
    if (m.find("GreyConfigInfo") != m.end() && !m["GreyConfigInfo"].empty()) {
      greyConfigInfo = make_shared<string>(boost::any_cast<string>(m["GreyConfigInfo"]));
    }
    if (m.find("GreyEndtime") != m.end() && !m["GreyEndtime"].empty()) {
      greyEndtime = make_shared<string>(boost::any_cast<string>(m["GreyEndtime"]));
    }
    if (m.find("GreyEndtimeData") != m.end() && !m["GreyEndtimeData"].empty()) {
      greyEndtimeData = make_shared<string>(boost::any_cast<string>(m["GreyEndtimeData"]));
    }
    if (m.find("GreyEndtimeStr") != m.end() && !m["GreyEndtimeStr"].empty()) {
      greyEndtimeStr = make_shared<string>(boost::any_cast<string>(m["GreyEndtimeStr"]));
    }
    if (m.find("GreyNum") != m.end() && !m["GreyNum"].empty()) {
      greyNum = make_shared<long>(boost::any_cast<long>(m["GreyNum"]));
    }
    if (m.find("GreyUrl") != m.end() && !m["GreyUrl"].empty()) {
      greyUrl = make_shared<string>(boost::any_cast<string>(m["GreyUrl"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Memo") != m.end() && !m["Memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["Memo"]));
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["Modifier"]));
    }
    if (m.find("PackageId") != m.end() && !m["PackageId"].empty()) {
      packageId = make_shared<long>(boost::any_cast<long>(m["PackageId"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("ProductId") != m.end() && !m["ProductId"].empty()) {
      productId = make_shared<string>(boost::any_cast<string>(m["ProductId"]));
    }
    if (m.find("ProductVersion") != m.end() && !m["ProductVersion"].empty()) {
      productVersion = make_shared<string>(boost::any_cast<string>(m["ProductVersion"]));
    }
    if (m.find("PublishMode") != m.end() && !m["PublishMode"].empty()) {
      publishMode = make_shared<long>(boost::any_cast<long>(m["PublishMode"]));
    }
    if (m.find("PublishType") != m.end() && !m["PublishType"].empty()) {
      publishType = make_shared<long>(boost::any_cast<long>(m["PublishType"]));
    }
    if (m.find("ReleaseVersion") != m.end() && !m["ReleaseVersion"].empty()) {
      releaseVersion = make_shared<string>(boost::any_cast<string>(m["ReleaseVersion"]));
    }
    if (m.find("ResIds") != m.end() && !m["ResIds"].empty()) {
      resIds = make_shared<string>(boost::any_cast<string>(m["ResIds"]));
    }
    if (m.find("SerialVersionUID") != m.end() && !m["SerialVersionUID"].empty()) {
      serialVersionUID = make_shared<long>(boost::any_cast<long>(m["SerialVersionUID"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("SyncMode") != m.end() && !m["SyncMode"].empty()) {
      syncMode = make_shared<string>(boost::any_cast<string>(m["SyncMode"]));
    }
    if (m.find("SyncResult") != m.end() && !m["SyncResult"].empty()) {
      syncResult = make_shared<string>(boost::any_cast<string>(m["SyncResult"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<long>(boost::any_cast<long>(m["TaskStatus"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
    if (m.find("TaskVersion") != m.end() && !m["TaskVersion"].empty()) {
      taskVersion = make_shared<long>(boost::any_cast<long>(m["TaskVersion"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("UpgradeNoticeNum") != m.end() && !m["UpgradeNoticeNum"].empty()) {
      upgradeNoticeNum = make_shared<long>(boost::any_cast<long>(m["UpgradeNoticeNum"]));
    }
    if (m.find("UpgradeProgress") != m.end() && !m["UpgradeProgress"].empty()) {
      upgradeProgress = make_shared<string>(boost::any_cast<string>(m["UpgradeProgress"]));
    }
    if (m.find("WhitelistIds") != m.end() && !m["WhitelistIds"].empty()) {
      whitelistIds = make_shared<string>(boost::any_cast<string>(m["WhitelistIds"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateMcubeNebulaTaskRequest() = default;
};
class CreateMcubeNebulaTaskResponseBodyCreateMcubeNebulaTaskResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> nebulaTaskId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  CreateMcubeNebulaTaskResponseBodyCreateMcubeNebulaTaskResult() {}

  explicit CreateMcubeNebulaTaskResponseBodyCreateMcubeNebulaTaskResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (nebulaTaskId) {
      res["NebulaTaskId"] = boost::any(*nebulaTaskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("NebulaTaskId") != m.end() && !m["NebulaTaskId"].empty()) {
      nebulaTaskId = make_shared<string>(boost::any_cast<string>(m["NebulaTaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMcubeNebulaTaskResponseBodyCreateMcubeNebulaTaskResult() = default;
};
class CreateMcubeNebulaTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateMcubeNebulaTaskResponseBodyCreateMcubeNebulaTaskResult> createMcubeNebulaTaskResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  CreateMcubeNebulaTaskResponseBody() {}

  explicit CreateMcubeNebulaTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createMcubeNebulaTaskResult) {
      res["CreateMcubeNebulaTaskResult"] = createMcubeNebulaTaskResult ? boost::any(createMcubeNebulaTaskResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateMcubeNebulaTaskResult") != m.end() && !m["CreateMcubeNebulaTaskResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateMcubeNebulaTaskResult"].type()) {
        CreateMcubeNebulaTaskResponseBodyCreateMcubeNebulaTaskResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateMcubeNebulaTaskResult"]));
        createMcubeNebulaTaskResult = make_shared<CreateMcubeNebulaTaskResponseBodyCreateMcubeNebulaTaskResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~CreateMcubeNebulaTaskResponseBody() = default;
};
class CreateMcubeNebulaTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMcubeNebulaTaskResponseBody> body{};

  CreateMcubeNebulaTaskResponse() {}

  explicit CreateMcubeNebulaTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMcubeNebulaTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMcubeNebulaTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMcubeNebulaTaskResponse() = default;
};
class CreateMcubeUpgradePackageRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appVersion{};
  shared_ptr<string> appstoreUrl{};
  shared_ptr<string> bundleId{};
  shared_ptr<string> customDomainName{};
  shared_ptr<string> desc{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> iconFileUrl{};
  shared_ptr<long> installAmount{};
  shared_ptr<string> iosSymbolfileUrl{};
  shared_ptr<long> isEnterprise{};
  shared_ptr<long> needCheck{};
  shared_ptr<bool> onexFlag{};
  shared_ptr<string> platform{};
  shared_ptr<string> tenantId{};
  shared_ptr<long> validDays{};
  shared_ptr<string> workspaceId{};

  CreateMcubeUpgradePackageRequest() {}

  explicit CreateMcubeUpgradePackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appVersion) {
      res["AppVersion"] = boost::any(*appVersion);
    }
    if (appstoreUrl) {
      res["AppstoreUrl"] = boost::any(*appstoreUrl);
    }
    if (bundleId) {
      res["BundleId"] = boost::any(*bundleId);
    }
    if (customDomainName) {
      res["CustomDomainName"] = boost::any(*customDomainName);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (iconFileUrl) {
      res["IconFileUrl"] = boost::any(*iconFileUrl);
    }
    if (installAmount) {
      res["InstallAmount"] = boost::any(*installAmount);
    }
    if (iosSymbolfileUrl) {
      res["IosSymbolfileUrl"] = boost::any(*iosSymbolfileUrl);
    }
    if (isEnterprise) {
      res["IsEnterprise"] = boost::any(*isEnterprise);
    }
    if (needCheck) {
      res["NeedCheck"] = boost::any(*needCheck);
    }
    if (onexFlag) {
      res["OnexFlag"] = boost::any(*onexFlag);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (validDays) {
      res["ValidDays"] = boost::any(*validDays);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppVersion") != m.end() && !m["AppVersion"].empty()) {
      appVersion = make_shared<string>(boost::any_cast<string>(m["AppVersion"]));
    }
    if (m.find("AppstoreUrl") != m.end() && !m["AppstoreUrl"].empty()) {
      appstoreUrl = make_shared<string>(boost::any_cast<string>(m["AppstoreUrl"]));
    }
    if (m.find("BundleId") != m.end() && !m["BundleId"].empty()) {
      bundleId = make_shared<string>(boost::any_cast<string>(m["BundleId"]));
    }
    if (m.find("CustomDomainName") != m.end() && !m["CustomDomainName"].empty()) {
      customDomainName = make_shared<string>(boost::any_cast<string>(m["CustomDomainName"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("IconFileUrl") != m.end() && !m["IconFileUrl"].empty()) {
      iconFileUrl = make_shared<string>(boost::any_cast<string>(m["IconFileUrl"]));
    }
    if (m.find("InstallAmount") != m.end() && !m["InstallAmount"].empty()) {
      installAmount = make_shared<long>(boost::any_cast<long>(m["InstallAmount"]));
    }
    if (m.find("IosSymbolfileUrl") != m.end() && !m["IosSymbolfileUrl"].empty()) {
      iosSymbolfileUrl = make_shared<string>(boost::any_cast<string>(m["IosSymbolfileUrl"]));
    }
    if (m.find("IsEnterprise") != m.end() && !m["IsEnterprise"].empty()) {
      isEnterprise = make_shared<long>(boost::any_cast<long>(m["IsEnterprise"]));
    }
    if (m.find("NeedCheck") != m.end() && !m["NeedCheck"].empty()) {
      needCheck = make_shared<long>(boost::any_cast<long>(m["NeedCheck"]));
    }
    if (m.find("OnexFlag") != m.end() && !m["OnexFlag"].empty()) {
      onexFlag = make_shared<bool>(boost::any_cast<bool>(m["OnexFlag"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("ValidDays") != m.end() && !m["ValidDays"].empty()) {
      validDays = make_shared<long>(boost::any_cast<long>(m["ValidDays"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateMcubeUpgradePackageRequest() = default;
};
class CreateMcubeUpgradePackageResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  CreateMcubeUpgradePackageResponseBodyResultContent() {}

  explicit CreateMcubeUpgradePackageResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMcubeUpgradePackageResponseBodyResultContent() = default;
};
class CreateMcubeUpgradePackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<CreateMcubeUpgradePackageResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  CreateMcubeUpgradePackageResponseBody() {}

  explicit CreateMcubeUpgradePackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        CreateMcubeUpgradePackageResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<CreateMcubeUpgradePackageResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~CreateMcubeUpgradePackageResponseBody() = default;
};
class CreateMcubeUpgradePackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMcubeUpgradePackageResponseBody> body{};

  CreateMcubeUpgradePackageResponse() {}

  explicit CreateMcubeUpgradePackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMcubeUpgradePackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMcubeUpgradePackageResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMcubeUpgradePackageResponse() = default;
};
class CreateMcubeUpgradeTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> greyConfigInfo{};
  shared_ptr<string> greyEndtimeData{};
  shared_ptr<long> greyNum{};
  shared_ptr<long> historyForce{};
  shared_ptr<string> memo{};
  shared_ptr<long> packageInfoId{};
  shared_ptr<long> publishMode{};
  shared_ptr<long> publishType{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> upgradeContent{};
  shared_ptr<long> upgradeType{};
  shared_ptr<string> whitelistIds{};
  shared_ptr<string> workspaceId{};

  CreateMcubeUpgradeTaskRequest() {}

  explicit CreateMcubeUpgradeTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (greyConfigInfo) {
      res["GreyConfigInfo"] = boost::any(*greyConfigInfo);
    }
    if (greyEndtimeData) {
      res["GreyEndtimeData"] = boost::any(*greyEndtimeData);
    }
    if (greyNum) {
      res["GreyNum"] = boost::any(*greyNum);
    }
    if (historyForce) {
      res["HistoryForce"] = boost::any(*historyForce);
    }
    if (memo) {
      res["Memo"] = boost::any(*memo);
    }
    if (packageInfoId) {
      res["PackageInfoId"] = boost::any(*packageInfoId);
    }
    if (publishMode) {
      res["PublishMode"] = boost::any(*publishMode);
    }
    if (publishType) {
      res["PublishType"] = boost::any(*publishType);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (upgradeContent) {
      res["UpgradeContent"] = boost::any(*upgradeContent);
    }
    if (upgradeType) {
      res["UpgradeType"] = boost::any(*upgradeType);
    }
    if (whitelistIds) {
      res["WhitelistIds"] = boost::any(*whitelistIds);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GreyConfigInfo") != m.end() && !m["GreyConfigInfo"].empty()) {
      greyConfigInfo = make_shared<string>(boost::any_cast<string>(m["GreyConfigInfo"]));
    }
    if (m.find("GreyEndtimeData") != m.end() && !m["GreyEndtimeData"].empty()) {
      greyEndtimeData = make_shared<string>(boost::any_cast<string>(m["GreyEndtimeData"]));
    }
    if (m.find("GreyNum") != m.end() && !m["GreyNum"].empty()) {
      greyNum = make_shared<long>(boost::any_cast<long>(m["GreyNum"]));
    }
    if (m.find("HistoryForce") != m.end() && !m["HistoryForce"].empty()) {
      historyForce = make_shared<long>(boost::any_cast<long>(m["HistoryForce"]));
    }
    if (m.find("Memo") != m.end() && !m["Memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["Memo"]));
    }
    if (m.find("PackageInfoId") != m.end() && !m["PackageInfoId"].empty()) {
      packageInfoId = make_shared<long>(boost::any_cast<long>(m["PackageInfoId"]));
    }
    if (m.find("PublishMode") != m.end() && !m["PublishMode"].empty()) {
      publishMode = make_shared<long>(boost::any_cast<long>(m["PublishMode"]));
    }
    if (m.find("PublishType") != m.end() && !m["PublishType"].empty()) {
      publishType = make_shared<long>(boost::any_cast<long>(m["PublishType"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("UpgradeContent") != m.end() && !m["UpgradeContent"].empty()) {
      upgradeContent = make_shared<string>(boost::any_cast<string>(m["UpgradeContent"]));
    }
    if (m.find("UpgradeType") != m.end() && !m["UpgradeType"].empty()) {
      upgradeType = make_shared<long>(boost::any_cast<long>(m["UpgradeType"]));
    }
    if (m.find("WhitelistIds") != m.end() && !m["WhitelistIds"].empty()) {
      whitelistIds = make_shared<string>(boost::any_cast<string>(m["WhitelistIds"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateMcubeUpgradeTaskRequest() = default;
};
class CreateMcubeUpgradeTaskResponseBodyCreateTaskResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};
  shared_ptr<string> upgradeTaskId{};

  CreateMcubeUpgradeTaskResponseBodyCreateTaskResult() {}

  explicit CreateMcubeUpgradeTaskResponseBodyCreateTaskResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (upgradeTaskId) {
      res["upgradeTaskId"] = boost::any(*upgradeTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("upgradeTaskId") != m.end() && !m["upgradeTaskId"].empty()) {
      upgradeTaskId = make_shared<string>(boost::any_cast<string>(m["upgradeTaskId"]));
    }
  }


  virtual ~CreateMcubeUpgradeTaskResponseBodyCreateTaskResult() = default;
};
class CreateMcubeUpgradeTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateMcubeUpgradeTaskResponseBodyCreateTaskResult> createTaskResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  CreateMcubeUpgradeTaskResponseBody() {}

  explicit CreateMcubeUpgradeTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTaskResult) {
      res["CreateTaskResult"] = createTaskResult ? boost::any(createTaskResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTaskResult") != m.end() && !m["CreateTaskResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateTaskResult"].type()) {
        CreateMcubeUpgradeTaskResponseBodyCreateTaskResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateTaskResult"]));
        createTaskResult = make_shared<CreateMcubeUpgradeTaskResponseBodyCreateTaskResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~CreateMcubeUpgradeTaskResponseBody() = default;
};
class CreateMcubeUpgradeTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMcubeUpgradeTaskResponseBody> body{};

  CreateMcubeUpgradeTaskResponse() {}

  explicit CreateMcubeUpgradeTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMcubeUpgradeTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMcubeUpgradeTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMcubeUpgradeTaskResponse() = default;
};
class CreateMcubeVhostRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> vhost{};
  shared_ptr<string> workspaceId{};

  CreateMcubeVhostRequest() {}

  explicit CreateMcubeVhostRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (vhost) {
      res["Vhost"] = boost::any(*vhost);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("Vhost") != m.end() && !m["Vhost"].empty()) {
      vhost = make_shared<string>(boost::any_cast<string>(m["Vhost"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateMcubeVhostRequest() = default;
};
class CreateMcubeVhostResponseBodyCreateVhostResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  CreateMcubeVhostResponseBodyCreateVhostResult() {}

  explicit CreateMcubeVhostResponseBodyCreateVhostResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMcubeVhostResponseBodyCreateVhostResult() = default;
};
class CreateMcubeVhostResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateMcubeVhostResponseBodyCreateVhostResult> createVhostResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  CreateMcubeVhostResponseBody() {}

  explicit CreateMcubeVhostResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createVhostResult) {
      res["CreateVhostResult"] = createVhostResult ? boost::any(createVhostResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateVhostResult") != m.end() && !m["CreateVhostResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateVhostResult"].type()) {
        CreateMcubeVhostResponseBodyCreateVhostResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateVhostResult"]));
        createVhostResult = make_shared<CreateMcubeVhostResponseBodyCreateVhostResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~CreateMcubeVhostResponseBody() = default;
};
class CreateMcubeVhostResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMcubeVhostResponseBody> body{};

  CreateMcubeVhostResponse() {}

  explicit CreateMcubeVhostResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMcubeVhostResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMcubeVhostResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMcubeVhostResponse() = default;
};
class CreateMcubeWhitelistRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> whiteListName{};
  shared_ptr<string> whitelistType{};
  shared_ptr<string> workspaceId{};

  CreateMcubeWhitelistRequest() {}

  explicit CreateMcubeWhitelistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (whiteListName) {
      res["WhiteListName"] = boost::any(*whiteListName);
    }
    if (whitelistType) {
      res["WhitelistType"] = boost::any(*whitelistType);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WhiteListName") != m.end() && !m["WhiteListName"].empty()) {
      whiteListName = make_shared<string>(boost::any_cast<string>(m["WhiteListName"]));
    }
    if (m.find("WhitelistType") != m.end() && !m["WhitelistType"].empty()) {
      whitelistType = make_shared<string>(boost::any_cast<string>(m["WhitelistType"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateMcubeWhitelistRequest() = default;
};
class CreateMcubeWhitelistResponseBodyCreateWhitelistResult : public Darabonba::Model {
public:
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};
  shared_ptr<string> whitelistId{};

  CreateMcubeWhitelistResponseBodyCreateWhitelistResult() {}

  explicit CreateMcubeWhitelistResponseBodyCreateWhitelistResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (whitelistId) {
      res["WhitelistId"] = boost::any(*whitelistId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("WhitelistId") != m.end() && !m["WhitelistId"].empty()) {
      whitelistId = make_shared<string>(boost::any_cast<string>(m["WhitelistId"]));
    }
  }


  virtual ~CreateMcubeWhitelistResponseBodyCreateWhitelistResult() = default;
};
class CreateMcubeWhitelistResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateMcubeWhitelistResponseBodyCreateWhitelistResult> createWhitelistResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  CreateMcubeWhitelistResponseBody() {}

  explicit CreateMcubeWhitelistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createWhitelistResult) {
      res["CreateWhitelistResult"] = createWhitelistResult ? boost::any(createWhitelistResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateWhitelistResult") != m.end() && !m["CreateWhitelistResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateWhitelistResult"].type()) {
        CreateMcubeWhitelistResponseBodyCreateWhitelistResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateWhitelistResult"]));
        createWhitelistResult = make_shared<CreateMcubeWhitelistResponseBodyCreateWhitelistResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~CreateMcubeWhitelistResponseBody() = default;
};
class CreateMcubeWhitelistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMcubeWhitelistResponseBody> body{};

  CreateMcubeWhitelistResponse() {}

  explicit CreateMcubeWhitelistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMcubeWhitelistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMcubeWhitelistResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMcubeWhitelistResponse() = default;
};
class CreateMcubeWhitelistForIdeRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> userId{};
  shared_ptr<string> whitelistValue{};
  shared_ptr<string> workspaceId{};

  CreateMcubeWhitelistForIdeRequest() {}

  explicit CreateMcubeWhitelistForIdeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (whitelistValue) {
      res["WhitelistValue"] = boost::any(*whitelistValue);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WhitelistValue") != m.end() && !m["WhitelistValue"].empty()) {
      whitelistValue = make_shared<string>(boost::any_cast<string>(m["WhitelistValue"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateMcubeWhitelistForIdeRequest() = default;
};
class CreateMcubeWhitelistForIdeResponseBodyCreateWhitelistForIdeResult : public Darabonba::Model {
public:
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};
  shared_ptr<string> whitelistId{};

  CreateMcubeWhitelistForIdeResponseBodyCreateWhitelistForIdeResult() {}

  explicit CreateMcubeWhitelistForIdeResponseBodyCreateWhitelistForIdeResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (whitelistId) {
      res["WhitelistId"] = boost::any(*whitelistId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("WhitelistId") != m.end() && !m["WhitelistId"].empty()) {
      whitelistId = make_shared<string>(boost::any_cast<string>(m["WhitelistId"]));
    }
  }


  virtual ~CreateMcubeWhitelistForIdeResponseBodyCreateWhitelistForIdeResult() = default;
};
class CreateMcubeWhitelistForIdeResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateMcubeWhitelistForIdeResponseBodyCreateWhitelistForIdeResult> createWhitelistForIdeResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  CreateMcubeWhitelistForIdeResponseBody() {}

  explicit CreateMcubeWhitelistForIdeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createWhitelistForIdeResult) {
      res["CreateWhitelistForIdeResult"] = createWhitelistForIdeResult ? boost::any(createWhitelistForIdeResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateWhitelistForIdeResult") != m.end() && !m["CreateWhitelistForIdeResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateWhitelistForIdeResult"].type()) {
        CreateMcubeWhitelistForIdeResponseBodyCreateWhitelistForIdeResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateWhitelistForIdeResult"]));
        createWhitelistForIdeResult = make_shared<CreateMcubeWhitelistForIdeResponseBodyCreateWhitelistForIdeResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~CreateMcubeWhitelistForIdeResponseBody() = default;
};
class CreateMcubeWhitelistForIdeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMcubeWhitelistForIdeResponseBody> body{};

  CreateMcubeWhitelistForIdeResponse() {}

  explicit CreateMcubeWhitelistForIdeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMcubeWhitelistForIdeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMcubeWhitelistForIdeResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMcubeWhitelistForIdeResponse() = default;
};
class CreateMdsMiniprogramTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> greyConfigInfo{};
  shared_ptr<string> greyEndtimeData{};
  shared_ptr<string> greyNum{};
  shared_ptr<long> id{};
  shared_ptr<string> memo{};
  shared_ptr<long> packageId{};
  shared_ptr<string> publishMode{};
  shared_ptr<long> publishType{};
  shared_ptr<string> syncMode{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> whitelistIds{};
  shared_ptr<string> workspaceId{};

  CreateMdsMiniprogramTaskRequest() {}

  explicit CreateMdsMiniprogramTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (greyConfigInfo) {
      res["GreyConfigInfo"] = boost::any(*greyConfigInfo);
    }
    if (greyEndtimeData) {
      res["GreyEndtimeData"] = boost::any(*greyEndtimeData);
    }
    if (greyNum) {
      res["GreyNum"] = boost::any(*greyNum);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (memo) {
      res["Memo"] = boost::any(*memo);
    }
    if (packageId) {
      res["PackageId"] = boost::any(*packageId);
    }
    if (publishMode) {
      res["PublishMode"] = boost::any(*publishMode);
    }
    if (publishType) {
      res["PublishType"] = boost::any(*publishType);
    }
    if (syncMode) {
      res["SyncMode"] = boost::any(*syncMode);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (whitelistIds) {
      res["WhitelistIds"] = boost::any(*whitelistIds);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GreyConfigInfo") != m.end() && !m["GreyConfigInfo"].empty()) {
      greyConfigInfo = make_shared<string>(boost::any_cast<string>(m["GreyConfigInfo"]));
    }
    if (m.find("GreyEndtimeData") != m.end() && !m["GreyEndtimeData"].empty()) {
      greyEndtimeData = make_shared<string>(boost::any_cast<string>(m["GreyEndtimeData"]));
    }
    if (m.find("GreyNum") != m.end() && !m["GreyNum"].empty()) {
      greyNum = make_shared<string>(boost::any_cast<string>(m["GreyNum"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Memo") != m.end() && !m["Memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["Memo"]));
    }
    if (m.find("PackageId") != m.end() && !m["PackageId"].empty()) {
      packageId = make_shared<long>(boost::any_cast<long>(m["PackageId"]));
    }
    if (m.find("PublishMode") != m.end() && !m["PublishMode"].empty()) {
      publishMode = make_shared<string>(boost::any_cast<string>(m["PublishMode"]));
    }
    if (m.find("PublishType") != m.end() && !m["PublishType"].empty()) {
      publishType = make_shared<long>(boost::any_cast<long>(m["PublishType"]));
    }
    if (m.find("SyncMode") != m.end() && !m["SyncMode"].empty()) {
      syncMode = make_shared<string>(boost::any_cast<string>(m["SyncMode"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WhitelistIds") != m.end() && !m["WhitelistIds"].empty()) {
      whitelistIds = make_shared<string>(boost::any_cast<string>(m["WhitelistIds"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateMdsMiniprogramTaskRequest() = default;
};
class CreateMdsMiniprogramTaskResponseBodyResultContentData : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  CreateMdsMiniprogramTaskResponseBodyResultContentData() {}

  explicit CreateMdsMiniprogramTaskResponseBodyResultContentData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMdsMiniprogramTaskResponseBodyResultContentData() = default;
};
class CreateMdsMiniprogramTaskResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<CreateMdsMiniprogramTaskResponseBodyResultContentData> data{};
  shared_ptr<string> requestId{};

  CreateMdsMiniprogramTaskResponseBodyResultContent() {}

  explicit CreateMdsMiniprogramTaskResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateMdsMiniprogramTaskResponseBodyResultContentData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateMdsMiniprogramTaskResponseBodyResultContentData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateMdsMiniprogramTaskResponseBodyResultContent() = default;
};
class CreateMdsMiniprogramTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<CreateMdsMiniprogramTaskResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  CreateMdsMiniprogramTaskResponseBody() {}

  explicit CreateMdsMiniprogramTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        CreateMdsMiniprogramTaskResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<CreateMdsMiniprogramTaskResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~CreateMdsMiniprogramTaskResponseBody() = default;
};
class CreateMdsMiniprogramTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMdsMiniprogramTaskResponseBody> body{};

  CreateMdsMiniprogramTaskResponse() {}

  explicit CreateMdsMiniprogramTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMdsMiniprogramTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMdsMiniprogramTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMdsMiniprogramTaskResponse() = default;
};
class CreateMsaEnhanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMappcenterMsaEnhanceCreateJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  CreateMsaEnhanceRequest() {}

  explicit CreateMsaEnhanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMappcenterMsaEnhanceCreateJsonStr) {
      res["MpaasMappcenterMsaEnhanceCreateJsonStr"] = boost::any(*mpaasMappcenterMsaEnhanceCreateJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMappcenterMsaEnhanceCreateJsonStr") != m.end() && !m["MpaasMappcenterMsaEnhanceCreateJsonStr"].empty()) {
      mpaasMappcenterMsaEnhanceCreateJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMappcenterMsaEnhanceCreateJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateMsaEnhanceRequest() = default;
};
class CreateMsaEnhanceResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  CreateMsaEnhanceResponseBodyResultContent() {}

  explicit CreateMsaEnhanceResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMsaEnhanceResponseBodyResultContent() = default;
};
class CreateMsaEnhanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<CreateMsaEnhanceResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  CreateMsaEnhanceResponseBody() {}

  explicit CreateMsaEnhanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        CreateMsaEnhanceResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<CreateMsaEnhanceResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~CreateMsaEnhanceResponseBody() = default;
};
class CreateMsaEnhanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMsaEnhanceResponseBody> body{};

  CreateMsaEnhanceResponse() {}

  explicit CreateMsaEnhanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMsaEnhanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMsaEnhanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMsaEnhanceResponse() = default;
};
class CreateOpenGlobalDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appMaxVersion{};
  shared_ptr<string> appMinVersion{};
  shared_ptr<string> bizType{};
  shared_ptr<string> extAttrStr{};
  shared_ptr<long> maxUid{};
  shared_ptr<long> minUid{};
  shared_ptr<string> osType{};
  shared_ptr<string> payload{};
  shared_ptr<string> thirdMsgId{};
  shared_ptr<string> uids{};
  shared_ptr<long> validTimeEnd{};
  shared_ptr<long> validTimeStart{};
  shared_ptr<string> workspaceId{};

  CreateOpenGlobalDataRequest() {}

  explicit CreateOpenGlobalDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appMaxVersion) {
      res["AppMaxVersion"] = boost::any(*appMaxVersion);
    }
    if (appMinVersion) {
      res["AppMinVersion"] = boost::any(*appMinVersion);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (extAttrStr) {
      res["ExtAttrStr"] = boost::any(*extAttrStr);
    }
    if (maxUid) {
      res["MaxUid"] = boost::any(*maxUid);
    }
    if (minUid) {
      res["MinUid"] = boost::any(*minUid);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (payload) {
      res["Payload"] = boost::any(*payload);
    }
    if (thirdMsgId) {
      res["ThirdMsgId"] = boost::any(*thirdMsgId);
    }
    if (uids) {
      res["Uids"] = boost::any(*uids);
    }
    if (validTimeEnd) {
      res["ValidTimeEnd"] = boost::any(*validTimeEnd);
    }
    if (validTimeStart) {
      res["ValidTimeStart"] = boost::any(*validTimeStart);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppMaxVersion") != m.end() && !m["AppMaxVersion"].empty()) {
      appMaxVersion = make_shared<string>(boost::any_cast<string>(m["AppMaxVersion"]));
    }
    if (m.find("AppMinVersion") != m.end() && !m["AppMinVersion"].empty()) {
      appMinVersion = make_shared<string>(boost::any_cast<string>(m["AppMinVersion"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ExtAttrStr") != m.end() && !m["ExtAttrStr"].empty()) {
      extAttrStr = make_shared<string>(boost::any_cast<string>(m["ExtAttrStr"]));
    }
    if (m.find("MaxUid") != m.end() && !m["MaxUid"].empty()) {
      maxUid = make_shared<long>(boost::any_cast<long>(m["MaxUid"]));
    }
    if (m.find("MinUid") != m.end() && !m["MinUid"].empty()) {
      minUid = make_shared<long>(boost::any_cast<long>(m["MinUid"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      payload = make_shared<string>(boost::any_cast<string>(m["Payload"]));
    }
    if (m.find("ThirdMsgId") != m.end() && !m["ThirdMsgId"].empty()) {
      thirdMsgId = make_shared<string>(boost::any_cast<string>(m["ThirdMsgId"]));
    }
    if (m.find("Uids") != m.end() && !m["Uids"].empty()) {
      uids = make_shared<string>(boost::any_cast<string>(m["Uids"]));
    }
    if (m.find("ValidTimeEnd") != m.end() && !m["ValidTimeEnd"].empty()) {
      validTimeEnd = make_shared<long>(boost::any_cast<long>(m["ValidTimeEnd"]));
    }
    if (m.find("ValidTimeStart") != m.end() && !m["ValidTimeStart"].empty()) {
      validTimeStart = make_shared<long>(boost::any_cast<long>(m["ValidTimeStart"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateOpenGlobalDataRequest() = default;
};
class CreateOpenGlobalDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  CreateOpenGlobalDataResponseBody() {}

  explicit CreateOpenGlobalDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~CreateOpenGlobalDataResponseBody() = default;
};
class CreateOpenGlobalDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOpenGlobalDataResponseBody> body{};

  CreateOpenGlobalDataResponse() {}

  explicit CreateOpenGlobalDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOpenGlobalDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOpenGlobalDataResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOpenGlobalDataResponse() = default;
};
class CreateOpenSingleDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appMaxVersion{};
  shared_ptr<string> appMinVersion{};
  shared_ptr<string> bizType{};
  shared_ptr<bool> checkOnline{};
  shared_ptr<string> extAttrStr{};
  shared_ptr<string> linkToken{};
  shared_ptr<string> osType{};
  shared_ptr<string> payload{};
  shared_ptr<string> thirdMsgId{};
  shared_ptr<long> validTimeEnd{};
  shared_ptr<long> validTimeStart{};
  shared_ptr<string> workspaceId{};

  CreateOpenSingleDataRequest() {}

  explicit CreateOpenSingleDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appMaxVersion) {
      res["AppMaxVersion"] = boost::any(*appMaxVersion);
    }
    if (appMinVersion) {
      res["AppMinVersion"] = boost::any(*appMinVersion);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (checkOnline) {
      res["CheckOnline"] = boost::any(*checkOnline);
    }
    if (extAttrStr) {
      res["ExtAttrStr"] = boost::any(*extAttrStr);
    }
    if (linkToken) {
      res["LinkToken"] = boost::any(*linkToken);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (payload) {
      res["Payload"] = boost::any(*payload);
    }
    if (thirdMsgId) {
      res["ThirdMsgId"] = boost::any(*thirdMsgId);
    }
    if (validTimeEnd) {
      res["ValidTimeEnd"] = boost::any(*validTimeEnd);
    }
    if (validTimeStart) {
      res["ValidTimeStart"] = boost::any(*validTimeStart);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppMaxVersion") != m.end() && !m["AppMaxVersion"].empty()) {
      appMaxVersion = make_shared<string>(boost::any_cast<string>(m["AppMaxVersion"]));
    }
    if (m.find("AppMinVersion") != m.end() && !m["AppMinVersion"].empty()) {
      appMinVersion = make_shared<string>(boost::any_cast<string>(m["AppMinVersion"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("CheckOnline") != m.end() && !m["CheckOnline"].empty()) {
      checkOnline = make_shared<bool>(boost::any_cast<bool>(m["CheckOnline"]));
    }
    if (m.find("ExtAttrStr") != m.end() && !m["ExtAttrStr"].empty()) {
      extAttrStr = make_shared<string>(boost::any_cast<string>(m["ExtAttrStr"]));
    }
    if (m.find("LinkToken") != m.end() && !m["LinkToken"].empty()) {
      linkToken = make_shared<string>(boost::any_cast<string>(m["LinkToken"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      payload = make_shared<string>(boost::any_cast<string>(m["Payload"]));
    }
    if (m.find("ThirdMsgId") != m.end() && !m["ThirdMsgId"].empty()) {
      thirdMsgId = make_shared<string>(boost::any_cast<string>(m["ThirdMsgId"]));
    }
    if (m.find("ValidTimeEnd") != m.end() && !m["ValidTimeEnd"].empty()) {
      validTimeEnd = make_shared<long>(boost::any_cast<long>(m["ValidTimeEnd"]));
    }
    if (m.find("ValidTimeStart") != m.end() && !m["ValidTimeStart"].empty()) {
      validTimeStart = make_shared<long>(boost::any_cast<long>(m["ValidTimeStart"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateOpenSingleDataRequest() = default;
};
class CreateOpenSingleDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  CreateOpenSingleDataResponseBody() {}

  explicit CreateOpenSingleDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~CreateOpenSingleDataResponseBody() = default;
};
class CreateOpenSingleDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOpenSingleDataResponseBody> body{};

  CreateOpenSingleDataResponse() {}

  explicit CreateOpenSingleDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOpenSingleDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOpenSingleDataResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOpenSingleDataResponse() = default;
};
class DeleteCubecardWhitelistContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> whitelistId{};
  shared_ptr<string> whitelistValue{};
  shared_ptr<string> workspaceId{};

  DeleteCubecardWhitelistContentRequest() {}

  explicit DeleteCubecardWhitelistContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (whitelistId) {
      res["WhitelistId"] = boost::any(*whitelistId);
    }
    if (whitelistValue) {
      res["WhitelistValue"] = boost::any(*whitelistValue);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WhitelistId") != m.end() && !m["WhitelistId"].empty()) {
      whitelistId = make_shared<string>(boost::any_cast<string>(m["WhitelistId"]));
    }
    if (m.find("WhitelistValue") != m.end() && !m["WhitelistValue"].empty()) {
      whitelistValue = make_shared<string>(boost::any_cast<string>(m["WhitelistValue"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~DeleteCubecardWhitelistContentRequest() = default;
};
class DeleteCubecardWhitelistContentResponseBodyResultContentData : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  DeleteCubecardWhitelistContentResponseBodyResultContentData() {}

  explicit DeleteCubecardWhitelistContentResponseBodyResultContentData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteCubecardWhitelistContentResponseBodyResultContentData() = default;
};
class DeleteCubecardWhitelistContentResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<DeleteCubecardWhitelistContentResponseBodyResultContentData> data{};
  shared_ptr<string> requestId{};

  DeleteCubecardWhitelistContentResponseBodyResultContent() {}

  explicit DeleteCubecardWhitelistContentResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeleteCubecardWhitelistContentResponseBodyResultContentData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeleteCubecardWhitelistContentResponseBodyResultContentData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCubecardWhitelistContentResponseBodyResultContent() = default;
};
class DeleteCubecardWhitelistContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<DeleteCubecardWhitelistContentResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  DeleteCubecardWhitelistContentResponseBody() {}

  explicit DeleteCubecardWhitelistContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        DeleteCubecardWhitelistContentResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<DeleteCubecardWhitelistContentResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~DeleteCubecardWhitelistContentResponseBody() = default;
};
class DeleteCubecardWhitelistContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCubecardWhitelistContentResponseBody> body{};

  DeleteCubecardWhitelistContentResponse() {}

  explicit DeleteCubecardWhitelistContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCubecardWhitelistContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCubecardWhitelistContentResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCubecardWhitelistContentResponse() = default;
};
class DeleteMcdpAimRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMappcenterMcdpAimDeleteJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  DeleteMcdpAimRequest() {}

  explicit DeleteMcdpAimRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMappcenterMcdpAimDeleteJsonStr) {
      res["MpaasMappcenterMcdpAimDeleteJsonStr"] = boost::any(*mpaasMappcenterMcdpAimDeleteJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMappcenterMcdpAimDeleteJsonStr") != m.end() && !m["MpaasMappcenterMcdpAimDeleteJsonStr"].empty()) {
      mpaasMappcenterMcdpAimDeleteJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMappcenterMcdpAimDeleteJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~DeleteMcdpAimRequest() = default;
};
class DeleteMcdpAimResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  DeleteMcdpAimResponseBodyResultContent() {}

  explicit DeleteMcdpAimResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMcdpAimResponseBodyResultContent() = default;
};
class DeleteMcdpAimResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<DeleteMcdpAimResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  DeleteMcdpAimResponseBody() {}

  explicit DeleteMcdpAimResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        DeleteMcdpAimResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<DeleteMcdpAimResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~DeleteMcdpAimResponseBody() = default;
};
class DeleteMcdpAimResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMcdpAimResponseBody> body{};

  DeleteMcdpAimResponse() {}

  explicit DeleteMcdpAimResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMcdpAimResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMcdpAimResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMcdpAimResponse() = default;
};
class DeleteMcdpCrowdRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMappcenterMcdpCrowdDeleteJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  DeleteMcdpCrowdRequest() {}

  explicit DeleteMcdpCrowdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMappcenterMcdpCrowdDeleteJsonStr) {
      res["MpaasMappcenterMcdpCrowdDeleteJsonStr"] = boost::any(*mpaasMappcenterMcdpCrowdDeleteJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMappcenterMcdpCrowdDeleteJsonStr") != m.end() && !m["MpaasMappcenterMcdpCrowdDeleteJsonStr"].empty()) {
      mpaasMappcenterMcdpCrowdDeleteJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMappcenterMcdpCrowdDeleteJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~DeleteMcdpCrowdRequest() = default;
};
class DeleteMcdpCrowdResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  DeleteMcdpCrowdResponseBodyResultContent() {}

  explicit DeleteMcdpCrowdResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMcdpCrowdResponseBodyResultContent() = default;
};
class DeleteMcdpCrowdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<DeleteMcdpCrowdResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  DeleteMcdpCrowdResponseBody() {}

  explicit DeleteMcdpCrowdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        DeleteMcdpCrowdResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<DeleteMcdpCrowdResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~DeleteMcdpCrowdResponseBody() = default;
};
class DeleteMcdpCrowdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMcdpCrowdResponseBody> body{};

  DeleteMcdpCrowdResponse() {}

  explicit DeleteMcdpCrowdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMcdpCrowdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMcdpCrowdResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMcdpCrowdResponse() = default;
};
class DeleteMcdpEventAttributeByIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMappcenterMcdpEventAttributeDeleteJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  DeleteMcdpEventAttributeByIdRequest() {}

  explicit DeleteMcdpEventAttributeByIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMappcenterMcdpEventAttributeDeleteJsonStr) {
      res["MpaasMappcenterMcdpEventAttributeDeleteJsonStr"] = boost::any(*mpaasMappcenterMcdpEventAttributeDeleteJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMappcenterMcdpEventAttributeDeleteJsonStr") != m.end() && !m["MpaasMappcenterMcdpEventAttributeDeleteJsonStr"].empty()) {
      mpaasMappcenterMcdpEventAttributeDeleteJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMappcenterMcdpEventAttributeDeleteJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~DeleteMcdpEventAttributeByIdRequest() = default;
};
class DeleteMcdpEventAttributeByIdResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  DeleteMcdpEventAttributeByIdResponseBodyResultContent() {}

  explicit DeleteMcdpEventAttributeByIdResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMcdpEventAttributeByIdResponseBodyResultContent() = default;
};
class DeleteMcdpEventAttributeByIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<DeleteMcdpEventAttributeByIdResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  DeleteMcdpEventAttributeByIdResponseBody() {}

  explicit DeleteMcdpEventAttributeByIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        DeleteMcdpEventAttributeByIdResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<DeleteMcdpEventAttributeByIdResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~DeleteMcdpEventAttributeByIdResponseBody() = default;
};
class DeleteMcdpEventAttributeByIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMcdpEventAttributeByIdResponseBody> body{};

  DeleteMcdpEventAttributeByIdResponse() {}

  explicit DeleteMcdpEventAttributeByIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMcdpEventAttributeByIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMcdpEventAttributeByIdResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMcdpEventAttributeByIdResponse() = default;
};
class DeleteMcdpEventByIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMappcenterMcdpEventDeleteJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  DeleteMcdpEventByIdRequest() {}

  explicit DeleteMcdpEventByIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMappcenterMcdpEventDeleteJsonStr) {
      res["MpaasMappcenterMcdpEventDeleteJsonStr"] = boost::any(*mpaasMappcenterMcdpEventDeleteJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMappcenterMcdpEventDeleteJsonStr") != m.end() && !m["MpaasMappcenterMcdpEventDeleteJsonStr"].empty()) {
      mpaasMappcenterMcdpEventDeleteJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMappcenterMcdpEventDeleteJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~DeleteMcdpEventByIdRequest() = default;
};
class DeleteMcdpEventByIdResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  DeleteMcdpEventByIdResponseBodyResultContent() {}

  explicit DeleteMcdpEventByIdResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMcdpEventByIdResponseBodyResultContent() = default;
};
class DeleteMcdpEventByIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<DeleteMcdpEventByIdResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  DeleteMcdpEventByIdResponseBody() {}

  explicit DeleteMcdpEventByIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        DeleteMcdpEventByIdResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<DeleteMcdpEventByIdResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~DeleteMcdpEventByIdResponseBody() = default;
};
class DeleteMcdpEventByIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMcdpEventByIdResponseBody> body{};

  DeleteMcdpEventByIdResponse() {}

  explicit DeleteMcdpEventByIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMcdpEventByIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMcdpEventByIdResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMcdpEventByIdResponse() = default;
};
class DeleteMcdpMaterialRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMappcenterMcdpMaterialDeleteJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  DeleteMcdpMaterialRequest() {}

  explicit DeleteMcdpMaterialRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMappcenterMcdpMaterialDeleteJsonStr) {
      res["MpaasMappcenterMcdpMaterialDeleteJsonStr"] = boost::any(*mpaasMappcenterMcdpMaterialDeleteJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMappcenterMcdpMaterialDeleteJsonStr") != m.end() && !m["MpaasMappcenterMcdpMaterialDeleteJsonStr"].empty()) {
      mpaasMappcenterMcdpMaterialDeleteJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMappcenterMcdpMaterialDeleteJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~DeleteMcdpMaterialRequest() = default;
};
class DeleteMcdpMaterialResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  DeleteMcdpMaterialResponseBodyResultContent() {}

  explicit DeleteMcdpMaterialResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMcdpMaterialResponseBodyResultContent() = default;
};
class DeleteMcdpMaterialResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<DeleteMcdpMaterialResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  DeleteMcdpMaterialResponseBody() {}

  explicit DeleteMcdpMaterialResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        DeleteMcdpMaterialResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<DeleteMcdpMaterialResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~DeleteMcdpMaterialResponseBody() = default;
};
class DeleteMcdpMaterialResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMcdpMaterialResponseBody> body{};

  DeleteMcdpMaterialResponse() {}

  explicit DeleteMcdpMaterialResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMcdpMaterialResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMcdpMaterialResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMcdpMaterialResponse() = default;
};
class DeleteMcdpZoneRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMappcenterMcdpZoneDeleteJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  DeleteMcdpZoneRequest() {}

  explicit DeleteMcdpZoneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMappcenterMcdpZoneDeleteJsonStr) {
      res["MpaasMappcenterMcdpZoneDeleteJsonStr"] = boost::any(*mpaasMappcenterMcdpZoneDeleteJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMappcenterMcdpZoneDeleteJsonStr") != m.end() && !m["MpaasMappcenterMcdpZoneDeleteJsonStr"].empty()) {
      mpaasMappcenterMcdpZoneDeleteJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMappcenterMcdpZoneDeleteJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~DeleteMcdpZoneRequest() = default;
};
class DeleteMcdpZoneResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  DeleteMcdpZoneResponseBodyResultContent() {}

  explicit DeleteMcdpZoneResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMcdpZoneResponseBodyResultContent() = default;
};
class DeleteMcdpZoneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<DeleteMcdpZoneResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  DeleteMcdpZoneResponseBody() {}

  explicit DeleteMcdpZoneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        DeleteMcdpZoneResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<DeleteMcdpZoneResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~DeleteMcdpZoneResponseBody() = default;
};
class DeleteMcdpZoneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMcdpZoneResponseBody> body{};

  DeleteMcdpZoneResponse() {}

  explicit DeleteMcdpZoneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMcdpZoneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMcdpZoneResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMcdpZoneResponse() = default;
};
class DeleteMcubeMiniAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> h5Id{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  DeleteMcubeMiniAppRequest() {}

  explicit DeleteMcubeMiniAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (h5Id) {
      res["H5Id"] = boost::any(*h5Id);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("H5Id") != m.end() && !m["H5Id"].empty()) {
      h5Id = make_shared<string>(boost::any_cast<string>(m["H5Id"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~DeleteMcubeMiniAppRequest() = default;
};
class DeleteMcubeMiniAppResponseBodyDeleteMiniResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  DeleteMcubeMiniAppResponseBodyDeleteMiniResult() {}

  explicit DeleteMcubeMiniAppResponseBodyDeleteMiniResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMcubeMiniAppResponseBodyDeleteMiniResult() = default;
};
class DeleteMcubeMiniAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeleteMcubeMiniAppResponseBodyDeleteMiniResult> deleteMiniResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  DeleteMcubeMiniAppResponseBody() {}

  explicit DeleteMcubeMiniAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteMiniResult) {
      res["DeleteMiniResult"] = deleteMiniResult ? boost::any(deleteMiniResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteMiniResult") != m.end() && !m["DeleteMiniResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeleteMiniResult"].type()) {
        DeleteMcubeMiniAppResponseBodyDeleteMiniResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeleteMiniResult"]));
        deleteMiniResult = make_shared<DeleteMcubeMiniAppResponseBodyDeleteMiniResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~DeleteMcubeMiniAppResponseBody() = default;
};
class DeleteMcubeMiniAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMcubeMiniAppResponseBody> body{};

  DeleteMcubeMiniAppResponse() {}

  explicit DeleteMcubeMiniAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMcubeMiniAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMcubeMiniAppResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMcubeMiniAppResponse() = default;
};
class DeleteMcubeNebulaAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> h5Id{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  DeleteMcubeNebulaAppRequest() {}

  explicit DeleteMcubeNebulaAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (h5Id) {
      res["H5Id"] = boost::any(*h5Id);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("H5Id") != m.end() && !m["H5Id"].empty()) {
      h5Id = make_shared<string>(boost::any_cast<string>(m["H5Id"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~DeleteMcubeNebulaAppRequest() = default;
};
class DeleteMcubeNebulaAppResponseBodyDeleteMcubeNebulaAppResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  DeleteMcubeNebulaAppResponseBodyDeleteMcubeNebulaAppResult() {}

  explicit DeleteMcubeNebulaAppResponseBodyDeleteMcubeNebulaAppResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMcubeNebulaAppResponseBodyDeleteMcubeNebulaAppResult() = default;
};
class DeleteMcubeNebulaAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeleteMcubeNebulaAppResponseBodyDeleteMcubeNebulaAppResult> deleteMcubeNebulaAppResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  DeleteMcubeNebulaAppResponseBody() {}

  explicit DeleteMcubeNebulaAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteMcubeNebulaAppResult) {
      res["DeleteMcubeNebulaAppResult"] = deleteMcubeNebulaAppResult ? boost::any(deleteMcubeNebulaAppResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteMcubeNebulaAppResult") != m.end() && !m["DeleteMcubeNebulaAppResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeleteMcubeNebulaAppResult"].type()) {
        DeleteMcubeNebulaAppResponseBodyDeleteMcubeNebulaAppResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeleteMcubeNebulaAppResult"]));
        deleteMcubeNebulaAppResult = make_shared<DeleteMcubeNebulaAppResponseBodyDeleteMcubeNebulaAppResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~DeleteMcubeNebulaAppResponseBody() = default;
};
class DeleteMcubeNebulaAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMcubeNebulaAppResponseBody> body{};

  DeleteMcubeNebulaAppResponse() {}

  explicit DeleteMcubeNebulaAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMcubeNebulaAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMcubeNebulaAppResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMcubeNebulaAppResponse() = default;
};
class DeleteMcubeUpgradeResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> id{};
  shared_ptr<string> platform{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  DeleteMcubeUpgradeResourceRequest() {}

  explicit DeleteMcubeUpgradeResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~DeleteMcubeUpgradeResourceRequest() = default;
};
class DeleteMcubeUpgradeResourceResponseBodyDeleteResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  DeleteMcubeUpgradeResourceResponseBodyDeleteResult() {}

  explicit DeleteMcubeUpgradeResourceResponseBodyDeleteResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMcubeUpgradeResourceResponseBodyDeleteResult() = default;
};
class DeleteMcubeUpgradeResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeleteMcubeUpgradeResourceResponseBodyDeleteResult> deleteResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  DeleteMcubeUpgradeResourceResponseBody() {}

  explicit DeleteMcubeUpgradeResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteResult) {
      res["DeleteResult"] = deleteResult ? boost::any(deleteResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteResult") != m.end() && !m["DeleteResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeleteResult"].type()) {
        DeleteMcubeUpgradeResourceResponseBodyDeleteResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeleteResult"]));
        deleteResult = make_shared<DeleteMcubeUpgradeResourceResponseBodyDeleteResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~DeleteMcubeUpgradeResourceResponseBody() = default;
};
class DeleteMcubeUpgradeResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMcubeUpgradeResourceResponseBody> body{};

  DeleteMcubeUpgradeResourceResponse() {}

  explicit DeleteMcubeUpgradeResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMcubeUpgradeResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMcubeUpgradeResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMcubeUpgradeResourceResponse() = default;
};
class DeleteMcubeWhitelistRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> id{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  DeleteMcubeWhitelistRequest() {}

  explicit DeleteMcubeWhitelistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~DeleteMcubeWhitelistRequest() = default;
};
class DeleteMcubeWhitelistResponseBodyDeleteWhitelistResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  DeleteMcubeWhitelistResponseBodyDeleteWhitelistResult() {}

  explicit DeleteMcubeWhitelistResponseBodyDeleteWhitelistResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMcubeWhitelistResponseBodyDeleteWhitelistResult() = default;
};
class DeleteMcubeWhitelistResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeleteMcubeWhitelistResponseBodyDeleteWhitelistResult> deleteWhitelistResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  DeleteMcubeWhitelistResponseBody() {}

  explicit DeleteMcubeWhitelistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteWhitelistResult) {
      res["DeleteWhitelistResult"] = deleteWhitelistResult ? boost::any(deleteWhitelistResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteWhitelistResult") != m.end() && !m["DeleteWhitelistResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeleteWhitelistResult"].type()) {
        DeleteMcubeWhitelistResponseBodyDeleteWhitelistResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeleteWhitelistResult"]));
        deleteWhitelistResult = make_shared<DeleteMcubeWhitelistResponseBodyDeleteWhitelistResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~DeleteMcubeWhitelistResponseBody() = default;
};
class DeleteMcubeWhitelistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMcubeWhitelistResponseBody> body{};

  DeleteMcubeWhitelistResponse() {}

  explicit DeleteMcubeWhitelistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMcubeWhitelistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMcubeWhitelistResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMcubeWhitelistResponse() = default;
};
class DeleteMdsWhitelistContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> whitelistId{};
  shared_ptr<string> whitelistValue{};
  shared_ptr<string> workspaceId{};

  DeleteMdsWhitelistContentRequest() {}

  explicit DeleteMdsWhitelistContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (whitelistId) {
      res["WhitelistId"] = boost::any(*whitelistId);
    }
    if (whitelistValue) {
      res["WhitelistValue"] = boost::any(*whitelistValue);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WhitelistId") != m.end() && !m["WhitelistId"].empty()) {
      whitelistId = make_shared<string>(boost::any_cast<string>(m["WhitelistId"]));
    }
    if (m.find("WhitelistValue") != m.end() && !m["WhitelistValue"].empty()) {
      whitelistValue = make_shared<string>(boost::any_cast<string>(m["WhitelistValue"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~DeleteMdsWhitelistContentRequest() = default;
};
class DeleteMdsWhitelistContentResponseBodyResultContentData : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  DeleteMdsWhitelistContentResponseBodyResultContentData() {}

  explicit DeleteMdsWhitelistContentResponseBodyResultContentData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMdsWhitelistContentResponseBodyResultContentData() = default;
};
class DeleteMdsWhitelistContentResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<DeleteMdsWhitelistContentResponseBodyResultContentData> data{};
  shared_ptr<string> requestId{};

  DeleteMdsWhitelistContentResponseBodyResultContent() {}

  explicit DeleteMdsWhitelistContentResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeleteMdsWhitelistContentResponseBodyResultContentData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeleteMdsWhitelistContentResponseBodyResultContentData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMdsWhitelistContentResponseBodyResultContent() = default;
};
class DeleteMdsWhitelistContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<DeleteMdsWhitelistContentResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  DeleteMdsWhitelistContentResponseBody() {}

  explicit DeleteMdsWhitelistContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        DeleteMdsWhitelistContentResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<DeleteMdsWhitelistContentResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~DeleteMdsWhitelistContentResponseBody() = default;
};
class DeleteMdsWhitelistContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMdsWhitelistContentResponseBody> body{};

  DeleteMdsWhitelistContentResponse() {}

  explicit DeleteMdsWhitelistContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMdsWhitelistContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMdsWhitelistContentResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMdsWhitelistContentResponse() = default;
};
class ExistMcubeRsaKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  ExistMcubeRsaKeyRequest() {}

  explicit ExistMcubeRsaKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ExistMcubeRsaKeyRequest() = default;
};
class ExistMcubeRsaKeyResponseBodyCheckRsaKeyResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  ExistMcubeRsaKeyResponseBodyCheckRsaKeyResult() {}

  explicit ExistMcubeRsaKeyResponseBodyCheckRsaKeyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ExistMcubeRsaKeyResponseBodyCheckRsaKeyResult() = default;
};
class ExistMcubeRsaKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<ExistMcubeRsaKeyResponseBodyCheckRsaKeyResult> checkRsaKeyResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  ExistMcubeRsaKeyResponseBody() {}

  explicit ExistMcubeRsaKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkRsaKeyResult) {
      res["CheckRsaKeyResult"] = checkRsaKeyResult ? boost::any(checkRsaKeyResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckRsaKeyResult") != m.end() && !m["CheckRsaKeyResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckRsaKeyResult"].type()) {
        ExistMcubeRsaKeyResponseBodyCheckRsaKeyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckRsaKeyResult"]));
        checkRsaKeyResult = make_shared<ExistMcubeRsaKeyResponseBodyCheckRsaKeyResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~ExistMcubeRsaKeyResponseBody() = default;
};
class ExistMcubeRsaKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExistMcubeRsaKeyResponseBody> body{};

  ExistMcubeRsaKeyResponse() {}

  explicit ExistMcubeRsaKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExistMcubeRsaKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExistMcubeRsaKeyResponseBody>(model1);
      }
    }
  }


  virtual ~ExistMcubeRsaKeyResponse() = default;
};
class ExportMappCenterAppConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> apkFileUrl{};
  shared_ptr<string> appId{};
  shared_ptr<string> certRsaBase64{};
  shared_ptr<string> identifier{};
  shared_ptr<bool> onexFlag{};
  shared_ptr<string> systemType{};
  shared_ptr<string> workspaceId{};

  ExportMappCenterAppConfigRequest() {}

  explicit ExportMappCenterAppConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apkFileUrl) {
      res["ApkFileUrl"] = boost::any(*apkFileUrl);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (certRsaBase64) {
      res["CertRsaBase64"] = boost::any(*certRsaBase64);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (onexFlag) {
      res["OnexFlag"] = boost::any(*onexFlag);
    }
    if (systemType) {
      res["SystemType"] = boost::any(*systemType);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApkFileUrl") != m.end() && !m["ApkFileUrl"].empty()) {
      apkFileUrl = make_shared<string>(boost::any_cast<string>(m["ApkFileUrl"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CertRsaBase64") != m.end() && !m["CertRsaBase64"].empty()) {
      certRsaBase64 = make_shared<string>(boost::any_cast<string>(m["CertRsaBase64"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("OnexFlag") != m.end() && !m["OnexFlag"].empty()) {
      onexFlag = make_shared<bool>(boost::any_cast<bool>(m["OnexFlag"]));
    }
    if (m.find("SystemType") != m.end() && !m["SystemType"].empty()) {
      systemType = make_shared<string>(boost::any_cast<string>(m["SystemType"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ExportMappCenterAppConfigRequest() = default;
};
class ExportMappCenterAppConfigResponseBodyExportMappCenterAppConfigResult : public Darabonba::Model {
public:
  shared_ptr<string> configDownloadUrl{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  ExportMappCenterAppConfigResponseBodyExportMappCenterAppConfigResult() {}

  explicit ExportMappCenterAppConfigResponseBodyExportMappCenterAppConfigResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configDownloadUrl) {
      res["ConfigDownloadUrl"] = boost::any(*configDownloadUrl);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigDownloadUrl") != m.end() && !m["ConfigDownloadUrl"].empty()) {
      configDownloadUrl = make_shared<string>(boost::any_cast<string>(m["ConfigDownloadUrl"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ExportMappCenterAppConfigResponseBodyExportMappCenterAppConfigResult() = default;
};
class ExportMappCenterAppConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<ExportMappCenterAppConfigResponseBodyExportMappCenterAppConfigResult> exportMappCenterAppConfigResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  ExportMappCenterAppConfigResponseBody() {}

  explicit ExportMappCenterAppConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exportMappCenterAppConfigResult) {
      res["ExportMappCenterAppConfigResult"] = exportMappCenterAppConfigResult ? boost::any(exportMappCenterAppConfigResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExportMappCenterAppConfigResult") != m.end() && !m["ExportMappCenterAppConfigResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExportMappCenterAppConfigResult"].type()) {
        ExportMappCenterAppConfigResponseBodyExportMappCenterAppConfigResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExportMappCenterAppConfigResult"]));
        exportMappCenterAppConfigResult = make_shared<ExportMappCenterAppConfigResponseBodyExportMappCenterAppConfigResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~ExportMappCenterAppConfigResponseBody() = default;
};
class ExportMappCenterAppConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportMappCenterAppConfigResponseBody> body{};

  ExportMappCenterAppConfigResponse() {}

  explicit ExportMappCenterAppConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportMappCenterAppConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportMappCenterAppConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ExportMappCenterAppConfigResponse() = default;
};
class GetFileTokenForUploadToMsaRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> onexFlag{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  GetFileTokenForUploadToMsaRequest() {}

  explicit GetFileTokenForUploadToMsaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (onexFlag) {
      res["OnexFlag"] = boost::any(*onexFlag);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("OnexFlag") != m.end() && !m["OnexFlag"].empty()) {
      onexFlag = make_shared<bool>(boost::any_cast<bool>(m["OnexFlag"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetFileTokenForUploadToMsaRequest() = default;
};
class GetFileTokenForUploadToMsaResponseBodyResultContentContent : public Darabonba::Model {
public:
  shared_ptr<string> accessid{};
  shared_ptr<string> dir{};
  shared_ptr<string> expire{};
  shared_ptr<string> host{};
  shared_ptr<string> policy{};
  shared_ptr<string> signature{};

  GetFileTokenForUploadToMsaResponseBodyResultContentContent() {}

  explicit GetFileTokenForUploadToMsaResponseBodyResultContentContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessid) {
      res["Accessid"] = boost::any(*accessid);
    }
    if (dir) {
      res["Dir"] = boost::any(*dir);
    }
    if (expire) {
      res["Expire"] = boost::any(*expire);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Accessid") != m.end() && !m["Accessid"].empty()) {
      accessid = make_shared<string>(boost::any_cast<string>(m["Accessid"]));
    }
    if (m.find("Dir") != m.end() && !m["Dir"].empty()) {
      dir = make_shared<string>(boost::any_cast<string>(m["Dir"]));
    }
    if (m.find("Expire") != m.end() && !m["Expire"].empty()) {
      expire = make_shared<string>(boost::any_cast<string>(m["Expire"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
  }


  virtual ~GetFileTokenForUploadToMsaResponseBodyResultContentContent() = default;
};
class GetFileTokenForUploadToMsaResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<GetFileTokenForUploadToMsaResponseBodyResultContentContent> content{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultMsg{};
  shared_ptr<string> success{};

  GetFileTokenForUploadToMsaResponseBodyResultContent() {}

  explicit GetFileTokenForUploadToMsaResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        GetFileTokenForUploadToMsaResponseBodyResultContentContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<GetFileTokenForUploadToMsaResponseBodyResultContentContent>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetFileTokenForUploadToMsaResponseBodyResultContent() = default;
};
class GetFileTokenForUploadToMsaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<GetFileTokenForUploadToMsaResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  GetFileTokenForUploadToMsaResponseBody() {}

  explicit GetFileTokenForUploadToMsaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        GetFileTokenForUploadToMsaResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<GetFileTokenForUploadToMsaResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~GetFileTokenForUploadToMsaResponseBody() = default;
};
class GetFileTokenForUploadToMsaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetFileTokenForUploadToMsaResponseBody> body{};

  GetFileTokenForUploadToMsaResponse() {}

  explicit GetFileTokenForUploadToMsaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFileTokenForUploadToMsaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFileTokenForUploadToMsaResponseBody>(model1);
      }
    }
  }


  virtual ~GetFileTokenForUploadToMsaResponse() = default;
};
class GetLogUrlInMsaRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> id{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  GetLogUrlInMsaRequest() {}

  explicit GetLogUrlInMsaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetLogUrlInMsaRequest() = default;
};
class GetLogUrlInMsaResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  GetLogUrlInMsaResponseBodyResultContent() {}

  explicit GetLogUrlInMsaResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetLogUrlInMsaResponseBodyResultContent() = default;
};
class GetLogUrlInMsaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<GetLogUrlInMsaResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  GetLogUrlInMsaResponseBody() {}

  explicit GetLogUrlInMsaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        GetLogUrlInMsaResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<GetLogUrlInMsaResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~GetLogUrlInMsaResponseBody() = default;
};
class GetLogUrlInMsaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLogUrlInMsaResponseBody> body{};

  GetLogUrlInMsaResponse() {}

  explicit GetLogUrlInMsaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLogUrlInMsaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLogUrlInMsaResponseBody>(model1);
      }
    }
  }


  virtual ~GetLogUrlInMsaResponse() = default;
};
class GetMcubeFileTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> onexFlag{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  GetMcubeFileTokenRequest() {}

  explicit GetMcubeFileTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (onexFlag) {
      res["OnexFlag"] = boost::any(*onexFlag);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("OnexFlag") != m.end() && !m["OnexFlag"].empty()) {
      onexFlag = make_shared<bool>(boost::any_cast<bool>(m["OnexFlag"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetMcubeFileTokenRequest() = default;
};
class GetMcubeFileTokenResponseBodyGetFileTokenResultFileToken : public Darabonba::Model {
public:
  shared_ptr<string> accessid{};
  shared_ptr<string> dir{};
  shared_ptr<string> expire{};
  shared_ptr<string> host{};
  shared_ptr<string> policy{};
  shared_ptr<string> signature{};

  GetMcubeFileTokenResponseBodyGetFileTokenResultFileToken() {}

  explicit GetMcubeFileTokenResponseBodyGetFileTokenResultFileToken(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessid) {
      res["Accessid"] = boost::any(*accessid);
    }
    if (dir) {
      res["Dir"] = boost::any(*dir);
    }
    if (expire) {
      res["Expire"] = boost::any(*expire);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Accessid") != m.end() && !m["Accessid"].empty()) {
      accessid = make_shared<string>(boost::any_cast<string>(m["Accessid"]));
    }
    if (m.find("Dir") != m.end() && !m["Dir"].empty()) {
      dir = make_shared<string>(boost::any_cast<string>(m["Dir"]));
    }
    if (m.find("Expire") != m.end() && !m["Expire"].empty()) {
      expire = make_shared<string>(boost::any_cast<string>(m["Expire"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
  }


  virtual ~GetMcubeFileTokenResponseBodyGetFileTokenResultFileToken() = default;
};
class GetMcubeFileTokenResponseBodyGetFileTokenResult : public Darabonba::Model {
public:
  shared_ptr<GetMcubeFileTokenResponseBodyGetFileTokenResultFileToken> fileToken{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  GetMcubeFileTokenResponseBodyGetFileTokenResult() {}

  explicit GetMcubeFileTokenResponseBodyGetFileTokenResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileToken) {
      res["FileToken"] = fileToken ? boost::any(fileToken->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileToken") != m.end() && !m["FileToken"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileToken"].type()) {
        GetMcubeFileTokenResponseBodyGetFileTokenResultFileToken model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileToken"]));
        fileToken = make_shared<GetMcubeFileTokenResponseBodyGetFileTokenResultFileToken>(model1);
      }
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetMcubeFileTokenResponseBodyGetFileTokenResult() = default;
};
class GetMcubeFileTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMcubeFileTokenResponseBodyGetFileTokenResult> getFileTokenResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  GetMcubeFileTokenResponseBody() {}

  explicit GetMcubeFileTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (getFileTokenResult) {
      res["GetFileTokenResult"] = getFileTokenResult ? boost::any(getFileTokenResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GetFileTokenResult") != m.end() && !m["GetFileTokenResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["GetFileTokenResult"].type()) {
        GetMcubeFileTokenResponseBodyGetFileTokenResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GetFileTokenResult"]));
        getFileTokenResult = make_shared<GetMcubeFileTokenResponseBodyGetFileTokenResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~GetMcubeFileTokenResponseBody() = default;
};
class GetMcubeFileTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMcubeFileTokenResponseBody> body{};

  GetMcubeFileTokenResponse() {}

  explicit GetMcubeFileTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMcubeFileTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMcubeFileTokenResponseBody>(model1);
      }
    }
  }


  virtual ~GetMcubeFileTokenResponse() = default;
};
class GetMcubeNebulaResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> id{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  GetMcubeNebulaResourceRequest() {}

  explicit GetMcubeNebulaResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetMcubeNebulaResourceRequest() = default;
};
class GetMcubeNebulaResourceResponseBodyGetNebulaResourceResultNebulaResourceInfo : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<long> autoInstall{};
  shared_ptr<string> clientVersionMax{};
  shared_ptr<string> clientVersionMin{};
  shared_ptr<string> creator{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> extendInfo{};
  shared_ptr<string> extraData{};
  shared_ptr<string> fallbackBaseUrl{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> h5Id{};
  shared_ptr<string> h5Name{};
  shared_ptr<string> h5Version{};
  shared_ptr<long> id{};
  shared_ptr<long> installType{};
  shared_ptr<string> mainUrl{};
  shared_ptr<string> memo{};
  shared_ptr<long> metaId{};
  shared_ptr<string> modifier{};
  shared_ptr<long> packageType{};
  shared_ptr<string> platform{};
  shared_ptr<long> publishPeriod{};
  shared_ptr<string> resourceType{};
  shared_ptr<long> status{};
  shared_ptr<string> vhost{};

  GetMcubeNebulaResourceResponseBodyGetNebulaResourceResultNebulaResourceInfo() {}

  explicit GetMcubeNebulaResourceResponseBodyGetNebulaResourceResultNebulaResourceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (autoInstall) {
      res["AutoInstall"] = boost::any(*autoInstall);
    }
    if (clientVersionMax) {
      res["ClientVersionMax"] = boost::any(*clientVersionMax);
    }
    if (clientVersionMin) {
      res["ClientVersionMin"] = boost::any(*clientVersionMin);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (extraData) {
      res["ExtraData"] = boost::any(*extraData);
    }
    if (fallbackBaseUrl) {
      res["FallbackBaseUrl"] = boost::any(*fallbackBaseUrl);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (h5Id) {
      res["H5Id"] = boost::any(*h5Id);
    }
    if (h5Name) {
      res["H5Name"] = boost::any(*h5Name);
    }
    if (h5Version) {
      res["H5Version"] = boost::any(*h5Version);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (installType) {
      res["InstallType"] = boost::any(*installType);
    }
    if (mainUrl) {
      res["MainUrl"] = boost::any(*mainUrl);
    }
    if (memo) {
      res["Memo"] = boost::any(*memo);
    }
    if (metaId) {
      res["MetaId"] = boost::any(*metaId);
    }
    if (modifier) {
      res["Modifier"] = boost::any(*modifier);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (publishPeriod) {
      res["PublishPeriod"] = boost::any(*publishPeriod);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vhost) {
      res["Vhost"] = boost::any(*vhost);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("AutoInstall") != m.end() && !m["AutoInstall"].empty()) {
      autoInstall = make_shared<long>(boost::any_cast<long>(m["AutoInstall"]));
    }
    if (m.find("ClientVersionMax") != m.end() && !m["ClientVersionMax"].empty()) {
      clientVersionMax = make_shared<string>(boost::any_cast<string>(m["ClientVersionMax"]));
    }
    if (m.find("ClientVersionMin") != m.end() && !m["ClientVersionMin"].empty()) {
      clientVersionMin = make_shared<string>(boost::any_cast<string>(m["ClientVersionMin"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      extendInfo = make_shared<string>(boost::any_cast<string>(m["ExtendInfo"]));
    }
    if (m.find("ExtraData") != m.end() && !m["ExtraData"].empty()) {
      extraData = make_shared<string>(boost::any_cast<string>(m["ExtraData"]));
    }
    if (m.find("FallbackBaseUrl") != m.end() && !m["FallbackBaseUrl"].empty()) {
      fallbackBaseUrl = make_shared<string>(boost::any_cast<string>(m["FallbackBaseUrl"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("H5Id") != m.end() && !m["H5Id"].empty()) {
      h5Id = make_shared<string>(boost::any_cast<string>(m["H5Id"]));
    }
    if (m.find("H5Name") != m.end() && !m["H5Name"].empty()) {
      h5Name = make_shared<string>(boost::any_cast<string>(m["H5Name"]));
    }
    if (m.find("H5Version") != m.end() && !m["H5Version"].empty()) {
      h5Version = make_shared<string>(boost::any_cast<string>(m["H5Version"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstallType") != m.end() && !m["InstallType"].empty()) {
      installType = make_shared<long>(boost::any_cast<long>(m["InstallType"]));
    }
    if (m.find("MainUrl") != m.end() && !m["MainUrl"].empty()) {
      mainUrl = make_shared<string>(boost::any_cast<string>(m["MainUrl"]));
    }
    if (m.find("Memo") != m.end() && !m["Memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["Memo"]));
    }
    if (m.find("MetaId") != m.end() && !m["MetaId"].empty()) {
      metaId = make_shared<long>(boost::any_cast<long>(m["MetaId"]));
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["Modifier"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<long>(boost::any_cast<long>(m["PackageType"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("PublishPeriod") != m.end() && !m["PublishPeriod"].empty()) {
      publishPeriod = make_shared<long>(boost::any_cast<long>(m["PublishPeriod"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Vhost") != m.end() && !m["Vhost"].empty()) {
      vhost = make_shared<string>(boost::any_cast<string>(m["Vhost"]));
    }
  }


  virtual ~GetMcubeNebulaResourceResponseBodyGetNebulaResourceResultNebulaResourceInfo() = default;
};
class GetMcubeNebulaResourceResponseBodyGetNebulaResourceResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<GetMcubeNebulaResourceResponseBodyGetNebulaResourceResultNebulaResourceInfo> nebulaResourceInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  GetMcubeNebulaResourceResponseBodyGetNebulaResourceResult() {}

  explicit GetMcubeNebulaResourceResponseBodyGetNebulaResourceResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (nebulaResourceInfo) {
      res["NebulaResourceInfo"] = nebulaResourceInfo ? boost::any(nebulaResourceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("NebulaResourceInfo") != m.end() && !m["NebulaResourceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["NebulaResourceInfo"].type()) {
        GetMcubeNebulaResourceResponseBodyGetNebulaResourceResultNebulaResourceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NebulaResourceInfo"]));
        nebulaResourceInfo = make_shared<GetMcubeNebulaResourceResponseBodyGetNebulaResourceResultNebulaResourceInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetMcubeNebulaResourceResponseBodyGetNebulaResourceResult() = default;
};
class GetMcubeNebulaResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMcubeNebulaResourceResponseBodyGetNebulaResourceResult> getNebulaResourceResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  GetMcubeNebulaResourceResponseBody() {}

  explicit GetMcubeNebulaResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (getNebulaResourceResult) {
      res["GetNebulaResourceResult"] = getNebulaResourceResult ? boost::any(getNebulaResourceResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GetNebulaResourceResult") != m.end() && !m["GetNebulaResourceResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["GetNebulaResourceResult"].type()) {
        GetMcubeNebulaResourceResponseBodyGetNebulaResourceResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GetNebulaResourceResult"]));
        getNebulaResourceResult = make_shared<GetMcubeNebulaResourceResponseBodyGetNebulaResourceResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~GetMcubeNebulaResourceResponseBody() = default;
};
class GetMcubeNebulaResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMcubeNebulaResourceResponseBody> body{};

  GetMcubeNebulaResourceResponse() {}

  explicit GetMcubeNebulaResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMcubeNebulaResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMcubeNebulaResourceResponseBody>(model1);
      }
    }
  }


  virtual ~GetMcubeNebulaResourceResponse() = default;
};
class GetMcubeNebulaTaskDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> taskId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  GetMcubeNebulaTaskDetailRequest() {}

  explicit GetMcubeNebulaTaskDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetMcubeNebulaTaskDetailRequest() = default;
};
class GetMcubeNebulaTaskDetailResponseBodyGetMcubeNebulaTaskDetailResultNebulaTaskDetailRuleJsonList : public Darabonba::Model {
public:
  shared_ptr<string> operation{};
  shared_ptr<string> ruleElement{};
  shared_ptr<string> ruleType{};
  shared_ptr<string> value{};

  GetMcubeNebulaTaskDetailResponseBodyGetMcubeNebulaTaskDetailResultNebulaTaskDetailRuleJsonList() {}

  explicit GetMcubeNebulaTaskDetailResponseBodyGetMcubeNebulaTaskDetailResultNebulaTaskDetailRuleJsonList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (ruleElement) {
      res["RuleElement"] = boost::any(*ruleElement);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("RuleElement") != m.end() && !m["RuleElement"].empty()) {
      ruleElement = make_shared<string>(boost::any_cast<string>(m["RuleElement"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetMcubeNebulaTaskDetailResponseBodyGetMcubeNebulaTaskDetailResultNebulaTaskDetailRuleJsonList() = default;
};
class GetMcubeNebulaTaskDetailResponseBodyGetMcubeNebulaTaskDetailResultNebulaTaskDetail : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<string> appId{};
  shared_ptr<long> atomic{};
  shared_ptr<long> baseInfoId{};
  shared_ptr<string> bizType{};
  shared_ptr<string> creator{};
  shared_ptr<long> cronexpress{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> extraData{};
  shared_ptr<string> fileSize{};
  shared_ptr<long> fullRepair{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> gmtModifiedStr{};
  shared_ptr<string> greyConfigInfo{};
  shared_ptr<string> greyEndtime{};
  shared_ptr<string> greyEndtimeData{};
  shared_ptr<string> greyEndtimeStr{};
  shared_ptr<long> greyNum{};
  shared_ptr<string> greyUrl{};
  shared_ptr<long> id{};
  shared_ptr<string> issueDesc{};
  shared_ptr<string> memo{};
  shared_ptr<string> modifier{};
  shared_ptr<string> ossPath{};
  shared_ptr<long> packageId{};
  shared_ptr<long> percent{};
  shared_ptr<string> platform{};
  shared_ptr<string> productId{};
  shared_ptr<string> productVersion{};
  shared_ptr<long> publishMode{};
  shared_ptr<long> publishPeriod{};
  shared_ptr<long> publishType{};
  shared_ptr<long> quickRollback{};
  shared_ptr<string> releaseVersion{};
  shared_ptr<vector<GetMcubeNebulaTaskDetailResponseBodyGetMcubeNebulaTaskDetailResultNebulaTaskDetailRuleJsonList>> ruleJsonList{};
  shared_ptr<string> sourceId{};
  shared_ptr<string> sourceName{};
  shared_ptr<string> sourceType{};
  shared_ptr<long> status{};
  shared_ptr<string> syncResult{};
  shared_ptr<long> syncType{};
  shared_ptr<string> taskName{};
  shared_ptr<long> taskStatus{};
  shared_ptr<long> taskType{};
  shared_ptr<long> taskVersion{};
  shared_ptr<long> upgradeNoticeNum{};
  shared_ptr<string> upgradeProgress{};
  shared_ptr<string> whitelistIds{};
  shared_ptr<string> workspaceId{};

  GetMcubeNebulaTaskDetailResponseBodyGetMcubeNebulaTaskDetailResultNebulaTaskDetail() {}

  explicit GetMcubeNebulaTaskDetailResponseBodyGetMcubeNebulaTaskDetailResultNebulaTaskDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (atomic) {
      res["Atomic"] = boost::any(*atomic);
    }
    if (baseInfoId) {
      res["BaseInfoId"] = boost::any(*baseInfoId);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (cronexpress) {
      res["Cronexpress"] = boost::any(*cronexpress);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (extraData) {
      res["ExtraData"] = boost::any(*extraData);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fullRepair) {
      res["FullRepair"] = boost::any(*fullRepair);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtModifiedStr) {
      res["GmtModifiedStr"] = boost::any(*gmtModifiedStr);
    }
    if (greyConfigInfo) {
      res["GreyConfigInfo"] = boost::any(*greyConfigInfo);
    }
    if (greyEndtime) {
      res["GreyEndtime"] = boost::any(*greyEndtime);
    }
    if (greyEndtimeData) {
      res["GreyEndtimeData"] = boost::any(*greyEndtimeData);
    }
    if (greyEndtimeStr) {
      res["GreyEndtimeStr"] = boost::any(*greyEndtimeStr);
    }
    if (greyNum) {
      res["GreyNum"] = boost::any(*greyNum);
    }
    if (greyUrl) {
      res["GreyUrl"] = boost::any(*greyUrl);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (issueDesc) {
      res["IssueDesc"] = boost::any(*issueDesc);
    }
    if (memo) {
      res["Memo"] = boost::any(*memo);
    }
    if (modifier) {
      res["Modifier"] = boost::any(*modifier);
    }
    if (ossPath) {
      res["OssPath"] = boost::any(*ossPath);
    }
    if (packageId) {
      res["PackageId"] = boost::any(*packageId);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (productId) {
      res["ProductId"] = boost::any(*productId);
    }
    if (productVersion) {
      res["ProductVersion"] = boost::any(*productVersion);
    }
    if (publishMode) {
      res["PublishMode"] = boost::any(*publishMode);
    }
    if (publishPeriod) {
      res["PublishPeriod"] = boost::any(*publishPeriod);
    }
    if (publishType) {
      res["PublishType"] = boost::any(*publishType);
    }
    if (quickRollback) {
      res["QuickRollback"] = boost::any(*quickRollback);
    }
    if (releaseVersion) {
      res["ReleaseVersion"] = boost::any(*releaseVersion);
    }
    if (ruleJsonList) {
      vector<boost::any> temp1;
      for(auto item1:*ruleJsonList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleJsonList"] = boost::any(temp1);
    }
    if (sourceId) {
      res["SourceId"] = boost::any(*sourceId);
    }
    if (sourceName) {
      res["SourceName"] = boost::any(*sourceName);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (syncResult) {
      res["SyncResult"] = boost::any(*syncResult);
    }
    if (syncType) {
      res["SyncType"] = boost::any(*syncType);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (taskVersion) {
      res["TaskVersion"] = boost::any(*taskVersion);
    }
    if (upgradeNoticeNum) {
      res["UpgradeNoticeNum"] = boost::any(*upgradeNoticeNum);
    }
    if (upgradeProgress) {
      res["UpgradeProgress"] = boost::any(*upgradeProgress);
    }
    if (whitelistIds) {
      res["WhitelistIds"] = boost::any(*whitelistIds);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Atomic") != m.end() && !m["Atomic"].empty()) {
      atomic = make_shared<long>(boost::any_cast<long>(m["Atomic"]));
    }
    if (m.find("BaseInfoId") != m.end() && !m["BaseInfoId"].empty()) {
      baseInfoId = make_shared<long>(boost::any_cast<long>(m["BaseInfoId"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Cronexpress") != m.end() && !m["Cronexpress"].empty()) {
      cronexpress = make_shared<long>(boost::any_cast<long>(m["Cronexpress"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("ExtraData") != m.end() && !m["ExtraData"].empty()) {
      extraData = make_shared<string>(boost::any_cast<string>(m["ExtraData"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FullRepair") != m.end() && !m["FullRepair"].empty()) {
      fullRepair = make_shared<long>(boost::any_cast<long>(m["FullRepair"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtModifiedStr") != m.end() && !m["GmtModifiedStr"].empty()) {
      gmtModifiedStr = make_shared<string>(boost::any_cast<string>(m["GmtModifiedStr"]));
    }
    if (m.find("GreyConfigInfo") != m.end() && !m["GreyConfigInfo"].empty()) {
      greyConfigInfo = make_shared<string>(boost::any_cast<string>(m["GreyConfigInfo"]));
    }
    if (m.find("GreyEndtime") != m.end() && !m["GreyEndtime"].empty()) {
      greyEndtime = make_shared<string>(boost::any_cast<string>(m["GreyEndtime"]));
    }
    if (m.find("GreyEndtimeData") != m.end() && !m["GreyEndtimeData"].empty()) {
      greyEndtimeData = make_shared<string>(boost::any_cast<string>(m["GreyEndtimeData"]));
    }
    if (m.find("GreyEndtimeStr") != m.end() && !m["GreyEndtimeStr"].empty()) {
      greyEndtimeStr = make_shared<string>(boost::any_cast<string>(m["GreyEndtimeStr"]));
    }
    if (m.find("GreyNum") != m.end() && !m["GreyNum"].empty()) {
      greyNum = make_shared<long>(boost::any_cast<long>(m["GreyNum"]));
    }
    if (m.find("GreyUrl") != m.end() && !m["GreyUrl"].empty()) {
      greyUrl = make_shared<string>(boost::any_cast<string>(m["GreyUrl"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IssueDesc") != m.end() && !m["IssueDesc"].empty()) {
      issueDesc = make_shared<string>(boost::any_cast<string>(m["IssueDesc"]));
    }
    if (m.find("Memo") != m.end() && !m["Memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["Memo"]));
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["Modifier"]));
    }
    if (m.find("OssPath") != m.end() && !m["OssPath"].empty()) {
      ossPath = make_shared<string>(boost::any_cast<string>(m["OssPath"]));
    }
    if (m.find("PackageId") != m.end() && !m["PackageId"].empty()) {
      packageId = make_shared<long>(boost::any_cast<long>(m["PackageId"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("ProductId") != m.end() && !m["ProductId"].empty()) {
      productId = make_shared<string>(boost::any_cast<string>(m["ProductId"]));
    }
    if (m.find("ProductVersion") != m.end() && !m["ProductVersion"].empty()) {
      productVersion = make_shared<string>(boost::any_cast<string>(m["ProductVersion"]));
    }
    if (m.find("PublishMode") != m.end() && !m["PublishMode"].empty()) {
      publishMode = make_shared<long>(boost::any_cast<long>(m["PublishMode"]));
    }
    if (m.find("PublishPeriod") != m.end() && !m["PublishPeriod"].empty()) {
      publishPeriod = make_shared<long>(boost::any_cast<long>(m["PublishPeriod"]));
    }
    if (m.find("PublishType") != m.end() && !m["PublishType"].empty()) {
      publishType = make_shared<long>(boost::any_cast<long>(m["PublishType"]));
    }
    if (m.find("QuickRollback") != m.end() && !m["QuickRollback"].empty()) {
      quickRollback = make_shared<long>(boost::any_cast<long>(m["QuickRollback"]));
    }
    if (m.find("ReleaseVersion") != m.end() && !m["ReleaseVersion"].empty()) {
      releaseVersion = make_shared<string>(boost::any_cast<string>(m["ReleaseVersion"]));
    }
    if (m.find("RuleJsonList") != m.end() && !m["RuleJsonList"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleJsonList"].type()) {
        vector<GetMcubeNebulaTaskDetailResponseBodyGetMcubeNebulaTaskDetailResultNebulaTaskDetailRuleJsonList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleJsonList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMcubeNebulaTaskDetailResponseBodyGetMcubeNebulaTaskDetailResultNebulaTaskDetailRuleJsonList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleJsonList = make_shared<vector<GetMcubeNebulaTaskDetailResponseBodyGetMcubeNebulaTaskDetailResultNebulaTaskDetailRuleJsonList>>(expect1);
      }
    }
    if (m.find("SourceId") != m.end() && !m["SourceId"].empty()) {
      sourceId = make_shared<string>(boost::any_cast<string>(m["SourceId"]));
    }
    if (m.find("SourceName") != m.end() && !m["SourceName"].empty()) {
      sourceName = make_shared<string>(boost::any_cast<string>(m["SourceName"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("SyncResult") != m.end() && !m["SyncResult"].empty()) {
      syncResult = make_shared<string>(boost::any_cast<string>(m["SyncResult"]));
    }
    if (m.find("SyncType") != m.end() && !m["SyncType"].empty()) {
      syncType = make_shared<long>(boost::any_cast<long>(m["SyncType"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<long>(boost::any_cast<long>(m["TaskStatus"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
    if (m.find("TaskVersion") != m.end() && !m["TaskVersion"].empty()) {
      taskVersion = make_shared<long>(boost::any_cast<long>(m["TaskVersion"]));
    }
    if (m.find("UpgradeNoticeNum") != m.end() && !m["UpgradeNoticeNum"].empty()) {
      upgradeNoticeNum = make_shared<long>(boost::any_cast<long>(m["UpgradeNoticeNum"]));
    }
    if (m.find("UpgradeProgress") != m.end() && !m["UpgradeProgress"].empty()) {
      upgradeProgress = make_shared<string>(boost::any_cast<string>(m["UpgradeProgress"]));
    }
    if (m.find("WhitelistIds") != m.end() && !m["WhitelistIds"].empty()) {
      whitelistIds = make_shared<string>(boost::any_cast<string>(m["WhitelistIds"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetMcubeNebulaTaskDetailResponseBodyGetMcubeNebulaTaskDetailResultNebulaTaskDetail() = default;
};
class GetMcubeNebulaTaskDetailResponseBodyGetMcubeNebulaTaskDetailResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<GetMcubeNebulaTaskDetailResponseBodyGetMcubeNebulaTaskDetailResultNebulaTaskDetail> nebulaTaskDetail{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  GetMcubeNebulaTaskDetailResponseBodyGetMcubeNebulaTaskDetailResult() {}

  explicit GetMcubeNebulaTaskDetailResponseBodyGetMcubeNebulaTaskDetailResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (nebulaTaskDetail) {
      res["NebulaTaskDetail"] = nebulaTaskDetail ? boost::any(nebulaTaskDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("NebulaTaskDetail") != m.end() && !m["NebulaTaskDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["NebulaTaskDetail"].type()) {
        GetMcubeNebulaTaskDetailResponseBodyGetMcubeNebulaTaskDetailResultNebulaTaskDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NebulaTaskDetail"]));
        nebulaTaskDetail = make_shared<GetMcubeNebulaTaskDetailResponseBodyGetMcubeNebulaTaskDetailResultNebulaTaskDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetMcubeNebulaTaskDetailResponseBodyGetMcubeNebulaTaskDetailResult() = default;
};
class GetMcubeNebulaTaskDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMcubeNebulaTaskDetailResponseBodyGetMcubeNebulaTaskDetailResult> getMcubeNebulaTaskDetailResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  GetMcubeNebulaTaskDetailResponseBody() {}

  explicit GetMcubeNebulaTaskDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (getMcubeNebulaTaskDetailResult) {
      res["GetMcubeNebulaTaskDetailResult"] = getMcubeNebulaTaskDetailResult ? boost::any(getMcubeNebulaTaskDetailResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GetMcubeNebulaTaskDetailResult") != m.end() && !m["GetMcubeNebulaTaskDetailResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["GetMcubeNebulaTaskDetailResult"].type()) {
        GetMcubeNebulaTaskDetailResponseBodyGetMcubeNebulaTaskDetailResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GetMcubeNebulaTaskDetailResult"]));
        getMcubeNebulaTaskDetailResult = make_shared<GetMcubeNebulaTaskDetailResponseBodyGetMcubeNebulaTaskDetailResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~GetMcubeNebulaTaskDetailResponseBody() = default;
};
class GetMcubeNebulaTaskDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMcubeNebulaTaskDetailResponseBody> body{};

  GetMcubeNebulaTaskDetailResponse() {}

  explicit GetMcubeNebulaTaskDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMcubeNebulaTaskDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMcubeNebulaTaskDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetMcubeNebulaTaskDetailResponse() = default;
};
class GetMcubeUpgradePackageInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> packageId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  GetMcubeUpgradePackageInfoRequest() {}

  explicit GetMcubeUpgradePackageInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (packageId) {
      res["PackageId"] = boost::any(*packageId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("PackageId") != m.end() && !m["PackageId"].empty()) {
      packageId = make_shared<long>(boost::any_cast<long>(m["PackageId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetMcubeUpgradePackageInfoRequest() = default;
};
class GetMcubeUpgradePackageInfoResponseBodyGetPackageResultPackageInfoMobileTestFlightConfigDO : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<long> installAmount{};
  shared_ptr<string> invalidTime{};
  shared_ptr<long> upgradeId{};

  GetMcubeUpgradePackageInfoResponseBodyGetPackageResultPackageInfoMobileTestFlightConfigDO() {}

  explicit GetMcubeUpgradePackageInfoResponseBodyGetPackageResultPackageInfoMobileTestFlightConfigDO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (installAmount) {
      res["InstallAmount"] = boost::any(*installAmount);
    }
    if (invalidTime) {
      res["InvalidTime"] = boost::any(*invalidTime);
    }
    if (upgradeId) {
      res["UpgradeId"] = boost::any(*upgradeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstallAmount") != m.end() && !m["InstallAmount"].empty()) {
      installAmount = make_shared<long>(boost::any_cast<long>(m["InstallAmount"]));
    }
    if (m.find("InvalidTime") != m.end() && !m["InvalidTime"].empty()) {
      invalidTime = make_shared<string>(boost::any_cast<string>(m["InvalidTime"]));
    }
    if (m.find("UpgradeId") != m.end() && !m["UpgradeId"].empty()) {
      upgradeId = make_shared<long>(boost::any_cast<long>(m["UpgradeId"]));
    }
  }


  virtual ~GetMcubeUpgradePackageInfoResponseBodyGetPackageResultPackageInfoMobileTestFlightConfigDO() = default;
};
class GetMcubeUpgradePackageInfoResponseBodyGetPackageResultPackageInfoUpgradeBaseInfoDO : public Darabonba::Model {
public:
  shared_ptr<bool> allowCreateTask{};
  shared_ptr<string> appCode{};
  shared_ptr<string> appstoreUrl{};
  shared_ptr<string> backLog{};
  shared_ptr<string> changeLog{};
  shared_ptr<long> clientFileSize{};
  shared_ptr<string> clientName{};
  shared_ptr<string> cpId{};
  shared_ptr<string> creator{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> globalVariables{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtCreateStr{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> gmtModifiedStr{};
  shared_ptr<long> id{};
  shared_ptr<string> innerVersion{};
  shared_ptr<string> iosSymbol{};
  shared_ptr<long> isEnterprise{};
  shared_ptr<long> isRc{};
  shared_ptr<long> isRelease{};
  shared_ptr<string> maxVersion{};
  shared_ptr<string> md5{};
  shared_ptr<string> modifier{};
  shared_ptr<long> needCheck{};
  shared_ptr<string> ossPath{};
  shared_ptr<string> packageType{};
  shared_ptr<string> platform{};
  shared_ptr<string> productId{};
  shared_ptr<string> productName{};
  shared_ptr<string> productVersion{};
  shared_ptr<long> publishPeriod{};
  shared_ptr<string> qrcodeUrl{};
  shared_ptr<string> releaseType{};
  shared_ptr<string> releaseWindow{};
  shared_ptr<string> scmDownloadUrl{};
  shared_ptr<long> serverVersion{};
  shared_ptr<string> verificationCode{};
  shared_ptr<long> verifyResult{};
  shared_ptr<string> versionCode{};

  GetMcubeUpgradePackageInfoResponseBodyGetPackageResultPackageInfoUpgradeBaseInfoDO() {}

  explicit GetMcubeUpgradePackageInfoResponseBodyGetPackageResultPackageInfoUpgradeBaseInfoDO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowCreateTask) {
      res["AllowCreateTask"] = boost::any(*allowCreateTask);
    }
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (appstoreUrl) {
      res["AppstoreUrl"] = boost::any(*appstoreUrl);
    }
    if (backLog) {
      res["BackLog"] = boost::any(*backLog);
    }
    if (changeLog) {
      res["ChangeLog"] = boost::any(*changeLog);
    }
    if (clientFileSize) {
      res["ClientFileSize"] = boost::any(*clientFileSize);
    }
    if (clientName) {
      res["ClientName"] = boost::any(*clientName);
    }
    if (cpId) {
      res["CpId"] = boost::any(*cpId);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (globalVariables) {
      res["GlobalVariables"] = boost::any(*globalVariables);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtCreateStr) {
      res["GmtCreateStr"] = boost::any(*gmtCreateStr);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtModifiedStr) {
      res["GmtModifiedStr"] = boost::any(*gmtModifiedStr);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (innerVersion) {
      res["InnerVersion"] = boost::any(*innerVersion);
    }
    if (iosSymbol) {
      res["IosSymbol"] = boost::any(*iosSymbol);
    }
    if (isEnterprise) {
      res["IsEnterprise"] = boost::any(*isEnterprise);
    }
    if (isRc) {
      res["IsRc"] = boost::any(*isRc);
    }
    if (isRelease) {
      res["IsRelease"] = boost::any(*isRelease);
    }
    if (maxVersion) {
      res["MaxVersion"] = boost::any(*maxVersion);
    }
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    if (modifier) {
      res["Modifier"] = boost::any(*modifier);
    }
    if (needCheck) {
      res["NeedCheck"] = boost::any(*needCheck);
    }
    if (ossPath) {
      res["OssPath"] = boost::any(*ossPath);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (productId) {
      res["ProductId"] = boost::any(*productId);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (productVersion) {
      res["ProductVersion"] = boost::any(*productVersion);
    }
    if (publishPeriod) {
      res["PublishPeriod"] = boost::any(*publishPeriod);
    }
    if (qrcodeUrl) {
      res["QrcodeUrl"] = boost::any(*qrcodeUrl);
    }
    if (releaseType) {
      res["ReleaseType"] = boost::any(*releaseType);
    }
    if (releaseWindow) {
      res["ReleaseWindow"] = boost::any(*releaseWindow);
    }
    if (scmDownloadUrl) {
      res["ScmDownloadUrl"] = boost::any(*scmDownloadUrl);
    }
    if (serverVersion) {
      res["ServerVersion"] = boost::any(*serverVersion);
    }
    if (verificationCode) {
      res["VerificationCode"] = boost::any(*verificationCode);
    }
    if (verifyResult) {
      res["VerifyResult"] = boost::any(*verifyResult);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowCreateTask") != m.end() && !m["AllowCreateTask"].empty()) {
      allowCreateTask = make_shared<bool>(boost::any_cast<bool>(m["AllowCreateTask"]));
    }
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("AppstoreUrl") != m.end() && !m["AppstoreUrl"].empty()) {
      appstoreUrl = make_shared<string>(boost::any_cast<string>(m["AppstoreUrl"]));
    }
    if (m.find("BackLog") != m.end() && !m["BackLog"].empty()) {
      backLog = make_shared<string>(boost::any_cast<string>(m["BackLog"]));
    }
    if (m.find("ChangeLog") != m.end() && !m["ChangeLog"].empty()) {
      changeLog = make_shared<string>(boost::any_cast<string>(m["ChangeLog"]));
    }
    if (m.find("ClientFileSize") != m.end() && !m["ClientFileSize"].empty()) {
      clientFileSize = make_shared<long>(boost::any_cast<long>(m["ClientFileSize"]));
    }
    if (m.find("ClientName") != m.end() && !m["ClientName"].empty()) {
      clientName = make_shared<string>(boost::any_cast<string>(m["ClientName"]));
    }
    if (m.find("CpId") != m.end() && !m["CpId"].empty()) {
      cpId = make_shared<string>(boost::any_cast<string>(m["CpId"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("GlobalVariables") != m.end() && !m["GlobalVariables"].empty()) {
      globalVariables = make_shared<string>(boost::any_cast<string>(m["GlobalVariables"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtCreateStr") != m.end() && !m["GmtCreateStr"].empty()) {
      gmtCreateStr = make_shared<string>(boost::any_cast<string>(m["GmtCreateStr"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtModifiedStr") != m.end() && !m["GmtModifiedStr"].empty()) {
      gmtModifiedStr = make_shared<string>(boost::any_cast<string>(m["GmtModifiedStr"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InnerVersion") != m.end() && !m["InnerVersion"].empty()) {
      innerVersion = make_shared<string>(boost::any_cast<string>(m["InnerVersion"]));
    }
    if (m.find("IosSymbol") != m.end() && !m["IosSymbol"].empty()) {
      iosSymbol = make_shared<string>(boost::any_cast<string>(m["IosSymbol"]));
    }
    if (m.find("IsEnterprise") != m.end() && !m["IsEnterprise"].empty()) {
      isEnterprise = make_shared<long>(boost::any_cast<long>(m["IsEnterprise"]));
    }
    if (m.find("IsRc") != m.end() && !m["IsRc"].empty()) {
      isRc = make_shared<long>(boost::any_cast<long>(m["IsRc"]));
    }
    if (m.find("IsRelease") != m.end() && !m["IsRelease"].empty()) {
      isRelease = make_shared<long>(boost::any_cast<long>(m["IsRelease"]));
    }
    if (m.find("MaxVersion") != m.end() && !m["MaxVersion"].empty()) {
      maxVersion = make_shared<string>(boost::any_cast<string>(m["MaxVersion"]));
    }
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["Modifier"]));
    }
    if (m.find("NeedCheck") != m.end() && !m["NeedCheck"].empty()) {
      needCheck = make_shared<long>(boost::any_cast<long>(m["NeedCheck"]));
    }
    if (m.find("OssPath") != m.end() && !m["OssPath"].empty()) {
      ossPath = make_shared<string>(boost::any_cast<string>(m["OssPath"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("ProductId") != m.end() && !m["ProductId"].empty()) {
      productId = make_shared<string>(boost::any_cast<string>(m["ProductId"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("ProductVersion") != m.end() && !m["ProductVersion"].empty()) {
      productVersion = make_shared<string>(boost::any_cast<string>(m["ProductVersion"]));
    }
    if (m.find("PublishPeriod") != m.end() && !m["PublishPeriod"].empty()) {
      publishPeriod = make_shared<long>(boost::any_cast<long>(m["PublishPeriod"]));
    }
    if (m.find("QrcodeUrl") != m.end() && !m["QrcodeUrl"].empty()) {
      qrcodeUrl = make_shared<string>(boost::any_cast<string>(m["QrcodeUrl"]));
    }
    if (m.find("ReleaseType") != m.end() && !m["ReleaseType"].empty()) {
      releaseType = make_shared<string>(boost::any_cast<string>(m["ReleaseType"]));
    }
    if (m.find("ReleaseWindow") != m.end() && !m["ReleaseWindow"].empty()) {
      releaseWindow = make_shared<string>(boost::any_cast<string>(m["ReleaseWindow"]));
    }
    if (m.find("ScmDownloadUrl") != m.end() && !m["ScmDownloadUrl"].empty()) {
      scmDownloadUrl = make_shared<string>(boost::any_cast<string>(m["ScmDownloadUrl"]));
    }
    if (m.find("ServerVersion") != m.end() && !m["ServerVersion"].empty()) {
      serverVersion = make_shared<long>(boost::any_cast<long>(m["ServerVersion"]));
    }
    if (m.find("VerificationCode") != m.end() && !m["VerificationCode"].empty()) {
      verificationCode = make_shared<string>(boost::any_cast<string>(m["VerificationCode"]));
    }
    if (m.find("VerifyResult") != m.end() && !m["VerifyResult"].empty()) {
      verifyResult = make_shared<long>(boost::any_cast<long>(m["VerifyResult"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
  }


  virtual ~GetMcubeUpgradePackageInfoResponseBodyGetPackageResultPackageInfoUpgradeBaseInfoDO() = default;
};
class GetMcubeUpgradePackageInfoResponseBodyGetPackageResultPackageInfo : public Darabonba::Model {
public:
  shared_ptr<GetMcubeUpgradePackageInfoResponseBodyGetPackageResultPackageInfoMobileTestFlightConfigDO> mobileTestFlightConfigDO{};
  shared_ptr<GetMcubeUpgradePackageInfoResponseBodyGetPackageResultPackageInfoUpgradeBaseInfoDO> upgradeBaseInfoDO{};

  GetMcubeUpgradePackageInfoResponseBodyGetPackageResultPackageInfo() {}

  explicit GetMcubeUpgradePackageInfoResponseBodyGetPackageResultPackageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mobileTestFlightConfigDO) {
      res["MobileTestFlightConfigDO"] = mobileTestFlightConfigDO ? boost::any(mobileTestFlightConfigDO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (upgradeBaseInfoDO) {
      res["UpgradeBaseInfoDO"] = upgradeBaseInfoDO ? boost::any(upgradeBaseInfoDO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MobileTestFlightConfigDO") != m.end() && !m["MobileTestFlightConfigDO"].empty()) {
      if (typeid(map<string, boost::any>) == m["MobileTestFlightConfigDO"].type()) {
        GetMcubeUpgradePackageInfoResponseBodyGetPackageResultPackageInfoMobileTestFlightConfigDO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MobileTestFlightConfigDO"]));
        mobileTestFlightConfigDO = make_shared<GetMcubeUpgradePackageInfoResponseBodyGetPackageResultPackageInfoMobileTestFlightConfigDO>(model1);
      }
    }
    if (m.find("UpgradeBaseInfoDO") != m.end() && !m["UpgradeBaseInfoDO"].empty()) {
      if (typeid(map<string, boost::any>) == m["UpgradeBaseInfoDO"].type()) {
        GetMcubeUpgradePackageInfoResponseBodyGetPackageResultPackageInfoUpgradeBaseInfoDO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UpgradeBaseInfoDO"]));
        upgradeBaseInfoDO = make_shared<GetMcubeUpgradePackageInfoResponseBodyGetPackageResultPackageInfoUpgradeBaseInfoDO>(model1);
      }
    }
  }


  virtual ~GetMcubeUpgradePackageInfoResponseBodyGetPackageResultPackageInfo() = default;
};
class GetMcubeUpgradePackageInfoResponseBodyGetPackageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<GetMcubeUpgradePackageInfoResponseBodyGetPackageResultPackageInfo> packageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  GetMcubeUpgradePackageInfoResponseBodyGetPackageResult() {}

  explicit GetMcubeUpgradePackageInfoResponseBodyGetPackageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (packageInfo) {
      res["PackageInfo"] = packageInfo ? boost::any(packageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("PackageInfo") != m.end() && !m["PackageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PackageInfo"].type()) {
        GetMcubeUpgradePackageInfoResponseBodyGetPackageResultPackageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PackageInfo"]));
        packageInfo = make_shared<GetMcubeUpgradePackageInfoResponseBodyGetPackageResultPackageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetMcubeUpgradePackageInfoResponseBodyGetPackageResult() = default;
};
class GetMcubeUpgradePackageInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMcubeUpgradePackageInfoResponseBodyGetPackageResult> getPackageResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  GetMcubeUpgradePackageInfoResponseBody() {}

  explicit GetMcubeUpgradePackageInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (getPackageResult) {
      res["GetPackageResult"] = getPackageResult ? boost::any(getPackageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GetPackageResult") != m.end() && !m["GetPackageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["GetPackageResult"].type()) {
        GetMcubeUpgradePackageInfoResponseBodyGetPackageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GetPackageResult"]));
        getPackageResult = make_shared<GetMcubeUpgradePackageInfoResponseBodyGetPackageResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~GetMcubeUpgradePackageInfoResponseBody() = default;
};
class GetMcubeUpgradePackageInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMcubeUpgradePackageInfoResponseBody> body{};

  GetMcubeUpgradePackageInfoResponse() {}

  explicit GetMcubeUpgradePackageInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMcubeUpgradePackageInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMcubeUpgradePackageInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetMcubeUpgradePackageInfoResponse() = default;
};
class GetMcubeUpgradeTaskInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> taskId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  GetMcubeUpgradeTaskInfoRequest() {}

  explicit GetMcubeUpgradeTaskInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetMcubeUpgradeTaskInfoRequest() = default;
};
class GetMcubeUpgradeTaskInfoResponseBodyGetTaskResultTaskInfoRuleJsonList : public Darabonba::Model {
public:
  shared_ptr<string> operation{};
  shared_ptr<string> ruleElement{};
  shared_ptr<string> ruleType{};
  shared_ptr<string> value{};

  GetMcubeUpgradeTaskInfoResponseBodyGetTaskResultTaskInfoRuleJsonList() {}

  explicit GetMcubeUpgradeTaskInfoResponseBodyGetTaskResultTaskInfoRuleJsonList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (ruleElement) {
      res["RuleElement"] = boost::any(*ruleElement);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("RuleElement") != m.end() && !m["RuleElement"].empty()) {
      ruleElement = make_shared<string>(boost::any_cast<string>(m["RuleElement"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetMcubeUpgradeTaskInfoResponseBodyGetTaskResultTaskInfoRuleJsonList() = default;
};
class GetMcubeUpgradeTaskInfoResponseBodyGetTaskResultTaskInfoWhitelist : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<long> id{};
  shared_ptr<string> idType{};
  shared_ptr<string> platform{};
  shared_ptr<long> status{};
  shared_ptr<string> userType{};
  shared_ptr<long> whiteListCount{};
  shared_ptr<string> whiteListName{};
  shared_ptr<string> whitelistType{};

  GetMcubeUpgradeTaskInfoResponseBodyGetTaskResultTaskInfoWhitelist() {}

  explicit GetMcubeUpgradeTaskInfoResponseBodyGetTaskResultTaskInfoWhitelist(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (idType) {
      res["IdType"] = boost::any(*idType);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userType) {
      res["UserType"] = boost::any(*userType);
    }
    if (whiteListCount) {
      res["WhiteListCount"] = boost::any(*whiteListCount);
    }
    if (whiteListName) {
      res["WhiteListName"] = boost::any(*whiteListName);
    }
    if (whitelistType) {
      res["WhitelistType"] = boost::any(*whitelistType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IdType") != m.end() && !m["IdType"].empty()) {
      idType = make_shared<string>(boost::any_cast<string>(m["IdType"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("UserType") != m.end() && !m["UserType"].empty()) {
      userType = make_shared<string>(boost::any_cast<string>(m["UserType"]));
    }
    if (m.find("WhiteListCount") != m.end() && !m["WhiteListCount"].empty()) {
      whiteListCount = make_shared<long>(boost::any_cast<long>(m["WhiteListCount"]));
    }
    if (m.find("WhiteListName") != m.end() && !m["WhiteListName"].empty()) {
      whiteListName = make_shared<string>(boost::any_cast<string>(m["WhiteListName"]));
    }
    if (m.find("WhitelistType") != m.end() && !m["WhitelistType"].empty()) {
      whitelistType = make_shared<string>(boost::any_cast<string>(m["WhitelistType"]));
    }
  }


  virtual ~GetMcubeUpgradeTaskInfoResponseBodyGetTaskResultTaskInfoWhitelist() = default;
};
class GetMcubeUpgradeTaskInfoResponseBodyGetTaskResultTaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<string> appId{};
  shared_ptr<string> appstoreUrl{};
  shared_ptr<string> creater{};
  shared_ptr<string> creator{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> greyConfigInfo{};
  shared_ptr<string> greyEndtimeData{};
  shared_ptr<long> greyNum{};
  shared_ptr<long> historyForce{};
  shared_ptr<long> id{};
  shared_ptr<long> isEnterprise{};
  shared_ptr<long> isOfficial{};
  shared_ptr<long> isRc{};
  shared_ptr<long> isRelease{};
  shared_ptr<string> memo{};
  shared_ptr<string> modifier{};
  shared_ptr<string> netType{};
  shared_ptr<string> osVersion{};
  shared_ptr<long> packageInfoId{};
  shared_ptr<string> packageType{};
  shared_ptr<string> platform{};
  shared_ptr<string> productId{};
  shared_ptr<long> publishMode{};
  shared_ptr<long> publishType{};
  shared_ptr<string> pushContent{};
  shared_ptr<string> qrcodeUrl{};
  shared_ptr<vector<GetMcubeUpgradeTaskInfoResponseBodyGetTaskResultTaskInfoRuleJsonList>> ruleJsonList{};
  shared_ptr<long> silentType{};
  shared_ptr<long> taskStatus{};
  shared_ptr<string> upgradeContent{};
  shared_ptr<long> upgradeType{};
  shared_ptr<long> upgradeValidTime{};
  shared_ptr<vector<GetMcubeUpgradeTaskInfoResponseBodyGetTaskResultTaskInfoWhitelist>> whitelist{};
  shared_ptr<string> whitelistIds{};
  shared_ptr<string> workspaceId{};

  GetMcubeUpgradeTaskInfoResponseBodyGetTaskResultTaskInfo() {}

  explicit GetMcubeUpgradeTaskInfoResponseBodyGetTaskResultTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appstoreUrl) {
      res["AppstoreUrl"] = boost::any(*appstoreUrl);
    }
    if (creater) {
      res["Creater"] = boost::any(*creater);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (greyConfigInfo) {
      res["GreyConfigInfo"] = boost::any(*greyConfigInfo);
    }
    if (greyEndtimeData) {
      res["GreyEndtimeData"] = boost::any(*greyEndtimeData);
    }
    if (greyNum) {
      res["GreyNum"] = boost::any(*greyNum);
    }
    if (historyForce) {
      res["HistoryForce"] = boost::any(*historyForce);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isEnterprise) {
      res["IsEnterprise"] = boost::any(*isEnterprise);
    }
    if (isOfficial) {
      res["IsOfficial"] = boost::any(*isOfficial);
    }
    if (isRc) {
      res["IsRc"] = boost::any(*isRc);
    }
    if (isRelease) {
      res["IsRelease"] = boost::any(*isRelease);
    }
    if (memo) {
      res["Memo"] = boost::any(*memo);
    }
    if (modifier) {
      res["Modifier"] = boost::any(*modifier);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (osVersion) {
      res["OsVersion"] = boost::any(*osVersion);
    }
    if (packageInfoId) {
      res["PackageInfoId"] = boost::any(*packageInfoId);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (productId) {
      res["ProductId"] = boost::any(*productId);
    }
    if (publishMode) {
      res["PublishMode"] = boost::any(*publishMode);
    }
    if (publishType) {
      res["PublishType"] = boost::any(*publishType);
    }
    if (pushContent) {
      res["PushContent"] = boost::any(*pushContent);
    }
    if (qrcodeUrl) {
      res["QrcodeUrl"] = boost::any(*qrcodeUrl);
    }
    if (ruleJsonList) {
      vector<boost::any> temp1;
      for(auto item1:*ruleJsonList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleJsonList"] = boost::any(temp1);
    }
    if (silentType) {
      res["SilentType"] = boost::any(*silentType);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (upgradeContent) {
      res["UpgradeContent"] = boost::any(*upgradeContent);
    }
    if (upgradeType) {
      res["UpgradeType"] = boost::any(*upgradeType);
    }
    if (upgradeValidTime) {
      res["UpgradeValidTime"] = boost::any(*upgradeValidTime);
    }
    if (whitelist) {
      vector<boost::any> temp1;
      for(auto item1:*whitelist){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Whitelist"] = boost::any(temp1);
    }
    if (whitelistIds) {
      res["WhitelistIds"] = boost::any(*whitelistIds);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppstoreUrl") != m.end() && !m["AppstoreUrl"].empty()) {
      appstoreUrl = make_shared<string>(boost::any_cast<string>(m["AppstoreUrl"]));
    }
    if (m.find("Creater") != m.end() && !m["Creater"].empty()) {
      creater = make_shared<string>(boost::any_cast<string>(m["Creater"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("GreyConfigInfo") != m.end() && !m["GreyConfigInfo"].empty()) {
      greyConfigInfo = make_shared<string>(boost::any_cast<string>(m["GreyConfigInfo"]));
    }
    if (m.find("GreyEndtimeData") != m.end() && !m["GreyEndtimeData"].empty()) {
      greyEndtimeData = make_shared<string>(boost::any_cast<string>(m["GreyEndtimeData"]));
    }
    if (m.find("GreyNum") != m.end() && !m["GreyNum"].empty()) {
      greyNum = make_shared<long>(boost::any_cast<long>(m["GreyNum"]));
    }
    if (m.find("HistoryForce") != m.end() && !m["HistoryForce"].empty()) {
      historyForce = make_shared<long>(boost::any_cast<long>(m["HistoryForce"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsEnterprise") != m.end() && !m["IsEnterprise"].empty()) {
      isEnterprise = make_shared<long>(boost::any_cast<long>(m["IsEnterprise"]));
    }
    if (m.find("IsOfficial") != m.end() && !m["IsOfficial"].empty()) {
      isOfficial = make_shared<long>(boost::any_cast<long>(m["IsOfficial"]));
    }
    if (m.find("IsRc") != m.end() && !m["IsRc"].empty()) {
      isRc = make_shared<long>(boost::any_cast<long>(m["IsRc"]));
    }
    if (m.find("IsRelease") != m.end() && !m["IsRelease"].empty()) {
      isRelease = make_shared<long>(boost::any_cast<long>(m["IsRelease"]));
    }
    if (m.find("Memo") != m.end() && !m["Memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["Memo"]));
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["Modifier"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("OsVersion") != m.end() && !m["OsVersion"].empty()) {
      osVersion = make_shared<string>(boost::any_cast<string>(m["OsVersion"]));
    }
    if (m.find("PackageInfoId") != m.end() && !m["PackageInfoId"].empty()) {
      packageInfoId = make_shared<long>(boost::any_cast<long>(m["PackageInfoId"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("ProductId") != m.end() && !m["ProductId"].empty()) {
      productId = make_shared<string>(boost::any_cast<string>(m["ProductId"]));
    }
    if (m.find("PublishMode") != m.end() && !m["PublishMode"].empty()) {
      publishMode = make_shared<long>(boost::any_cast<long>(m["PublishMode"]));
    }
    if (m.find("PublishType") != m.end() && !m["PublishType"].empty()) {
      publishType = make_shared<long>(boost::any_cast<long>(m["PublishType"]));
    }
    if (m.find("PushContent") != m.end() && !m["PushContent"].empty()) {
      pushContent = make_shared<string>(boost::any_cast<string>(m["PushContent"]));
    }
    if (m.find("QrcodeUrl") != m.end() && !m["QrcodeUrl"].empty()) {
      qrcodeUrl = make_shared<string>(boost::any_cast<string>(m["QrcodeUrl"]));
    }
    if (m.find("RuleJsonList") != m.end() && !m["RuleJsonList"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleJsonList"].type()) {
        vector<GetMcubeUpgradeTaskInfoResponseBodyGetTaskResultTaskInfoRuleJsonList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleJsonList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMcubeUpgradeTaskInfoResponseBodyGetTaskResultTaskInfoRuleJsonList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleJsonList = make_shared<vector<GetMcubeUpgradeTaskInfoResponseBodyGetTaskResultTaskInfoRuleJsonList>>(expect1);
      }
    }
    if (m.find("SilentType") != m.end() && !m["SilentType"].empty()) {
      silentType = make_shared<long>(boost::any_cast<long>(m["SilentType"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<long>(boost::any_cast<long>(m["TaskStatus"]));
    }
    if (m.find("UpgradeContent") != m.end() && !m["UpgradeContent"].empty()) {
      upgradeContent = make_shared<string>(boost::any_cast<string>(m["UpgradeContent"]));
    }
    if (m.find("UpgradeType") != m.end() && !m["UpgradeType"].empty()) {
      upgradeType = make_shared<long>(boost::any_cast<long>(m["UpgradeType"]));
    }
    if (m.find("UpgradeValidTime") != m.end() && !m["UpgradeValidTime"].empty()) {
      upgradeValidTime = make_shared<long>(boost::any_cast<long>(m["UpgradeValidTime"]));
    }
    if (m.find("Whitelist") != m.end() && !m["Whitelist"].empty()) {
      if (typeid(vector<boost::any>) == m["Whitelist"].type()) {
        vector<GetMcubeUpgradeTaskInfoResponseBodyGetTaskResultTaskInfoWhitelist> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Whitelist"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMcubeUpgradeTaskInfoResponseBodyGetTaskResultTaskInfoWhitelist model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        whitelist = make_shared<vector<GetMcubeUpgradeTaskInfoResponseBodyGetTaskResultTaskInfoWhitelist>>(expect1);
      }
    }
    if (m.find("WhitelistIds") != m.end() && !m["WhitelistIds"].empty()) {
      whitelistIds = make_shared<string>(boost::any_cast<string>(m["WhitelistIds"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetMcubeUpgradeTaskInfoResponseBodyGetTaskResultTaskInfo() = default;
};
class GetMcubeUpgradeTaskInfoResponseBodyGetTaskResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};
  shared_ptr<GetMcubeUpgradeTaskInfoResponseBodyGetTaskResultTaskInfo> taskInfo{};

  GetMcubeUpgradeTaskInfoResponseBodyGetTaskResult() {}

  explicit GetMcubeUpgradeTaskInfoResponseBodyGetTaskResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskInfo) {
      res["TaskInfo"] = taskInfo ? boost::any(taskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TaskInfo") != m.end() && !m["TaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInfo"].type()) {
        GetMcubeUpgradeTaskInfoResponseBodyGetTaskResultTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInfo"]));
        taskInfo = make_shared<GetMcubeUpgradeTaskInfoResponseBodyGetTaskResultTaskInfo>(model1);
      }
    }
  }


  virtual ~GetMcubeUpgradeTaskInfoResponseBodyGetTaskResult() = default;
};
class GetMcubeUpgradeTaskInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMcubeUpgradeTaskInfoResponseBodyGetTaskResult> getTaskResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  GetMcubeUpgradeTaskInfoResponseBody() {}

  explicit GetMcubeUpgradeTaskInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (getTaskResult) {
      res["GetTaskResult"] = getTaskResult ? boost::any(getTaskResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GetTaskResult") != m.end() && !m["GetTaskResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["GetTaskResult"].type()) {
        GetMcubeUpgradeTaskInfoResponseBodyGetTaskResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GetTaskResult"]));
        getTaskResult = make_shared<GetMcubeUpgradeTaskInfoResponseBodyGetTaskResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~GetMcubeUpgradeTaskInfoResponseBody() = default;
};
class GetMcubeUpgradeTaskInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMcubeUpgradeTaskInfoResponseBody> body{};

  GetMcubeUpgradeTaskInfoResponse() {}

  explicit GetMcubeUpgradeTaskInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMcubeUpgradeTaskInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMcubeUpgradeTaskInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetMcubeUpgradeTaskInfoResponse() = default;
};
class GetMdsMiniConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> h5Id{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  GetMdsMiniConfigRequest() {}

  explicit GetMdsMiniConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (h5Id) {
      res["H5Id"] = boost::any(*h5Id);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("H5Id") != m.end() && !m["H5Id"].empty()) {
      h5Id = make_shared<string>(boost::any_cast<string>(m["H5Id"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetMdsMiniConfigRequest() = default;
};
class GetMdsMiniConfigResponseBodyResultContentDataContentApiConfigList : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<long> configStatus{};
  shared_ptr<string> configType{};
  shared_ptr<string> configValue{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> h5Id{};
  shared_ptr<string> h5Name{};
  shared_ptr<long> id{};

  GetMdsMiniConfigResponseBodyResultContentDataContentApiConfigList() {}

  explicit GetMdsMiniConfigResponseBodyResultContentDataContentApiConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (configStatus) {
      res["ConfigStatus"] = boost::any(*configStatus);
    }
    if (configType) {
      res["ConfigType"] = boost::any(*configType);
    }
    if (configValue) {
      res["ConfigValue"] = boost::any(*configValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (h5Id) {
      res["H5Id"] = boost::any(*h5Id);
    }
    if (h5Name) {
      res["H5Name"] = boost::any(*h5Name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("ConfigStatus") != m.end() && !m["ConfigStatus"].empty()) {
      configStatus = make_shared<long>(boost::any_cast<long>(m["ConfigStatus"]));
    }
    if (m.find("ConfigType") != m.end() && !m["ConfigType"].empty()) {
      configType = make_shared<string>(boost::any_cast<string>(m["ConfigType"]));
    }
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["ConfigValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("H5Id") != m.end() && !m["H5Id"].empty()) {
      h5Id = make_shared<string>(boost::any_cast<string>(m["H5Id"]));
    }
    if (m.find("H5Name") != m.end() && !m["H5Name"].empty()) {
      h5Name = make_shared<string>(boost::any_cast<string>(m["H5Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetMdsMiniConfigResponseBodyResultContentDataContentApiConfigList() = default;
};
class GetMdsMiniConfigResponseBodyResultContentDataContentPrivilegeSwitch : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<long> configStatus{};
  shared_ptr<string> configType{};
  shared_ptr<string> configValue{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> h5Id{};
  shared_ptr<string> h5Name{};
  shared_ptr<long> id{};

  GetMdsMiniConfigResponseBodyResultContentDataContentPrivilegeSwitch() {}

  explicit GetMdsMiniConfigResponseBodyResultContentDataContentPrivilegeSwitch(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (configStatus) {
      res["ConfigStatus"] = boost::any(*configStatus);
    }
    if (configType) {
      res["ConfigType"] = boost::any(*configType);
    }
    if (configValue) {
      res["ConfigValue"] = boost::any(*configValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (h5Id) {
      res["H5Id"] = boost::any(*h5Id);
    }
    if (h5Name) {
      res["H5Name"] = boost::any(*h5Name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("ConfigStatus") != m.end() && !m["ConfigStatus"].empty()) {
      configStatus = make_shared<long>(boost::any_cast<long>(m["ConfigStatus"]));
    }
    if (m.find("ConfigType") != m.end() && !m["ConfigType"].empty()) {
      configType = make_shared<string>(boost::any_cast<string>(m["ConfigType"]));
    }
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["ConfigValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("H5Id") != m.end() && !m["H5Id"].empty()) {
      h5Id = make_shared<string>(boost::any_cast<string>(m["H5Id"]));
    }
    if (m.find("H5Name") != m.end() && !m["H5Name"].empty()) {
      h5Name = make_shared<string>(boost::any_cast<string>(m["H5Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetMdsMiniConfigResponseBodyResultContentDataContentPrivilegeSwitch() = default;
};
class GetMdsMiniConfigResponseBodyResultContentDataContentServerDomainConfigList : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<long> configStatus{};
  shared_ptr<string> configType{};
  shared_ptr<string> configValue{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> h5Id{};
  shared_ptr<string> h5Name{};
  shared_ptr<long> id{};

  GetMdsMiniConfigResponseBodyResultContentDataContentServerDomainConfigList() {}

  explicit GetMdsMiniConfigResponseBodyResultContentDataContentServerDomainConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (configStatus) {
      res["ConfigStatus"] = boost::any(*configStatus);
    }
    if (configType) {
      res["ConfigType"] = boost::any(*configType);
    }
    if (configValue) {
      res["ConfigValue"] = boost::any(*configValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (h5Id) {
      res["H5Id"] = boost::any(*h5Id);
    }
    if (h5Name) {
      res["H5Name"] = boost::any(*h5Name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("ConfigStatus") != m.end() && !m["ConfigStatus"].empty()) {
      configStatus = make_shared<long>(boost::any_cast<long>(m["ConfigStatus"]));
    }
    if (m.find("ConfigType") != m.end() && !m["ConfigType"].empty()) {
      configType = make_shared<string>(boost::any_cast<string>(m["ConfigType"]));
    }
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["ConfigValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("H5Id") != m.end() && !m["H5Id"].empty()) {
      h5Id = make_shared<string>(boost::any_cast<string>(m["H5Id"]));
    }
    if (m.find("H5Name") != m.end() && !m["H5Name"].empty()) {
      h5Name = make_shared<string>(boost::any_cast<string>(m["H5Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetMdsMiniConfigResponseBodyResultContentDataContentServerDomainConfigList() = default;
};
class GetMdsMiniConfigResponseBodyResultContentDataContentWebviewDomainConfigList : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<long> configStatus{};
  shared_ptr<string> configType{};
  shared_ptr<string> configValue{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> h5Id{};
  shared_ptr<string> h5Name{};
  shared_ptr<long> id{};

  GetMdsMiniConfigResponseBodyResultContentDataContentWebviewDomainConfigList() {}

  explicit GetMdsMiniConfigResponseBodyResultContentDataContentWebviewDomainConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (configStatus) {
      res["ConfigStatus"] = boost::any(*configStatus);
    }
    if (configType) {
      res["ConfigType"] = boost::any(*configType);
    }
    if (configValue) {
      res["ConfigValue"] = boost::any(*configValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (h5Id) {
      res["H5Id"] = boost::any(*h5Id);
    }
    if (h5Name) {
      res["H5Name"] = boost::any(*h5Name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("ConfigStatus") != m.end() && !m["ConfigStatus"].empty()) {
      configStatus = make_shared<long>(boost::any_cast<long>(m["ConfigStatus"]));
    }
    if (m.find("ConfigType") != m.end() && !m["ConfigType"].empty()) {
      configType = make_shared<string>(boost::any_cast<string>(m["ConfigType"]));
    }
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["ConfigValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("H5Id") != m.end() && !m["H5Id"].empty()) {
      h5Id = make_shared<string>(boost::any_cast<string>(m["H5Id"]));
    }
    if (m.find("H5Name") != m.end() && !m["H5Name"].empty()) {
      h5Name = make_shared<string>(boost::any_cast<string>(m["H5Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetMdsMiniConfigResponseBodyResultContentDataContentWebviewDomainConfigList() = default;
};
class GetMdsMiniConfigResponseBodyResultContentDataContent : public Darabonba::Model {
public:
  shared_ptr<vector<GetMdsMiniConfigResponseBodyResultContentDataContentApiConfigList>> apiConfigList{};
  shared_ptr<string> appCode{};
  shared_ptr<string> enableServerDomainCount{};
  shared_ptr<string> h5Id{};
  shared_ptr<string> h5Name{};
  shared_ptr<GetMdsMiniConfigResponseBodyResultContentDataContentPrivilegeSwitch> privilegeSwitch{};
  shared_ptr<vector<GetMdsMiniConfigResponseBodyResultContentDataContentServerDomainConfigList>> serverDomainConfigList{};
  shared_ptr<vector<GetMdsMiniConfigResponseBodyResultContentDataContentWebviewDomainConfigList>> webviewDomainConfigList{};

  GetMdsMiniConfigResponseBodyResultContentDataContent() {}

  explicit GetMdsMiniConfigResponseBodyResultContentDataContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*apiConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiConfigList"] = boost::any(temp1);
    }
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (enableServerDomainCount) {
      res["EnableServerDomainCount"] = boost::any(*enableServerDomainCount);
    }
    if (h5Id) {
      res["H5Id"] = boost::any(*h5Id);
    }
    if (h5Name) {
      res["H5Name"] = boost::any(*h5Name);
    }
    if (privilegeSwitch) {
      res["PrivilegeSwitch"] = privilegeSwitch ? boost::any(privilegeSwitch->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serverDomainConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*serverDomainConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServerDomainConfigList"] = boost::any(temp1);
    }
    if (webviewDomainConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*webviewDomainConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WebviewDomainConfigList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiConfigList") != m.end() && !m["ApiConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiConfigList"].type()) {
        vector<GetMdsMiniConfigResponseBodyResultContentDataContentApiConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMdsMiniConfigResponseBodyResultContentDataContentApiConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiConfigList = make_shared<vector<GetMdsMiniConfigResponseBodyResultContentDataContentApiConfigList>>(expect1);
      }
    }
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("EnableServerDomainCount") != m.end() && !m["EnableServerDomainCount"].empty()) {
      enableServerDomainCount = make_shared<string>(boost::any_cast<string>(m["EnableServerDomainCount"]));
    }
    if (m.find("H5Id") != m.end() && !m["H5Id"].empty()) {
      h5Id = make_shared<string>(boost::any_cast<string>(m["H5Id"]));
    }
    if (m.find("H5Name") != m.end() && !m["H5Name"].empty()) {
      h5Name = make_shared<string>(boost::any_cast<string>(m["H5Name"]));
    }
    if (m.find("PrivilegeSwitch") != m.end() && !m["PrivilegeSwitch"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivilegeSwitch"].type()) {
        GetMdsMiniConfigResponseBodyResultContentDataContentPrivilegeSwitch model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivilegeSwitch"]));
        privilegeSwitch = make_shared<GetMdsMiniConfigResponseBodyResultContentDataContentPrivilegeSwitch>(model1);
      }
    }
    if (m.find("ServerDomainConfigList") != m.end() && !m["ServerDomainConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["ServerDomainConfigList"].type()) {
        vector<GetMdsMiniConfigResponseBodyResultContentDataContentServerDomainConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServerDomainConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMdsMiniConfigResponseBodyResultContentDataContentServerDomainConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serverDomainConfigList = make_shared<vector<GetMdsMiniConfigResponseBodyResultContentDataContentServerDomainConfigList>>(expect1);
      }
    }
    if (m.find("WebviewDomainConfigList") != m.end() && !m["WebviewDomainConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["WebviewDomainConfigList"].type()) {
        vector<GetMdsMiniConfigResponseBodyResultContentDataContentWebviewDomainConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WebviewDomainConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMdsMiniConfigResponseBodyResultContentDataContentWebviewDomainConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        webviewDomainConfigList = make_shared<vector<GetMdsMiniConfigResponseBodyResultContentDataContentWebviewDomainConfigList>>(expect1);
      }
    }
  }


  virtual ~GetMdsMiniConfigResponseBodyResultContentDataContent() = default;
};
class GetMdsMiniConfigResponseBodyResultContentData : public Darabonba::Model {
public:
  shared_ptr<GetMdsMiniConfigResponseBodyResultContentDataContent> content{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  GetMdsMiniConfigResponseBodyResultContentData() {}

  explicit GetMdsMiniConfigResponseBodyResultContentData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        GetMdsMiniConfigResponseBodyResultContentDataContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<GetMdsMiniConfigResponseBodyResultContentDataContent>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetMdsMiniConfigResponseBodyResultContentData() = default;
};
class GetMdsMiniConfigResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<GetMdsMiniConfigResponseBodyResultContentData> data{};
  shared_ptr<string> requestId{};

  GetMdsMiniConfigResponseBodyResultContent() {}

  explicit GetMdsMiniConfigResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMdsMiniConfigResponseBodyResultContentData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMdsMiniConfigResponseBodyResultContentData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMdsMiniConfigResponseBodyResultContent() = default;
};
class GetMdsMiniConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<GetMdsMiniConfigResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  GetMdsMiniConfigResponseBody() {}

  explicit GetMdsMiniConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        GetMdsMiniConfigResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<GetMdsMiniConfigResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~GetMdsMiniConfigResponseBody() = default;
};
class GetMdsMiniConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMdsMiniConfigResponseBody> body{};

  GetMdsMiniConfigResponse() {}

  explicit GetMdsMiniConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMdsMiniConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMdsMiniConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GetMdsMiniConfigResponse() = default;
};
class GetUserAppDonwloadUrlInMsaRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> id{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  GetUserAppDonwloadUrlInMsaRequest() {}

  explicit GetUserAppDonwloadUrlInMsaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetUserAppDonwloadUrlInMsaRequest() = default;
};
class GetUserAppDonwloadUrlInMsaResponseBodyResultContentData : public Darabonba::Model {
public:
  shared_ptr<string> filename{};
  shared_ptr<string> url{};

  GetUserAppDonwloadUrlInMsaResponseBodyResultContentData() {}

  explicit GetUserAppDonwloadUrlInMsaResponseBodyResultContentData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filename) {
      res["Filename"] = boost::any(*filename);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filename") != m.end() && !m["Filename"].empty()) {
      filename = make_shared<string>(boost::any_cast<string>(m["Filename"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetUserAppDonwloadUrlInMsaResponseBodyResultContentData() = default;
};
class GetUserAppDonwloadUrlInMsaResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetUserAppDonwloadUrlInMsaResponseBodyResultContentData> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  GetUserAppDonwloadUrlInMsaResponseBodyResultContent() {}

  explicit GetUserAppDonwloadUrlInMsaResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetUserAppDonwloadUrlInMsaResponseBodyResultContentData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetUserAppDonwloadUrlInMsaResponseBodyResultContentData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetUserAppDonwloadUrlInMsaResponseBodyResultContent() = default;
};
class GetUserAppDonwloadUrlInMsaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<GetUserAppDonwloadUrlInMsaResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  GetUserAppDonwloadUrlInMsaResponseBody() {}

  explicit GetUserAppDonwloadUrlInMsaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        GetUserAppDonwloadUrlInMsaResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<GetUserAppDonwloadUrlInMsaResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~GetUserAppDonwloadUrlInMsaResponseBody() = default;
};
class GetUserAppDonwloadUrlInMsaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserAppDonwloadUrlInMsaResponseBody> body{};

  GetUserAppDonwloadUrlInMsaResponse() {}

  explicit GetUserAppDonwloadUrlInMsaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserAppDonwloadUrlInMsaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserAppDonwloadUrlInMsaResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserAppDonwloadUrlInMsaResponse() = default;
};
class GetUserAppEnhanceProcessInMsaRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> id{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  GetUserAppEnhanceProcessInMsaRequest() {}

  explicit GetUserAppEnhanceProcessInMsaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetUserAppEnhanceProcessInMsaRequest() = default;
};
class GetUserAppEnhanceProcessInMsaResponseBodyResultContentDataEnhanceMapping : public Darabonba::Model {
public:
  shared_ptr<string> info{};
  shared_ptr<string> reason{};
  shared_ptr<string> type{};

  GetUserAppEnhanceProcessInMsaResponseBodyResultContentDataEnhanceMapping() {}

  explicit GetUserAppEnhanceProcessInMsaResponseBodyResultContentDataEnhanceMapping(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = boost::any(*info);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      info = make_shared<string>(boost::any_cast<string>(m["Info"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetUserAppEnhanceProcessInMsaResponseBodyResultContentDataEnhanceMapping() = default;
};
class GetUserAppEnhanceProcessInMsaResponseBodyResultContentData : public Darabonba::Model {
public:
  shared_ptr<string> afterMd5{};
  shared_ptr<long> afterSize{};
  shared_ptr<string> appCode{};
  shared_ptr<string> appPackage{};
  shared_ptr<vector<string>> assetsFileList{};
  shared_ptr<string> beforeMd5{};
  shared_ptr<long> beforeSize{};
  shared_ptr<vector<string>> classForest{};
  shared_ptr<vector<GetUserAppEnhanceProcessInMsaResponseBodyResultContentDataEnhanceMapping>> enhanceMapping{};
  shared_ptr<vector<string>> enhanceRules{};
  shared_ptr<vector<string>> enhancedAssetsFiles{};
  shared_ptr<vector<string>> enhancedClasses{};
  shared_ptr<vector<string>> enhancedSoFiles{};
  shared_ptr<long> id{};
  shared_ptr<string> label{};
  shared_ptr<long> progress{};
  shared_ptr<vector<string>> soFileList{};
  shared_ptr<long> status{};
  shared_ptr<string> taskType{};
  shared_ptr<string> versionCode{};
  shared_ptr<string> versionName{};

  GetUserAppEnhanceProcessInMsaResponseBodyResultContentData() {}

  explicit GetUserAppEnhanceProcessInMsaResponseBodyResultContentData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (afterMd5) {
      res["AfterMd5"] = boost::any(*afterMd5);
    }
    if (afterSize) {
      res["AfterSize"] = boost::any(*afterSize);
    }
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (appPackage) {
      res["AppPackage"] = boost::any(*appPackage);
    }
    if (assetsFileList) {
      res["AssetsFileList"] = boost::any(*assetsFileList);
    }
    if (beforeMd5) {
      res["BeforeMd5"] = boost::any(*beforeMd5);
    }
    if (beforeSize) {
      res["BeforeSize"] = boost::any(*beforeSize);
    }
    if (classForest) {
      res["ClassForest"] = boost::any(*classForest);
    }
    if (enhanceMapping) {
      vector<boost::any> temp1;
      for(auto item1:*enhanceMapping){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnhanceMapping"] = boost::any(temp1);
    }
    if (enhanceRules) {
      res["EnhanceRules"] = boost::any(*enhanceRules);
    }
    if (enhancedAssetsFiles) {
      res["EnhancedAssetsFiles"] = boost::any(*enhancedAssetsFiles);
    }
    if (enhancedClasses) {
      res["EnhancedClasses"] = boost::any(*enhancedClasses);
    }
    if (enhancedSoFiles) {
      res["EnhancedSoFiles"] = boost::any(*enhancedSoFiles);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (soFileList) {
      res["SoFileList"] = boost::any(*soFileList);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    if (versionName) {
      res["VersionName"] = boost::any(*versionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AfterMd5") != m.end() && !m["AfterMd5"].empty()) {
      afterMd5 = make_shared<string>(boost::any_cast<string>(m["AfterMd5"]));
    }
    if (m.find("AfterSize") != m.end() && !m["AfterSize"].empty()) {
      afterSize = make_shared<long>(boost::any_cast<long>(m["AfterSize"]));
    }
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("AppPackage") != m.end() && !m["AppPackage"].empty()) {
      appPackage = make_shared<string>(boost::any_cast<string>(m["AppPackage"]));
    }
    if (m.find("AssetsFileList") != m.end() && !m["AssetsFileList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AssetsFileList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AssetsFileList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      assetsFileList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("BeforeMd5") != m.end() && !m["BeforeMd5"].empty()) {
      beforeMd5 = make_shared<string>(boost::any_cast<string>(m["BeforeMd5"]));
    }
    if (m.find("BeforeSize") != m.end() && !m["BeforeSize"].empty()) {
      beforeSize = make_shared<long>(boost::any_cast<long>(m["BeforeSize"]));
    }
    if (m.find("ClassForest") != m.end() && !m["ClassForest"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ClassForest"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ClassForest"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      classForest = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnhanceMapping") != m.end() && !m["EnhanceMapping"].empty()) {
      if (typeid(vector<boost::any>) == m["EnhanceMapping"].type()) {
        vector<GetUserAppEnhanceProcessInMsaResponseBodyResultContentDataEnhanceMapping> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnhanceMapping"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetUserAppEnhanceProcessInMsaResponseBodyResultContentDataEnhanceMapping model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        enhanceMapping = make_shared<vector<GetUserAppEnhanceProcessInMsaResponseBodyResultContentDataEnhanceMapping>>(expect1);
      }
    }
    if (m.find("EnhanceRules") != m.end() && !m["EnhanceRules"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnhanceRules"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnhanceRules"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      enhanceRules = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnhancedAssetsFiles") != m.end() && !m["EnhancedAssetsFiles"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnhancedAssetsFiles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnhancedAssetsFiles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      enhancedAssetsFiles = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnhancedClasses") != m.end() && !m["EnhancedClasses"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnhancedClasses"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnhancedClasses"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      enhancedClasses = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnhancedSoFiles") != m.end() && !m["EnhancedSoFiles"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnhancedSoFiles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnhancedSoFiles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      enhancedSoFiles = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("SoFileList") != m.end() && !m["SoFileList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SoFileList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SoFileList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      soFileList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
    if (m.find("VersionName") != m.end() && !m["VersionName"].empty()) {
      versionName = make_shared<string>(boost::any_cast<string>(m["VersionName"]));
    }
  }


  virtual ~GetUserAppEnhanceProcessInMsaResponseBodyResultContentData() = default;
};
class GetUserAppEnhanceProcessInMsaResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetUserAppEnhanceProcessInMsaResponseBodyResultContentData> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  GetUserAppEnhanceProcessInMsaResponseBodyResultContent() {}

  explicit GetUserAppEnhanceProcessInMsaResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetUserAppEnhanceProcessInMsaResponseBodyResultContentData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetUserAppEnhanceProcessInMsaResponseBodyResultContentData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetUserAppEnhanceProcessInMsaResponseBodyResultContent() = default;
};
class GetUserAppEnhanceProcessInMsaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<GetUserAppEnhanceProcessInMsaResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  GetUserAppEnhanceProcessInMsaResponseBody() {}

  explicit GetUserAppEnhanceProcessInMsaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        GetUserAppEnhanceProcessInMsaResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<GetUserAppEnhanceProcessInMsaResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~GetUserAppEnhanceProcessInMsaResponseBody() = default;
};
class GetUserAppEnhanceProcessInMsaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserAppEnhanceProcessInMsaResponseBody> body{};

  GetUserAppEnhanceProcessInMsaResponse() {}

  explicit GetUserAppEnhanceProcessInMsaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserAppEnhanceProcessInMsaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserAppEnhanceProcessInMsaResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserAppEnhanceProcessInMsaResponse() = default;
};
class GetUserAppUploadProcessInMsaRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> id{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  GetUserAppUploadProcessInMsaRequest() {}

  explicit GetUserAppUploadProcessInMsaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetUserAppUploadProcessInMsaRequest() = default;
};
class GetUserAppUploadProcessInMsaResponseBodyResultContentDataApkInfoEnhanceMapping : public Darabonba::Model {
public:
  shared_ptr<string> info{};
  shared_ptr<string> reason{};
  shared_ptr<string> type{};

  GetUserAppUploadProcessInMsaResponseBodyResultContentDataApkInfoEnhanceMapping() {}

  explicit GetUserAppUploadProcessInMsaResponseBodyResultContentDataApkInfoEnhanceMapping(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = boost::any(*info);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      info = make_shared<string>(boost::any_cast<string>(m["Info"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetUserAppUploadProcessInMsaResponseBodyResultContentDataApkInfoEnhanceMapping() = default;
};
class GetUserAppUploadProcessInMsaResponseBodyResultContentDataApkInfo : public Darabonba::Model {
public:
  shared_ptr<string> afterMd5{};
  shared_ptr<long> afterSize{};
  shared_ptr<string> appCode{};
  shared_ptr<string> appPackage{};
  shared_ptr<vector<string>> assetsFileList{};
  shared_ptr<string> beforeMd5{};
  shared_ptr<long> beforeSize{};
  shared_ptr<string> classForest{};
  shared_ptr<vector<GetUserAppUploadProcessInMsaResponseBodyResultContentDataApkInfoEnhanceMapping>> enhanceMapping{};
  shared_ptr<vector<string>> enhanceRules{};
  shared_ptr<vector<string>> enhancedAssetsFiles{};
  shared_ptr<vector<string>> enhancedClasses{};
  shared_ptr<vector<string>> enhancedSoFiles{};
  shared_ptr<long> id{};
  shared_ptr<string> label{};
  shared_ptr<long> progress{};
  shared_ptr<vector<string>> soFileList{};
  shared_ptr<long> status{};
  shared_ptr<string> taskType{};
  shared_ptr<string> versionCode{};
  shared_ptr<string> versionName{};

  GetUserAppUploadProcessInMsaResponseBodyResultContentDataApkInfo() {}

  explicit GetUserAppUploadProcessInMsaResponseBodyResultContentDataApkInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (afterMd5) {
      res["AfterMd5"] = boost::any(*afterMd5);
    }
    if (afterSize) {
      res["AfterSize"] = boost::any(*afterSize);
    }
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (appPackage) {
      res["AppPackage"] = boost::any(*appPackage);
    }
    if (assetsFileList) {
      res["AssetsFileList"] = boost::any(*assetsFileList);
    }
    if (beforeMd5) {
      res["BeforeMd5"] = boost::any(*beforeMd5);
    }
    if (beforeSize) {
      res["BeforeSize"] = boost::any(*beforeSize);
    }
    if (classForest) {
      res["ClassForest"] = boost::any(*classForest);
    }
    if (enhanceMapping) {
      vector<boost::any> temp1;
      for(auto item1:*enhanceMapping){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnhanceMapping"] = boost::any(temp1);
    }
    if (enhanceRules) {
      res["EnhanceRules"] = boost::any(*enhanceRules);
    }
    if (enhancedAssetsFiles) {
      res["EnhancedAssetsFiles"] = boost::any(*enhancedAssetsFiles);
    }
    if (enhancedClasses) {
      res["EnhancedClasses"] = boost::any(*enhancedClasses);
    }
    if (enhancedSoFiles) {
      res["EnhancedSoFiles"] = boost::any(*enhancedSoFiles);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (soFileList) {
      res["SoFileList"] = boost::any(*soFileList);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    if (versionName) {
      res["VersionName"] = boost::any(*versionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AfterMd5") != m.end() && !m["AfterMd5"].empty()) {
      afterMd5 = make_shared<string>(boost::any_cast<string>(m["AfterMd5"]));
    }
    if (m.find("AfterSize") != m.end() && !m["AfterSize"].empty()) {
      afterSize = make_shared<long>(boost::any_cast<long>(m["AfterSize"]));
    }
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("AppPackage") != m.end() && !m["AppPackage"].empty()) {
      appPackage = make_shared<string>(boost::any_cast<string>(m["AppPackage"]));
    }
    if (m.find("AssetsFileList") != m.end() && !m["AssetsFileList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AssetsFileList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AssetsFileList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      assetsFileList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("BeforeMd5") != m.end() && !m["BeforeMd5"].empty()) {
      beforeMd5 = make_shared<string>(boost::any_cast<string>(m["BeforeMd5"]));
    }
    if (m.find("BeforeSize") != m.end() && !m["BeforeSize"].empty()) {
      beforeSize = make_shared<long>(boost::any_cast<long>(m["BeforeSize"]));
    }
    if (m.find("ClassForest") != m.end() && !m["ClassForest"].empty()) {
      classForest = make_shared<string>(boost::any_cast<string>(m["ClassForest"]));
    }
    if (m.find("EnhanceMapping") != m.end() && !m["EnhanceMapping"].empty()) {
      if (typeid(vector<boost::any>) == m["EnhanceMapping"].type()) {
        vector<GetUserAppUploadProcessInMsaResponseBodyResultContentDataApkInfoEnhanceMapping> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnhanceMapping"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetUserAppUploadProcessInMsaResponseBodyResultContentDataApkInfoEnhanceMapping model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        enhanceMapping = make_shared<vector<GetUserAppUploadProcessInMsaResponseBodyResultContentDataApkInfoEnhanceMapping>>(expect1);
      }
    }
    if (m.find("EnhanceRules") != m.end() && !m["EnhanceRules"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnhanceRules"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnhanceRules"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      enhanceRules = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnhancedAssetsFiles") != m.end() && !m["EnhancedAssetsFiles"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnhancedAssetsFiles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnhancedAssetsFiles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      enhancedAssetsFiles = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnhancedClasses") != m.end() && !m["EnhancedClasses"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnhancedClasses"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnhancedClasses"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      enhancedClasses = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnhancedSoFiles") != m.end() && !m["EnhancedSoFiles"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnhancedSoFiles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnhancedSoFiles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      enhancedSoFiles = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("SoFileList") != m.end() && !m["SoFileList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SoFileList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SoFileList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      soFileList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
    if (m.find("VersionName") != m.end() && !m["VersionName"].empty()) {
      versionName = make_shared<string>(boost::any_cast<string>(m["VersionName"]));
    }
  }


  virtual ~GetUserAppUploadProcessInMsaResponseBodyResultContentDataApkInfo() = default;
};
class GetUserAppUploadProcessInMsaResponseBodyResultContentData : public Darabonba::Model {
public:
  shared_ptr<GetUserAppUploadProcessInMsaResponseBodyResultContentDataApkInfo> apkInfo{};
  shared_ptr<long> enhanceTaskId{};
  shared_ptr<long> id{};
  shared_ptr<long> progress{};
  shared_ptr<long> status{};

  GetUserAppUploadProcessInMsaResponseBodyResultContentData() {}

  explicit GetUserAppUploadProcessInMsaResponseBodyResultContentData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apkInfo) {
      res["ApkInfo"] = apkInfo ? boost::any(apkInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (enhanceTaskId) {
      res["EnhanceTaskId"] = boost::any(*enhanceTaskId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApkInfo") != m.end() && !m["ApkInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApkInfo"].type()) {
        GetUserAppUploadProcessInMsaResponseBodyResultContentDataApkInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApkInfo"]));
        apkInfo = make_shared<GetUserAppUploadProcessInMsaResponseBodyResultContentDataApkInfo>(model1);
      }
    }
    if (m.find("EnhanceTaskId") != m.end() && !m["EnhanceTaskId"].empty()) {
      enhanceTaskId = make_shared<long>(boost::any_cast<long>(m["EnhanceTaskId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~GetUserAppUploadProcessInMsaResponseBodyResultContentData() = default;
};
class GetUserAppUploadProcessInMsaResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetUserAppUploadProcessInMsaResponseBodyResultContentData> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  GetUserAppUploadProcessInMsaResponseBodyResultContent() {}

  explicit GetUserAppUploadProcessInMsaResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetUserAppUploadProcessInMsaResponseBodyResultContentData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetUserAppUploadProcessInMsaResponseBodyResultContentData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetUserAppUploadProcessInMsaResponseBodyResultContent() = default;
};
class GetUserAppUploadProcessInMsaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<GetUserAppUploadProcessInMsaResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  GetUserAppUploadProcessInMsaResponseBody() {}

  explicit GetUserAppUploadProcessInMsaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        GetUserAppUploadProcessInMsaResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<GetUserAppUploadProcessInMsaResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~GetUserAppUploadProcessInMsaResponseBody() = default;
};
class GetUserAppUploadProcessInMsaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserAppUploadProcessInMsaResponseBody> body{};

  GetUserAppUploadProcessInMsaResponse() {}

  explicit GetUserAppUploadProcessInMsaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserAppUploadProcessInMsaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserAppUploadProcessInMsaResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserAppUploadProcessInMsaResponse() = default;
};
class ListMappCenterAppsResponseBodyListMappCenterAppResultMappCenterAppListAndroidConfig : public Darabonba::Model {
public:
  shared_ptr<string> certRSA{};
  shared_ptr<string> packageName{};

  ListMappCenterAppsResponseBodyListMappCenterAppResultMappCenterAppListAndroidConfig() {}

  explicit ListMappCenterAppsResponseBodyListMappCenterAppResultMappCenterAppListAndroidConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certRSA) {
      res["CertRSA"] = boost::any(*certRSA);
    }
    if (packageName) {
      res["PackageName"] = boost::any(*packageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertRSA") != m.end() && !m["CertRSA"].empty()) {
      certRSA = make_shared<string>(boost::any_cast<string>(m["CertRSA"]));
    }
    if (m.find("PackageName") != m.end() && !m["PackageName"].empty()) {
      packageName = make_shared<string>(boost::any_cast<string>(m["PackageName"]));
    }
  }


  virtual ~ListMappCenterAppsResponseBodyListMappCenterAppResultMappCenterAppListAndroidConfig() = default;
};
class ListMappCenterAppsResponseBodyListMappCenterAppResultMappCenterAppListIosConfig : public Darabonba::Model {
public:
  shared_ptr<string> bundleId{};

  ListMappCenterAppsResponseBodyListMappCenterAppResultMappCenterAppListIosConfig() {}

  explicit ListMappCenterAppsResponseBodyListMappCenterAppResultMappCenterAppListIosConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bundleId) {
      res["BundleId"] = boost::any(*bundleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BundleId") != m.end() && !m["BundleId"].empty()) {
      bundleId = make_shared<string>(boost::any_cast<string>(m["BundleId"]));
    }
  }


  virtual ~ListMappCenterAppsResponseBodyListMappCenterAppResultMappCenterAppListIosConfig() = default;
};
class ListMappCenterAppsResponseBodyListMappCenterAppResultMappCenterAppList : public Darabonba::Model {
public:
  shared_ptr<ListMappCenterAppsResponseBodyListMappCenterAppResultMappCenterAppListAndroidConfig> androidConfig{};
  shared_ptr<string> appDesc{};
  shared_ptr<string> appIcon{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> appSecret{};
  shared_ptr<string> creator{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<ListMappCenterAppsResponseBodyListMappCenterAppResultMappCenterAppListIosConfig> iosConfig{};
  shared_ptr<string> modifier{};
  shared_ptr<string> monitorJson{};
  shared_ptr<long> status{};
  shared_ptr<string> tenantId{};
  shared_ptr<long> type{};

  ListMappCenterAppsResponseBodyListMappCenterAppResultMappCenterAppList() {}

  explicit ListMappCenterAppsResponseBodyListMappCenterAppResultMappCenterAppList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (androidConfig) {
      res["AndroidConfig"] = androidConfig ? boost::any(androidConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (appDesc) {
      res["AppDesc"] = boost::any(*appDesc);
    }
    if (appIcon) {
      res["AppIcon"] = boost::any(*appIcon);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appSecret) {
      res["AppSecret"] = boost::any(*appSecret);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (iosConfig) {
      res["IosConfig"] = iosConfig ? boost::any(iosConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modifier) {
      res["Modifier"] = boost::any(*modifier);
    }
    if (monitorJson) {
      res["MonitorJson"] = boost::any(*monitorJson);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AndroidConfig") != m.end() && !m["AndroidConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AndroidConfig"].type()) {
        ListMappCenterAppsResponseBodyListMappCenterAppResultMappCenterAppListAndroidConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AndroidConfig"]));
        androidConfig = make_shared<ListMappCenterAppsResponseBodyListMappCenterAppResultMappCenterAppListAndroidConfig>(model1);
      }
    }
    if (m.find("AppDesc") != m.end() && !m["AppDesc"].empty()) {
      appDesc = make_shared<string>(boost::any_cast<string>(m["AppDesc"]));
    }
    if (m.find("AppIcon") != m.end() && !m["AppIcon"].empty()) {
      appIcon = make_shared<string>(boost::any_cast<string>(m["AppIcon"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppSecret") != m.end() && !m["AppSecret"].empty()) {
      appSecret = make_shared<string>(boost::any_cast<string>(m["AppSecret"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IosConfig") != m.end() && !m["IosConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IosConfig"].type()) {
        ListMappCenterAppsResponseBodyListMappCenterAppResultMappCenterAppListIosConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IosConfig"]));
        iosConfig = make_shared<ListMappCenterAppsResponseBodyListMappCenterAppResultMappCenterAppListIosConfig>(model1);
      }
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["Modifier"]));
    }
    if (m.find("MonitorJson") != m.end() && !m["MonitorJson"].empty()) {
      monitorJson = make_shared<string>(boost::any_cast<string>(m["MonitorJson"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~ListMappCenterAppsResponseBodyListMappCenterAppResultMappCenterAppList() = default;
};
class ListMappCenterAppsResponseBodyListMappCenterAppResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListMappCenterAppsResponseBodyListMappCenterAppResultMappCenterAppList>> mappCenterAppList{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  ListMappCenterAppsResponseBodyListMappCenterAppResult() {}

  explicit ListMappCenterAppsResponseBodyListMappCenterAppResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mappCenterAppList) {
      vector<boost::any> temp1;
      for(auto item1:*mappCenterAppList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MappCenterAppList"] = boost::any(temp1);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MappCenterAppList") != m.end() && !m["MappCenterAppList"].empty()) {
      if (typeid(vector<boost::any>) == m["MappCenterAppList"].type()) {
        vector<ListMappCenterAppsResponseBodyListMappCenterAppResultMappCenterAppList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MappCenterAppList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMappCenterAppsResponseBodyListMappCenterAppResultMappCenterAppList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mappCenterAppList = make_shared<vector<ListMappCenterAppsResponseBodyListMappCenterAppResultMappCenterAppList>>(expect1);
      }
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListMappCenterAppsResponseBodyListMappCenterAppResult() = default;
};
class ListMappCenterAppsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListMappCenterAppsResponseBodyListMappCenterAppResult> listMappCenterAppResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  ListMappCenterAppsResponseBody() {}

  explicit ListMappCenterAppsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listMappCenterAppResult) {
      res["ListMappCenterAppResult"] = listMappCenterAppResult ? boost::any(listMappCenterAppResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListMappCenterAppResult") != m.end() && !m["ListMappCenterAppResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListMappCenterAppResult"].type()) {
        ListMappCenterAppsResponseBodyListMappCenterAppResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListMappCenterAppResult"]));
        listMappCenterAppResult = make_shared<ListMappCenterAppsResponseBodyListMappCenterAppResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~ListMappCenterAppsResponseBody() = default;
};
class ListMappCenterAppsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMappCenterAppsResponseBody> body{};

  ListMappCenterAppsResponse() {}

  explicit ListMappCenterAppsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMappCenterAppsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMappCenterAppsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMappCenterAppsResponse() = default;
};
class ListMappCenterWorkspacesResponseBodyListMappCenterWorkspaceResultMappCenterWorkspaceList : public Darabonba::Model {
public:
  shared_ptr<string> compatibleId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> displayName{};
  shared_ptr<string> id{};
  shared_ptr<string> region{};
  shared_ptr<string> status{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> type{};
  shared_ptr<long> uid{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> workspaceId{};
  shared_ptr<string> zones{};

  ListMappCenterWorkspacesResponseBodyListMappCenterWorkspaceResultMappCenterWorkspaceList() {}

  explicit ListMappCenterWorkspacesResponseBodyListMappCenterWorkspaceResultMappCenterWorkspaceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compatibleId) {
      res["CompatibleId"] = boost::any(*compatibleId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    if (zones) {
      res["Zones"] = boost::any(*zones);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompatibleId") != m.end() && !m["CompatibleId"].empty()) {
      compatibleId = make_shared<string>(boost::any_cast<string>(m["CompatibleId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<long>(boost::any_cast<long>(m["Uid"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
    if (m.find("Zones") != m.end() && !m["Zones"].empty()) {
      zones = make_shared<string>(boost::any_cast<string>(m["Zones"]));
    }
  }


  virtual ~ListMappCenterWorkspacesResponseBodyListMappCenterWorkspaceResultMappCenterWorkspaceList() = default;
};
class ListMappCenterWorkspacesResponseBodyListMappCenterWorkspaceResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListMappCenterWorkspacesResponseBodyListMappCenterWorkspaceResultMappCenterWorkspaceList>> mappCenterWorkspaceList{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};
  shared_ptr<string> userId{};

  ListMappCenterWorkspacesResponseBodyListMappCenterWorkspaceResult() {}

  explicit ListMappCenterWorkspacesResponseBodyListMappCenterWorkspaceResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mappCenterWorkspaceList) {
      vector<boost::any> temp1;
      for(auto item1:*mappCenterWorkspaceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MappCenterWorkspaceList"] = boost::any(temp1);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MappCenterWorkspaceList") != m.end() && !m["MappCenterWorkspaceList"].empty()) {
      if (typeid(vector<boost::any>) == m["MappCenterWorkspaceList"].type()) {
        vector<ListMappCenterWorkspacesResponseBodyListMappCenterWorkspaceResultMappCenterWorkspaceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MappCenterWorkspaceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMappCenterWorkspacesResponseBodyListMappCenterWorkspaceResultMappCenterWorkspaceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mappCenterWorkspaceList = make_shared<vector<ListMappCenterWorkspacesResponseBodyListMappCenterWorkspaceResultMappCenterWorkspaceList>>(expect1);
      }
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListMappCenterWorkspacesResponseBodyListMappCenterWorkspaceResult() = default;
};
class ListMappCenterWorkspacesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListMappCenterWorkspacesResponseBodyListMappCenterWorkspaceResult> listMappCenterWorkspaceResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  ListMappCenterWorkspacesResponseBody() {}

  explicit ListMappCenterWorkspacesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listMappCenterWorkspaceResult) {
      res["ListMappCenterWorkspaceResult"] = listMappCenterWorkspaceResult ? boost::any(listMappCenterWorkspaceResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListMappCenterWorkspaceResult") != m.end() && !m["ListMappCenterWorkspaceResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListMappCenterWorkspaceResult"].type()) {
        ListMappCenterWorkspacesResponseBodyListMappCenterWorkspaceResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListMappCenterWorkspaceResult"]));
        listMappCenterWorkspaceResult = make_shared<ListMappCenterWorkspacesResponseBodyListMappCenterWorkspaceResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~ListMappCenterWorkspacesResponseBody() = default;
};
class ListMappCenterWorkspacesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMappCenterWorkspacesResponseBody> body{};

  ListMappCenterWorkspacesResponse() {}

  explicit ListMappCenterWorkspacesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMappCenterWorkspacesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMappCenterWorkspacesResponseBody>(model1);
      }
    }
  }


  virtual ~ListMappCenterWorkspacesResponse() = default;
};
class ListMcdpAimRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> emptyTag{};
  shared_ptr<string> keyword{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sort{};
  shared_ptr<string> sortField{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> type{};
  shared_ptr<string> workspaceId{};

  ListMcdpAimRequest() {}

  explicit ListMcdpAimRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (emptyTag) {
      res["EmptyTag"] = boost::any(*emptyTag);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (sortField) {
      res["SortField"] = boost::any(*sortField);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EmptyTag") != m.end() && !m["EmptyTag"].empty()) {
      emptyTag = make_shared<string>(boost::any_cast<string>(m["EmptyTag"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("SortField") != m.end() && !m["SortField"].empty()) {
      sortField = make_shared<string>(boost::any_cast<string>(m["SortField"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListMcdpAimRequest() = default;
};
class ListMcdpAimResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  ListMcdpAimResponseBodyResultContent() {}

  explicit ListMcdpAimResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListMcdpAimResponseBodyResultContent() = default;
};
class ListMcdpAimResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<ListMcdpAimResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  ListMcdpAimResponseBody() {}

  explicit ListMcdpAimResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        ListMcdpAimResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<ListMcdpAimResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~ListMcdpAimResponseBody() = default;
};
class ListMcdpAimResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMcdpAimResponseBody> body{};

  ListMcdpAimResponse() {}

  explicit ListMcdpAimResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMcdpAimResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMcdpAimResponseBody>(model1);
      }
    }
  }


  virtual ~ListMcdpAimResponse() = default;
};
class ListMcubeMiniAppsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  ListMcubeMiniAppsRequest() {}

  explicit ListMcubeMiniAppsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListMcubeMiniAppsRequest() = default;
};
class ListMcubeMiniAppsResponseBodyListMiniResultMiniProgramList : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> h5Id{};
  shared_ptr<string> h5Name{};

  ListMcubeMiniAppsResponseBodyListMiniResultMiniProgramList() {}

  explicit ListMcubeMiniAppsResponseBodyListMiniResultMiniProgramList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (h5Id) {
      res["H5Id"] = boost::any(*h5Id);
    }
    if (h5Name) {
      res["H5Name"] = boost::any(*h5Name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("H5Id") != m.end() && !m["H5Id"].empty()) {
      h5Id = make_shared<string>(boost::any_cast<string>(m["H5Id"]));
    }
    if (m.find("H5Name") != m.end() && !m["H5Name"].empty()) {
      h5Name = make_shared<string>(boost::any_cast<string>(m["H5Name"]));
    }
  }


  virtual ~ListMcubeMiniAppsResponseBodyListMiniResultMiniProgramList() = default;
};
class ListMcubeMiniAppsResponseBodyListMiniResult : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<bool> hasMore{};
  shared_ptr<vector<ListMcubeMiniAppsResponseBodyListMiniResultMiniProgramList>> miniProgramList{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListMcubeMiniAppsResponseBodyListMiniResult() {}

  explicit ListMcubeMiniAppsResponseBodyListMiniResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (miniProgramList) {
      vector<boost::any> temp1;
      for(auto item1:*miniProgramList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MiniProgramList"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("MiniProgramList") != m.end() && !m["MiniProgramList"].empty()) {
      if (typeid(vector<boost::any>) == m["MiniProgramList"].type()) {
        vector<ListMcubeMiniAppsResponseBodyListMiniResultMiniProgramList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MiniProgramList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMcubeMiniAppsResponseBodyListMiniResultMiniProgramList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        miniProgramList = make_shared<vector<ListMcubeMiniAppsResponseBodyListMiniResultMiniProgramList>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListMcubeMiniAppsResponseBodyListMiniResult() = default;
};
class ListMcubeMiniAppsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListMcubeMiniAppsResponseBodyListMiniResult> listMiniResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  ListMcubeMiniAppsResponseBody() {}

  explicit ListMcubeMiniAppsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listMiniResult) {
      res["ListMiniResult"] = listMiniResult ? boost::any(listMiniResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListMiniResult") != m.end() && !m["ListMiniResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListMiniResult"].type()) {
        ListMcubeMiniAppsResponseBodyListMiniResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListMiniResult"]));
        listMiniResult = make_shared<ListMcubeMiniAppsResponseBodyListMiniResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~ListMcubeMiniAppsResponseBody() = default;
};
class ListMcubeMiniAppsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMcubeMiniAppsResponseBody> body{};

  ListMcubeMiniAppsResponse() {}

  explicit ListMcubeMiniAppsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMcubeMiniAppsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMcubeMiniAppsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMcubeMiniAppsResponse() = default;
};
class ListMcubeMiniPackagesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> h5Id{};
  shared_ptr<string> packageTypes{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  ListMcubeMiniPackagesRequest() {}

  explicit ListMcubeMiniPackagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (h5Id) {
      res["H5Id"] = boost::any(*h5Id);
    }
    if (packageTypes) {
      res["PackageTypes"] = boost::any(*packageTypes);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("H5Id") != m.end() && !m["H5Id"].empty()) {
      h5Id = make_shared<string>(boost::any_cast<string>(m["H5Id"]));
    }
    if (m.find("PackageTypes") != m.end() && !m["PackageTypes"].empty()) {
      packageTypes = make_shared<string>(boost::any_cast<string>(m["PackageTypes"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListMcubeMiniPackagesRequest() = default;
};
class ListMcubeMiniPackagesResponseBodyListMiniPackageResultMiniPackageList : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<long> autoInstall{};
  shared_ptr<string> clientVersionMax{};
  shared_ptr<string> clientVersionMin{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> extendInfo{};
  shared_ptr<string> extraData{};
  shared_ptr<string> fallbackBaseUrl{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> h5Id{};
  shared_ptr<string> h5Name{};
  shared_ptr<string> h5Version{};
  shared_ptr<long> id{};
  shared_ptr<long> installType{};
  shared_ptr<string> mainUrl{};
  shared_ptr<string> memo{};
  shared_ptr<long> packageType{};
  shared_ptr<string> platform{};
  shared_ptr<long> publishPeriod{};
  shared_ptr<long> resourceType{};
  shared_ptr<long> status{};

  ListMcubeMiniPackagesResponseBodyListMiniPackageResultMiniPackageList() {}

  explicit ListMcubeMiniPackagesResponseBodyListMiniPackageResultMiniPackageList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (autoInstall) {
      res["AutoInstall"] = boost::any(*autoInstall);
    }
    if (clientVersionMax) {
      res["ClientVersionMax"] = boost::any(*clientVersionMax);
    }
    if (clientVersionMin) {
      res["ClientVersionMin"] = boost::any(*clientVersionMin);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (extraData) {
      res["ExtraData"] = boost::any(*extraData);
    }
    if (fallbackBaseUrl) {
      res["FallbackBaseUrl"] = boost::any(*fallbackBaseUrl);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (h5Id) {
      res["H5Id"] = boost::any(*h5Id);
    }
    if (h5Name) {
      res["H5Name"] = boost::any(*h5Name);
    }
    if (h5Version) {
      res["H5Version"] = boost::any(*h5Version);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (installType) {
      res["InstallType"] = boost::any(*installType);
    }
    if (mainUrl) {
      res["MainUrl"] = boost::any(*mainUrl);
    }
    if (memo) {
      res["Memo"] = boost::any(*memo);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (publishPeriod) {
      res["PublishPeriod"] = boost::any(*publishPeriod);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("AutoInstall") != m.end() && !m["AutoInstall"].empty()) {
      autoInstall = make_shared<long>(boost::any_cast<long>(m["AutoInstall"]));
    }
    if (m.find("ClientVersionMax") != m.end() && !m["ClientVersionMax"].empty()) {
      clientVersionMax = make_shared<string>(boost::any_cast<string>(m["ClientVersionMax"]));
    }
    if (m.find("ClientVersionMin") != m.end() && !m["ClientVersionMin"].empty()) {
      clientVersionMin = make_shared<string>(boost::any_cast<string>(m["ClientVersionMin"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      extendInfo = make_shared<string>(boost::any_cast<string>(m["ExtendInfo"]));
    }
    if (m.find("ExtraData") != m.end() && !m["ExtraData"].empty()) {
      extraData = make_shared<string>(boost::any_cast<string>(m["ExtraData"]));
    }
    if (m.find("FallbackBaseUrl") != m.end() && !m["FallbackBaseUrl"].empty()) {
      fallbackBaseUrl = make_shared<string>(boost::any_cast<string>(m["FallbackBaseUrl"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("H5Id") != m.end() && !m["H5Id"].empty()) {
      h5Id = make_shared<string>(boost::any_cast<string>(m["H5Id"]));
    }
    if (m.find("H5Name") != m.end() && !m["H5Name"].empty()) {
      h5Name = make_shared<string>(boost::any_cast<string>(m["H5Name"]));
    }
    if (m.find("H5Version") != m.end() && !m["H5Version"].empty()) {
      h5Version = make_shared<string>(boost::any_cast<string>(m["H5Version"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstallType") != m.end() && !m["InstallType"].empty()) {
      installType = make_shared<long>(boost::any_cast<long>(m["InstallType"]));
    }
    if (m.find("MainUrl") != m.end() && !m["MainUrl"].empty()) {
      mainUrl = make_shared<string>(boost::any_cast<string>(m["MainUrl"]));
    }
    if (m.find("Memo") != m.end() && !m["Memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["Memo"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<long>(boost::any_cast<long>(m["PackageType"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("PublishPeriod") != m.end() && !m["PublishPeriod"].empty()) {
      publishPeriod = make_shared<long>(boost::any_cast<long>(m["PublishPeriod"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<long>(boost::any_cast<long>(m["ResourceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ListMcubeMiniPackagesResponseBodyListMiniPackageResultMiniPackageList() = default;
};
class ListMcubeMiniPackagesResponseBodyListMiniPackageResult : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<bool> hasMore{};
  shared_ptr<vector<ListMcubeMiniPackagesResponseBodyListMiniPackageResultMiniPackageList>> miniPackageList{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListMcubeMiniPackagesResponseBodyListMiniPackageResult() {}

  explicit ListMcubeMiniPackagesResponseBodyListMiniPackageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (miniPackageList) {
      vector<boost::any> temp1;
      for(auto item1:*miniPackageList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MiniPackageList"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("MiniPackageList") != m.end() && !m["MiniPackageList"].empty()) {
      if (typeid(vector<boost::any>) == m["MiniPackageList"].type()) {
        vector<ListMcubeMiniPackagesResponseBodyListMiniPackageResultMiniPackageList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MiniPackageList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMcubeMiniPackagesResponseBodyListMiniPackageResultMiniPackageList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        miniPackageList = make_shared<vector<ListMcubeMiniPackagesResponseBodyListMiniPackageResultMiniPackageList>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListMcubeMiniPackagesResponseBodyListMiniPackageResult() = default;
};
class ListMcubeMiniPackagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListMcubeMiniPackagesResponseBodyListMiniPackageResult> listMiniPackageResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  ListMcubeMiniPackagesResponseBody() {}

  explicit ListMcubeMiniPackagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listMiniPackageResult) {
      res["ListMiniPackageResult"] = listMiniPackageResult ? boost::any(listMiniPackageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListMiniPackageResult") != m.end() && !m["ListMiniPackageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListMiniPackageResult"].type()) {
        ListMcubeMiniPackagesResponseBodyListMiniPackageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListMiniPackageResult"]));
        listMiniPackageResult = make_shared<ListMcubeMiniPackagesResponseBodyListMiniPackageResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~ListMcubeMiniPackagesResponseBody() = default;
};
class ListMcubeMiniPackagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMcubeMiniPackagesResponseBody> body{};

  ListMcubeMiniPackagesResponse() {}

  explicit ListMcubeMiniPackagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMcubeMiniPackagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMcubeMiniPackagesResponseBody>(model1);
      }
    }
  }


  virtual ~ListMcubeMiniPackagesResponse() = default;
};
class ListMcubeMiniTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> id{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  ListMcubeMiniTasksRequest() {}

  explicit ListMcubeMiniTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListMcubeMiniTasksRequest() = default;
};
class ListMcubeMiniTasksResponseBodyListMiniTaskResultMiniTaskList : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> greyConfigInfo{};
  shared_ptr<string> greyEndtime{};
  shared_ptr<string> greyEndtimeData{};
  shared_ptr<long> greyNum{};
  shared_ptr<long> id{};
  shared_ptr<string> memo{};
  shared_ptr<long> packageId{};
  shared_ptr<string> platform{};
  shared_ptr<string> productVersion{};
  shared_ptr<long> publishMode{};
  shared_ptr<long> publishType{};
  shared_ptr<string> status{};
  shared_ptr<long> taskStatus{};
  shared_ptr<string> whitelistIds{};

  ListMcubeMiniTasksResponseBodyListMiniTaskResultMiniTaskList() {}

  explicit ListMcubeMiniTasksResponseBodyListMiniTaskResultMiniTaskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (greyConfigInfo) {
      res["GreyConfigInfo"] = boost::any(*greyConfigInfo);
    }
    if (greyEndtime) {
      res["GreyEndtime"] = boost::any(*greyEndtime);
    }
    if (greyEndtimeData) {
      res["GreyEndtimeData"] = boost::any(*greyEndtimeData);
    }
    if (greyNum) {
      res["GreyNum"] = boost::any(*greyNum);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (memo) {
      res["Memo"] = boost::any(*memo);
    }
    if (packageId) {
      res["PackageId"] = boost::any(*packageId);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (productVersion) {
      res["ProductVersion"] = boost::any(*productVersion);
    }
    if (publishMode) {
      res["PublishMode"] = boost::any(*publishMode);
    }
    if (publishType) {
      res["PublishType"] = boost::any(*publishType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (whitelistIds) {
      res["WhitelistIds"] = boost::any(*whitelistIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GreyConfigInfo") != m.end() && !m["GreyConfigInfo"].empty()) {
      greyConfigInfo = make_shared<string>(boost::any_cast<string>(m["GreyConfigInfo"]));
    }
    if (m.find("GreyEndtime") != m.end() && !m["GreyEndtime"].empty()) {
      greyEndtime = make_shared<string>(boost::any_cast<string>(m["GreyEndtime"]));
    }
    if (m.find("GreyEndtimeData") != m.end() && !m["GreyEndtimeData"].empty()) {
      greyEndtimeData = make_shared<string>(boost::any_cast<string>(m["GreyEndtimeData"]));
    }
    if (m.find("GreyNum") != m.end() && !m["GreyNum"].empty()) {
      greyNum = make_shared<long>(boost::any_cast<long>(m["GreyNum"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Memo") != m.end() && !m["Memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["Memo"]));
    }
    if (m.find("PackageId") != m.end() && !m["PackageId"].empty()) {
      packageId = make_shared<long>(boost::any_cast<long>(m["PackageId"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("ProductVersion") != m.end() && !m["ProductVersion"].empty()) {
      productVersion = make_shared<string>(boost::any_cast<string>(m["ProductVersion"]));
    }
    if (m.find("PublishMode") != m.end() && !m["PublishMode"].empty()) {
      publishMode = make_shared<long>(boost::any_cast<long>(m["PublishMode"]));
    }
    if (m.find("PublishType") != m.end() && !m["PublishType"].empty()) {
      publishType = make_shared<long>(boost::any_cast<long>(m["PublishType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<long>(boost::any_cast<long>(m["TaskStatus"]));
    }
    if (m.find("WhitelistIds") != m.end() && !m["WhitelistIds"].empty()) {
      whitelistIds = make_shared<string>(boost::any_cast<string>(m["WhitelistIds"]));
    }
  }


  virtual ~ListMcubeMiniTasksResponseBodyListMiniTaskResultMiniTaskList() = default;
};
class ListMcubeMiniTasksResponseBodyListMiniTaskResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListMcubeMiniTasksResponseBodyListMiniTaskResultMiniTaskList>> miniTaskList{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  ListMcubeMiniTasksResponseBodyListMiniTaskResult() {}

  explicit ListMcubeMiniTasksResponseBodyListMiniTaskResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (miniTaskList) {
      vector<boost::any> temp1;
      for(auto item1:*miniTaskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MiniTaskList"] = boost::any(temp1);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MiniTaskList") != m.end() && !m["MiniTaskList"].empty()) {
      if (typeid(vector<boost::any>) == m["MiniTaskList"].type()) {
        vector<ListMcubeMiniTasksResponseBodyListMiniTaskResultMiniTaskList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MiniTaskList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMcubeMiniTasksResponseBodyListMiniTaskResultMiniTaskList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        miniTaskList = make_shared<vector<ListMcubeMiniTasksResponseBodyListMiniTaskResultMiniTaskList>>(expect1);
      }
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListMcubeMiniTasksResponseBodyListMiniTaskResult() = default;
};
class ListMcubeMiniTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListMcubeMiniTasksResponseBodyListMiniTaskResult> listMiniTaskResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  ListMcubeMiniTasksResponseBody() {}

  explicit ListMcubeMiniTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listMiniTaskResult) {
      res["ListMiniTaskResult"] = listMiniTaskResult ? boost::any(listMiniTaskResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListMiniTaskResult") != m.end() && !m["ListMiniTaskResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListMiniTaskResult"].type()) {
        ListMcubeMiniTasksResponseBodyListMiniTaskResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListMiniTaskResult"]));
        listMiniTaskResult = make_shared<ListMcubeMiniTasksResponseBodyListMiniTaskResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~ListMcubeMiniTasksResponseBody() = default;
};
class ListMcubeMiniTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMcubeMiniTasksResponseBody> body{};

  ListMcubeMiniTasksResponse() {}

  explicit ListMcubeMiniTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMcubeMiniTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMcubeMiniTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ListMcubeMiniTasksResponse() = default;
};
class ListMcubeNebulaAppsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  ListMcubeNebulaAppsRequest() {}

  explicit ListMcubeNebulaAppsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListMcubeNebulaAppsRequest() = default;
};
class ListMcubeNebulaAppsResponseBodyListMcubeNebulaAppsResultNebulaAppInfos : public Darabonba::Model {
public:
  shared_ptr<string> h5Id{};
  shared_ptr<string> h5Name{};

  ListMcubeNebulaAppsResponseBodyListMcubeNebulaAppsResultNebulaAppInfos() {}

  explicit ListMcubeNebulaAppsResponseBodyListMcubeNebulaAppsResultNebulaAppInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (h5Id) {
      res["H5Id"] = boost::any(*h5Id);
    }
    if (h5Name) {
      res["H5Name"] = boost::any(*h5Name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("H5Id") != m.end() && !m["H5Id"].empty()) {
      h5Id = make_shared<string>(boost::any_cast<string>(m["H5Id"]));
    }
    if (m.find("H5Name") != m.end() && !m["H5Name"].empty()) {
      h5Name = make_shared<string>(boost::any_cast<string>(m["H5Name"]));
    }
  }


  virtual ~ListMcubeNebulaAppsResponseBodyListMcubeNebulaAppsResultNebulaAppInfos() = default;
};
class ListMcubeNebulaAppsResponseBodyListMcubeNebulaAppsResult : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> hasMore{};
  shared_ptr<vector<ListMcubeNebulaAppsResponseBodyListMcubeNebulaAppsResultNebulaAppInfos>> nebulaAppInfos{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListMcubeNebulaAppsResponseBodyListMcubeNebulaAppsResult() {}

  explicit ListMcubeNebulaAppsResponseBodyListMcubeNebulaAppsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (nebulaAppInfos) {
      vector<boost::any> temp1;
      for(auto item1:*nebulaAppInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NebulaAppInfos"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("NebulaAppInfos") != m.end() && !m["NebulaAppInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["NebulaAppInfos"].type()) {
        vector<ListMcubeNebulaAppsResponseBodyListMcubeNebulaAppsResultNebulaAppInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NebulaAppInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMcubeNebulaAppsResponseBodyListMcubeNebulaAppsResultNebulaAppInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nebulaAppInfos = make_shared<vector<ListMcubeNebulaAppsResponseBodyListMcubeNebulaAppsResultNebulaAppInfos>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListMcubeNebulaAppsResponseBodyListMcubeNebulaAppsResult() = default;
};
class ListMcubeNebulaAppsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListMcubeNebulaAppsResponseBodyListMcubeNebulaAppsResult> listMcubeNebulaAppsResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  ListMcubeNebulaAppsResponseBody() {}

  explicit ListMcubeNebulaAppsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listMcubeNebulaAppsResult) {
      res["ListMcubeNebulaAppsResult"] = listMcubeNebulaAppsResult ? boost::any(listMcubeNebulaAppsResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListMcubeNebulaAppsResult") != m.end() && !m["ListMcubeNebulaAppsResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListMcubeNebulaAppsResult"].type()) {
        ListMcubeNebulaAppsResponseBodyListMcubeNebulaAppsResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListMcubeNebulaAppsResult"]));
        listMcubeNebulaAppsResult = make_shared<ListMcubeNebulaAppsResponseBodyListMcubeNebulaAppsResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~ListMcubeNebulaAppsResponseBody() = default;
};
class ListMcubeNebulaAppsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMcubeNebulaAppsResponseBody> body{};

  ListMcubeNebulaAppsResponse() {}

  explicit ListMcubeNebulaAppsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMcubeNebulaAppsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMcubeNebulaAppsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMcubeNebulaAppsResponse() = default;
};
class ListMcubeNebulaResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> h5Id{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  ListMcubeNebulaResourcesRequest() {}

  explicit ListMcubeNebulaResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (h5Id) {
      res["H5Id"] = boost::any(*h5Id);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("H5Id") != m.end() && !m["H5Id"].empty()) {
      h5Id = make_shared<string>(boost::any_cast<string>(m["H5Id"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListMcubeNebulaResourcesRequest() = default;
};
class ListMcubeNebulaResourcesResponseBodyListMcubeNebulaResourceResultNebulaResourceInfo : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<long> autoInstall{};
  shared_ptr<string> clientVersionMax{};
  shared_ptr<string> clientVersionMin{};
  shared_ptr<string> creator{};
  shared_ptr<string> debugUrl{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> extendInfo{};
  shared_ptr<string> extraData{};
  shared_ptr<string> fallbackBaseUrl{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> h5Id{};
  shared_ptr<string> h5Name{};
  shared_ptr<string> h5Version{};
  shared_ptr<long> id{};
  shared_ptr<long> installType{};
  shared_ptr<long> lazyLoad{};
  shared_ptr<string> mainUrl{};
  shared_ptr<string> md5{};
  shared_ptr<string> memo{};
  shared_ptr<long> metaId{};
  shared_ptr<string> modifier{};
  shared_ptr<long> packageType{};
  shared_ptr<string> platform{};
  shared_ptr<long> publishPeriod{};
  shared_ptr<string> releaseVersion{};
  shared_ptr<string> resourceType{};
  shared_ptr<long> status{};
  shared_ptr<string> vhost{};

  ListMcubeNebulaResourcesResponseBodyListMcubeNebulaResourceResultNebulaResourceInfo() {}

  explicit ListMcubeNebulaResourcesResponseBodyListMcubeNebulaResourceResultNebulaResourceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (autoInstall) {
      res["AutoInstall"] = boost::any(*autoInstall);
    }
    if (clientVersionMax) {
      res["ClientVersionMax"] = boost::any(*clientVersionMax);
    }
    if (clientVersionMin) {
      res["ClientVersionMin"] = boost::any(*clientVersionMin);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (debugUrl) {
      res["DebugUrl"] = boost::any(*debugUrl);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (extraData) {
      res["ExtraData"] = boost::any(*extraData);
    }
    if (fallbackBaseUrl) {
      res["FallbackBaseUrl"] = boost::any(*fallbackBaseUrl);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (h5Id) {
      res["H5Id"] = boost::any(*h5Id);
    }
    if (h5Name) {
      res["H5Name"] = boost::any(*h5Name);
    }
    if (h5Version) {
      res["H5Version"] = boost::any(*h5Version);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (installType) {
      res["InstallType"] = boost::any(*installType);
    }
    if (lazyLoad) {
      res["LazyLoad"] = boost::any(*lazyLoad);
    }
    if (mainUrl) {
      res["MainUrl"] = boost::any(*mainUrl);
    }
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    if (memo) {
      res["Memo"] = boost::any(*memo);
    }
    if (metaId) {
      res["MetaId"] = boost::any(*metaId);
    }
    if (modifier) {
      res["Modifier"] = boost::any(*modifier);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (publishPeriod) {
      res["PublishPeriod"] = boost::any(*publishPeriod);
    }
    if (releaseVersion) {
      res["ReleaseVersion"] = boost::any(*releaseVersion);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vhost) {
      res["Vhost"] = boost::any(*vhost);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("AutoInstall") != m.end() && !m["AutoInstall"].empty()) {
      autoInstall = make_shared<long>(boost::any_cast<long>(m["AutoInstall"]));
    }
    if (m.find("ClientVersionMax") != m.end() && !m["ClientVersionMax"].empty()) {
      clientVersionMax = make_shared<string>(boost::any_cast<string>(m["ClientVersionMax"]));
    }
    if (m.find("ClientVersionMin") != m.end() && !m["ClientVersionMin"].empty()) {
      clientVersionMin = make_shared<string>(boost::any_cast<string>(m["ClientVersionMin"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("DebugUrl") != m.end() && !m["DebugUrl"].empty()) {
      debugUrl = make_shared<string>(boost::any_cast<string>(m["DebugUrl"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      extendInfo = make_shared<string>(boost::any_cast<string>(m["ExtendInfo"]));
    }
    if (m.find("ExtraData") != m.end() && !m["ExtraData"].empty()) {
      extraData = make_shared<string>(boost::any_cast<string>(m["ExtraData"]));
    }
    if (m.find("FallbackBaseUrl") != m.end() && !m["FallbackBaseUrl"].empty()) {
      fallbackBaseUrl = make_shared<string>(boost::any_cast<string>(m["FallbackBaseUrl"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("H5Id") != m.end() && !m["H5Id"].empty()) {
      h5Id = make_shared<string>(boost::any_cast<string>(m["H5Id"]));
    }
    if (m.find("H5Name") != m.end() && !m["H5Name"].empty()) {
      h5Name = make_shared<string>(boost::any_cast<string>(m["H5Name"]));
    }
    if (m.find("H5Version") != m.end() && !m["H5Version"].empty()) {
      h5Version = make_shared<string>(boost::any_cast<string>(m["H5Version"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstallType") != m.end() && !m["InstallType"].empty()) {
      installType = make_shared<long>(boost::any_cast<long>(m["InstallType"]));
    }
    if (m.find("LazyLoad") != m.end() && !m["LazyLoad"].empty()) {
      lazyLoad = make_shared<long>(boost::any_cast<long>(m["LazyLoad"]));
    }
    if (m.find("MainUrl") != m.end() && !m["MainUrl"].empty()) {
      mainUrl = make_shared<string>(boost::any_cast<string>(m["MainUrl"]));
    }
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
    if (m.find("Memo") != m.end() && !m["Memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["Memo"]));
    }
    if (m.find("MetaId") != m.end() && !m["MetaId"].empty()) {
      metaId = make_shared<long>(boost::any_cast<long>(m["MetaId"]));
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["Modifier"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<long>(boost::any_cast<long>(m["PackageType"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("PublishPeriod") != m.end() && !m["PublishPeriod"].empty()) {
      publishPeriod = make_shared<long>(boost::any_cast<long>(m["PublishPeriod"]));
    }
    if (m.find("ReleaseVersion") != m.end() && !m["ReleaseVersion"].empty()) {
      releaseVersion = make_shared<string>(boost::any_cast<string>(m["ReleaseVersion"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Vhost") != m.end() && !m["Vhost"].empty()) {
      vhost = make_shared<string>(boost::any_cast<string>(m["Vhost"]));
    }
  }


  virtual ~ListMcubeNebulaResourcesResponseBodyListMcubeNebulaResourceResultNebulaResourceInfo() = default;
};
class ListMcubeNebulaResourcesResponseBodyListMcubeNebulaResourceResult : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> hasMore{};
  shared_ptr<vector<ListMcubeNebulaResourcesResponseBodyListMcubeNebulaResourceResultNebulaResourceInfo>> nebulaResourceInfo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListMcubeNebulaResourcesResponseBodyListMcubeNebulaResourceResult() {}

  explicit ListMcubeNebulaResourcesResponseBodyListMcubeNebulaResourceResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (nebulaResourceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*nebulaResourceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NebulaResourceInfo"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("NebulaResourceInfo") != m.end() && !m["NebulaResourceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["NebulaResourceInfo"].type()) {
        vector<ListMcubeNebulaResourcesResponseBodyListMcubeNebulaResourceResultNebulaResourceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NebulaResourceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMcubeNebulaResourcesResponseBodyListMcubeNebulaResourceResultNebulaResourceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nebulaResourceInfo = make_shared<vector<ListMcubeNebulaResourcesResponseBodyListMcubeNebulaResourceResultNebulaResourceInfo>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListMcubeNebulaResourcesResponseBodyListMcubeNebulaResourceResult() = default;
};
class ListMcubeNebulaResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListMcubeNebulaResourcesResponseBodyListMcubeNebulaResourceResult> listMcubeNebulaResourceResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  ListMcubeNebulaResourcesResponseBody() {}

  explicit ListMcubeNebulaResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listMcubeNebulaResourceResult) {
      res["ListMcubeNebulaResourceResult"] = listMcubeNebulaResourceResult ? boost::any(listMcubeNebulaResourceResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListMcubeNebulaResourceResult") != m.end() && !m["ListMcubeNebulaResourceResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListMcubeNebulaResourceResult"].type()) {
        ListMcubeNebulaResourcesResponseBodyListMcubeNebulaResourceResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListMcubeNebulaResourceResult"]));
        listMcubeNebulaResourceResult = make_shared<ListMcubeNebulaResourcesResponseBodyListMcubeNebulaResourceResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~ListMcubeNebulaResourcesResponseBody() = default;
};
class ListMcubeNebulaResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMcubeNebulaResourcesResponseBody> body{};

  ListMcubeNebulaResourcesResponse() {}

  explicit ListMcubeNebulaResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMcubeNebulaResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMcubeNebulaResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListMcubeNebulaResourcesResponse() = default;
};
class ListMcubeNebulaTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> id{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  ListMcubeNebulaTasksRequest() {}

  explicit ListMcubeNebulaTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListMcubeNebulaTasksRequest() = default;
};
class ListMcubeNebulaTasksResponseBodyListMcubeNebulaTaskResultNebulaTaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<string> bizType{};
  shared_ptr<string> creator{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> gmtModifiedStr{};
  shared_ptr<string> greyConfigInfo{};
  shared_ptr<string> greyEndtime{};
  shared_ptr<string> greyEndtimeData{};
  shared_ptr<string> greyEndtimeStr{};
  shared_ptr<long> greyNum{};
  shared_ptr<string> greyUrl{};
  shared_ptr<long> id{};
  shared_ptr<string> memo{};
  shared_ptr<string> modifier{};
  shared_ptr<long> packageId{};
  shared_ptr<long> percent{};
  shared_ptr<string> platform{};
  shared_ptr<string> productId{};
  shared_ptr<string> productVersion{};
  shared_ptr<long> publishMode{};
  shared_ptr<long> publishType{};
  shared_ptr<string> releaseVersion{};
  shared_ptr<long> status{};
  shared_ptr<string> syncResult{};
  shared_ptr<string> taskName{};
  shared_ptr<long> taskStatus{};
  shared_ptr<long> taskType{};
  shared_ptr<long> taskVersion{};
  shared_ptr<long> upgradeNoticeNum{};
  shared_ptr<string> upgradeProgress{};
  shared_ptr<string> whitelistIds{};

  ListMcubeNebulaTasksResponseBodyListMcubeNebulaTaskResultNebulaTaskInfo() {}

  explicit ListMcubeNebulaTasksResponseBodyListMcubeNebulaTaskResultNebulaTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtModifiedStr) {
      res["GmtModifiedStr"] = boost::any(*gmtModifiedStr);
    }
    if (greyConfigInfo) {
      res["GreyConfigInfo"] = boost::any(*greyConfigInfo);
    }
    if (greyEndtime) {
      res["GreyEndtime"] = boost::any(*greyEndtime);
    }
    if (greyEndtimeData) {
      res["GreyEndtimeData"] = boost::any(*greyEndtimeData);
    }
    if (greyEndtimeStr) {
      res["GreyEndtimeStr"] = boost::any(*greyEndtimeStr);
    }
    if (greyNum) {
      res["GreyNum"] = boost::any(*greyNum);
    }
    if (greyUrl) {
      res["GreyUrl"] = boost::any(*greyUrl);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (memo) {
      res["Memo"] = boost::any(*memo);
    }
    if (modifier) {
      res["Modifier"] = boost::any(*modifier);
    }
    if (packageId) {
      res["PackageId"] = boost::any(*packageId);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (productId) {
      res["ProductId"] = boost::any(*productId);
    }
    if (productVersion) {
      res["ProductVersion"] = boost::any(*productVersion);
    }
    if (publishMode) {
      res["PublishMode"] = boost::any(*publishMode);
    }
    if (publishType) {
      res["PublishType"] = boost::any(*publishType);
    }
    if (releaseVersion) {
      res["ReleaseVersion"] = boost::any(*releaseVersion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (syncResult) {
      res["SyncResult"] = boost::any(*syncResult);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (taskVersion) {
      res["TaskVersion"] = boost::any(*taskVersion);
    }
    if (upgradeNoticeNum) {
      res["UpgradeNoticeNum"] = boost::any(*upgradeNoticeNum);
    }
    if (upgradeProgress) {
      res["UpgradeProgress"] = boost::any(*upgradeProgress);
    }
    if (whitelistIds) {
      res["WhitelistIds"] = boost::any(*whitelistIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtModifiedStr") != m.end() && !m["GmtModifiedStr"].empty()) {
      gmtModifiedStr = make_shared<string>(boost::any_cast<string>(m["GmtModifiedStr"]));
    }
    if (m.find("GreyConfigInfo") != m.end() && !m["GreyConfigInfo"].empty()) {
      greyConfigInfo = make_shared<string>(boost::any_cast<string>(m["GreyConfigInfo"]));
    }
    if (m.find("GreyEndtime") != m.end() && !m["GreyEndtime"].empty()) {
      greyEndtime = make_shared<string>(boost::any_cast<string>(m["GreyEndtime"]));
    }
    if (m.find("GreyEndtimeData") != m.end() && !m["GreyEndtimeData"].empty()) {
      greyEndtimeData = make_shared<string>(boost::any_cast<string>(m["GreyEndtimeData"]));
    }
    if (m.find("GreyEndtimeStr") != m.end() && !m["GreyEndtimeStr"].empty()) {
      greyEndtimeStr = make_shared<string>(boost::any_cast<string>(m["GreyEndtimeStr"]));
    }
    if (m.find("GreyNum") != m.end() && !m["GreyNum"].empty()) {
      greyNum = make_shared<long>(boost::any_cast<long>(m["GreyNum"]));
    }
    if (m.find("GreyUrl") != m.end() && !m["GreyUrl"].empty()) {
      greyUrl = make_shared<string>(boost::any_cast<string>(m["GreyUrl"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Memo") != m.end() && !m["Memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["Memo"]));
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["Modifier"]));
    }
    if (m.find("PackageId") != m.end() && !m["PackageId"].empty()) {
      packageId = make_shared<long>(boost::any_cast<long>(m["PackageId"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("ProductId") != m.end() && !m["ProductId"].empty()) {
      productId = make_shared<string>(boost::any_cast<string>(m["ProductId"]));
    }
    if (m.find("ProductVersion") != m.end() && !m["ProductVersion"].empty()) {
      productVersion = make_shared<string>(boost::any_cast<string>(m["ProductVersion"]));
    }
    if (m.find("PublishMode") != m.end() && !m["PublishMode"].empty()) {
      publishMode = make_shared<long>(boost::any_cast<long>(m["PublishMode"]));
    }
    if (m.find("PublishType") != m.end() && !m["PublishType"].empty()) {
      publishType = make_shared<long>(boost::any_cast<long>(m["PublishType"]));
    }
    if (m.find("ReleaseVersion") != m.end() && !m["ReleaseVersion"].empty()) {
      releaseVersion = make_shared<string>(boost::any_cast<string>(m["ReleaseVersion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("SyncResult") != m.end() && !m["SyncResult"].empty()) {
      syncResult = make_shared<string>(boost::any_cast<string>(m["SyncResult"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<long>(boost::any_cast<long>(m["TaskStatus"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
    if (m.find("TaskVersion") != m.end() && !m["TaskVersion"].empty()) {
      taskVersion = make_shared<long>(boost::any_cast<long>(m["TaskVersion"]));
    }
    if (m.find("UpgradeNoticeNum") != m.end() && !m["UpgradeNoticeNum"].empty()) {
      upgradeNoticeNum = make_shared<long>(boost::any_cast<long>(m["UpgradeNoticeNum"]));
    }
    if (m.find("UpgradeProgress") != m.end() && !m["UpgradeProgress"].empty()) {
      upgradeProgress = make_shared<string>(boost::any_cast<string>(m["UpgradeProgress"]));
    }
    if (m.find("WhitelistIds") != m.end() && !m["WhitelistIds"].empty()) {
      whitelistIds = make_shared<string>(boost::any_cast<string>(m["WhitelistIds"]));
    }
  }


  virtual ~ListMcubeNebulaTasksResponseBodyListMcubeNebulaTaskResultNebulaTaskInfo() = default;
};
class ListMcubeNebulaTasksResponseBodyListMcubeNebulaTaskResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<vector<ListMcubeNebulaTasksResponseBodyListMcubeNebulaTaskResultNebulaTaskInfo>> nebulaTaskInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  ListMcubeNebulaTasksResponseBodyListMcubeNebulaTaskResult() {}

  explicit ListMcubeNebulaTasksResponseBodyListMcubeNebulaTaskResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (nebulaTaskInfo) {
      vector<boost::any> temp1;
      for(auto item1:*nebulaTaskInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NebulaTaskInfo"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("NebulaTaskInfo") != m.end() && !m["NebulaTaskInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["NebulaTaskInfo"].type()) {
        vector<ListMcubeNebulaTasksResponseBodyListMcubeNebulaTaskResultNebulaTaskInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NebulaTaskInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMcubeNebulaTasksResponseBodyListMcubeNebulaTaskResultNebulaTaskInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nebulaTaskInfo = make_shared<vector<ListMcubeNebulaTasksResponseBodyListMcubeNebulaTaskResultNebulaTaskInfo>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListMcubeNebulaTasksResponseBodyListMcubeNebulaTaskResult() = default;
};
class ListMcubeNebulaTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListMcubeNebulaTasksResponseBodyListMcubeNebulaTaskResult> listMcubeNebulaTaskResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  ListMcubeNebulaTasksResponseBody() {}

  explicit ListMcubeNebulaTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listMcubeNebulaTaskResult) {
      res["ListMcubeNebulaTaskResult"] = listMcubeNebulaTaskResult ? boost::any(listMcubeNebulaTaskResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListMcubeNebulaTaskResult") != m.end() && !m["ListMcubeNebulaTaskResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListMcubeNebulaTaskResult"].type()) {
        ListMcubeNebulaTasksResponseBodyListMcubeNebulaTaskResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListMcubeNebulaTaskResult"]));
        listMcubeNebulaTaskResult = make_shared<ListMcubeNebulaTasksResponseBodyListMcubeNebulaTaskResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~ListMcubeNebulaTasksResponseBody() = default;
};
class ListMcubeNebulaTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMcubeNebulaTasksResponseBody> body{};

  ListMcubeNebulaTasksResponse() {}

  explicit ListMcubeNebulaTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMcubeNebulaTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMcubeNebulaTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ListMcubeNebulaTasksResponse() = default;
};
class ListMcubeUpgradePackagesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  ListMcubeUpgradePackagesRequest() {}

  explicit ListMcubeUpgradePackagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListMcubeUpgradePackagesRequest() = default;
};
class ListMcubeUpgradePackagesResponseBodyListPackagesResultPackages : public Darabonba::Model {
public:
  shared_ptr<bool> allowCreateTask{};
  shared_ptr<string> appCode{};
  shared_ptr<string> appstoreUrl{};
  shared_ptr<string> backLog{};
  shared_ptr<string> changeLog{};
  shared_ptr<long> clientFileSize{};
  shared_ptr<string> clientName{};
  shared_ptr<string> cpId{};
  shared_ptr<string> creator{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> globalVariables{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtCreateStr{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> gmtModifiedStr{};
  shared_ptr<long> id{};
  shared_ptr<string> innerVersion{};
  shared_ptr<string> iosSymbol{};
  shared_ptr<long> isEnterprise{};
  shared_ptr<long> isRc{};
  shared_ptr<long> isRelease{};
  shared_ptr<string> maxVersion{};
  shared_ptr<string> md5{};
  shared_ptr<string> modifier{};
  shared_ptr<long> needCheck{};
  shared_ptr<string> ossPath{};
  shared_ptr<string> packageType{};
  shared_ptr<string> platform{};
  shared_ptr<string> productId{};
  shared_ptr<string> productName{};
  shared_ptr<string> productVersion{};
  shared_ptr<long> publishPeriod{};
  shared_ptr<string> qrcodeUrl{};
  shared_ptr<string> releaseType{};
  shared_ptr<string> releaseWindow{};
  shared_ptr<string> scmDownloadUrl{};
  shared_ptr<long> serverVersion{};
  shared_ptr<string> verificationCode{};
  shared_ptr<long> verifyResult{};
  shared_ptr<string> versionCode{};

  ListMcubeUpgradePackagesResponseBodyListPackagesResultPackages() {}

  explicit ListMcubeUpgradePackagesResponseBodyListPackagesResultPackages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowCreateTask) {
      res["AllowCreateTask"] = boost::any(*allowCreateTask);
    }
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (appstoreUrl) {
      res["AppstoreUrl"] = boost::any(*appstoreUrl);
    }
    if (backLog) {
      res["BackLog"] = boost::any(*backLog);
    }
    if (changeLog) {
      res["ChangeLog"] = boost::any(*changeLog);
    }
    if (clientFileSize) {
      res["ClientFileSize"] = boost::any(*clientFileSize);
    }
    if (clientName) {
      res["ClientName"] = boost::any(*clientName);
    }
    if (cpId) {
      res["CpId"] = boost::any(*cpId);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (globalVariables) {
      res["GlobalVariables"] = boost::any(*globalVariables);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtCreateStr) {
      res["GmtCreateStr"] = boost::any(*gmtCreateStr);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtModifiedStr) {
      res["GmtModifiedStr"] = boost::any(*gmtModifiedStr);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (innerVersion) {
      res["InnerVersion"] = boost::any(*innerVersion);
    }
    if (iosSymbol) {
      res["IosSymbol"] = boost::any(*iosSymbol);
    }
    if (isEnterprise) {
      res["IsEnterprise"] = boost::any(*isEnterprise);
    }
    if (isRc) {
      res["IsRc"] = boost::any(*isRc);
    }
    if (isRelease) {
      res["IsRelease"] = boost::any(*isRelease);
    }
    if (maxVersion) {
      res["MaxVersion"] = boost::any(*maxVersion);
    }
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    if (modifier) {
      res["Modifier"] = boost::any(*modifier);
    }
    if (needCheck) {
      res["NeedCheck"] = boost::any(*needCheck);
    }
    if (ossPath) {
      res["OssPath"] = boost::any(*ossPath);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (productId) {
      res["ProductId"] = boost::any(*productId);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (productVersion) {
      res["ProductVersion"] = boost::any(*productVersion);
    }
    if (publishPeriod) {
      res["PublishPeriod"] = boost::any(*publishPeriod);
    }
    if (qrcodeUrl) {
      res["QrcodeUrl"] = boost::any(*qrcodeUrl);
    }
    if (releaseType) {
      res["ReleaseType"] = boost::any(*releaseType);
    }
    if (releaseWindow) {
      res["ReleaseWindow"] = boost::any(*releaseWindow);
    }
    if (scmDownloadUrl) {
      res["ScmDownloadUrl"] = boost::any(*scmDownloadUrl);
    }
    if (serverVersion) {
      res["ServerVersion"] = boost::any(*serverVersion);
    }
    if (verificationCode) {
      res["VerificationCode"] = boost::any(*verificationCode);
    }
    if (verifyResult) {
      res["VerifyResult"] = boost::any(*verifyResult);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowCreateTask") != m.end() && !m["AllowCreateTask"].empty()) {
      allowCreateTask = make_shared<bool>(boost::any_cast<bool>(m["AllowCreateTask"]));
    }
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("AppstoreUrl") != m.end() && !m["AppstoreUrl"].empty()) {
      appstoreUrl = make_shared<string>(boost::any_cast<string>(m["AppstoreUrl"]));
    }
    if (m.find("BackLog") != m.end() && !m["BackLog"].empty()) {
      backLog = make_shared<string>(boost::any_cast<string>(m["BackLog"]));
    }
    if (m.find("ChangeLog") != m.end() && !m["ChangeLog"].empty()) {
      changeLog = make_shared<string>(boost::any_cast<string>(m["ChangeLog"]));
    }
    if (m.find("ClientFileSize") != m.end() && !m["ClientFileSize"].empty()) {
      clientFileSize = make_shared<long>(boost::any_cast<long>(m["ClientFileSize"]));
    }
    if (m.find("ClientName") != m.end() && !m["ClientName"].empty()) {
      clientName = make_shared<string>(boost::any_cast<string>(m["ClientName"]));
    }
    if (m.find("CpId") != m.end() && !m["CpId"].empty()) {
      cpId = make_shared<string>(boost::any_cast<string>(m["CpId"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("GlobalVariables") != m.end() && !m["GlobalVariables"].empty()) {
      globalVariables = make_shared<string>(boost::any_cast<string>(m["GlobalVariables"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtCreateStr") != m.end() && !m["GmtCreateStr"].empty()) {
      gmtCreateStr = make_shared<string>(boost::any_cast<string>(m["GmtCreateStr"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtModifiedStr") != m.end() && !m["GmtModifiedStr"].empty()) {
      gmtModifiedStr = make_shared<string>(boost::any_cast<string>(m["GmtModifiedStr"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InnerVersion") != m.end() && !m["InnerVersion"].empty()) {
      innerVersion = make_shared<string>(boost::any_cast<string>(m["InnerVersion"]));
    }
    if (m.find("IosSymbol") != m.end() && !m["IosSymbol"].empty()) {
      iosSymbol = make_shared<string>(boost::any_cast<string>(m["IosSymbol"]));
    }
    if (m.find("IsEnterprise") != m.end() && !m["IsEnterprise"].empty()) {
      isEnterprise = make_shared<long>(boost::any_cast<long>(m["IsEnterprise"]));
    }
    if (m.find("IsRc") != m.end() && !m["IsRc"].empty()) {
      isRc = make_shared<long>(boost::any_cast<long>(m["IsRc"]));
    }
    if (m.find("IsRelease") != m.end() && !m["IsRelease"].empty()) {
      isRelease = make_shared<long>(boost::any_cast<long>(m["IsRelease"]));
    }
    if (m.find("MaxVersion") != m.end() && !m["MaxVersion"].empty()) {
      maxVersion = make_shared<string>(boost::any_cast<string>(m["MaxVersion"]));
    }
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["Modifier"]));
    }
    if (m.find("NeedCheck") != m.end() && !m["NeedCheck"].empty()) {
      needCheck = make_shared<long>(boost::any_cast<long>(m["NeedCheck"]));
    }
    if (m.find("OssPath") != m.end() && !m["OssPath"].empty()) {
      ossPath = make_shared<string>(boost::any_cast<string>(m["OssPath"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("ProductId") != m.end() && !m["ProductId"].empty()) {
      productId = make_shared<string>(boost::any_cast<string>(m["ProductId"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("ProductVersion") != m.end() && !m["ProductVersion"].empty()) {
      productVersion = make_shared<string>(boost::any_cast<string>(m["ProductVersion"]));
    }
    if (m.find("PublishPeriod") != m.end() && !m["PublishPeriod"].empty()) {
      publishPeriod = make_shared<long>(boost::any_cast<long>(m["PublishPeriod"]));
    }
    if (m.find("QrcodeUrl") != m.end() && !m["QrcodeUrl"].empty()) {
      qrcodeUrl = make_shared<string>(boost::any_cast<string>(m["QrcodeUrl"]));
    }
    if (m.find("ReleaseType") != m.end() && !m["ReleaseType"].empty()) {
      releaseType = make_shared<string>(boost::any_cast<string>(m["ReleaseType"]));
    }
    if (m.find("ReleaseWindow") != m.end() && !m["ReleaseWindow"].empty()) {
      releaseWindow = make_shared<string>(boost::any_cast<string>(m["ReleaseWindow"]));
    }
    if (m.find("ScmDownloadUrl") != m.end() && !m["ScmDownloadUrl"].empty()) {
      scmDownloadUrl = make_shared<string>(boost::any_cast<string>(m["ScmDownloadUrl"]));
    }
    if (m.find("ServerVersion") != m.end() && !m["ServerVersion"].empty()) {
      serverVersion = make_shared<long>(boost::any_cast<long>(m["ServerVersion"]));
    }
    if (m.find("VerificationCode") != m.end() && !m["VerificationCode"].empty()) {
      verificationCode = make_shared<string>(boost::any_cast<string>(m["VerificationCode"]));
    }
    if (m.find("VerifyResult") != m.end() && !m["VerifyResult"].empty()) {
      verifyResult = make_shared<long>(boost::any_cast<long>(m["VerifyResult"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
  }


  virtual ~ListMcubeUpgradePackagesResponseBodyListPackagesResultPackages() = default;
};
class ListMcubeUpgradePackagesResponseBodyListPackagesResult : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> hasMore{};
  shared_ptr<vector<ListMcubeUpgradePackagesResponseBodyListPackagesResultPackages>> packages{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListMcubeUpgradePackagesResponseBodyListPackagesResult() {}

  explicit ListMcubeUpgradePackagesResponseBodyListPackagesResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (packages) {
      vector<boost::any> temp1;
      for(auto item1:*packages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Packages"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("Packages") != m.end() && !m["Packages"].empty()) {
      if (typeid(vector<boost::any>) == m["Packages"].type()) {
        vector<ListMcubeUpgradePackagesResponseBodyListPackagesResultPackages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Packages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMcubeUpgradePackagesResponseBodyListPackagesResultPackages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        packages = make_shared<vector<ListMcubeUpgradePackagesResponseBodyListPackagesResultPackages>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListMcubeUpgradePackagesResponseBodyListPackagesResult() = default;
};
class ListMcubeUpgradePackagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListMcubeUpgradePackagesResponseBodyListPackagesResult> listPackagesResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  ListMcubeUpgradePackagesResponseBody() {}

  explicit ListMcubeUpgradePackagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listPackagesResult) {
      res["ListPackagesResult"] = listPackagesResult ? boost::any(listPackagesResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListPackagesResult") != m.end() && !m["ListPackagesResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListPackagesResult"].type()) {
        ListMcubeUpgradePackagesResponseBodyListPackagesResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListPackagesResult"]));
        listPackagesResult = make_shared<ListMcubeUpgradePackagesResponseBodyListPackagesResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~ListMcubeUpgradePackagesResponseBody() = default;
};
class ListMcubeUpgradePackagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMcubeUpgradePackagesResponseBody> body{};

  ListMcubeUpgradePackagesResponse() {}

  explicit ListMcubeUpgradePackagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMcubeUpgradePackagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMcubeUpgradePackagesResponseBody>(model1);
      }
    }
  }


  virtual ~ListMcubeUpgradePackagesResponse() = default;
};
class ListMcubeUpgradeTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> packageId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  ListMcubeUpgradeTasksRequest() {}

  explicit ListMcubeUpgradeTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (packageId) {
      res["PackageId"] = boost::any(*packageId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("PackageId") != m.end() && !m["PackageId"].empty()) {
      packageId = make_shared<string>(boost::any_cast<string>(m["PackageId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListMcubeUpgradeTasksRequest() = default;
};
class ListMcubeUpgradeTasksResponseBodyListTaskResultTaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<string> creator{};
  shared_ptr<long> devicePercent{};
  shared_ptr<long> executionOrder{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtCreateStr{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> gmtModifiedStr{};
  shared_ptr<string> greyConfigInfo{};
  shared_ptr<string> greyEndtime{};
  shared_ptr<long> greyNotice{};
  shared_ptr<long> greyNum{};
  shared_ptr<long> greyPausePoint{};
  shared_ptr<long> greyPauseType{};
  shared_ptr<long> greyUv{};
  shared_ptr<long> historyForce{};
  shared_ptr<string> huobanNoticeId{};
  shared_ptr<string> huobanUrl{};
  shared_ptr<long> id{};
  shared_ptr<string> innerVersion{};
  shared_ptr<long> isEnterprise{};
  shared_ptr<long> isOfficial{};
  shared_ptr<long> isPush{};
  shared_ptr<long> isRelease{};
  shared_ptr<string> maxVersion{};
  shared_ptr<string> memo{};
  shared_ptr<string> modifier{};
  shared_ptr<long> packageInfoId{};
  shared_ptr<string> platform{};
  shared_ptr<string> productId{};
  shared_ptr<string> productVersion{};
  shared_ptr<long> publishMode{};
  shared_ptr<long> publishType{};
  shared_ptr<string> pushContent{};
  shared_ptr<string> realGreyEndtime{};
  shared_ptr<string> realGreyEndtimeStr{};
  shared_ptr<long> realGreyEndtype{};
  shared_ptr<long> realGreyNum{};
  shared_ptr<long> realGreyUv{};
  shared_ptr<long> silentType{};
  shared_ptr<string> syncResult{};
  shared_ptr<long> taskStatus{};
  shared_ptr<string> upgradeContent{};
  shared_ptr<long> upgradeType{};
  shared_ptr<long> upgradeValidTime{};
  shared_ptr<string> whitelistIds{};

  ListMcubeUpgradeTasksResponseBodyListTaskResultTaskInfo() {}

  explicit ListMcubeUpgradeTasksResponseBodyListTaskResultTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (devicePercent) {
      res["DevicePercent"] = boost::any(*devicePercent);
    }
    if (executionOrder) {
      res["ExecutionOrder"] = boost::any(*executionOrder);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtCreateStr) {
      res["GmtCreateStr"] = boost::any(*gmtCreateStr);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtModifiedStr) {
      res["GmtModifiedStr"] = boost::any(*gmtModifiedStr);
    }
    if (greyConfigInfo) {
      res["GreyConfigInfo"] = boost::any(*greyConfigInfo);
    }
    if (greyEndtime) {
      res["GreyEndtime"] = boost::any(*greyEndtime);
    }
    if (greyNotice) {
      res["GreyNotice"] = boost::any(*greyNotice);
    }
    if (greyNum) {
      res["GreyNum"] = boost::any(*greyNum);
    }
    if (greyPausePoint) {
      res["GreyPausePoint"] = boost::any(*greyPausePoint);
    }
    if (greyPauseType) {
      res["GreyPauseType"] = boost::any(*greyPauseType);
    }
    if (greyUv) {
      res["GreyUv"] = boost::any(*greyUv);
    }
    if (historyForce) {
      res["HistoryForce"] = boost::any(*historyForce);
    }
    if (huobanNoticeId) {
      res["HuobanNoticeId"] = boost::any(*huobanNoticeId);
    }
    if (huobanUrl) {
      res["HuobanUrl"] = boost::any(*huobanUrl);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (innerVersion) {
      res["InnerVersion"] = boost::any(*innerVersion);
    }
    if (isEnterprise) {
      res["IsEnterprise"] = boost::any(*isEnterprise);
    }
    if (isOfficial) {
      res["IsOfficial"] = boost::any(*isOfficial);
    }
    if (isPush) {
      res["IsPush"] = boost::any(*isPush);
    }
    if (isRelease) {
      res["IsRelease"] = boost::any(*isRelease);
    }
    if (maxVersion) {
      res["MaxVersion"] = boost::any(*maxVersion);
    }
    if (memo) {
      res["Memo"] = boost::any(*memo);
    }
    if (modifier) {
      res["Modifier"] = boost::any(*modifier);
    }
    if (packageInfoId) {
      res["PackageInfoId"] = boost::any(*packageInfoId);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (productId) {
      res["ProductId"] = boost::any(*productId);
    }
    if (productVersion) {
      res["ProductVersion"] = boost::any(*productVersion);
    }
    if (publishMode) {
      res["PublishMode"] = boost::any(*publishMode);
    }
    if (publishType) {
      res["PublishType"] = boost::any(*publishType);
    }
    if (pushContent) {
      res["PushContent"] = boost::any(*pushContent);
    }
    if (realGreyEndtime) {
      res["RealGreyEndtime"] = boost::any(*realGreyEndtime);
    }
    if (realGreyEndtimeStr) {
      res["RealGreyEndtimeStr"] = boost::any(*realGreyEndtimeStr);
    }
    if (realGreyEndtype) {
      res["RealGreyEndtype"] = boost::any(*realGreyEndtype);
    }
    if (realGreyNum) {
      res["RealGreyNum"] = boost::any(*realGreyNum);
    }
    if (realGreyUv) {
      res["RealGreyUv"] = boost::any(*realGreyUv);
    }
    if (silentType) {
      res["SilentType"] = boost::any(*silentType);
    }
    if (syncResult) {
      res["SyncResult"] = boost::any(*syncResult);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (upgradeContent) {
      res["UpgradeContent"] = boost::any(*upgradeContent);
    }
    if (upgradeType) {
      res["UpgradeType"] = boost::any(*upgradeType);
    }
    if (upgradeValidTime) {
      res["UpgradeValidTime"] = boost::any(*upgradeValidTime);
    }
    if (whitelistIds) {
      res["WhitelistIds"] = boost::any(*whitelistIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("DevicePercent") != m.end() && !m["DevicePercent"].empty()) {
      devicePercent = make_shared<long>(boost::any_cast<long>(m["DevicePercent"]));
    }
    if (m.find("ExecutionOrder") != m.end() && !m["ExecutionOrder"].empty()) {
      executionOrder = make_shared<long>(boost::any_cast<long>(m["ExecutionOrder"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtCreateStr") != m.end() && !m["GmtCreateStr"].empty()) {
      gmtCreateStr = make_shared<string>(boost::any_cast<string>(m["GmtCreateStr"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtModifiedStr") != m.end() && !m["GmtModifiedStr"].empty()) {
      gmtModifiedStr = make_shared<string>(boost::any_cast<string>(m["GmtModifiedStr"]));
    }
    if (m.find("GreyConfigInfo") != m.end() && !m["GreyConfigInfo"].empty()) {
      greyConfigInfo = make_shared<string>(boost::any_cast<string>(m["GreyConfigInfo"]));
    }
    if (m.find("GreyEndtime") != m.end() && !m["GreyEndtime"].empty()) {
      greyEndtime = make_shared<string>(boost::any_cast<string>(m["GreyEndtime"]));
    }
    if (m.find("GreyNotice") != m.end() && !m["GreyNotice"].empty()) {
      greyNotice = make_shared<long>(boost::any_cast<long>(m["GreyNotice"]));
    }
    if (m.find("GreyNum") != m.end() && !m["GreyNum"].empty()) {
      greyNum = make_shared<long>(boost::any_cast<long>(m["GreyNum"]));
    }
    if (m.find("GreyPausePoint") != m.end() && !m["GreyPausePoint"].empty()) {
      greyPausePoint = make_shared<long>(boost::any_cast<long>(m["GreyPausePoint"]));
    }
    if (m.find("GreyPauseType") != m.end() && !m["GreyPauseType"].empty()) {
      greyPauseType = make_shared<long>(boost::any_cast<long>(m["GreyPauseType"]));
    }
    if (m.find("GreyUv") != m.end() && !m["GreyUv"].empty()) {
      greyUv = make_shared<long>(boost::any_cast<long>(m["GreyUv"]));
    }
    if (m.find("HistoryForce") != m.end() && !m["HistoryForce"].empty()) {
      historyForce = make_shared<long>(boost::any_cast<long>(m["HistoryForce"]));
    }
    if (m.find("HuobanNoticeId") != m.end() && !m["HuobanNoticeId"].empty()) {
      huobanNoticeId = make_shared<string>(boost::any_cast<string>(m["HuobanNoticeId"]));
    }
    if (m.find("HuobanUrl") != m.end() && !m["HuobanUrl"].empty()) {
      huobanUrl = make_shared<string>(boost::any_cast<string>(m["HuobanUrl"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InnerVersion") != m.end() && !m["InnerVersion"].empty()) {
      innerVersion = make_shared<string>(boost::any_cast<string>(m["InnerVersion"]));
    }
    if (m.find("IsEnterprise") != m.end() && !m["IsEnterprise"].empty()) {
      isEnterprise = make_shared<long>(boost::any_cast<long>(m["IsEnterprise"]));
    }
    if (m.find("IsOfficial") != m.end() && !m["IsOfficial"].empty()) {
      isOfficial = make_shared<long>(boost::any_cast<long>(m["IsOfficial"]));
    }
    if (m.find("IsPush") != m.end() && !m["IsPush"].empty()) {
      isPush = make_shared<long>(boost::any_cast<long>(m["IsPush"]));
    }
    if (m.find("IsRelease") != m.end() && !m["IsRelease"].empty()) {
      isRelease = make_shared<long>(boost::any_cast<long>(m["IsRelease"]));
    }
    if (m.find("MaxVersion") != m.end() && !m["MaxVersion"].empty()) {
      maxVersion = make_shared<string>(boost::any_cast<string>(m["MaxVersion"]));
    }
    if (m.find("Memo") != m.end() && !m["Memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["Memo"]));
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["Modifier"]));
    }
    if (m.find("PackageInfoId") != m.end() && !m["PackageInfoId"].empty()) {
      packageInfoId = make_shared<long>(boost::any_cast<long>(m["PackageInfoId"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("ProductId") != m.end() && !m["ProductId"].empty()) {
      productId = make_shared<string>(boost::any_cast<string>(m["ProductId"]));
    }
    if (m.find("ProductVersion") != m.end() && !m["ProductVersion"].empty()) {
      productVersion = make_shared<string>(boost::any_cast<string>(m["ProductVersion"]));
    }
    if (m.find("PublishMode") != m.end() && !m["PublishMode"].empty()) {
      publishMode = make_shared<long>(boost::any_cast<long>(m["PublishMode"]));
    }
    if (m.find("PublishType") != m.end() && !m["PublishType"].empty()) {
      publishType = make_shared<long>(boost::any_cast<long>(m["PublishType"]));
    }
    if (m.find("PushContent") != m.end() && !m["PushContent"].empty()) {
      pushContent = make_shared<string>(boost::any_cast<string>(m["PushContent"]));
    }
    if (m.find("RealGreyEndtime") != m.end() && !m["RealGreyEndtime"].empty()) {
      realGreyEndtime = make_shared<string>(boost::any_cast<string>(m["RealGreyEndtime"]));
    }
    if (m.find("RealGreyEndtimeStr") != m.end() && !m["RealGreyEndtimeStr"].empty()) {
      realGreyEndtimeStr = make_shared<string>(boost::any_cast<string>(m["RealGreyEndtimeStr"]));
    }
    if (m.find("RealGreyEndtype") != m.end() && !m["RealGreyEndtype"].empty()) {
      realGreyEndtype = make_shared<long>(boost::any_cast<long>(m["RealGreyEndtype"]));
    }
    if (m.find("RealGreyNum") != m.end() && !m["RealGreyNum"].empty()) {
      realGreyNum = make_shared<long>(boost::any_cast<long>(m["RealGreyNum"]));
    }
    if (m.find("RealGreyUv") != m.end() && !m["RealGreyUv"].empty()) {
      realGreyUv = make_shared<long>(boost::any_cast<long>(m["RealGreyUv"]));
    }
    if (m.find("SilentType") != m.end() && !m["SilentType"].empty()) {
      silentType = make_shared<long>(boost::any_cast<long>(m["SilentType"]));
    }
    if (m.find("SyncResult") != m.end() && !m["SyncResult"].empty()) {
      syncResult = make_shared<string>(boost::any_cast<string>(m["SyncResult"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<long>(boost::any_cast<long>(m["TaskStatus"]));
    }
    if (m.find("UpgradeContent") != m.end() && !m["UpgradeContent"].empty()) {
      upgradeContent = make_shared<string>(boost::any_cast<string>(m["UpgradeContent"]));
    }
    if (m.find("UpgradeType") != m.end() && !m["UpgradeType"].empty()) {
      upgradeType = make_shared<long>(boost::any_cast<long>(m["UpgradeType"]));
    }
    if (m.find("UpgradeValidTime") != m.end() && !m["UpgradeValidTime"].empty()) {
      upgradeValidTime = make_shared<long>(boost::any_cast<long>(m["UpgradeValidTime"]));
    }
    if (m.find("WhitelistIds") != m.end() && !m["WhitelistIds"].empty()) {
      whitelistIds = make_shared<string>(boost::any_cast<string>(m["WhitelistIds"]));
    }
  }


  virtual ~ListMcubeUpgradeTasksResponseBodyListTaskResultTaskInfo() = default;
};
class ListMcubeUpgradeTasksResponseBodyListTaskResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};
  shared_ptr<vector<ListMcubeUpgradeTasksResponseBodyListTaskResultTaskInfo>> taskInfo{};

  ListMcubeUpgradeTasksResponseBodyListTaskResult() {}

  explicit ListMcubeUpgradeTasksResponseBodyListTaskResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskInfo) {
      vector<boost::any> temp1;
      for(auto item1:*taskInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TaskInfo") != m.end() && !m["TaskInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskInfo"].type()) {
        vector<ListMcubeUpgradeTasksResponseBodyListTaskResultTaskInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMcubeUpgradeTasksResponseBodyListTaskResultTaskInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskInfo = make_shared<vector<ListMcubeUpgradeTasksResponseBodyListTaskResultTaskInfo>>(expect1);
      }
    }
  }


  virtual ~ListMcubeUpgradeTasksResponseBodyListTaskResult() = default;
};
class ListMcubeUpgradeTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListMcubeUpgradeTasksResponseBodyListTaskResult> listTaskResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  ListMcubeUpgradeTasksResponseBody() {}

  explicit ListMcubeUpgradeTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listTaskResult) {
      res["ListTaskResult"] = listTaskResult ? boost::any(listTaskResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListTaskResult") != m.end() && !m["ListTaskResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListTaskResult"].type()) {
        ListMcubeUpgradeTasksResponseBodyListTaskResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListTaskResult"]));
        listTaskResult = make_shared<ListMcubeUpgradeTasksResponseBodyListTaskResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~ListMcubeUpgradeTasksResponseBody() = default;
};
class ListMcubeUpgradeTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMcubeUpgradeTasksResponseBody> body{};

  ListMcubeUpgradeTasksResponse() {}

  explicit ListMcubeUpgradeTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMcubeUpgradeTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMcubeUpgradeTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ListMcubeUpgradeTasksResponse() = default;
};
class ListMcubeWhitelistsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> whitelistName{};
  shared_ptr<string> workspaceId{};

  ListMcubeWhitelistsRequest() {}

  explicit ListMcubeWhitelistsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (whitelistName) {
      res["WhitelistName"] = boost::any(*whitelistName);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WhitelistName") != m.end() && !m["WhitelistName"].empty()) {
      whitelistName = make_shared<string>(boost::any_cast<string>(m["WhitelistName"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListMcubeWhitelistsRequest() = default;
};
class ListMcubeWhitelistsResponseBodyListWhitelistResultWhitelists : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<long> whiteListCount{};
  shared_ptr<string> whiteListName{};
  shared_ptr<string> whitelistType{};

  ListMcubeWhitelistsResponseBodyListWhitelistResultWhitelists() {}

  explicit ListMcubeWhitelistsResponseBodyListWhitelistResultWhitelists(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (whiteListCount) {
      res["WhiteListCount"] = boost::any(*whiteListCount);
    }
    if (whiteListName) {
      res["WhiteListName"] = boost::any(*whiteListName);
    }
    if (whitelistType) {
      res["WhitelistType"] = boost::any(*whitelistType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("WhiteListCount") != m.end() && !m["WhiteListCount"].empty()) {
      whiteListCount = make_shared<long>(boost::any_cast<long>(m["WhiteListCount"]));
    }
    if (m.find("WhiteListName") != m.end() && !m["WhiteListName"].empty()) {
      whiteListName = make_shared<string>(boost::any_cast<string>(m["WhiteListName"]));
    }
    if (m.find("WhitelistType") != m.end() && !m["WhitelistType"].empty()) {
      whitelistType = make_shared<string>(boost::any_cast<string>(m["WhitelistType"]));
    }
  }


  virtual ~ListMcubeWhitelistsResponseBodyListWhitelistResultWhitelists() = default;
};
class ListMcubeWhitelistsResponseBodyListWhitelistResult : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<bool> hasMore{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListMcubeWhitelistsResponseBodyListWhitelistResultWhitelists>> whitelists{};

  ListMcubeWhitelistsResponseBodyListWhitelistResult() {}

  explicit ListMcubeWhitelistsResponseBodyListWhitelistResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (whitelists) {
      vector<boost::any> temp1;
      for(auto item1:*whitelists){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Whitelists"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Whitelists") != m.end() && !m["Whitelists"].empty()) {
      if (typeid(vector<boost::any>) == m["Whitelists"].type()) {
        vector<ListMcubeWhitelistsResponseBodyListWhitelistResultWhitelists> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Whitelists"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMcubeWhitelistsResponseBodyListWhitelistResultWhitelists model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        whitelists = make_shared<vector<ListMcubeWhitelistsResponseBodyListWhitelistResultWhitelists>>(expect1);
      }
    }
  }


  virtual ~ListMcubeWhitelistsResponseBodyListWhitelistResult() = default;
};
class ListMcubeWhitelistsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListMcubeWhitelistsResponseBodyListWhitelistResult> listWhitelistResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  ListMcubeWhitelistsResponseBody() {}

  explicit ListMcubeWhitelistsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listWhitelistResult) {
      res["ListWhitelistResult"] = listWhitelistResult ? boost::any(listWhitelistResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListWhitelistResult") != m.end() && !m["ListWhitelistResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListWhitelistResult"].type()) {
        ListMcubeWhitelistsResponseBodyListWhitelistResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListWhitelistResult"]));
        listWhitelistResult = make_shared<ListMcubeWhitelistsResponseBodyListWhitelistResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~ListMcubeWhitelistsResponseBody() = default;
};
class ListMcubeWhitelistsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMcubeWhitelistsResponseBody> body{};

  ListMcubeWhitelistsResponse() {}

  explicit ListMcubeWhitelistsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMcubeWhitelistsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMcubeWhitelistsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMcubeWhitelistsResponse() = default;
};
class ListMgsApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiStatus{};
  shared_ptr<string> apiType{};
  shared_ptr<string> appId{};
  shared_ptr<string> format{};
  shared_ptr<string> host{};
  shared_ptr<string> needEncrypt{};
  shared_ptr<string> needEtag{};
  shared_ptr<string> needSign{};
  shared_ptr<string> operationType{};
  shared_ptr<string> optFuzzy{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> sysId{};
  shared_ptr<string> sysName{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  ListMgsApiRequest() {}

  explicit ListMgsApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiStatus) {
      res["ApiStatus"] = boost::any(*apiStatus);
    }
    if (apiType) {
      res["ApiType"] = boost::any(*apiType);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (needEncrypt) {
      res["NeedEncrypt"] = boost::any(*needEncrypt);
    }
    if (needEtag) {
      res["NeedEtag"] = boost::any(*needEtag);
    }
    if (needSign) {
      res["NeedSign"] = boost::any(*needSign);
    }
    if (operationType) {
      res["OperationType"] = boost::any(*operationType);
    }
    if (optFuzzy) {
      res["OptFuzzy"] = boost::any(*optFuzzy);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sysId) {
      res["SysId"] = boost::any(*sysId);
    }
    if (sysName) {
      res["SysName"] = boost::any(*sysName);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiStatus") != m.end() && !m["ApiStatus"].empty()) {
      apiStatus = make_shared<string>(boost::any_cast<string>(m["ApiStatus"]));
    }
    if (m.find("ApiType") != m.end() && !m["ApiType"].empty()) {
      apiType = make_shared<string>(boost::any_cast<string>(m["ApiType"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("NeedEncrypt") != m.end() && !m["NeedEncrypt"].empty()) {
      needEncrypt = make_shared<string>(boost::any_cast<string>(m["NeedEncrypt"]));
    }
    if (m.find("NeedEtag") != m.end() && !m["NeedEtag"].empty()) {
      needEtag = make_shared<string>(boost::any_cast<string>(m["NeedEtag"]));
    }
    if (m.find("NeedSign") != m.end() && !m["NeedSign"].empty()) {
      needSign = make_shared<string>(boost::any_cast<string>(m["NeedSign"]));
    }
    if (m.find("OperationType") != m.end() && !m["OperationType"].empty()) {
      operationType = make_shared<string>(boost::any_cast<string>(m["OperationType"]));
    }
    if (m.find("OptFuzzy") != m.end() && !m["OptFuzzy"].empty()) {
      optFuzzy = make_shared<string>(boost::any_cast<string>(m["OptFuzzy"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SysId") != m.end() && !m["SysId"].empty()) {
      sysId = make_shared<long>(boost::any_cast<long>(m["SysId"]));
    }
    if (m.find("SysName") != m.end() && !m["SysName"].empty()) {
      sysName = make_shared<string>(boost::any_cast<string>(m["SysName"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListMgsApiRequest() = default;
};
class ListMgsApiResponseBodyResultContentValueApiInvokerHttpInvoker : public Darabonba::Model {
public:
  shared_ptr<string> charset{};
  shared_ptr<string> contentType{};
  shared_ptr<string> host{};
  shared_ptr<string> method{};
  shared_ptr<string> path{};

  ListMgsApiResponseBodyResultContentValueApiInvokerHttpInvoker() {}

  explicit ListMgsApiResponseBodyResultContentValueApiInvokerHttpInvoker(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charset) {
      res["Charset"] = boost::any(*charset);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Charset") != m.end() && !m["Charset"].empty()) {
      charset = make_shared<string>(boost::any_cast<string>(m["Charset"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~ListMgsApiResponseBodyResultContentValueApiInvokerHttpInvoker() = default;
};
class ListMgsApiResponseBodyResultContentValueApiInvoker : public Darabonba::Model {
public:
  shared_ptr<ListMgsApiResponseBodyResultContentValueApiInvokerHttpInvoker> httpInvoker{};
  shared_ptr<string> rpcInvoker{};

  ListMgsApiResponseBodyResultContentValueApiInvoker() {}

  explicit ListMgsApiResponseBodyResultContentValueApiInvoker(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpInvoker) {
      res["HttpInvoker"] = httpInvoker ? boost::any(httpInvoker->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rpcInvoker) {
      res["RpcInvoker"] = boost::any(*rpcInvoker);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpInvoker") != m.end() && !m["HttpInvoker"].empty()) {
      if (typeid(map<string, boost::any>) == m["HttpInvoker"].type()) {
        ListMgsApiResponseBodyResultContentValueApiInvokerHttpInvoker model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HttpInvoker"]));
        httpInvoker = make_shared<ListMgsApiResponseBodyResultContentValueApiInvokerHttpInvoker>(model1);
      }
    }
    if (m.find("RpcInvoker") != m.end() && !m["RpcInvoker"].empty()) {
      rpcInvoker = make_shared<string>(boost::any_cast<string>(m["RpcInvoker"]));
    }
  }


  virtual ~ListMgsApiResponseBodyResultContentValueApiInvoker() = default;
};
class ListMgsApiResponseBodyResultContentValueCacheRule : public Darabonba::Model {
public:
  shared_ptr<string> cacheKey{};
  shared_ptr<bool> needCache{};
  shared_ptr<long> ttl{};

  ListMgsApiResponseBodyResultContentValueCacheRule() {}

  explicit ListMgsApiResponseBodyResultContentValueCacheRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cacheKey) {
      res["CacheKey"] = boost::any(*cacheKey);
    }
    if (needCache) {
      res["NeedCache"] = boost::any(*needCache);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CacheKey") != m.end() && !m["CacheKey"].empty()) {
      cacheKey = make_shared<string>(boost::any_cast<string>(m["CacheKey"]));
    }
    if (m.find("NeedCache") != m.end() && !m["NeedCache"].empty()) {
      needCache = make_shared<bool>(boost::any_cast<bool>(m["NeedCache"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
  }


  virtual ~ListMgsApiResponseBodyResultContentValueCacheRule() = default;
};
class ListMgsApiResponseBodyResultContentValueCircuitBreakerRule : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> defaultResponse{};
  shared_ptr<long> errorThreshold{};
  shared_ptr<long> id{};
  shared_ptr<string> model{};
  shared_ptr<long> openTimeoutSeconds{};
  shared_ptr<double> slowRatioThreshold{};
  shared_ptr<string> switchStatus{};
  shared_ptr<long> windowsInSeconds{};
  shared_ptr<string> workspaceId{};

  ListMgsApiResponseBodyResultContentValueCircuitBreakerRule() {}

  explicit ListMgsApiResponseBodyResultContentValueCircuitBreakerRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (defaultResponse) {
      res["DefaultResponse"] = boost::any(*defaultResponse);
    }
    if (errorThreshold) {
      res["ErrorThreshold"] = boost::any(*errorThreshold);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (openTimeoutSeconds) {
      res["OpenTimeoutSeconds"] = boost::any(*openTimeoutSeconds);
    }
    if (slowRatioThreshold) {
      res["SlowRatioThreshold"] = boost::any(*slowRatioThreshold);
    }
    if (switchStatus) {
      res["SwitchStatus"] = boost::any(*switchStatus);
    }
    if (windowsInSeconds) {
      res["WindowsInSeconds"] = boost::any(*windowsInSeconds);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DefaultResponse") != m.end() && !m["DefaultResponse"].empty()) {
      defaultResponse = make_shared<string>(boost::any_cast<string>(m["DefaultResponse"]));
    }
    if (m.find("ErrorThreshold") != m.end() && !m["ErrorThreshold"].empty()) {
      errorThreshold = make_shared<long>(boost::any_cast<long>(m["ErrorThreshold"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("OpenTimeoutSeconds") != m.end() && !m["OpenTimeoutSeconds"].empty()) {
      openTimeoutSeconds = make_shared<long>(boost::any_cast<long>(m["OpenTimeoutSeconds"]));
    }
    if (m.find("SlowRatioThreshold") != m.end() && !m["SlowRatioThreshold"].empty()) {
      slowRatioThreshold = make_shared<double>(boost::any_cast<double>(m["SlowRatioThreshold"]));
    }
    if (m.find("SwitchStatus") != m.end() && !m["SwitchStatus"].empty()) {
      switchStatus = make_shared<string>(boost::any_cast<string>(m["SwitchStatus"]));
    }
    if (m.find("WindowsInSeconds") != m.end() && !m["WindowsInSeconds"].empty()) {
      windowsInSeconds = make_shared<long>(boost::any_cast<long>(m["WindowsInSeconds"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListMgsApiResponseBodyResultContentValueCircuitBreakerRule() = default;
};
class ListMgsApiResponseBodyResultContentValueHeaderRule : public Darabonba::Model {
public:
  shared_ptr<string> headerKey{};
  shared_ptr<string> location{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ListMgsApiResponseBodyResultContentValueHeaderRule() {}

  explicit ListMgsApiResponseBodyResultContentValueHeaderRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerKey) {
      res["HeaderKey"] = boost::any(*headerKey);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeaderKey") != m.end() && !m["HeaderKey"].empty()) {
      headerKey = make_shared<string>(boost::any_cast<string>(m["HeaderKey"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListMgsApiResponseBodyResultContentValueHeaderRule() = default;
};
class ListMgsApiResponseBodyResultContentValueHeaderRules : public Darabonba::Model {
public:
  shared_ptr<string> headerKey{};
  shared_ptr<string> location{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ListMgsApiResponseBodyResultContentValueHeaderRules() {}

  explicit ListMgsApiResponseBodyResultContentValueHeaderRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerKey) {
      res["HeaderKey"] = boost::any(*headerKey);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeaderKey") != m.end() && !m["HeaderKey"].empty()) {
      headerKey = make_shared<string>(boost::any_cast<string>(m["HeaderKey"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListMgsApiResponseBodyResultContentValueHeaderRules() = default;
};
class ListMgsApiResponseBodyResultContentValueLimitRule : public Darabonba::Model {
public:
  shared_ptr<string> defaultResponse{};
  shared_ptr<string> i18nResponse{};
  shared_ptr<long> interval{};
  shared_ptr<long> limit{};
  shared_ptr<string> mode{};

  ListMgsApiResponseBodyResultContentValueLimitRule() {}

  explicit ListMgsApiResponseBodyResultContentValueLimitRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultResponse) {
      res["DefaultResponse"] = boost::any(*defaultResponse);
    }
    if (i18nResponse) {
      res["I18nResponse"] = boost::any(*i18nResponse);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultResponse") != m.end() && !m["DefaultResponse"].empty()) {
      defaultResponse = make_shared<string>(boost::any_cast<string>(m["DefaultResponse"]));
    }
    if (m.find("I18nResponse") != m.end() && !m["I18nResponse"].empty()) {
      i18nResponse = make_shared<string>(boost::any_cast<string>(m["I18nResponse"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
  }


  virtual ~ListMgsApiResponseBodyResultContentValueLimitRule() = default;
};
class ListMgsApiResponseBodyResultContentValueMigrateRule : public Darabonba::Model {
public:
  shared_ptr<long> flowPercent{};
  shared_ptr<bool> needMigrate{};
  shared_ptr<bool> needSwitchCompletely{};
  shared_ptr<long> sysId{};
  shared_ptr<string> sysName{};
  shared_ptr<string> upstreamType{};

  ListMgsApiResponseBodyResultContentValueMigrateRule() {}

  explicit ListMgsApiResponseBodyResultContentValueMigrateRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowPercent) {
      res["FlowPercent"] = boost::any(*flowPercent);
    }
    if (needMigrate) {
      res["NeedMigrate"] = boost::any(*needMigrate);
    }
    if (needSwitchCompletely) {
      res["NeedSwitchCompletely"] = boost::any(*needSwitchCompletely);
    }
    if (sysId) {
      res["SysId"] = boost::any(*sysId);
    }
    if (sysName) {
      res["SysName"] = boost::any(*sysName);
    }
    if (upstreamType) {
      res["UpstreamType"] = boost::any(*upstreamType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowPercent") != m.end() && !m["FlowPercent"].empty()) {
      flowPercent = make_shared<long>(boost::any_cast<long>(m["FlowPercent"]));
    }
    if (m.find("NeedMigrate") != m.end() && !m["NeedMigrate"].empty()) {
      needMigrate = make_shared<bool>(boost::any_cast<bool>(m["NeedMigrate"]));
    }
    if (m.find("NeedSwitchCompletely") != m.end() && !m["NeedSwitchCompletely"].empty()) {
      needSwitchCompletely = make_shared<bool>(boost::any_cast<bool>(m["NeedSwitchCompletely"]));
    }
    if (m.find("SysId") != m.end() && !m["SysId"].empty()) {
      sysId = make_shared<long>(boost::any_cast<long>(m["SysId"]));
    }
    if (m.find("SysName") != m.end() && !m["SysName"].empty()) {
      sysName = make_shared<string>(boost::any_cast<string>(m["SysName"]));
    }
    if (m.find("UpstreamType") != m.end() && !m["UpstreamType"].empty()) {
      upstreamType = make_shared<string>(boost::any_cast<string>(m["UpstreamType"]));
    }
  }


  virtual ~ListMgsApiResponseBodyResultContentValueMigrateRule() = default;
};
class ListMgsApiResponseBodyResultContentValueMockRule : public Darabonba::Model {
public:
  shared_ptr<string> mockData{};
  shared_ptr<bool> needMock{};
  shared_ptr<long> percentage{};
  shared_ptr<string> type{};

  ListMgsApiResponseBodyResultContentValueMockRule() {}

  explicit ListMgsApiResponseBodyResultContentValueMockRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mockData) {
      res["MockData"] = boost::any(*mockData);
    }
    if (needMock) {
      res["NeedMock"] = boost::any(*needMock);
    }
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MockData") != m.end() && !m["MockData"].empty()) {
      mockData = make_shared<string>(boost::any_cast<string>(m["MockData"]));
    }
    if (m.find("NeedMock") != m.end() && !m["NeedMock"].empty()) {
      needMock = make_shared<bool>(boost::any_cast<bool>(m["NeedMock"]));
    }
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListMgsApiResponseBodyResultContentValueMockRule() = default;
};
class ListMgsApiResponseBodyResultContentValueRequestParams : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> appId{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> location{};
  shared_ptr<string> name{};
  shared_ptr<string> refType{};
  shared_ptr<string> type{};
  shared_ptr<string> workspaceId{};

  ListMgsApiResponseBodyResultContentValueRequestParams() {}

  explicit ListMgsApiResponseBodyResultContentValueRequestParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (refType) {
      res["RefType"] = boost::any(*refType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RefType") != m.end() && !m["RefType"].empty()) {
      refType = make_shared<string>(boost::any_cast<string>(m["RefType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListMgsApiResponseBodyResultContentValueRequestParams() = default;
};
class ListMgsApiResponseBodyResultContentValue : public Darabonba::Model {
public:
  shared_ptr<ListMgsApiResponseBodyResultContentValueApiInvoker> apiInvoker{};
  shared_ptr<string> apiName{};
  shared_ptr<string> apiStatus{};
  shared_ptr<string> apiType{};
  shared_ptr<string> appId{};
  shared_ptr<string> authRuleName{};
  shared_ptr<ListMgsApiResponseBodyResultContentValueCacheRule> cacheRule{};
  shared_ptr<string> charset{};
  shared_ptr<ListMgsApiResponseBodyResultContentValueCircuitBreakerRule> circuitBreakerRule{};
  shared_ptr<string> contentType{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<vector<ListMgsApiResponseBodyResultContentValueHeaderRule>> headerRule{};
  shared_ptr<vector<ListMgsApiResponseBodyResultContentValueHeaderRules>> headerRules{};
  shared_ptr<string> host{};
  shared_ptr<long> id{};
  shared_ptr<string> interfaceType{};
  shared_ptr<ListMgsApiResponseBodyResultContentValueLimitRule> limitRule{};
  shared_ptr<string> method{};
  shared_ptr<string> methodName{};
  shared_ptr<ListMgsApiResponseBodyResultContentValueMigrateRule> migrateRule{};
  shared_ptr<ListMgsApiResponseBodyResultContentValueMockRule> mockRule{};
  shared_ptr<string> needETag{};
  shared_ptr<string> needEncrypt{};
  shared_ptr<string> needJsonp{};
  shared_ptr<string> needSign{};
  shared_ptr<string> operationType{};
  shared_ptr<string> paramGetMethod{};
  shared_ptr<string> path{};
  shared_ptr<string> requestBodyModel{};
  shared_ptr<vector<ListMgsApiResponseBodyResultContentValueRequestParams>> requestParams{};
  shared_ptr<string> responseBodyModel{};
  shared_ptr<long> sysId{};
  shared_ptr<string> sysName{};
  shared_ptr<string> timeout{};
  shared_ptr<string> workspaceId{};

  ListMgsApiResponseBodyResultContentValue() {}

  explicit ListMgsApiResponseBodyResultContentValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInvoker) {
      res["ApiInvoker"] = apiInvoker ? boost::any(apiInvoker->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (apiStatus) {
      res["ApiStatus"] = boost::any(*apiStatus);
    }
    if (apiType) {
      res["ApiType"] = boost::any(*apiType);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (authRuleName) {
      res["AuthRuleName"] = boost::any(*authRuleName);
    }
    if (cacheRule) {
      res["CacheRule"] = cacheRule ? boost::any(cacheRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (charset) {
      res["Charset"] = boost::any(*charset);
    }
    if (circuitBreakerRule) {
      res["CircuitBreakerRule"] = circuitBreakerRule ? boost::any(circuitBreakerRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (headerRule) {
      vector<boost::any> temp1;
      for(auto item1:*headerRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HeaderRule"] = boost::any(temp1);
    }
    if (headerRules) {
      vector<boost::any> temp1;
      for(auto item1:*headerRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HeaderRules"] = boost::any(temp1);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (interfaceType) {
      res["InterfaceType"] = boost::any(*interfaceType);
    }
    if (limitRule) {
      res["LimitRule"] = limitRule ? boost::any(limitRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (migrateRule) {
      res["MigrateRule"] = migrateRule ? boost::any(migrateRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mockRule) {
      res["MockRule"] = mockRule ? boost::any(mockRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (needETag) {
      res["NeedETag"] = boost::any(*needETag);
    }
    if (needEncrypt) {
      res["NeedEncrypt"] = boost::any(*needEncrypt);
    }
    if (needJsonp) {
      res["NeedJsonp"] = boost::any(*needJsonp);
    }
    if (needSign) {
      res["NeedSign"] = boost::any(*needSign);
    }
    if (operationType) {
      res["OperationType"] = boost::any(*operationType);
    }
    if (paramGetMethod) {
      res["ParamGetMethod"] = boost::any(*paramGetMethod);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (requestBodyModel) {
      res["RequestBodyModel"] = boost::any(*requestBodyModel);
    }
    if (requestParams) {
      vector<boost::any> temp1;
      for(auto item1:*requestParams){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParams"] = boost::any(temp1);
    }
    if (responseBodyModel) {
      res["ResponseBodyModel"] = boost::any(*responseBodyModel);
    }
    if (sysId) {
      res["SysId"] = boost::any(*sysId);
    }
    if (sysName) {
      res["SysName"] = boost::any(*sysName);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInvoker") != m.end() && !m["ApiInvoker"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiInvoker"].type()) {
        ListMgsApiResponseBodyResultContentValueApiInvoker model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiInvoker"]));
        apiInvoker = make_shared<ListMgsApiResponseBodyResultContentValueApiInvoker>(model1);
      }
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("ApiStatus") != m.end() && !m["ApiStatus"].empty()) {
      apiStatus = make_shared<string>(boost::any_cast<string>(m["ApiStatus"]));
    }
    if (m.find("ApiType") != m.end() && !m["ApiType"].empty()) {
      apiType = make_shared<string>(boost::any_cast<string>(m["ApiType"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AuthRuleName") != m.end() && !m["AuthRuleName"].empty()) {
      authRuleName = make_shared<string>(boost::any_cast<string>(m["AuthRuleName"]));
    }
    if (m.find("CacheRule") != m.end() && !m["CacheRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["CacheRule"].type()) {
        ListMgsApiResponseBodyResultContentValueCacheRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CacheRule"]));
        cacheRule = make_shared<ListMgsApiResponseBodyResultContentValueCacheRule>(model1);
      }
    }
    if (m.find("Charset") != m.end() && !m["Charset"].empty()) {
      charset = make_shared<string>(boost::any_cast<string>(m["Charset"]));
    }
    if (m.find("CircuitBreakerRule") != m.end() && !m["CircuitBreakerRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["CircuitBreakerRule"].type()) {
        ListMgsApiResponseBodyResultContentValueCircuitBreakerRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CircuitBreakerRule"]));
        circuitBreakerRule = make_shared<ListMgsApiResponseBodyResultContentValueCircuitBreakerRule>(model1);
      }
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("HeaderRule") != m.end() && !m["HeaderRule"].empty()) {
      if (typeid(vector<boost::any>) == m["HeaderRule"].type()) {
        vector<ListMgsApiResponseBodyResultContentValueHeaderRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HeaderRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMgsApiResponseBodyResultContentValueHeaderRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        headerRule = make_shared<vector<ListMgsApiResponseBodyResultContentValueHeaderRule>>(expect1);
      }
    }
    if (m.find("HeaderRules") != m.end() && !m["HeaderRules"].empty()) {
      if (typeid(vector<boost::any>) == m["HeaderRules"].type()) {
        vector<ListMgsApiResponseBodyResultContentValueHeaderRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HeaderRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMgsApiResponseBodyResultContentValueHeaderRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        headerRules = make_shared<vector<ListMgsApiResponseBodyResultContentValueHeaderRules>>(expect1);
      }
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InterfaceType") != m.end() && !m["InterfaceType"].empty()) {
      interfaceType = make_shared<string>(boost::any_cast<string>(m["InterfaceType"]));
    }
    if (m.find("LimitRule") != m.end() && !m["LimitRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["LimitRule"].type()) {
        ListMgsApiResponseBodyResultContentValueLimitRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LimitRule"]));
        limitRule = make_shared<ListMgsApiResponseBodyResultContentValueLimitRule>(model1);
      }
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("MigrateRule") != m.end() && !m["MigrateRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["MigrateRule"].type()) {
        ListMgsApiResponseBodyResultContentValueMigrateRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MigrateRule"]));
        migrateRule = make_shared<ListMgsApiResponseBodyResultContentValueMigrateRule>(model1);
      }
    }
    if (m.find("MockRule") != m.end() && !m["MockRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["MockRule"].type()) {
        ListMgsApiResponseBodyResultContentValueMockRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MockRule"]));
        mockRule = make_shared<ListMgsApiResponseBodyResultContentValueMockRule>(model1);
      }
    }
    if (m.find("NeedETag") != m.end() && !m["NeedETag"].empty()) {
      needETag = make_shared<string>(boost::any_cast<string>(m["NeedETag"]));
    }
    if (m.find("NeedEncrypt") != m.end() && !m["NeedEncrypt"].empty()) {
      needEncrypt = make_shared<string>(boost::any_cast<string>(m["NeedEncrypt"]));
    }
    if (m.find("NeedJsonp") != m.end() && !m["NeedJsonp"].empty()) {
      needJsonp = make_shared<string>(boost::any_cast<string>(m["NeedJsonp"]));
    }
    if (m.find("NeedSign") != m.end() && !m["NeedSign"].empty()) {
      needSign = make_shared<string>(boost::any_cast<string>(m["NeedSign"]));
    }
    if (m.find("OperationType") != m.end() && !m["OperationType"].empty()) {
      operationType = make_shared<string>(boost::any_cast<string>(m["OperationType"]));
    }
    if (m.find("ParamGetMethod") != m.end() && !m["ParamGetMethod"].empty()) {
      paramGetMethod = make_shared<string>(boost::any_cast<string>(m["ParamGetMethod"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("RequestBodyModel") != m.end() && !m["RequestBodyModel"].empty()) {
      requestBodyModel = make_shared<string>(boost::any_cast<string>(m["RequestBodyModel"]));
    }
    if (m.find("RequestParams") != m.end() && !m["RequestParams"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParams"].type()) {
        vector<ListMgsApiResponseBodyResultContentValueRequestParams> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParams"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMgsApiResponseBodyResultContentValueRequestParams model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParams = make_shared<vector<ListMgsApiResponseBodyResultContentValueRequestParams>>(expect1);
      }
    }
    if (m.find("ResponseBodyModel") != m.end() && !m["ResponseBodyModel"].empty()) {
      responseBodyModel = make_shared<string>(boost::any_cast<string>(m["ResponseBodyModel"]));
    }
    if (m.find("SysId") != m.end() && !m["SysId"].empty()) {
      sysId = make_shared<long>(boost::any_cast<long>(m["SysId"]));
    }
    if (m.find("SysName") != m.end() && !m["SysName"].empty()) {
      sysName = make_shared<string>(boost::any_cast<string>(m["SysName"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<string>(boost::any_cast<string>(m["Timeout"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListMgsApiResponseBodyResultContentValue() = default;
};
class ListMgsApiResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<vector<ListMgsApiResponseBodyResultContentValue>> value{};

  ListMgsApiResponseBodyResultContent() {}

  explicit ListMgsApiResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (value) {
      vector<boost::any> temp1;
      for(auto item1:*value){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Value"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<ListMgsApiResponseBodyResultContentValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Value"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMgsApiResponseBodyResultContentValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        value = make_shared<vector<ListMgsApiResponseBodyResultContentValue>>(expect1);
      }
    }
  }


  virtual ~ListMgsApiResponseBodyResultContent() = default;
};
class ListMgsApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<ListMgsApiResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  ListMgsApiResponseBody() {}

  explicit ListMgsApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        ListMgsApiResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<ListMgsApiResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~ListMgsApiResponseBody() = default;
};
class ListMgsApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMgsApiResponseBody> body{};

  ListMgsApiResponse() {}

  explicit ListMgsApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMgsApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMgsApiResponseBody>(model1);
      }
    }
  }


  virtual ~ListMgsApiResponse() = default;
};
class LogMsaQueryRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> id{};
  shared_ptr<string> onexFlag{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  LogMsaQueryRequest() {}

  explicit LogMsaQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (onexFlag) {
      res["OnexFlag"] = boost::any(*onexFlag);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OnexFlag") != m.end() && !m["OnexFlag"].empty()) {
      onexFlag = make_shared<string>(boost::any_cast<string>(m["OnexFlag"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~LogMsaQueryRequest() = default;
};
class LogMsaQueryResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  LogMsaQueryResponseBodyResultContent() {}

  explicit LogMsaQueryResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~LogMsaQueryResponseBodyResultContent() = default;
};
class LogMsaQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<LogMsaQueryResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  LogMsaQueryResponseBody() {}

  explicit LogMsaQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        LogMsaQueryResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<LogMsaQueryResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~LogMsaQueryResponseBody() = default;
};
class LogMsaQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<LogMsaQueryResponseBody> body{};

  LogMsaQueryResponse() {}

  explicit LogMsaQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        LogMsaQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<LogMsaQueryResponseBody>(model1);
      }
    }
  }


  virtual ~LogMsaQueryResponse() = default;
};
class MTRSOCRServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> imageRaw{};
  shared_ptr<bool> mask{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> type{};
  shared_ptr<string> workspaceId{};

  MTRSOCRServiceRequest() {}

  explicit MTRSOCRServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (imageRaw) {
      res["ImageRaw"] = boost::any(*imageRaw);
    }
    if (mask) {
      res["Mask"] = boost::any(*mask);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ImageRaw") != m.end() && !m["ImageRaw"].empty()) {
      imageRaw = make_shared<string>(boost::any_cast<string>(m["ImageRaw"]));
    }
    if (m.find("Mask") != m.end() && !m["Mask"].empty()) {
      mask = make_shared<bool>(boost::any_cast<bool>(m["Mask"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~MTRSOCRServiceRequest() = default;
};
class MTRSOCRServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> msg{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> status{};
  shared_ptr<string> traceId{};

  MTRSOCRServiceResponseBody() {}

  explicit MTRSOCRServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~MTRSOCRServiceResponseBody() = default;
};
class MTRSOCRServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MTRSOCRServiceResponseBody> body{};

  MTRSOCRServiceResponse() {}

  explicit MTRSOCRServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MTRSOCRServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MTRSOCRServiceResponseBody>(model1);
      }
    }
  }


  virtual ~MTRSOCRServiceResponse() = default;
};
class OpenApiAddActiveCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMqcpOpenApiAddActiveCodeReqJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  OpenApiAddActiveCodeRequest() {}

  explicit OpenApiAddActiveCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMqcpOpenApiAddActiveCodeReqJsonStr) {
      res["MpaasMqcpOpenApiAddActiveCodeReqJsonStr"] = boost::any(*mpaasMqcpOpenApiAddActiveCodeReqJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMqcpOpenApiAddActiveCodeReqJsonStr") != m.end() && !m["MpaasMqcpOpenApiAddActiveCodeReqJsonStr"].empty()) {
      mpaasMqcpOpenApiAddActiveCodeReqJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMqcpOpenApiAddActiveCodeReqJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~OpenApiAddActiveCodeRequest() = default;
};
class OpenApiAddActiveCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultContent{};

  OpenApiAddActiveCodeResponseBody() {}

  explicit OpenApiAddActiveCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = boost::any(*resultContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      resultContent = make_shared<string>(boost::any_cast<string>(m["ResultContent"]));
    }
  }


  virtual ~OpenApiAddActiveCodeResponseBody() = default;
};
class OpenApiAddActiveCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenApiAddActiveCodeResponseBody> body{};

  OpenApiAddActiveCodeResponse() {}

  explicit OpenApiAddActiveCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenApiAddActiveCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenApiAddActiveCodeResponseBody>(model1);
      }
    }
  }


  virtual ~OpenApiAddActiveCodeResponse() = default;
};
class OpenApiAddActiveSceneRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMqcpOpenApiAddActiveSceneReqJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  OpenApiAddActiveSceneRequest() {}

  explicit OpenApiAddActiveSceneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMqcpOpenApiAddActiveSceneReqJsonStr) {
      res["MpaasMqcpOpenApiAddActiveSceneReqJsonStr"] = boost::any(*mpaasMqcpOpenApiAddActiveSceneReqJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMqcpOpenApiAddActiveSceneReqJsonStr") != m.end() && !m["MpaasMqcpOpenApiAddActiveSceneReqJsonStr"].empty()) {
      mpaasMqcpOpenApiAddActiveSceneReqJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMqcpOpenApiAddActiveSceneReqJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~OpenApiAddActiveSceneRequest() = default;
};
class OpenApiAddActiveSceneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultContent{};

  OpenApiAddActiveSceneResponseBody() {}

  explicit OpenApiAddActiveSceneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = boost::any(*resultContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      resultContent = make_shared<string>(boost::any_cast<string>(m["ResultContent"]));
    }
  }


  virtual ~OpenApiAddActiveSceneResponseBody() = default;
};
class OpenApiAddActiveSceneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenApiAddActiveSceneResponseBody> body{};

  OpenApiAddActiveSceneResponse() {}

  explicit OpenApiAddActiveSceneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenApiAddActiveSceneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenApiAddActiveSceneResponseBody>(model1);
      }
    }
  }


  virtual ~OpenApiAddActiveSceneResponse() = default;
};
class OpenApiCallbackRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMqcpOpenApiCallbackRequestJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  OpenApiCallbackRequest() {}

  explicit OpenApiCallbackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMqcpOpenApiCallbackRequestJsonStr) {
      res["MpaasMqcpOpenApiCallbackRequestJsonStr"] = boost::any(*mpaasMqcpOpenApiCallbackRequestJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMqcpOpenApiCallbackRequestJsonStr") != m.end() && !m["MpaasMqcpOpenApiCallbackRequestJsonStr"].empty()) {
      mpaasMqcpOpenApiCallbackRequestJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMqcpOpenApiCallbackRequestJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~OpenApiCallbackRequest() = default;
};
class OpenApiCallbackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultContent{};

  OpenApiCallbackResponseBody() {}

  explicit OpenApiCallbackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = boost::any(*resultContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      resultContent = make_shared<string>(boost::any_cast<string>(m["ResultContent"]));
    }
  }


  virtual ~OpenApiCallbackResponseBody() = default;
};
class OpenApiCallbackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenApiCallbackResponseBody> body{};

  OpenApiCallbackResponse() {}

  explicit OpenApiCallbackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenApiCallbackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenApiCallbackResponseBody>(model1);
      }
    }
  }


  virtual ~OpenApiCallbackResponse() = default;
};
class OpenApiDecodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMqcpOpenApiDecodeRequestJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  OpenApiDecodeRequest() {}

  explicit OpenApiDecodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMqcpOpenApiDecodeRequestJsonStr) {
      res["MpaasMqcpOpenApiDecodeRequestJsonStr"] = boost::any(*mpaasMqcpOpenApiDecodeRequestJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMqcpOpenApiDecodeRequestJsonStr") != m.end() && !m["MpaasMqcpOpenApiDecodeRequestJsonStr"].empty()) {
      mpaasMqcpOpenApiDecodeRequestJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMqcpOpenApiDecodeRequestJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~OpenApiDecodeRequest() = default;
};
class OpenApiDecodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultContent{};

  OpenApiDecodeResponseBody() {}

  explicit OpenApiDecodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = boost::any(*resultContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      resultContent = make_shared<string>(boost::any_cast<string>(m["ResultContent"]));
    }
  }


  virtual ~OpenApiDecodeResponseBody() = default;
};
class OpenApiDecodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenApiDecodeResponseBody> body{};

  OpenApiDecodeResponse() {}

  explicit OpenApiDecodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenApiDecodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenApiDecodeResponseBody>(model1);
      }
    }
  }


  virtual ~OpenApiDecodeResponse() = default;
};
class OpenApiDeleteActiveCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMqcpOpenApiDeleteActiveCodeReqJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  OpenApiDeleteActiveCodeRequest() {}

  explicit OpenApiDeleteActiveCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMqcpOpenApiDeleteActiveCodeReqJsonStr) {
      res["MpaasMqcpOpenApiDeleteActiveCodeReqJsonStr"] = boost::any(*mpaasMqcpOpenApiDeleteActiveCodeReqJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMqcpOpenApiDeleteActiveCodeReqJsonStr") != m.end() && !m["MpaasMqcpOpenApiDeleteActiveCodeReqJsonStr"].empty()) {
      mpaasMqcpOpenApiDeleteActiveCodeReqJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMqcpOpenApiDeleteActiveCodeReqJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~OpenApiDeleteActiveCodeRequest() = default;
};
class OpenApiDeleteActiveCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultContent{};

  OpenApiDeleteActiveCodeResponseBody() {}

  explicit OpenApiDeleteActiveCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = boost::any(*resultContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      resultContent = make_shared<string>(boost::any_cast<string>(m["ResultContent"]));
    }
  }


  virtual ~OpenApiDeleteActiveCodeResponseBody() = default;
};
class OpenApiDeleteActiveCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenApiDeleteActiveCodeResponseBody> body{};

  OpenApiDeleteActiveCodeResponse() {}

  explicit OpenApiDeleteActiveCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenApiDeleteActiveCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenApiDeleteActiveCodeResponseBody>(model1);
      }
    }
  }


  virtual ~OpenApiDeleteActiveCodeResponse() = default;
};
class OpenApiEncodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMqcpOpenApiEncodeRequestJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  OpenApiEncodeRequest() {}

  explicit OpenApiEncodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMqcpOpenApiEncodeRequestJsonStr) {
      res["MpaasMqcpOpenApiEncodeRequestJsonStr"] = boost::any(*mpaasMqcpOpenApiEncodeRequestJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMqcpOpenApiEncodeRequestJsonStr") != m.end() && !m["MpaasMqcpOpenApiEncodeRequestJsonStr"].empty()) {
      mpaasMqcpOpenApiEncodeRequestJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMqcpOpenApiEncodeRequestJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~OpenApiEncodeRequest() = default;
};
class OpenApiEncodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultContent{};

  OpenApiEncodeResponseBody() {}

  explicit OpenApiEncodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = boost::any(*resultContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      resultContent = make_shared<string>(boost::any_cast<string>(m["ResultContent"]));
    }
  }


  virtual ~OpenApiEncodeResponseBody() = default;
};
class OpenApiEncodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenApiEncodeResponseBody> body{};

  OpenApiEncodeResponse() {}

  explicit OpenApiEncodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenApiEncodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenApiEncodeResponseBody>(model1);
      }
    }
  }


  virtual ~OpenApiEncodeResponse() = default;
};
class OpenApiQueryActiveCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMqcpOpenApiQueryActiveCodeReqJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  OpenApiQueryActiveCodeRequest() {}

  explicit OpenApiQueryActiveCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMqcpOpenApiQueryActiveCodeReqJsonStr) {
      res["MpaasMqcpOpenApiQueryActiveCodeReqJsonStr"] = boost::any(*mpaasMqcpOpenApiQueryActiveCodeReqJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMqcpOpenApiQueryActiveCodeReqJsonStr") != m.end() && !m["MpaasMqcpOpenApiQueryActiveCodeReqJsonStr"].empty()) {
      mpaasMqcpOpenApiQueryActiveCodeReqJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMqcpOpenApiQueryActiveCodeReqJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~OpenApiQueryActiveCodeRequest() = default;
};
class OpenApiQueryActiveCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultContent{};
  shared_ptr<string> resultMessage{};

  OpenApiQueryActiveCodeResponseBody() {}

  explicit OpenApiQueryActiveCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = boost::any(*resultContent);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      resultContent = make_shared<string>(boost::any_cast<string>(m["ResultContent"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~OpenApiQueryActiveCodeResponseBody() = default;
};
class OpenApiQueryActiveCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenApiQueryActiveCodeResponseBody> body{};

  OpenApiQueryActiveCodeResponse() {}

  explicit OpenApiQueryActiveCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenApiQueryActiveCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenApiQueryActiveCodeResponseBody>(model1);
      }
    }
  }


  virtual ~OpenApiQueryActiveCodeResponse() = default;
};
class OpenApiQueryActiveSceneRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMqcpOpenApiQueryActiveSceneReqJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  OpenApiQueryActiveSceneRequest() {}

  explicit OpenApiQueryActiveSceneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMqcpOpenApiQueryActiveSceneReqJsonStr) {
      res["MpaasMqcpOpenApiQueryActiveSceneReqJsonStr"] = boost::any(*mpaasMqcpOpenApiQueryActiveSceneReqJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMqcpOpenApiQueryActiveSceneReqJsonStr") != m.end() && !m["MpaasMqcpOpenApiQueryActiveSceneReqJsonStr"].empty()) {
      mpaasMqcpOpenApiQueryActiveSceneReqJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMqcpOpenApiQueryActiveSceneReqJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~OpenApiQueryActiveSceneRequest() = default;
};
class OpenApiQueryActiveSceneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultContent{};

  OpenApiQueryActiveSceneResponseBody() {}

  explicit OpenApiQueryActiveSceneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = boost::any(*resultContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      resultContent = make_shared<string>(boost::any_cast<string>(m["ResultContent"]));
    }
  }


  virtual ~OpenApiQueryActiveSceneResponseBody() = default;
};
class OpenApiQueryActiveSceneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenApiQueryActiveSceneResponseBody> body{};

  OpenApiQueryActiveSceneResponse() {}

  explicit OpenApiQueryActiveSceneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenApiQueryActiveSceneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenApiQueryActiveSceneResponseBody>(model1);
      }
    }
  }


  virtual ~OpenApiQueryActiveSceneResponse() = default;
};
class OpenApiUniqueEncodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMqcpOpenApiUniqueEncodeRequestJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  OpenApiUniqueEncodeRequest() {}

  explicit OpenApiUniqueEncodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMqcpOpenApiUniqueEncodeRequestJsonStr) {
      res["MpaasMqcpOpenApiUniqueEncodeRequestJsonStr"] = boost::any(*mpaasMqcpOpenApiUniqueEncodeRequestJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMqcpOpenApiUniqueEncodeRequestJsonStr") != m.end() && !m["MpaasMqcpOpenApiUniqueEncodeRequestJsonStr"].empty()) {
      mpaasMqcpOpenApiUniqueEncodeRequestJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMqcpOpenApiUniqueEncodeRequestJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~OpenApiUniqueEncodeRequest() = default;
};
class OpenApiUniqueEncodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultContent{};

  OpenApiUniqueEncodeResponseBody() {}

  explicit OpenApiUniqueEncodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = boost::any(*resultContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      resultContent = make_shared<string>(boost::any_cast<string>(m["ResultContent"]));
    }
  }


  virtual ~OpenApiUniqueEncodeResponseBody() = default;
};
class OpenApiUniqueEncodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenApiUniqueEncodeResponseBody> body{};

  OpenApiUniqueEncodeResponse() {}

  explicit OpenApiUniqueEncodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenApiUniqueEncodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenApiUniqueEncodeResponseBody>(model1);
      }
    }
  }


  virtual ~OpenApiUniqueEncodeResponse() = default;
};
class OpenApiUpdateActiveCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMqcpOpenApiUpdateActiveCodeReqJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  OpenApiUpdateActiveCodeRequest() {}

  explicit OpenApiUpdateActiveCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMqcpOpenApiUpdateActiveCodeReqJsonStr) {
      res["MpaasMqcpOpenApiUpdateActiveCodeReqJsonStr"] = boost::any(*mpaasMqcpOpenApiUpdateActiveCodeReqJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMqcpOpenApiUpdateActiveCodeReqJsonStr") != m.end() && !m["MpaasMqcpOpenApiUpdateActiveCodeReqJsonStr"].empty()) {
      mpaasMqcpOpenApiUpdateActiveCodeReqJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMqcpOpenApiUpdateActiveCodeReqJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~OpenApiUpdateActiveCodeRequest() = default;
};
class OpenApiUpdateActiveCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultContent{};

  OpenApiUpdateActiveCodeResponseBody() {}

  explicit OpenApiUpdateActiveCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = boost::any(*resultContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      resultContent = make_shared<string>(boost::any_cast<string>(m["ResultContent"]));
    }
  }


  virtual ~OpenApiUpdateActiveCodeResponseBody() = default;
};
class OpenApiUpdateActiveCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenApiUpdateActiveCodeResponseBody> body{};

  OpenApiUpdateActiveCodeResponse() {}

  explicit OpenApiUpdateActiveCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenApiUpdateActiveCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenApiUpdateActiveCodeResponseBody>(model1);
      }
    }
  }


  virtual ~OpenApiUpdateActiveCodeResponse() = default;
};
class OpenApiUpdateActiveSceneRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMqcpOpenApiUpdateActiveSceneReqJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  OpenApiUpdateActiveSceneRequest() {}

  explicit OpenApiUpdateActiveSceneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMqcpOpenApiUpdateActiveSceneReqJsonStr) {
      res["MpaasMqcpOpenApiUpdateActiveSceneReqJsonStr"] = boost::any(*mpaasMqcpOpenApiUpdateActiveSceneReqJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMqcpOpenApiUpdateActiveSceneReqJsonStr") != m.end() && !m["MpaasMqcpOpenApiUpdateActiveSceneReqJsonStr"].empty()) {
      mpaasMqcpOpenApiUpdateActiveSceneReqJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMqcpOpenApiUpdateActiveSceneReqJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~OpenApiUpdateActiveSceneRequest() = default;
};
class OpenApiUpdateActiveSceneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultContent{};

  OpenApiUpdateActiveSceneResponseBody() {}

  explicit OpenApiUpdateActiveSceneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = boost::any(*resultContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      resultContent = make_shared<string>(boost::any_cast<string>(m["ResultContent"]));
    }
  }


  virtual ~OpenApiUpdateActiveSceneResponseBody() = default;
};
class OpenApiUpdateActiveSceneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenApiUpdateActiveSceneResponseBody> body{};

  OpenApiUpdateActiveSceneResponse() {}

  explicit OpenApiUpdateActiveSceneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenApiUpdateActiveSceneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenApiUpdateActiveSceneResponseBody>(model1);
      }
    }
  }


  virtual ~OpenApiUpdateActiveSceneResponse() = default;
};
class PushBindRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> deliveryToken{};
  shared_ptr<long> osType{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> userId{};
  shared_ptr<string> workspaceId{};

  PushBindRequest() {}

  explicit PushBindRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (deliveryToken) {
      res["DeliveryToken"] = boost::any(*deliveryToken);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DeliveryToken") != m.end() && !m["DeliveryToken"].empty()) {
      deliveryToken = make_shared<string>(boost::any_cast<string>(m["DeliveryToken"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<long>(boost::any_cast<long>(m["OsType"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~PushBindRequest() = default;
};
class PushBindResponseBodyPushResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  PushBindResponseBodyPushResult() {}

  explicit PushBindResponseBodyPushResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PushBindResponseBodyPushResult() = default;
};
class PushBindResponseBody : public Darabonba::Model {
public:
  shared_ptr<PushBindResponseBodyPushResult> pushResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  PushBindResponseBody() {}

  explicit PushBindResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pushResult) {
      res["PushResult"] = pushResult ? boost::any(pushResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PushResult") != m.end() && !m["PushResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PushResult"].type()) {
        PushBindResponseBodyPushResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PushResult"]));
        pushResult = make_shared<PushBindResponseBodyPushResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~PushBindResponseBody() = default;
};
class PushBindResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PushBindResponseBody> body{};

  PushBindResponse() {}

  explicit PushBindResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PushBindResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PushBindResponseBody>(model1);
      }
    }
  }


  virtual ~PushBindResponse() = default;
};
class PushBroadcastRequest : public Darabonba::Model {
public:
  shared_ptr<long> androidChannel{};
  shared_ptr<string> appId{};
  shared_ptr<long> bindPeriod{};
  shared_ptr<string> channelId{};
  shared_ptr<string> classification{};
  shared_ptr<long> deliveryType{};
  shared_ptr<long> expiredSeconds{};
  shared_ptr<string> extendedParams{};
  shared_ptr<string> miChannelId{};
  shared_ptr<string> msgkey{};
  shared_ptr<string> notifyType{};
  shared_ptr<long> pushAction{};
  shared_ptr<long> pushStatus{};
  shared_ptr<long> silent{};
  shared_ptr<string> strategyContent{};
  shared_ptr<long> strategyType{};
  shared_ptr<string> taskName{};
  shared_ptr<string> templateKeyValue{};
  shared_ptr<string> templateName{};
  shared_ptr<map<string, boost::any>> thirdChannelCategory{};
  shared_ptr<long> unBindPeriod{};
  shared_ptr<string> workspaceId{};

  PushBroadcastRequest() {}

  explicit PushBroadcastRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (androidChannel) {
      res["AndroidChannel"] = boost::any(*androidChannel);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (bindPeriod) {
      res["BindPeriod"] = boost::any(*bindPeriod);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (deliveryType) {
      res["DeliveryType"] = boost::any(*deliveryType);
    }
    if (expiredSeconds) {
      res["ExpiredSeconds"] = boost::any(*expiredSeconds);
    }
    if (extendedParams) {
      res["ExtendedParams"] = boost::any(*extendedParams);
    }
    if (miChannelId) {
      res["MiChannelId"] = boost::any(*miChannelId);
    }
    if (msgkey) {
      res["Msgkey"] = boost::any(*msgkey);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (pushAction) {
      res["PushAction"] = boost::any(*pushAction);
    }
    if (pushStatus) {
      res["PushStatus"] = boost::any(*pushStatus);
    }
    if (silent) {
      res["Silent"] = boost::any(*silent);
    }
    if (strategyContent) {
      res["StrategyContent"] = boost::any(*strategyContent);
    }
    if (strategyType) {
      res["StrategyType"] = boost::any(*strategyType);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (templateKeyValue) {
      res["TemplateKeyValue"] = boost::any(*templateKeyValue);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (thirdChannelCategory) {
      res["ThirdChannelCategory"] = boost::any(*thirdChannelCategory);
    }
    if (unBindPeriod) {
      res["UnBindPeriod"] = boost::any(*unBindPeriod);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AndroidChannel") != m.end() && !m["AndroidChannel"].empty()) {
      androidChannel = make_shared<long>(boost::any_cast<long>(m["AndroidChannel"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BindPeriod") != m.end() && !m["BindPeriod"].empty()) {
      bindPeriod = make_shared<long>(boost::any_cast<long>(m["BindPeriod"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classification = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("DeliveryType") != m.end() && !m["DeliveryType"].empty()) {
      deliveryType = make_shared<long>(boost::any_cast<long>(m["DeliveryType"]));
    }
    if (m.find("ExpiredSeconds") != m.end() && !m["ExpiredSeconds"].empty()) {
      expiredSeconds = make_shared<long>(boost::any_cast<long>(m["ExpiredSeconds"]));
    }
    if (m.find("ExtendedParams") != m.end() && !m["ExtendedParams"].empty()) {
      extendedParams = make_shared<string>(boost::any_cast<string>(m["ExtendedParams"]));
    }
    if (m.find("MiChannelId") != m.end() && !m["MiChannelId"].empty()) {
      miChannelId = make_shared<string>(boost::any_cast<string>(m["MiChannelId"]));
    }
    if (m.find("Msgkey") != m.end() && !m["Msgkey"].empty()) {
      msgkey = make_shared<string>(boost::any_cast<string>(m["Msgkey"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
    if (m.find("PushAction") != m.end() && !m["PushAction"].empty()) {
      pushAction = make_shared<long>(boost::any_cast<long>(m["PushAction"]));
    }
    if (m.find("PushStatus") != m.end() && !m["PushStatus"].empty()) {
      pushStatus = make_shared<long>(boost::any_cast<long>(m["PushStatus"]));
    }
    if (m.find("Silent") != m.end() && !m["Silent"].empty()) {
      silent = make_shared<long>(boost::any_cast<long>(m["Silent"]));
    }
    if (m.find("StrategyContent") != m.end() && !m["StrategyContent"].empty()) {
      strategyContent = make_shared<string>(boost::any_cast<string>(m["StrategyContent"]));
    }
    if (m.find("StrategyType") != m.end() && !m["StrategyType"].empty()) {
      strategyType = make_shared<long>(boost::any_cast<long>(m["StrategyType"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TemplateKeyValue") != m.end() && !m["TemplateKeyValue"].empty()) {
      templateKeyValue = make_shared<string>(boost::any_cast<string>(m["TemplateKeyValue"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("ThirdChannelCategory") != m.end() && !m["ThirdChannelCategory"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ThirdChannelCategory"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      thirdChannelCategory = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("UnBindPeriod") != m.end() && !m["UnBindPeriod"].empty()) {
      unBindPeriod = make_shared<long>(boost::any_cast<long>(m["UnBindPeriod"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~PushBroadcastRequest() = default;
};
class PushBroadcastShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> androidChannel{};
  shared_ptr<string> appId{};
  shared_ptr<long> bindPeriod{};
  shared_ptr<string> channelId{};
  shared_ptr<string> classification{};
  shared_ptr<long> deliveryType{};
  shared_ptr<long> expiredSeconds{};
  shared_ptr<string> extendedParams{};
  shared_ptr<string> miChannelId{};
  shared_ptr<string> msgkey{};
  shared_ptr<string> notifyType{};
  shared_ptr<long> pushAction{};
  shared_ptr<long> pushStatus{};
  shared_ptr<long> silent{};
  shared_ptr<string> strategyContent{};
  shared_ptr<long> strategyType{};
  shared_ptr<string> taskName{};
  shared_ptr<string> templateKeyValue{};
  shared_ptr<string> templateName{};
  shared_ptr<string> thirdChannelCategoryShrink{};
  shared_ptr<long> unBindPeriod{};
  shared_ptr<string> workspaceId{};

  PushBroadcastShrinkRequest() {}

  explicit PushBroadcastShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (androidChannel) {
      res["AndroidChannel"] = boost::any(*androidChannel);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (bindPeriod) {
      res["BindPeriod"] = boost::any(*bindPeriod);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (deliveryType) {
      res["DeliveryType"] = boost::any(*deliveryType);
    }
    if (expiredSeconds) {
      res["ExpiredSeconds"] = boost::any(*expiredSeconds);
    }
    if (extendedParams) {
      res["ExtendedParams"] = boost::any(*extendedParams);
    }
    if (miChannelId) {
      res["MiChannelId"] = boost::any(*miChannelId);
    }
    if (msgkey) {
      res["Msgkey"] = boost::any(*msgkey);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (pushAction) {
      res["PushAction"] = boost::any(*pushAction);
    }
    if (pushStatus) {
      res["PushStatus"] = boost::any(*pushStatus);
    }
    if (silent) {
      res["Silent"] = boost::any(*silent);
    }
    if (strategyContent) {
      res["StrategyContent"] = boost::any(*strategyContent);
    }
    if (strategyType) {
      res["StrategyType"] = boost::any(*strategyType);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (templateKeyValue) {
      res["TemplateKeyValue"] = boost::any(*templateKeyValue);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (thirdChannelCategoryShrink) {
      res["ThirdChannelCategory"] = boost::any(*thirdChannelCategoryShrink);
    }
    if (unBindPeriod) {
      res["UnBindPeriod"] = boost::any(*unBindPeriod);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AndroidChannel") != m.end() && !m["AndroidChannel"].empty()) {
      androidChannel = make_shared<long>(boost::any_cast<long>(m["AndroidChannel"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BindPeriod") != m.end() && !m["BindPeriod"].empty()) {
      bindPeriod = make_shared<long>(boost::any_cast<long>(m["BindPeriod"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classification = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("DeliveryType") != m.end() && !m["DeliveryType"].empty()) {
      deliveryType = make_shared<long>(boost::any_cast<long>(m["DeliveryType"]));
    }
    if (m.find("ExpiredSeconds") != m.end() && !m["ExpiredSeconds"].empty()) {
      expiredSeconds = make_shared<long>(boost::any_cast<long>(m["ExpiredSeconds"]));
    }
    if (m.find("ExtendedParams") != m.end() && !m["ExtendedParams"].empty()) {
      extendedParams = make_shared<string>(boost::any_cast<string>(m["ExtendedParams"]));
    }
    if (m.find("MiChannelId") != m.end() && !m["MiChannelId"].empty()) {
      miChannelId = make_shared<string>(boost::any_cast<string>(m["MiChannelId"]));
    }
    if (m.find("Msgkey") != m.end() && !m["Msgkey"].empty()) {
      msgkey = make_shared<string>(boost::any_cast<string>(m["Msgkey"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
    if (m.find("PushAction") != m.end() && !m["PushAction"].empty()) {
      pushAction = make_shared<long>(boost::any_cast<long>(m["PushAction"]));
    }
    if (m.find("PushStatus") != m.end() && !m["PushStatus"].empty()) {
      pushStatus = make_shared<long>(boost::any_cast<long>(m["PushStatus"]));
    }
    if (m.find("Silent") != m.end() && !m["Silent"].empty()) {
      silent = make_shared<long>(boost::any_cast<long>(m["Silent"]));
    }
    if (m.find("StrategyContent") != m.end() && !m["StrategyContent"].empty()) {
      strategyContent = make_shared<string>(boost::any_cast<string>(m["StrategyContent"]));
    }
    if (m.find("StrategyType") != m.end() && !m["StrategyType"].empty()) {
      strategyType = make_shared<long>(boost::any_cast<long>(m["StrategyType"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TemplateKeyValue") != m.end() && !m["TemplateKeyValue"].empty()) {
      templateKeyValue = make_shared<string>(boost::any_cast<string>(m["TemplateKeyValue"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("ThirdChannelCategory") != m.end() && !m["ThirdChannelCategory"].empty()) {
      thirdChannelCategoryShrink = make_shared<string>(boost::any_cast<string>(m["ThirdChannelCategory"]));
    }
    if (m.find("UnBindPeriod") != m.end() && !m["UnBindPeriod"].empty()) {
      unBindPeriod = make_shared<long>(boost::any_cast<long>(m["UnBindPeriod"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~PushBroadcastShrinkRequest() = default;
};
class PushBroadcastResponseBodyPushResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  PushBroadcastResponseBodyPushResult() {}

  explicit PushBroadcastResponseBodyPushResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PushBroadcastResponseBodyPushResult() = default;
};
class PushBroadcastResponseBody : public Darabonba::Model {
public:
  shared_ptr<PushBroadcastResponseBodyPushResult> pushResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  PushBroadcastResponseBody() {}

  explicit PushBroadcastResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pushResult) {
      res["PushResult"] = pushResult ? boost::any(pushResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PushResult") != m.end() && !m["PushResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PushResult"].type()) {
        PushBroadcastResponseBodyPushResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PushResult"]));
        pushResult = make_shared<PushBroadcastResponseBodyPushResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~PushBroadcastResponseBody() = default;
};
class PushBroadcastResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PushBroadcastResponseBody> body{};

  PushBroadcastResponse() {}

  explicit PushBroadcastResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PushBroadcastResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PushBroadcastResponseBody>(model1);
      }
    }
  }


  virtual ~PushBroadcastResponse() = default;
};
class PushMultipleRequestTargetMsg : public Darabonba::Model {
public:
  shared_ptr<string> extendedParams{};
  shared_ptr<string> msgKey{};
  shared_ptr<string> target{};
  shared_ptr<string> templateKeyValue{};

  PushMultipleRequestTargetMsg() {}

  explicit PushMultipleRequestTargetMsg(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extendedParams) {
      res["ExtendedParams"] = boost::any(*extendedParams);
    }
    if (msgKey) {
      res["MsgKey"] = boost::any(*msgKey);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (templateKeyValue) {
      res["TemplateKeyValue"] = boost::any(*templateKeyValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtendedParams") != m.end() && !m["ExtendedParams"].empty()) {
      extendedParams = make_shared<string>(boost::any_cast<string>(m["ExtendedParams"]));
    }
    if (m.find("MsgKey") != m.end() && !m["MsgKey"].empty()) {
      msgKey = make_shared<string>(boost::any_cast<string>(m["MsgKey"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("TemplateKeyValue") != m.end() && !m["TemplateKeyValue"].empty()) {
      templateKeyValue = make_shared<string>(boost::any_cast<string>(m["TemplateKeyValue"]));
    }
  }


  virtual ~PushMultipleRequestTargetMsg() = default;
};
class PushMultipleRequest : public Darabonba::Model {
public:
  shared_ptr<boost::any> activityContentState{};
  shared_ptr<string> activityEvent{};
  shared_ptr<string> appId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> classification{};
  shared_ptr<long> deliveryType{};
  shared_ptr<long> dismissalDate{};
  shared_ptr<long> expiredSeconds{};
  shared_ptr<string> extendedParams{};
  shared_ptr<string> miChannelId{};
  shared_ptr<string> notifyType{};
  shared_ptr<long> pushAction{};
  shared_ptr<long> silent{};
  shared_ptr<string> strategyContent{};
  shared_ptr<long> strategyType{};
  shared_ptr<vector<PushMultipleRequestTargetMsg>> targetMsg{};
  shared_ptr<string> taskName{};
  shared_ptr<string> templateName{};
  shared_ptr<map<string, boost::any>> thirdChannelCategory{};
  shared_ptr<string> workspaceId{};

  PushMultipleRequest() {}

  explicit PushMultipleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityContentState) {
      res["ActivityContentState"] = boost::any(*activityContentState);
    }
    if (activityEvent) {
      res["ActivityEvent"] = boost::any(*activityEvent);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (deliveryType) {
      res["DeliveryType"] = boost::any(*deliveryType);
    }
    if (dismissalDate) {
      res["DismissalDate"] = boost::any(*dismissalDate);
    }
    if (expiredSeconds) {
      res["ExpiredSeconds"] = boost::any(*expiredSeconds);
    }
    if (extendedParams) {
      res["ExtendedParams"] = boost::any(*extendedParams);
    }
    if (miChannelId) {
      res["MiChannelId"] = boost::any(*miChannelId);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (pushAction) {
      res["PushAction"] = boost::any(*pushAction);
    }
    if (silent) {
      res["Silent"] = boost::any(*silent);
    }
    if (strategyContent) {
      res["StrategyContent"] = boost::any(*strategyContent);
    }
    if (strategyType) {
      res["StrategyType"] = boost::any(*strategyType);
    }
    if (targetMsg) {
      vector<boost::any> temp1;
      for(auto item1:*targetMsg){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TargetMsg"] = boost::any(temp1);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (thirdChannelCategory) {
      res["ThirdChannelCategory"] = boost::any(*thirdChannelCategory);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityContentState") != m.end() && !m["ActivityContentState"].empty()) {
      activityContentState = make_shared<boost::any>(boost::any_cast<boost::any>(m["ActivityContentState"]));
    }
    if (m.find("ActivityEvent") != m.end() && !m["ActivityEvent"].empty()) {
      activityEvent = make_shared<string>(boost::any_cast<string>(m["ActivityEvent"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classification = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("DeliveryType") != m.end() && !m["DeliveryType"].empty()) {
      deliveryType = make_shared<long>(boost::any_cast<long>(m["DeliveryType"]));
    }
    if (m.find("DismissalDate") != m.end() && !m["DismissalDate"].empty()) {
      dismissalDate = make_shared<long>(boost::any_cast<long>(m["DismissalDate"]));
    }
    if (m.find("ExpiredSeconds") != m.end() && !m["ExpiredSeconds"].empty()) {
      expiredSeconds = make_shared<long>(boost::any_cast<long>(m["ExpiredSeconds"]));
    }
    if (m.find("ExtendedParams") != m.end() && !m["ExtendedParams"].empty()) {
      extendedParams = make_shared<string>(boost::any_cast<string>(m["ExtendedParams"]));
    }
    if (m.find("MiChannelId") != m.end() && !m["MiChannelId"].empty()) {
      miChannelId = make_shared<string>(boost::any_cast<string>(m["MiChannelId"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
    if (m.find("PushAction") != m.end() && !m["PushAction"].empty()) {
      pushAction = make_shared<long>(boost::any_cast<long>(m["PushAction"]));
    }
    if (m.find("Silent") != m.end() && !m["Silent"].empty()) {
      silent = make_shared<long>(boost::any_cast<long>(m["Silent"]));
    }
    if (m.find("StrategyContent") != m.end() && !m["StrategyContent"].empty()) {
      strategyContent = make_shared<string>(boost::any_cast<string>(m["StrategyContent"]));
    }
    if (m.find("StrategyType") != m.end() && !m["StrategyType"].empty()) {
      strategyType = make_shared<long>(boost::any_cast<long>(m["StrategyType"]));
    }
    if (m.find("TargetMsg") != m.end() && !m["TargetMsg"].empty()) {
      if (typeid(vector<boost::any>) == m["TargetMsg"].type()) {
        vector<PushMultipleRequestTargetMsg> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TargetMsg"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PushMultipleRequestTargetMsg model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targetMsg = make_shared<vector<PushMultipleRequestTargetMsg>>(expect1);
      }
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("ThirdChannelCategory") != m.end() && !m["ThirdChannelCategory"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ThirdChannelCategory"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      thirdChannelCategory = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~PushMultipleRequest() = default;
};
class PushMultipleShrinkRequestTargetMsg : public Darabonba::Model {
public:
  shared_ptr<string> extendedParams{};
  shared_ptr<string> msgKey{};
  shared_ptr<string> target{};
  shared_ptr<string> templateKeyValue{};

  PushMultipleShrinkRequestTargetMsg() {}

  explicit PushMultipleShrinkRequestTargetMsg(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extendedParams) {
      res["ExtendedParams"] = boost::any(*extendedParams);
    }
    if (msgKey) {
      res["MsgKey"] = boost::any(*msgKey);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (templateKeyValue) {
      res["TemplateKeyValue"] = boost::any(*templateKeyValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtendedParams") != m.end() && !m["ExtendedParams"].empty()) {
      extendedParams = make_shared<string>(boost::any_cast<string>(m["ExtendedParams"]));
    }
    if (m.find("MsgKey") != m.end() && !m["MsgKey"].empty()) {
      msgKey = make_shared<string>(boost::any_cast<string>(m["MsgKey"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("TemplateKeyValue") != m.end() && !m["TemplateKeyValue"].empty()) {
      templateKeyValue = make_shared<string>(boost::any_cast<string>(m["TemplateKeyValue"]));
    }
  }


  virtual ~PushMultipleShrinkRequestTargetMsg() = default;
};
class PushMultipleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<boost::any> activityContentState{};
  shared_ptr<string> activityEvent{};
  shared_ptr<string> appId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> classification{};
  shared_ptr<long> deliveryType{};
  shared_ptr<long> dismissalDate{};
  shared_ptr<long> expiredSeconds{};
  shared_ptr<string> extendedParams{};
  shared_ptr<string> miChannelId{};
  shared_ptr<string> notifyType{};
  shared_ptr<long> pushAction{};
  shared_ptr<long> silent{};
  shared_ptr<string> strategyContent{};
  shared_ptr<long> strategyType{};
  shared_ptr<vector<PushMultipleShrinkRequestTargetMsg>> targetMsg{};
  shared_ptr<string> taskName{};
  shared_ptr<string> templateName{};
  shared_ptr<string> thirdChannelCategoryShrink{};
  shared_ptr<string> workspaceId{};

  PushMultipleShrinkRequest() {}

  explicit PushMultipleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityContentState) {
      res["ActivityContentState"] = boost::any(*activityContentState);
    }
    if (activityEvent) {
      res["ActivityEvent"] = boost::any(*activityEvent);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (deliveryType) {
      res["DeliveryType"] = boost::any(*deliveryType);
    }
    if (dismissalDate) {
      res["DismissalDate"] = boost::any(*dismissalDate);
    }
    if (expiredSeconds) {
      res["ExpiredSeconds"] = boost::any(*expiredSeconds);
    }
    if (extendedParams) {
      res["ExtendedParams"] = boost::any(*extendedParams);
    }
    if (miChannelId) {
      res["MiChannelId"] = boost::any(*miChannelId);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (pushAction) {
      res["PushAction"] = boost::any(*pushAction);
    }
    if (silent) {
      res["Silent"] = boost::any(*silent);
    }
    if (strategyContent) {
      res["StrategyContent"] = boost::any(*strategyContent);
    }
    if (strategyType) {
      res["StrategyType"] = boost::any(*strategyType);
    }
    if (targetMsg) {
      vector<boost::any> temp1;
      for(auto item1:*targetMsg){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TargetMsg"] = boost::any(temp1);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (thirdChannelCategoryShrink) {
      res["ThirdChannelCategory"] = boost::any(*thirdChannelCategoryShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityContentState") != m.end() && !m["ActivityContentState"].empty()) {
      activityContentState = make_shared<boost::any>(boost::any_cast<boost::any>(m["ActivityContentState"]));
    }
    if (m.find("ActivityEvent") != m.end() && !m["ActivityEvent"].empty()) {
      activityEvent = make_shared<string>(boost::any_cast<string>(m["ActivityEvent"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classification = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("DeliveryType") != m.end() && !m["DeliveryType"].empty()) {
      deliveryType = make_shared<long>(boost::any_cast<long>(m["DeliveryType"]));
    }
    if (m.find("DismissalDate") != m.end() && !m["DismissalDate"].empty()) {
      dismissalDate = make_shared<long>(boost::any_cast<long>(m["DismissalDate"]));
    }
    if (m.find("ExpiredSeconds") != m.end() && !m["ExpiredSeconds"].empty()) {
      expiredSeconds = make_shared<long>(boost::any_cast<long>(m["ExpiredSeconds"]));
    }
    if (m.find("ExtendedParams") != m.end() && !m["ExtendedParams"].empty()) {
      extendedParams = make_shared<string>(boost::any_cast<string>(m["ExtendedParams"]));
    }
    if (m.find("MiChannelId") != m.end() && !m["MiChannelId"].empty()) {
      miChannelId = make_shared<string>(boost::any_cast<string>(m["MiChannelId"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
    if (m.find("PushAction") != m.end() && !m["PushAction"].empty()) {
      pushAction = make_shared<long>(boost::any_cast<long>(m["PushAction"]));
    }
    if (m.find("Silent") != m.end() && !m["Silent"].empty()) {
      silent = make_shared<long>(boost::any_cast<long>(m["Silent"]));
    }
    if (m.find("StrategyContent") != m.end() && !m["StrategyContent"].empty()) {
      strategyContent = make_shared<string>(boost::any_cast<string>(m["StrategyContent"]));
    }
    if (m.find("StrategyType") != m.end() && !m["StrategyType"].empty()) {
      strategyType = make_shared<long>(boost::any_cast<long>(m["StrategyType"]));
    }
    if (m.find("TargetMsg") != m.end() && !m["TargetMsg"].empty()) {
      if (typeid(vector<boost::any>) == m["TargetMsg"].type()) {
        vector<PushMultipleShrinkRequestTargetMsg> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TargetMsg"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PushMultipleShrinkRequestTargetMsg model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targetMsg = make_shared<vector<PushMultipleShrinkRequestTargetMsg>>(expect1);
      }
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("ThirdChannelCategory") != m.end() && !m["ThirdChannelCategory"].empty()) {
      thirdChannelCategoryShrink = make_shared<string>(boost::any_cast<string>(m["ThirdChannelCategory"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~PushMultipleShrinkRequest() = default;
};
class PushMultipleResponseBodyPushResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  PushMultipleResponseBodyPushResult() {}

  explicit PushMultipleResponseBodyPushResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PushMultipleResponseBodyPushResult() = default;
};
class PushMultipleResponseBody : public Darabonba::Model {
public:
  shared_ptr<PushMultipleResponseBodyPushResult> pushResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  PushMultipleResponseBody() {}

  explicit PushMultipleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pushResult) {
      res["PushResult"] = pushResult ? boost::any(pushResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PushResult") != m.end() && !m["PushResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PushResult"].type()) {
        PushMultipleResponseBodyPushResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PushResult"]));
        pushResult = make_shared<PushMultipleResponseBodyPushResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~PushMultipleResponseBody() = default;
};
class PushMultipleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PushMultipleResponseBody> body{};

  PushMultipleResponse() {}

  explicit PushMultipleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PushMultipleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PushMultipleResponseBody>(model1);
      }
    }
  }


  virtual ~PushMultipleResponse() = default;
};
class PushReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appVersion{};
  shared_ptr<string> channel{};
  shared_ptr<string> connectType{};
  shared_ptr<string> deliveryToken{};
  shared_ptr<string> imei{};
  shared_ptr<string> imsi{};
  shared_ptr<string> model{};
  shared_ptr<long> osType{};
  shared_ptr<string> pushVersion{};
  shared_ptr<long> thirdChannel{};
  shared_ptr<string> thirdChannelDeviceToken{};
  shared_ptr<string> workspaceId{};

  PushReportRequest() {}

  explicit PushReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appVersion) {
      res["AppVersion"] = boost::any(*appVersion);
    }
    if (channel) {
      res["Channel"] = boost::any(*channel);
    }
    if (connectType) {
      res["ConnectType"] = boost::any(*connectType);
    }
    if (deliveryToken) {
      res["DeliveryToken"] = boost::any(*deliveryToken);
    }
    if (imei) {
      res["Imei"] = boost::any(*imei);
    }
    if (imsi) {
      res["Imsi"] = boost::any(*imsi);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (pushVersion) {
      res["PushVersion"] = boost::any(*pushVersion);
    }
    if (thirdChannel) {
      res["ThirdChannel"] = boost::any(*thirdChannel);
    }
    if (thirdChannelDeviceToken) {
      res["ThirdChannelDeviceToken"] = boost::any(*thirdChannelDeviceToken);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppVersion") != m.end() && !m["AppVersion"].empty()) {
      appVersion = make_shared<string>(boost::any_cast<string>(m["AppVersion"]));
    }
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["Channel"]));
    }
    if (m.find("ConnectType") != m.end() && !m["ConnectType"].empty()) {
      connectType = make_shared<string>(boost::any_cast<string>(m["ConnectType"]));
    }
    if (m.find("DeliveryToken") != m.end() && !m["DeliveryToken"].empty()) {
      deliveryToken = make_shared<string>(boost::any_cast<string>(m["DeliveryToken"]));
    }
    if (m.find("Imei") != m.end() && !m["Imei"].empty()) {
      imei = make_shared<string>(boost::any_cast<string>(m["Imei"]));
    }
    if (m.find("Imsi") != m.end() && !m["Imsi"].empty()) {
      imsi = make_shared<string>(boost::any_cast<string>(m["Imsi"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<long>(boost::any_cast<long>(m["OsType"]));
    }
    if (m.find("PushVersion") != m.end() && !m["PushVersion"].empty()) {
      pushVersion = make_shared<string>(boost::any_cast<string>(m["PushVersion"]));
    }
    if (m.find("ThirdChannel") != m.end() && !m["ThirdChannel"].empty()) {
      thirdChannel = make_shared<long>(boost::any_cast<long>(m["ThirdChannel"]));
    }
    if (m.find("ThirdChannelDeviceToken") != m.end() && !m["ThirdChannelDeviceToken"].empty()) {
      thirdChannelDeviceToken = make_shared<string>(boost::any_cast<string>(m["ThirdChannelDeviceToken"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~PushReportRequest() = default;
};
class PushReportResponseBodyPushResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  PushReportResponseBodyPushResult() {}

  explicit PushReportResponseBodyPushResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PushReportResponseBodyPushResult() = default;
};
class PushReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<PushReportResponseBodyPushResult> pushResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  PushReportResponseBody() {}

  explicit PushReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pushResult) {
      res["PushResult"] = pushResult ? boost::any(pushResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PushResult") != m.end() && !m["PushResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PushResult"].type()) {
        PushReportResponseBodyPushResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PushResult"]));
        pushResult = make_shared<PushReportResponseBodyPushResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~PushReportResponseBody() = default;
};
class PushReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PushReportResponseBody> body{};

  PushReportResponse() {}

  explicit PushReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PushReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PushReportResponseBody>(model1);
      }
    }
  }


  virtual ~PushReportResponse() = default;
};
class PushSimpleRequest : public Darabonba::Model {
public:
  shared_ptr<boost::any> activityContentState{};
  shared_ptr<string> activityEvent{};
  shared_ptr<string> appId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> classification{};
  shared_ptr<string> content{};
  shared_ptr<long> deliveryType{};
  shared_ptr<long> dismissalDate{};
  shared_ptr<long> expiredSeconds{};
  shared_ptr<string> extendedParams{};
  shared_ptr<string> iconUrls{};
  shared_ptr<string> imageUrls{};
  shared_ptr<string> miChannelId{};
  shared_ptr<string> notifyType{};
  shared_ptr<long> pushAction{};
  shared_ptr<long> pushStyle{};
  shared_ptr<long> silent{};
  shared_ptr<string> smsSignName{};
  shared_ptr<long> smsStrategy{};
  shared_ptr<string> smsTemplateCode{};
  shared_ptr<string> smsTemplateParam{};
  shared_ptr<string> strategyContent{};
  shared_ptr<long> strategyType{};
  shared_ptr<string> targetMsgkey{};
  shared_ptr<string> taskName{};
  shared_ptr<map<string, boost::any>> thirdChannelCategory{};
  shared_ptr<string> title{};
  shared_ptr<string> uri{};
  shared_ptr<string> workspaceId{};

  PushSimpleRequest() {}

  explicit PushSimpleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityContentState) {
      res["ActivityContentState"] = boost::any(*activityContentState);
    }
    if (activityEvent) {
      res["ActivityEvent"] = boost::any(*activityEvent);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (deliveryType) {
      res["DeliveryType"] = boost::any(*deliveryType);
    }
    if (dismissalDate) {
      res["DismissalDate"] = boost::any(*dismissalDate);
    }
    if (expiredSeconds) {
      res["ExpiredSeconds"] = boost::any(*expiredSeconds);
    }
    if (extendedParams) {
      res["ExtendedParams"] = boost::any(*extendedParams);
    }
    if (iconUrls) {
      res["IconUrls"] = boost::any(*iconUrls);
    }
    if (imageUrls) {
      res["ImageUrls"] = boost::any(*imageUrls);
    }
    if (miChannelId) {
      res["MiChannelId"] = boost::any(*miChannelId);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (pushAction) {
      res["PushAction"] = boost::any(*pushAction);
    }
    if (pushStyle) {
      res["PushStyle"] = boost::any(*pushStyle);
    }
    if (silent) {
      res["Silent"] = boost::any(*silent);
    }
    if (smsSignName) {
      res["SmsSignName"] = boost::any(*smsSignName);
    }
    if (smsStrategy) {
      res["SmsStrategy"] = boost::any(*smsStrategy);
    }
    if (smsTemplateCode) {
      res["SmsTemplateCode"] = boost::any(*smsTemplateCode);
    }
    if (smsTemplateParam) {
      res["SmsTemplateParam"] = boost::any(*smsTemplateParam);
    }
    if (strategyContent) {
      res["StrategyContent"] = boost::any(*strategyContent);
    }
    if (strategyType) {
      res["StrategyType"] = boost::any(*strategyType);
    }
    if (targetMsgkey) {
      res["TargetMsgkey"] = boost::any(*targetMsgkey);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (thirdChannelCategory) {
      res["ThirdChannelCategory"] = boost::any(*thirdChannelCategory);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (uri) {
      res["Uri"] = boost::any(*uri);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityContentState") != m.end() && !m["ActivityContentState"].empty()) {
      activityContentState = make_shared<boost::any>(boost::any_cast<boost::any>(m["ActivityContentState"]));
    }
    if (m.find("ActivityEvent") != m.end() && !m["ActivityEvent"].empty()) {
      activityEvent = make_shared<string>(boost::any_cast<string>(m["ActivityEvent"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classification = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DeliveryType") != m.end() && !m["DeliveryType"].empty()) {
      deliveryType = make_shared<long>(boost::any_cast<long>(m["DeliveryType"]));
    }
    if (m.find("DismissalDate") != m.end() && !m["DismissalDate"].empty()) {
      dismissalDate = make_shared<long>(boost::any_cast<long>(m["DismissalDate"]));
    }
    if (m.find("ExpiredSeconds") != m.end() && !m["ExpiredSeconds"].empty()) {
      expiredSeconds = make_shared<long>(boost::any_cast<long>(m["ExpiredSeconds"]));
    }
    if (m.find("ExtendedParams") != m.end() && !m["ExtendedParams"].empty()) {
      extendedParams = make_shared<string>(boost::any_cast<string>(m["ExtendedParams"]));
    }
    if (m.find("IconUrls") != m.end() && !m["IconUrls"].empty()) {
      iconUrls = make_shared<string>(boost::any_cast<string>(m["IconUrls"]));
    }
    if (m.find("ImageUrls") != m.end() && !m["ImageUrls"].empty()) {
      imageUrls = make_shared<string>(boost::any_cast<string>(m["ImageUrls"]));
    }
    if (m.find("MiChannelId") != m.end() && !m["MiChannelId"].empty()) {
      miChannelId = make_shared<string>(boost::any_cast<string>(m["MiChannelId"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
    if (m.find("PushAction") != m.end() && !m["PushAction"].empty()) {
      pushAction = make_shared<long>(boost::any_cast<long>(m["PushAction"]));
    }
    if (m.find("PushStyle") != m.end() && !m["PushStyle"].empty()) {
      pushStyle = make_shared<long>(boost::any_cast<long>(m["PushStyle"]));
    }
    if (m.find("Silent") != m.end() && !m["Silent"].empty()) {
      silent = make_shared<long>(boost::any_cast<long>(m["Silent"]));
    }
    if (m.find("SmsSignName") != m.end() && !m["SmsSignName"].empty()) {
      smsSignName = make_shared<string>(boost::any_cast<string>(m["SmsSignName"]));
    }
    if (m.find("SmsStrategy") != m.end() && !m["SmsStrategy"].empty()) {
      smsStrategy = make_shared<long>(boost::any_cast<long>(m["SmsStrategy"]));
    }
    if (m.find("SmsTemplateCode") != m.end() && !m["SmsTemplateCode"].empty()) {
      smsTemplateCode = make_shared<string>(boost::any_cast<string>(m["SmsTemplateCode"]));
    }
    if (m.find("SmsTemplateParam") != m.end() && !m["SmsTemplateParam"].empty()) {
      smsTemplateParam = make_shared<string>(boost::any_cast<string>(m["SmsTemplateParam"]));
    }
    if (m.find("StrategyContent") != m.end() && !m["StrategyContent"].empty()) {
      strategyContent = make_shared<string>(boost::any_cast<string>(m["StrategyContent"]));
    }
    if (m.find("StrategyType") != m.end() && !m["StrategyType"].empty()) {
      strategyType = make_shared<long>(boost::any_cast<long>(m["StrategyType"]));
    }
    if (m.find("TargetMsgkey") != m.end() && !m["TargetMsgkey"].empty()) {
      targetMsgkey = make_shared<string>(boost::any_cast<string>(m["TargetMsgkey"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("ThirdChannelCategory") != m.end() && !m["ThirdChannelCategory"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ThirdChannelCategory"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      thirdChannelCategory = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Uri") != m.end() && !m["Uri"].empty()) {
      uri = make_shared<string>(boost::any_cast<string>(m["Uri"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~PushSimpleRequest() = default;
};
class PushSimpleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<boost::any> activityContentState{};
  shared_ptr<string> activityEvent{};
  shared_ptr<string> appId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> classification{};
  shared_ptr<string> content{};
  shared_ptr<long> deliveryType{};
  shared_ptr<long> dismissalDate{};
  shared_ptr<long> expiredSeconds{};
  shared_ptr<string> extendedParams{};
  shared_ptr<string> iconUrls{};
  shared_ptr<string> imageUrls{};
  shared_ptr<string> miChannelId{};
  shared_ptr<string> notifyType{};
  shared_ptr<long> pushAction{};
  shared_ptr<long> pushStyle{};
  shared_ptr<long> silent{};
  shared_ptr<string> smsSignName{};
  shared_ptr<long> smsStrategy{};
  shared_ptr<string> smsTemplateCode{};
  shared_ptr<string> smsTemplateParam{};
  shared_ptr<string> strategyContent{};
  shared_ptr<long> strategyType{};
  shared_ptr<string> targetMsgkey{};
  shared_ptr<string> taskName{};
  shared_ptr<string> thirdChannelCategoryShrink{};
  shared_ptr<string> title{};
  shared_ptr<string> uri{};
  shared_ptr<string> workspaceId{};

  PushSimpleShrinkRequest() {}

  explicit PushSimpleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityContentState) {
      res["ActivityContentState"] = boost::any(*activityContentState);
    }
    if (activityEvent) {
      res["ActivityEvent"] = boost::any(*activityEvent);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (deliveryType) {
      res["DeliveryType"] = boost::any(*deliveryType);
    }
    if (dismissalDate) {
      res["DismissalDate"] = boost::any(*dismissalDate);
    }
    if (expiredSeconds) {
      res["ExpiredSeconds"] = boost::any(*expiredSeconds);
    }
    if (extendedParams) {
      res["ExtendedParams"] = boost::any(*extendedParams);
    }
    if (iconUrls) {
      res["IconUrls"] = boost::any(*iconUrls);
    }
    if (imageUrls) {
      res["ImageUrls"] = boost::any(*imageUrls);
    }
    if (miChannelId) {
      res["MiChannelId"] = boost::any(*miChannelId);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (pushAction) {
      res["PushAction"] = boost::any(*pushAction);
    }
    if (pushStyle) {
      res["PushStyle"] = boost::any(*pushStyle);
    }
    if (silent) {
      res["Silent"] = boost::any(*silent);
    }
    if (smsSignName) {
      res["SmsSignName"] = boost::any(*smsSignName);
    }
    if (smsStrategy) {
      res["SmsStrategy"] = boost::any(*smsStrategy);
    }
    if (smsTemplateCode) {
      res["SmsTemplateCode"] = boost::any(*smsTemplateCode);
    }
    if (smsTemplateParam) {
      res["SmsTemplateParam"] = boost::any(*smsTemplateParam);
    }
    if (strategyContent) {
      res["StrategyContent"] = boost::any(*strategyContent);
    }
    if (strategyType) {
      res["StrategyType"] = boost::any(*strategyType);
    }
    if (targetMsgkey) {
      res["TargetMsgkey"] = boost::any(*targetMsgkey);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (thirdChannelCategoryShrink) {
      res["ThirdChannelCategory"] = boost::any(*thirdChannelCategoryShrink);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (uri) {
      res["Uri"] = boost::any(*uri);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityContentState") != m.end() && !m["ActivityContentState"].empty()) {
      activityContentState = make_shared<boost::any>(boost::any_cast<boost::any>(m["ActivityContentState"]));
    }
    if (m.find("ActivityEvent") != m.end() && !m["ActivityEvent"].empty()) {
      activityEvent = make_shared<string>(boost::any_cast<string>(m["ActivityEvent"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classification = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DeliveryType") != m.end() && !m["DeliveryType"].empty()) {
      deliveryType = make_shared<long>(boost::any_cast<long>(m["DeliveryType"]));
    }
    if (m.find("DismissalDate") != m.end() && !m["DismissalDate"].empty()) {
      dismissalDate = make_shared<long>(boost::any_cast<long>(m["DismissalDate"]));
    }
    if (m.find("ExpiredSeconds") != m.end() && !m["ExpiredSeconds"].empty()) {
      expiredSeconds = make_shared<long>(boost::any_cast<long>(m["ExpiredSeconds"]));
    }
    if (m.find("ExtendedParams") != m.end() && !m["ExtendedParams"].empty()) {
      extendedParams = make_shared<string>(boost::any_cast<string>(m["ExtendedParams"]));
    }
    if (m.find("IconUrls") != m.end() && !m["IconUrls"].empty()) {
      iconUrls = make_shared<string>(boost::any_cast<string>(m["IconUrls"]));
    }
    if (m.find("ImageUrls") != m.end() && !m["ImageUrls"].empty()) {
      imageUrls = make_shared<string>(boost::any_cast<string>(m["ImageUrls"]));
    }
    if (m.find("MiChannelId") != m.end() && !m["MiChannelId"].empty()) {
      miChannelId = make_shared<string>(boost::any_cast<string>(m["MiChannelId"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
    if (m.find("PushAction") != m.end() && !m["PushAction"].empty()) {
      pushAction = make_shared<long>(boost::any_cast<long>(m["PushAction"]));
    }
    if (m.find("PushStyle") != m.end() && !m["PushStyle"].empty()) {
      pushStyle = make_shared<long>(boost::any_cast<long>(m["PushStyle"]));
    }
    if (m.find("Silent") != m.end() && !m["Silent"].empty()) {
      silent = make_shared<long>(boost::any_cast<long>(m["Silent"]));
    }
    if (m.find("SmsSignName") != m.end() && !m["SmsSignName"].empty()) {
      smsSignName = make_shared<string>(boost::any_cast<string>(m["SmsSignName"]));
    }
    if (m.find("SmsStrategy") != m.end() && !m["SmsStrategy"].empty()) {
      smsStrategy = make_shared<long>(boost::any_cast<long>(m["SmsStrategy"]));
    }
    if (m.find("SmsTemplateCode") != m.end() && !m["SmsTemplateCode"].empty()) {
      smsTemplateCode = make_shared<string>(boost::any_cast<string>(m["SmsTemplateCode"]));
    }
    if (m.find("SmsTemplateParam") != m.end() && !m["SmsTemplateParam"].empty()) {
      smsTemplateParam = make_shared<string>(boost::any_cast<string>(m["SmsTemplateParam"]));
    }
    if (m.find("StrategyContent") != m.end() && !m["StrategyContent"].empty()) {
      strategyContent = make_shared<string>(boost::any_cast<string>(m["StrategyContent"]));
    }
    if (m.find("StrategyType") != m.end() && !m["StrategyType"].empty()) {
      strategyType = make_shared<long>(boost::any_cast<long>(m["StrategyType"]));
    }
    if (m.find("TargetMsgkey") != m.end() && !m["TargetMsgkey"].empty()) {
      targetMsgkey = make_shared<string>(boost::any_cast<string>(m["TargetMsgkey"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("ThirdChannelCategory") != m.end() && !m["ThirdChannelCategory"].empty()) {
      thirdChannelCategoryShrink = make_shared<string>(boost::any_cast<string>(m["ThirdChannelCategory"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Uri") != m.end() && !m["Uri"].empty()) {
      uri = make_shared<string>(boost::any_cast<string>(m["Uri"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~PushSimpleShrinkRequest() = default;
};
class PushSimpleResponseBodyPushResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  PushSimpleResponseBodyPushResult() {}

  explicit PushSimpleResponseBodyPushResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PushSimpleResponseBodyPushResult() = default;
};
class PushSimpleResponseBody : public Darabonba::Model {
public:
  shared_ptr<PushSimpleResponseBodyPushResult> pushResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  PushSimpleResponseBody() {}

  explicit PushSimpleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pushResult) {
      res["PushResult"] = pushResult ? boost::any(pushResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PushResult") != m.end() && !m["PushResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PushResult"].type()) {
        PushSimpleResponseBodyPushResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PushResult"]));
        pushResult = make_shared<PushSimpleResponseBodyPushResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~PushSimpleResponseBody() = default;
};
class PushSimpleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PushSimpleResponseBody> body{};

  PushSimpleResponse() {}

  explicit PushSimpleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PushSimpleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PushSimpleResponseBody>(model1);
      }
    }
  }


  virtual ~PushSimpleResponse() = default;
};
class PushTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<boost::any> activityContentState{};
  shared_ptr<string> activityEvent{};
  shared_ptr<string> appId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> classification{};
  shared_ptr<long> deliveryType{};
  shared_ptr<long> dismissalDate{};
  shared_ptr<long> expiredSeconds{};
  shared_ptr<string> extendedParams{};
  shared_ptr<string> miChannelId{};
  shared_ptr<string> notifyType{};
  shared_ptr<long> pushAction{};
  shared_ptr<long> silent{};
  shared_ptr<string> smsSignName{};
  shared_ptr<long> smsStrategy{};
  shared_ptr<string> smsTemplateCode{};
  shared_ptr<string> smsTemplateParam{};
  shared_ptr<string> strategyContent{};
  shared_ptr<long> strategyType{};
  shared_ptr<string> targetMsgkey{};
  shared_ptr<string> taskName{};
  shared_ptr<string> templateKeyValue{};
  shared_ptr<string> templateName{};
  shared_ptr<map<string, boost::any>> thirdChannelCategory{};
  shared_ptr<string> workspaceId{};

  PushTemplateRequest() {}

  explicit PushTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityContentState) {
      res["ActivityContentState"] = boost::any(*activityContentState);
    }
    if (activityEvent) {
      res["ActivityEvent"] = boost::any(*activityEvent);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (deliveryType) {
      res["DeliveryType"] = boost::any(*deliveryType);
    }
    if (dismissalDate) {
      res["DismissalDate"] = boost::any(*dismissalDate);
    }
    if (expiredSeconds) {
      res["ExpiredSeconds"] = boost::any(*expiredSeconds);
    }
    if (extendedParams) {
      res["ExtendedParams"] = boost::any(*extendedParams);
    }
    if (miChannelId) {
      res["MiChannelId"] = boost::any(*miChannelId);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (pushAction) {
      res["PushAction"] = boost::any(*pushAction);
    }
    if (silent) {
      res["Silent"] = boost::any(*silent);
    }
    if (smsSignName) {
      res["SmsSignName"] = boost::any(*smsSignName);
    }
    if (smsStrategy) {
      res["SmsStrategy"] = boost::any(*smsStrategy);
    }
    if (smsTemplateCode) {
      res["SmsTemplateCode"] = boost::any(*smsTemplateCode);
    }
    if (smsTemplateParam) {
      res["SmsTemplateParam"] = boost::any(*smsTemplateParam);
    }
    if (strategyContent) {
      res["StrategyContent"] = boost::any(*strategyContent);
    }
    if (strategyType) {
      res["StrategyType"] = boost::any(*strategyType);
    }
    if (targetMsgkey) {
      res["TargetMsgkey"] = boost::any(*targetMsgkey);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (templateKeyValue) {
      res["TemplateKeyValue"] = boost::any(*templateKeyValue);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (thirdChannelCategory) {
      res["ThirdChannelCategory"] = boost::any(*thirdChannelCategory);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityContentState") != m.end() && !m["ActivityContentState"].empty()) {
      activityContentState = make_shared<boost::any>(boost::any_cast<boost::any>(m["ActivityContentState"]));
    }
    if (m.find("ActivityEvent") != m.end() && !m["ActivityEvent"].empty()) {
      activityEvent = make_shared<string>(boost::any_cast<string>(m["ActivityEvent"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classification = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("DeliveryType") != m.end() && !m["DeliveryType"].empty()) {
      deliveryType = make_shared<long>(boost::any_cast<long>(m["DeliveryType"]));
    }
    if (m.find("DismissalDate") != m.end() && !m["DismissalDate"].empty()) {
      dismissalDate = make_shared<long>(boost::any_cast<long>(m["DismissalDate"]));
    }
    if (m.find("ExpiredSeconds") != m.end() && !m["ExpiredSeconds"].empty()) {
      expiredSeconds = make_shared<long>(boost::any_cast<long>(m["ExpiredSeconds"]));
    }
    if (m.find("ExtendedParams") != m.end() && !m["ExtendedParams"].empty()) {
      extendedParams = make_shared<string>(boost::any_cast<string>(m["ExtendedParams"]));
    }
    if (m.find("MiChannelId") != m.end() && !m["MiChannelId"].empty()) {
      miChannelId = make_shared<string>(boost::any_cast<string>(m["MiChannelId"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
    if (m.find("PushAction") != m.end() && !m["PushAction"].empty()) {
      pushAction = make_shared<long>(boost::any_cast<long>(m["PushAction"]));
    }
    if (m.find("Silent") != m.end() && !m["Silent"].empty()) {
      silent = make_shared<long>(boost::any_cast<long>(m["Silent"]));
    }
    if (m.find("SmsSignName") != m.end() && !m["SmsSignName"].empty()) {
      smsSignName = make_shared<string>(boost::any_cast<string>(m["SmsSignName"]));
    }
    if (m.find("SmsStrategy") != m.end() && !m["SmsStrategy"].empty()) {
      smsStrategy = make_shared<long>(boost::any_cast<long>(m["SmsStrategy"]));
    }
    if (m.find("SmsTemplateCode") != m.end() && !m["SmsTemplateCode"].empty()) {
      smsTemplateCode = make_shared<string>(boost::any_cast<string>(m["SmsTemplateCode"]));
    }
    if (m.find("SmsTemplateParam") != m.end() && !m["SmsTemplateParam"].empty()) {
      smsTemplateParam = make_shared<string>(boost::any_cast<string>(m["SmsTemplateParam"]));
    }
    if (m.find("StrategyContent") != m.end() && !m["StrategyContent"].empty()) {
      strategyContent = make_shared<string>(boost::any_cast<string>(m["StrategyContent"]));
    }
    if (m.find("StrategyType") != m.end() && !m["StrategyType"].empty()) {
      strategyType = make_shared<long>(boost::any_cast<long>(m["StrategyType"]));
    }
    if (m.find("TargetMsgkey") != m.end() && !m["TargetMsgkey"].empty()) {
      targetMsgkey = make_shared<string>(boost::any_cast<string>(m["TargetMsgkey"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TemplateKeyValue") != m.end() && !m["TemplateKeyValue"].empty()) {
      templateKeyValue = make_shared<string>(boost::any_cast<string>(m["TemplateKeyValue"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("ThirdChannelCategory") != m.end() && !m["ThirdChannelCategory"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ThirdChannelCategory"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      thirdChannelCategory = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~PushTemplateRequest() = default;
};
class PushTemplateShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<boost::any> activityContentState{};
  shared_ptr<string> activityEvent{};
  shared_ptr<string> appId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> classification{};
  shared_ptr<long> deliveryType{};
  shared_ptr<long> dismissalDate{};
  shared_ptr<long> expiredSeconds{};
  shared_ptr<string> extendedParams{};
  shared_ptr<string> miChannelId{};
  shared_ptr<string> notifyType{};
  shared_ptr<long> pushAction{};
  shared_ptr<long> silent{};
  shared_ptr<string> smsSignName{};
  shared_ptr<long> smsStrategy{};
  shared_ptr<string> smsTemplateCode{};
  shared_ptr<string> smsTemplateParam{};
  shared_ptr<string> strategyContent{};
  shared_ptr<long> strategyType{};
  shared_ptr<string> targetMsgkey{};
  shared_ptr<string> taskName{};
  shared_ptr<string> templateKeyValue{};
  shared_ptr<string> templateName{};
  shared_ptr<string> thirdChannelCategoryShrink{};
  shared_ptr<string> workspaceId{};

  PushTemplateShrinkRequest() {}

  explicit PushTemplateShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityContentState) {
      res["ActivityContentState"] = boost::any(*activityContentState);
    }
    if (activityEvent) {
      res["ActivityEvent"] = boost::any(*activityEvent);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (deliveryType) {
      res["DeliveryType"] = boost::any(*deliveryType);
    }
    if (dismissalDate) {
      res["DismissalDate"] = boost::any(*dismissalDate);
    }
    if (expiredSeconds) {
      res["ExpiredSeconds"] = boost::any(*expiredSeconds);
    }
    if (extendedParams) {
      res["ExtendedParams"] = boost::any(*extendedParams);
    }
    if (miChannelId) {
      res["MiChannelId"] = boost::any(*miChannelId);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (pushAction) {
      res["PushAction"] = boost::any(*pushAction);
    }
    if (silent) {
      res["Silent"] = boost::any(*silent);
    }
    if (smsSignName) {
      res["SmsSignName"] = boost::any(*smsSignName);
    }
    if (smsStrategy) {
      res["SmsStrategy"] = boost::any(*smsStrategy);
    }
    if (smsTemplateCode) {
      res["SmsTemplateCode"] = boost::any(*smsTemplateCode);
    }
    if (smsTemplateParam) {
      res["SmsTemplateParam"] = boost::any(*smsTemplateParam);
    }
    if (strategyContent) {
      res["StrategyContent"] = boost::any(*strategyContent);
    }
    if (strategyType) {
      res["StrategyType"] = boost::any(*strategyType);
    }
    if (targetMsgkey) {
      res["TargetMsgkey"] = boost::any(*targetMsgkey);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (templateKeyValue) {
      res["TemplateKeyValue"] = boost::any(*templateKeyValue);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (thirdChannelCategoryShrink) {
      res["ThirdChannelCategory"] = boost::any(*thirdChannelCategoryShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityContentState") != m.end() && !m["ActivityContentState"].empty()) {
      activityContentState = make_shared<boost::any>(boost::any_cast<boost::any>(m["ActivityContentState"]));
    }
    if (m.find("ActivityEvent") != m.end() && !m["ActivityEvent"].empty()) {
      activityEvent = make_shared<string>(boost::any_cast<string>(m["ActivityEvent"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classification = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("DeliveryType") != m.end() && !m["DeliveryType"].empty()) {
      deliveryType = make_shared<long>(boost::any_cast<long>(m["DeliveryType"]));
    }
    if (m.find("DismissalDate") != m.end() && !m["DismissalDate"].empty()) {
      dismissalDate = make_shared<long>(boost::any_cast<long>(m["DismissalDate"]));
    }
    if (m.find("ExpiredSeconds") != m.end() && !m["ExpiredSeconds"].empty()) {
      expiredSeconds = make_shared<long>(boost::any_cast<long>(m["ExpiredSeconds"]));
    }
    if (m.find("ExtendedParams") != m.end() && !m["ExtendedParams"].empty()) {
      extendedParams = make_shared<string>(boost::any_cast<string>(m["ExtendedParams"]));
    }
    if (m.find("MiChannelId") != m.end() && !m["MiChannelId"].empty()) {
      miChannelId = make_shared<string>(boost::any_cast<string>(m["MiChannelId"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
    if (m.find("PushAction") != m.end() && !m["PushAction"].empty()) {
      pushAction = make_shared<long>(boost::any_cast<long>(m["PushAction"]));
    }
    if (m.find("Silent") != m.end() && !m["Silent"].empty()) {
      silent = make_shared<long>(boost::any_cast<long>(m["Silent"]));
    }
    if (m.find("SmsSignName") != m.end() && !m["SmsSignName"].empty()) {
      smsSignName = make_shared<string>(boost::any_cast<string>(m["SmsSignName"]));
    }
    if (m.find("SmsStrategy") != m.end() && !m["SmsStrategy"].empty()) {
      smsStrategy = make_shared<long>(boost::any_cast<long>(m["SmsStrategy"]));
    }
    if (m.find("SmsTemplateCode") != m.end() && !m["SmsTemplateCode"].empty()) {
      smsTemplateCode = make_shared<string>(boost::any_cast<string>(m["SmsTemplateCode"]));
    }
    if (m.find("SmsTemplateParam") != m.end() && !m["SmsTemplateParam"].empty()) {
      smsTemplateParam = make_shared<string>(boost::any_cast<string>(m["SmsTemplateParam"]));
    }
    if (m.find("StrategyContent") != m.end() && !m["StrategyContent"].empty()) {
      strategyContent = make_shared<string>(boost::any_cast<string>(m["StrategyContent"]));
    }
    if (m.find("StrategyType") != m.end() && !m["StrategyType"].empty()) {
      strategyType = make_shared<long>(boost::any_cast<long>(m["StrategyType"]));
    }
    if (m.find("TargetMsgkey") != m.end() && !m["TargetMsgkey"].empty()) {
      targetMsgkey = make_shared<string>(boost::any_cast<string>(m["TargetMsgkey"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TemplateKeyValue") != m.end() && !m["TemplateKeyValue"].empty()) {
      templateKeyValue = make_shared<string>(boost::any_cast<string>(m["TemplateKeyValue"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("ThirdChannelCategory") != m.end() && !m["ThirdChannelCategory"].empty()) {
      thirdChannelCategoryShrink = make_shared<string>(boost::any_cast<string>(m["ThirdChannelCategory"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~PushTemplateShrinkRequest() = default;
};
class PushTemplateResponseBodyPushResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  PushTemplateResponseBodyPushResult() {}

  explicit PushTemplateResponseBodyPushResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PushTemplateResponseBodyPushResult() = default;
};
class PushTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<PushTemplateResponseBodyPushResult> pushResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  PushTemplateResponseBody() {}

  explicit PushTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pushResult) {
      res["PushResult"] = pushResult ? boost::any(pushResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PushResult") != m.end() && !m["PushResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PushResult"].type()) {
        PushTemplateResponseBodyPushResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PushResult"]));
        pushResult = make_shared<PushTemplateResponseBodyPushResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~PushTemplateResponseBody() = default;
};
class PushTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PushTemplateResponseBody> body{};

  PushTemplateResponse() {}

  explicit PushTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PushTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PushTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~PushTemplateResponse() = default;
};
class PushUnBindRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> deliveryToken{};
  shared_ptr<string> userId{};
  shared_ptr<string> workspaceId{};

  PushUnBindRequest() {}

  explicit PushUnBindRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (deliveryToken) {
      res["DeliveryToken"] = boost::any(*deliveryToken);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DeliveryToken") != m.end() && !m["DeliveryToken"].empty()) {
      deliveryToken = make_shared<string>(boost::any_cast<string>(m["DeliveryToken"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~PushUnBindRequest() = default;
};
class PushUnBindResponseBodyPushResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  PushUnBindResponseBodyPushResult() {}

  explicit PushUnBindResponseBodyPushResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PushUnBindResponseBodyPushResult() = default;
};
class PushUnBindResponseBody : public Darabonba::Model {
public:
  shared_ptr<PushUnBindResponseBodyPushResult> pushResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  PushUnBindResponseBody() {}

  explicit PushUnBindResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pushResult) {
      res["PushResult"] = pushResult ? boost::any(pushResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PushResult") != m.end() && !m["PushResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PushResult"].type()) {
        PushUnBindResponseBodyPushResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PushResult"]));
        pushResult = make_shared<PushUnBindResponseBodyPushResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~PushUnBindResponseBody() = default;
};
class PushUnBindResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PushUnBindResponseBody> body{};

  PushUnBindResponse() {}

  explicit PushUnBindResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PushUnBindResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PushUnBindResponseBody>(model1);
      }
    }
  }


  virtual ~PushUnBindResponse() = default;
};
class QueryInfoFromMdpRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mobile{};
  shared_ptr<string> mobileMd5{};
  shared_ptr<string> mobileSha256{};
  shared_ptr<string> riskScene{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  QueryInfoFromMdpRequest() {}

  explicit QueryInfoFromMdpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (mobileMd5) {
      res["MobileMd5"] = boost::any(*mobileMd5);
    }
    if (mobileSha256) {
      res["MobileSha256"] = boost::any(*mobileSha256);
    }
    if (riskScene) {
      res["RiskScene"] = boost::any(*riskScene);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("MobileMd5") != m.end() && !m["MobileMd5"].empty()) {
      mobileMd5 = make_shared<string>(boost::any_cast<string>(m["MobileMd5"]));
    }
    if (m.find("MobileSha256") != m.end() && !m["MobileSha256"].empty()) {
      mobileSha256 = make_shared<string>(boost::any_cast<string>(m["MobileSha256"]));
    }
    if (m.find("RiskScene") != m.end() && !m["RiskScene"].empty()) {
      riskScene = make_shared<string>(boost::any_cast<string>(m["RiskScene"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~QueryInfoFromMdpRequest() = default;
};
class QueryInfoFromMdpResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  QueryInfoFromMdpResponseBody() {}

  explicit QueryInfoFromMdpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<long>(boost::any_cast<long>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryInfoFromMdpResponseBody() = default;
};
class QueryInfoFromMdpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryInfoFromMdpResponseBody> body{};

  QueryInfoFromMdpResponse() {}

  explicit QueryInfoFromMdpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryInfoFromMdpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryInfoFromMdpResponseBody>(model1);
      }
    }
  }


  virtual ~QueryInfoFromMdpResponse() = default;
};
class QueryMappCenterAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> workspaceId{};

  QueryMappCenterAppRequest() {}

  explicit QueryMappCenterAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~QueryMappCenterAppRequest() = default;
};
class QueryMappCenterAppResponseBodyQueryMappCenterAppResultMappCenterAppAndroidConfig : public Darabonba::Model {
public:
  shared_ptr<string> certRSA{};
  shared_ptr<string> packageName{};

  QueryMappCenterAppResponseBodyQueryMappCenterAppResultMappCenterAppAndroidConfig() {}

  explicit QueryMappCenterAppResponseBodyQueryMappCenterAppResultMappCenterAppAndroidConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certRSA) {
      res["CertRSA"] = boost::any(*certRSA);
    }
    if (packageName) {
      res["PackageName"] = boost::any(*packageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertRSA") != m.end() && !m["CertRSA"].empty()) {
      certRSA = make_shared<string>(boost::any_cast<string>(m["CertRSA"]));
    }
    if (m.find("PackageName") != m.end() && !m["PackageName"].empty()) {
      packageName = make_shared<string>(boost::any_cast<string>(m["PackageName"]));
    }
  }


  virtual ~QueryMappCenterAppResponseBodyQueryMappCenterAppResultMappCenterAppAndroidConfig() = default;
};
class QueryMappCenterAppResponseBodyQueryMappCenterAppResultMappCenterAppIosConfig : public Darabonba::Model {
public:
  shared_ptr<string> bundleId{};

  QueryMappCenterAppResponseBodyQueryMappCenterAppResultMappCenterAppIosConfig() {}

  explicit QueryMappCenterAppResponseBodyQueryMappCenterAppResultMappCenterAppIosConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bundleId) {
      res["BundleId"] = boost::any(*bundleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BundleId") != m.end() && !m["BundleId"].empty()) {
      bundleId = make_shared<string>(boost::any_cast<string>(m["BundleId"]));
    }
  }


  virtual ~QueryMappCenterAppResponseBodyQueryMappCenterAppResultMappCenterAppIosConfig() = default;
};
class QueryMappCenterAppResponseBodyQueryMappCenterAppResultMappCenterApp : public Darabonba::Model {
public:
  shared_ptr<QueryMappCenterAppResponseBodyQueryMappCenterAppResultMappCenterAppAndroidConfig> androidConfig{};
  shared_ptr<string> appDesc{};
  shared_ptr<string> appIcon{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> appSecret{};
  shared_ptr<string> creator{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<QueryMappCenterAppResponseBodyQueryMappCenterAppResultMappCenterAppIosConfig> iosConfig{};
  shared_ptr<string> modifier{};
  shared_ptr<string> monitorJson{};
  shared_ptr<long> status{};
  shared_ptr<string> tenantId{};
  shared_ptr<long> type{};

  QueryMappCenterAppResponseBodyQueryMappCenterAppResultMappCenterApp() {}

  explicit QueryMappCenterAppResponseBodyQueryMappCenterAppResultMappCenterApp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (androidConfig) {
      res["AndroidConfig"] = androidConfig ? boost::any(androidConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (appDesc) {
      res["AppDesc"] = boost::any(*appDesc);
    }
    if (appIcon) {
      res["AppIcon"] = boost::any(*appIcon);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appSecret) {
      res["AppSecret"] = boost::any(*appSecret);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (iosConfig) {
      res["IosConfig"] = iosConfig ? boost::any(iosConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modifier) {
      res["Modifier"] = boost::any(*modifier);
    }
    if (monitorJson) {
      res["MonitorJson"] = boost::any(*monitorJson);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AndroidConfig") != m.end() && !m["AndroidConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AndroidConfig"].type()) {
        QueryMappCenterAppResponseBodyQueryMappCenterAppResultMappCenterAppAndroidConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AndroidConfig"]));
        androidConfig = make_shared<QueryMappCenterAppResponseBodyQueryMappCenterAppResultMappCenterAppAndroidConfig>(model1);
      }
    }
    if (m.find("AppDesc") != m.end() && !m["AppDesc"].empty()) {
      appDesc = make_shared<string>(boost::any_cast<string>(m["AppDesc"]));
    }
    if (m.find("AppIcon") != m.end() && !m["AppIcon"].empty()) {
      appIcon = make_shared<string>(boost::any_cast<string>(m["AppIcon"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppSecret") != m.end() && !m["AppSecret"].empty()) {
      appSecret = make_shared<string>(boost::any_cast<string>(m["AppSecret"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IosConfig") != m.end() && !m["IosConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IosConfig"].type()) {
        QueryMappCenterAppResponseBodyQueryMappCenterAppResultMappCenterAppIosConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IosConfig"]));
        iosConfig = make_shared<QueryMappCenterAppResponseBodyQueryMappCenterAppResultMappCenterAppIosConfig>(model1);
      }
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["Modifier"]));
    }
    if (m.find("MonitorJson") != m.end() && !m["MonitorJson"].empty()) {
      monitorJson = make_shared<string>(boost::any_cast<string>(m["MonitorJson"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryMappCenterAppResponseBodyQueryMappCenterAppResultMappCenterApp() = default;
};
class QueryMappCenterAppResponseBodyQueryMappCenterAppResult : public Darabonba::Model {
public:
  shared_ptr<QueryMappCenterAppResponseBodyQueryMappCenterAppResultMappCenterApp> mappCenterApp{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  QueryMappCenterAppResponseBodyQueryMappCenterAppResult() {}

  explicit QueryMappCenterAppResponseBodyQueryMappCenterAppResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mappCenterApp) {
      res["MappCenterApp"] = mappCenterApp ? boost::any(mappCenterApp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MappCenterApp") != m.end() && !m["MappCenterApp"].empty()) {
      if (typeid(map<string, boost::any>) == m["MappCenterApp"].type()) {
        QueryMappCenterAppResponseBodyQueryMappCenterAppResultMappCenterApp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MappCenterApp"]));
        mappCenterApp = make_shared<QueryMappCenterAppResponseBodyQueryMappCenterAppResultMappCenterApp>(model1);
      }
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryMappCenterAppResponseBodyQueryMappCenterAppResult() = default;
};
class QueryMappCenterAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMappCenterAppResponseBodyQueryMappCenterAppResult> queryMappCenterAppResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  QueryMappCenterAppResponseBody() {}

  explicit QueryMappCenterAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (queryMappCenterAppResult) {
      res["QueryMappCenterAppResult"] = queryMappCenterAppResult ? boost::any(queryMappCenterAppResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QueryMappCenterAppResult") != m.end() && !m["QueryMappCenterAppResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueryMappCenterAppResult"].type()) {
        QueryMappCenterAppResponseBodyQueryMappCenterAppResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QueryMappCenterAppResult"]));
        queryMappCenterAppResult = make_shared<QueryMappCenterAppResponseBodyQueryMappCenterAppResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~QueryMappCenterAppResponseBody() = default;
};
class QueryMappCenterAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMappCenterAppResponseBody> body{};

  QueryMappCenterAppResponse() {}

  explicit QueryMappCenterAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMappCenterAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMappCenterAppResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMappCenterAppResponse() = default;
};
class QueryMcdpAimRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> id{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  QueryMcdpAimRequest() {}

  explicit QueryMcdpAimRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~QueryMcdpAimRequest() = default;
};
class QueryMcdpAimResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  QueryMcdpAimResponseBodyResultContent() {}

  explicit QueryMcdpAimResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryMcdpAimResponseBodyResultContent() = default;
};
class QueryMcdpAimResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<QueryMcdpAimResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  QueryMcdpAimResponseBody() {}

  explicit QueryMcdpAimResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        QueryMcdpAimResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<QueryMcdpAimResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~QueryMcdpAimResponseBody() = default;
};
class QueryMcdpAimResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMcdpAimResponseBody> body{};

  QueryMcdpAimResponse() {}

  explicit QueryMcdpAimResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMcdpAimResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMcdpAimResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMcdpAimResponse() = default;
};
class QueryMcdpZoneRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> id{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  QueryMcdpZoneRequest() {}

  explicit QueryMcdpZoneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~QueryMcdpZoneRequest() = default;
};
class QueryMcdpZoneResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  QueryMcdpZoneResponseBodyResultContent() {}

  explicit QueryMcdpZoneResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryMcdpZoneResponseBodyResultContent() = default;
};
class QueryMcdpZoneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<QueryMcdpZoneResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  QueryMcdpZoneResponseBody() {}

  explicit QueryMcdpZoneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        QueryMcdpZoneResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<QueryMcdpZoneResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~QueryMcdpZoneResponseBody() = default;
};
class QueryMcdpZoneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMcdpZoneResponseBody> body{};

  QueryMcdpZoneResponse() {}

  explicit QueryMcdpZoneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMcdpZoneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMcdpZoneResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMcdpZoneResponse() = default;
};
class QueryMcubeMiniPackageRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> h5Id{};
  shared_ptr<string> id{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  QueryMcubeMiniPackageRequest() {}

  explicit QueryMcubeMiniPackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (h5Id) {
      res["H5Id"] = boost::any(*h5Id);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("H5Id") != m.end() && !m["H5Id"].empty()) {
      h5Id = make_shared<string>(boost::any_cast<string>(m["H5Id"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~QueryMcubeMiniPackageRequest() = default;
};
class QueryMcubeMiniPackageResponseBodyQueryMiniPackageResultMiniPackageInfo : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<long> autoInstall{};
  shared_ptr<string> clientVersionMax{};
  shared_ptr<string> clientVersionMin{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> extendInfo{};
  shared_ptr<string> extraData{};
  shared_ptr<string> fallbackBaseUrl{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> h5Id{};
  shared_ptr<string> h5Name{};
  shared_ptr<string> h5Version{};
  shared_ptr<long> id{};
  shared_ptr<long> installType{};
  shared_ptr<string> mainUrl{};
  shared_ptr<string> memo{};
  shared_ptr<long> packageType{};
  shared_ptr<string> platform{};
  shared_ptr<long> publishPeriod{};
  shared_ptr<long> resourceType{};
  shared_ptr<long> status{};

  QueryMcubeMiniPackageResponseBodyQueryMiniPackageResultMiniPackageInfo() {}

  explicit QueryMcubeMiniPackageResponseBodyQueryMiniPackageResultMiniPackageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (autoInstall) {
      res["AutoInstall"] = boost::any(*autoInstall);
    }
    if (clientVersionMax) {
      res["ClientVersionMax"] = boost::any(*clientVersionMax);
    }
    if (clientVersionMin) {
      res["ClientVersionMin"] = boost::any(*clientVersionMin);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (extraData) {
      res["ExtraData"] = boost::any(*extraData);
    }
    if (fallbackBaseUrl) {
      res["FallbackBaseUrl"] = boost::any(*fallbackBaseUrl);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (h5Id) {
      res["H5Id"] = boost::any(*h5Id);
    }
    if (h5Name) {
      res["H5Name"] = boost::any(*h5Name);
    }
    if (h5Version) {
      res["H5Version"] = boost::any(*h5Version);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (installType) {
      res["InstallType"] = boost::any(*installType);
    }
    if (mainUrl) {
      res["MainUrl"] = boost::any(*mainUrl);
    }
    if (memo) {
      res["Memo"] = boost::any(*memo);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (publishPeriod) {
      res["PublishPeriod"] = boost::any(*publishPeriod);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("AutoInstall") != m.end() && !m["AutoInstall"].empty()) {
      autoInstall = make_shared<long>(boost::any_cast<long>(m["AutoInstall"]));
    }
    if (m.find("ClientVersionMax") != m.end() && !m["ClientVersionMax"].empty()) {
      clientVersionMax = make_shared<string>(boost::any_cast<string>(m["ClientVersionMax"]));
    }
    if (m.find("ClientVersionMin") != m.end() && !m["ClientVersionMin"].empty()) {
      clientVersionMin = make_shared<string>(boost::any_cast<string>(m["ClientVersionMin"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      extendInfo = make_shared<string>(boost::any_cast<string>(m["ExtendInfo"]));
    }
    if (m.find("ExtraData") != m.end() && !m["ExtraData"].empty()) {
      extraData = make_shared<string>(boost::any_cast<string>(m["ExtraData"]));
    }
    if (m.find("FallbackBaseUrl") != m.end() && !m["FallbackBaseUrl"].empty()) {
      fallbackBaseUrl = make_shared<string>(boost::any_cast<string>(m["FallbackBaseUrl"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("H5Id") != m.end() && !m["H5Id"].empty()) {
      h5Id = make_shared<string>(boost::any_cast<string>(m["H5Id"]));
    }
    if (m.find("H5Name") != m.end() && !m["H5Name"].empty()) {
      h5Name = make_shared<string>(boost::any_cast<string>(m["H5Name"]));
    }
    if (m.find("H5Version") != m.end() && !m["H5Version"].empty()) {
      h5Version = make_shared<string>(boost::any_cast<string>(m["H5Version"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstallType") != m.end() && !m["InstallType"].empty()) {
      installType = make_shared<long>(boost::any_cast<long>(m["InstallType"]));
    }
    if (m.find("MainUrl") != m.end() && !m["MainUrl"].empty()) {
      mainUrl = make_shared<string>(boost::any_cast<string>(m["MainUrl"]));
    }
    if (m.find("Memo") != m.end() && !m["Memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["Memo"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<long>(boost::any_cast<long>(m["PackageType"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("PublishPeriod") != m.end() && !m["PublishPeriod"].empty()) {
      publishPeriod = make_shared<long>(boost::any_cast<long>(m["PublishPeriod"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<long>(boost::any_cast<long>(m["ResourceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~QueryMcubeMiniPackageResponseBodyQueryMiniPackageResultMiniPackageInfo() = default;
};
class QueryMcubeMiniPackageResponseBodyQueryMiniPackageResult : public Darabonba::Model {
public:
  shared_ptr<QueryMcubeMiniPackageResponseBodyQueryMiniPackageResultMiniPackageInfo> miniPackageInfo{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  QueryMcubeMiniPackageResponseBodyQueryMiniPackageResult() {}

  explicit QueryMcubeMiniPackageResponseBodyQueryMiniPackageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (miniPackageInfo) {
      res["MiniPackageInfo"] = miniPackageInfo ? boost::any(miniPackageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MiniPackageInfo") != m.end() && !m["MiniPackageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MiniPackageInfo"].type()) {
        QueryMcubeMiniPackageResponseBodyQueryMiniPackageResultMiniPackageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MiniPackageInfo"]));
        miniPackageInfo = make_shared<QueryMcubeMiniPackageResponseBodyQueryMiniPackageResultMiniPackageInfo>(model1);
      }
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryMcubeMiniPackageResponseBodyQueryMiniPackageResult() = default;
};
class QueryMcubeMiniPackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMcubeMiniPackageResponseBodyQueryMiniPackageResult> queryMiniPackageResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  QueryMcubeMiniPackageResponseBody() {}

  explicit QueryMcubeMiniPackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (queryMiniPackageResult) {
      res["QueryMiniPackageResult"] = queryMiniPackageResult ? boost::any(queryMiniPackageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QueryMiniPackageResult") != m.end() && !m["QueryMiniPackageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueryMiniPackageResult"].type()) {
        QueryMcubeMiniPackageResponseBodyQueryMiniPackageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QueryMiniPackageResult"]));
        queryMiniPackageResult = make_shared<QueryMcubeMiniPackageResponseBodyQueryMiniPackageResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~QueryMcubeMiniPackageResponseBody() = default;
};
class QueryMcubeMiniPackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMcubeMiniPackageResponseBody> body{};

  QueryMcubeMiniPackageResponse() {}

  explicit QueryMcubeMiniPackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMcubeMiniPackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMcubeMiniPackageResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMcubeMiniPackageResponse() = default;
};
class QueryMcubeMiniTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> taskId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  QueryMcubeMiniTaskRequest() {}

  explicit QueryMcubeMiniTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~QueryMcubeMiniTaskRequest() = default;
};
class QueryMcubeMiniTaskResponseBodyQueryMiniTaskResultMiniTaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> greyConfigInfo{};
  shared_ptr<string> greyEndtime{};
  shared_ptr<string> greyEndtimeData{};
  shared_ptr<long> greyNum{};
  shared_ptr<long> id{};
  shared_ptr<string> memo{};
  shared_ptr<long> packageId{};
  shared_ptr<string> platform{};
  shared_ptr<string> productVersion{};
  shared_ptr<long> publishMode{};
  shared_ptr<long> publishType{};
  shared_ptr<string> status{};
  shared_ptr<long> taskStatus{};
  shared_ptr<string> whitelistIds{};

  QueryMcubeMiniTaskResponseBodyQueryMiniTaskResultMiniTaskInfo() {}

  explicit QueryMcubeMiniTaskResponseBodyQueryMiniTaskResultMiniTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (greyConfigInfo) {
      res["GreyConfigInfo"] = boost::any(*greyConfigInfo);
    }
    if (greyEndtime) {
      res["GreyEndtime"] = boost::any(*greyEndtime);
    }
    if (greyEndtimeData) {
      res["GreyEndtimeData"] = boost::any(*greyEndtimeData);
    }
    if (greyNum) {
      res["GreyNum"] = boost::any(*greyNum);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (memo) {
      res["Memo"] = boost::any(*memo);
    }
    if (packageId) {
      res["PackageId"] = boost::any(*packageId);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (productVersion) {
      res["ProductVersion"] = boost::any(*productVersion);
    }
    if (publishMode) {
      res["PublishMode"] = boost::any(*publishMode);
    }
    if (publishType) {
      res["PublishType"] = boost::any(*publishType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (whitelistIds) {
      res["WhitelistIds"] = boost::any(*whitelistIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GreyConfigInfo") != m.end() && !m["GreyConfigInfo"].empty()) {
      greyConfigInfo = make_shared<string>(boost::any_cast<string>(m["GreyConfigInfo"]));
    }
    if (m.find("GreyEndtime") != m.end() && !m["GreyEndtime"].empty()) {
      greyEndtime = make_shared<string>(boost::any_cast<string>(m["GreyEndtime"]));
    }
    if (m.find("GreyEndtimeData") != m.end() && !m["GreyEndtimeData"].empty()) {
      greyEndtimeData = make_shared<string>(boost::any_cast<string>(m["GreyEndtimeData"]));
    }
    if (m.find("GreyNum") != m.end() && !m["GreyNum"].empty()) {
      greyNum = make_shared<long>(boost::any_cast<long>(m["GreyNum"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Memo") != m.end() && !m["Memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["Memo"]));
    }
    if (m.find("PackageId") != m.end() && !m["PackageId"].empty()) {
      packageId = make_shared<long>(boost::any_cast<long>(m["PackageId"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("ProductVersion") != m.end() && !m["ProductVersion"].empty()) {
      productVersion = make_shared<string>(boost::any_cast<string>(m["ProductVersion"]));
    }
    if (m.find("PublishMode") != m.end() && !m["PublishMode"].empty()) {
      publishMode = make_shared<long>(boost::any_cast<long>(m["PublishMode"]));
    }
    if (m.find("PublishType") != m.end() && !m["PublishType"].empty()) {
      publishType = make_shared<long>(boost::any_cast<long>(m["PublishType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<long>(boost::any_cast<long>(m["TaskStatus"]));
    }
    if (m.find("WhitelistIds") != m.end() && !m["WhitelistIds"].empty()) {
      whitelistIds = make_shared<string>(boost::any_cast<string>(m["WhitelistIds"]));
    }
  }


  virtual ~QueryMcubeMiniTaskResponseBodyQueryMiniTaskResultMiniTaskInfo() = default;
};
class QueryMcubeMiniTaskResponseBodyQueryMiniTaskResult : public Darabonba::Model {
public:
  shared_ptr<QueryMcubeMiniTaskResponseBodyQueryMiniTaskResultMiniTaskInfo> miniTaskInfo{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  QueryMcubeMiniTaskResponseBodyQueryMiniTaskResult() {}

  explicit QueryMcubeMiniTaskResponseBodyQueryMiniTaskResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (miniTaskInfo) {
      res["MiniTaskInfo"] = miniTaskInfo ? boost::any(miniTaskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MiniTaskInfo") != m.end() && !m["MiniTaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MiniTaskInfo"].type()) {
        QueryMcubeMiniTaskResponseBodyQueryMiniTaskResultMiniTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MiniTaskInfo"]));
        miniTaskInfo = make_shared<QueryMcubeMiniTaskResponseBodyQueryMiniTaskResultMiniTaskInfo>(model1);
      }
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryMcubeMiniTaskResponseBodyQueryMiniTaskResult() = default;
};
class QueryMcubeMiniTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMcubeMiniTaskResponseBodyQueryMiniTaskResult> queryMiniTaskResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  QueryMcubeMiniTaskResponseBody() {}

  explicit QueryMcubeMiniTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (queryMiniTaskResult) {
      res["QueryMiniTaskResult"] = queryMiniTaskResult ? boost::any(queryMiniTaskResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QueryMiniTaskResult") != m.end() && !m["QueryMiniTaskResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueryMiniTaskResult"].type()) {
        QueryMcubeMiniTaskResponseBodyQueryMiniTaskResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QueryMiniTaskResult"]));
        queryMiniTaskResult = make_shared<QueryMcubeMiniTaskResponseBodyQueryMiniTaskResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~QueryMcubeMiniTaskResponseBody() = default;
};
class QueryMcubeMiniTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMcubeMiniTaskResponseBody> body{};

  QueryMcubeMiniTaskResponse() {}

  explicit QueryMcubeMiniTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMcubeMiniTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMcubeMiniTaskResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMcubeMiniTaskResponse() = default;
};
class QueryMcubeVhostRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  QueryMcubeVhostRequest() {}

  explicit QueryMcubeVhostRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~QueryMcubeVhostRequest() = default;
};
class QueryMcubeVhostResponseBodyQueryVhostResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  QueryMcubeVhostResponseBodyQueryVhostResult() {}

  explicit QueryMcubeVhostResponseBodyQueryVhostResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryMcubeVhostResponseBodyQueryVhostResult() = default;
};
class QueryMcubeVhostResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMcubeVhostResponseBodyQueryVhostResult> queryVhostResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  QueryMcubeVhostResponseBody() {}

  explicit QueryMcubeVhostResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (queryVhostResult) {
      res["QueryVhostResult"] = queryVhostResult ? boost::any(queryVhostResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QueryVhostResult") != m.end() && !m["QueryVhostResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueryVhostResult"].type()) {
        QueryMcubeVhostResponseBodyQueryVhostResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QueryVhostResult"]));
        queryVhostResult = make_shared<QueryMcubeVhostResponseBodyQueryVhostResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~QueryMcubeVhostResponseBody() = default;
};
class QueryMcubeVhostResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMcubeVhostResponseBody> body{};

  QueryMcubeVhostResponse() {}

  explicit QueryMcubeVhostResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMcubeVhostResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMcubeVhostResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMcubeVhostResponse() = default;
};
class QueryMdsUpgradeTaskDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> taskId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  QueryMdsUpgradeTaskDetailRequest() {}

  explicit QueryMdsUpgradeTaskDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~QueryMdsUpgradeTaskDetailRequest() = default;
};
class QueryMdsUpgradeTaskDetailResponseBodyResultContentDataContentRuleJsonList : public Darabonba::Model {
public:
  shared_ptr<string> operation{};
  shared_ptr<string> ruleElement{};
  shared_ptr<string> ruleType{};
  shared_ptr<string> value{};

  QueryMdsUpgradeTaskDetailResponseBodyResultContentDataContentRuleJsonList() {}

  explicit QueryMdsUpgradeTaskDetailResponseBodyResultContentDataContentRuleJsonList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (ruleElement) {
      res["RuleElement"] = boost::any(*ruleElement);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("RuleElement") != m.end() && !m["RuleElement"].empty()) {
      ruleElement = make_shared<string>(boost::any_cast<string>(m["RuleElement"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryMdsUpgradeTaskDetailResponseBodyResultContentDataContentRuleJsonList() = default;
};
class QueryMdsUpgradeTaskDetailResponseBodyResultContentDataContentWhitelist : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<string> business{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> idType{};
  shared_ptr<string> platform{};
  shared_ptr<long> status{};
  shared_ptr<long> whiteListCount{};
  shared_ptr<string> whiteListName{};

  QueryMdsUpgradeTaskDetailResponseBodyResultContentDataContentWhitelist() {}

  explicit QueryMdsUpgradeTaskDetailResponseBodyResultContentDataContentWhitelist(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (business) {
      res["Business"] = boost::any(*business);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (idType) {
      res["IdType"] = boost::any(*idType);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (whiteListCount) {
      res["WhiteListCount"] = boost::any(*whiteListCount);
    }
    if (whiteListName) {
      res["WhiteListName"] = boost::any(*whiteListName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("Business") != m.end() && !m["Business"].empty()) {
      business = make_shared<string>(boost::any_cast<string>(m["Business"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IdType") != m.end() && !m["IdType"].empty()) {
      idType = make_shared<string>(boost::any_cast<string>(m["IdType"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("WhiteListCount") != m.end() && !m["WhiteListCount"].empty()) {
      whiteListCount = make_shared<long>(boost::any_cast<long>(m["WhiteListCount"]));
    }
    if (m.find("WhiteListName") != m.end() && !m["WhiteListName"].empty()) {
      whiteListName = make_shared<string>(boost::any_cast<string>(m["WhiteListName"]));
    }
  }


  virtual ~QueryMdsUpgradeTaskDetailResponseBodyResultContentDataContentWhitelist() = default;
};
class QueryMdsUpgradeTaskDetailResponseBodyResultContentDataContent : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<string> appId{};
  shared_ptr<string> appstoreurl{};
  shared_ptr<string> channelContains{};
  shared_ptr<string> channelExcludes{};
  shared_ptr<string> cityContains{};
  shared_ptr<string> cityExcludes{};
  shared_ptr<string> creator{};
  shared_ptr<long> deviceGreyNum{};
  shared_ptr<long> devicePercent{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<long> executionOrder{};
  shared_ptr<string> gmtCreateStr{};
  shared_ptr<string> greyConfigInfo{};
  shared_ptr<string> greyEndtimeData{};
  shared_ptr<long> greyNotice{};
  shared_ptr<long> greyNum{};
  shared_ptr<long> greyUv{};
  shared_ptr<long> id{};
  shared_ptr<string> innerVersion{};
  shared_ptr<long> isEnterprise{};
  shared_ptr<long> isOfficial{};
  shared_ptr<long> isPush{};
  shared_ptr<long> isRc{};
  shared_ptr<long> isRelease{};
  shared_ptr<string> memo{};
  shared_ptr<string> mobileModelContains{};
  shared_ptr<string> mobileModelExcludes{};
  shared_ptr<string> modifier{};
  shared_ptr<string> netType{};
  shared_ptr<string> osVersion{};
  shared_ptr<long> packageInfoId{};
  shared_ptr<string> packageType{};
  shared_ptr<string> platform{};
  shared_ptr<string> productId{};
  shared_ptr<string> productVersion{};
  shared_ptr<long> publishMode{};
  shared_ptr<long> publishType{};
  shared_ptr<string> pushContent{};
  shared_ptr<string> qrcodeUrl{};
  shared_ptr<string> releaseType{};
  shared_ptr<vector<QueryMdsUpgradeTaskDetailResponseBodyResultContentDataContentRuleJsonList>> ruleJsonList{};
  shared_ptr<long> silentType{};
  shared_ptr<string> syncMode{};
  shared_ptr<string> syncResult{};
  shared_ptr<long> taskStatus{};
  shared_ptr<string> upgradeContent{};
  shared_ptr<long> upgradeType{};
  shared_ptr<long> upgradeValidTime{};
  shared_ptr<vector<QueryMdsUpgradeTaskDetailResponseBodyResultContentDataContentWhitelist>> whitelist{};
  shared_ptr<string> whitelistIds{};

  QueryMdsUpgradeTaskDetailResponseBodyResultContentDataContent() {}

  explicit QueryMdsUpgradeTaskDetailResponseBodyResultContentDataContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appstoreurl) {
      res["Appstoreurl"] = boost::any(*appstoreurl);
    }
    if (channelContains) {
      res["ChannelContains"] = boost::any(*channelContains);
    }
    if (channelExcludes) {
      res["ChannelExcludes"] = boost::any(*channelExcludes);
    }
    if (cityContains) {
      res["CityContains"] = boost::any(*cityContains);
    }
    if (cityExcludes) {
      res["CityExcludes"] = boost::any(*cityExcludes);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (deviceGreyNum) {
      res["DeviceGreyNum"] = boost::any(*deviceGreyNum);
    }
    if (devicePercent) {
      res["DevicePercent"] = boost::any(*devicePercent);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (executionOrder) {
      res["ExecutionOrder"] = boost::any(*executionOrder);
    }
    if (gmtCreateStr) {
      res["GmtCreateStr"] = boost::any(*gmtCreateStr);
    }
    if (greyConfigInfo) {
      res["GreyConfigInfo"] = boost::any(*greyConfigInfo);
    }
    if (greyEndtimeData) {
      res["GreyEndtimeData"] = boost::any(*greyEndtimeData);
    }
    if (greyNotice) {
      res["GreyNotice"] = boost::any(*greyNotice);
    }
    if (greyNum) {
      res["GreyNum"] = boost::any(*greyNum);
    }
    if (greyUv) {
      res["GreyUv"] = boost::any(*greyUv);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (innerVersion) {
      res["InnerVersion"] = boost::any(*innerVersion);
    }
    if (isEnterprise) {
      res["IsEnterprise"] = boost::any(*isEnterprise);
    }
    if (isOfficial) {
      res["IsOfficial"] = boost::any(*isOfficial);
    }
    if (isPush) {
      res["IsPush"] = boost::any(*isPush);
    }
    if (isRc) {
      res["IsRc"] = boost::any(*isRc);
    }
    if (isRelease) {
      res["IsRelease"] = boost::any(*isRelease);
    }
    if (memo) {
      res["Memo"] = boost::any(*memo);
    }
    if (mobileModelContains) {
      res["MobileModelContains"] = boost::any(*mobileModelContains);
    }
    if (mobileModelExcludes) {
      res["MobileModelExcludes"] = boost::any(*mobileModelExcludes);
    }
    if (modifier) {
      res["Modifier"] = boost::any(*modifier);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (osVersion) {
      res["OsVersion"] = boost::any(*osVersion);
    }
    if (packageInfoId) {
      res["PackageInfoId"] = boost::any(*packageInfoId);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (productId) {
      res["ProductId"] = boost::any(*productId);
    }
    if (productVersion) {
      res["ProductVersion"] = boost::any(*productVersion);
    }
    if (publishMode) {
      res["PublishMode"] = boost::any(*publishMode);
    }
    if (publishType) {
      res["PublishType"] = boost::any(*publishType);
    }
    if (pushContent) {
      res["PushContent"] = boost::any(*pushContent);
    }
    if (qrcodeUrl) {
      res["QrcodeUrl"] = boost::any(*qrcodeUrl);
    }
    if (releaseType) {
      res["ReleaseType"] = boost::any(*releaseType);
    }
    if (ruleJsonList) {
      vector<boost::any> temp1;
      for(auto item1:*ruleJsonList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleJsonList"] = boost::any(temp1);
    }
    if (silentType) {
      res["SilentType"] = boost::any(*silentType);
    }
    if (syncMode) {
      res["SyncMode"] = boost::any(*syncMode);
    }
    if (syncResult) {
      res["SyncResult"] = boost::any(*syncResult);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (upgradeContent) {
      res["UpgradeContent"] = boost::any(*upgradeContent);
    }
    if (upgradeType) {
      res["UpgradeType"] = boost::any(*upgradeType);
    }
    if (upgradeValidTime) {
      res["UpgradeValidTime"] = boost::any(*upgradeValidTime);
    }
    if (whitelist) {
      vector<boost::any> temp1;
      for(auto item1:*whitelist){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Whitelist"] = boost::any(temp1);
    }
    if (whitelistIds) {
      res["WhitelistIds"] = boost::any(*whitelistIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Appstoreurl") != m.end() && !m["Appstoreurl"].empty()) {
      appstoreurl = make_shared<string>(boost::any_cast<string>(m["Appstoreurl"]));
    }
    if (m.find("ChannelContains") != m.end() && !m["ChannelContains"].empty()) {
      channelContains = make_shared<string>(boost::any_cast<string>(m["ChannelContains"]));
    }
    if (m.find("ChannelExcludes") != m.end() && !m["ChannelExcludes"].empty()) {
      channelExcludes = make_shared<string>(boost::any_cast<string>(m["ChannelExcludes"]));
    }
    if (m.find("CityContains") != m.end() && !m["CityContains"].empty()) {
      cityContains = make_shared<string>(boost::any_cast<string>(m["CityContains"]));
    }
    if (m.find("CityExcludes") != m.end() && !m["CityExcludes"].empty()) {
      cityExcludes = make_shared<string>(boost::any_cast<string>(m["CityExcludes"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("DeviceGreyNum") != m.end() && !m["DeviceGreyNum"].empty()) {
      deviceGreyNum = make_shared<long>(boost::any_cast<long>(m["DeviceGreyNum"]));
    }
    if (m.find("DevicePercent") != m.end() && !m["DevicePercent"].empty()) {
      devicePercent = make_shared<long>(boost::any_cast<long>(m["DevicePercent"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("ExecutionOrder") != m.end() && !m["ExecutionOrder"].empty()) {
      executionOrder = make_shared<long>(boost::any_cast<long>(m["ExecutionOrder"]));
    }
    if (m.find("GmtCreateStr") != m.end() && !m["GmtCreateStr"].empty()) {
      gmtCreateStr = make_shared<string>(boost::any_cast<string>(m["GmtCreateStr"]));
    }
    if (m.find("GreyConfigInfo") != m.end() && !m["GreyConfigInfo"].empty()) {
      greyConfigInfo = make_shared<string>(boost::any_cast<string>(m["GreyConfigInfo"]));
    }
    if (m.find("GreyEndtimeData") != m.end() && !m["GreyEndtimeData"].empty()) {
      greyEndtimeData = make_shared<string>(boost::any_cast<string>(m["GreyEndtimeData"]));
    }
    if (m.find("GreyNotice") != m.end() && !m["GreyNotice"].empty()) {
      greyNotice = make_shared<long>(boost::any_cast<long>(m["GreyNotice"]));
    }
    if (m.find("GreyNum") != m.end() && !m["GreyNum"].empty()) {
      greyNum = make_shared<long>(boost::any_cast<long>(m["GreyNum"]));
    }
    if (m.find("GreyUv") != m.end() && !m["GreyUv"].empty()) {
      greyUv = make_shared<long>(boost::any_cast<long>(m["GreyUv"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InnerVersion") != m.end() && !m["InnerVersion"].empty()) {
      innerVersion = make_shared<string>(boost::any_cast<string>(m["InnerVersion"]));
    }
    if (m.find("IsEnterprise") != m.end() && !m["IsEnterprise"].empty()) {
      isEnterprise = make_shared<long>(boost::any_cast<long>(m["IsEnterprise"]));
    }
    if (m.find("IsOfficial") != m.end() && !m["IsOfficial"].empty()) {
      isOfficial = make_shared<long>(boost::any_cast<long>(m["IsOfficial"]));
    }
    if (m.find("IsPush") != m.end() && !m["IsPush"].empty()) {
      isPush = make_shared<long>(boost::any_cast<long>(m["IsPush"]));
    }
    if (m.find("IsRc") != m.end() && !m["IsRc"].empty()) {
      isRc = make_shared<long>(boost::any_cast<long>(m["IsRc"]));
    }
    if (m.find("IsRelease") != m.end() && !m["IsRelease"].empty()) {
      isRelease = make_shared<long>(boost::any_cast<long>(m["IsRelease"]));
    }
    if (m.find("Memo") != m.end() && !m["Memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["Memo"]));
    }
    if (m.find("MobileModelContains") != m.end() && !m["MobileModelContains"].empty()) {
      mobileModelContains = make_shared<string>(boost::any_cast<string>(m["MobileModelContains"]));
    }
    if (m.find("MobileModelExcludes") != m.end() && !m["MobileModelExcludes"].empty()) {
      mobileModelExcludes = make_shared<string>(boost::any_cast<string>(m["MobileModelExcludes"]));
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["Modifier"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("OsVersion") != m.end() && !m["OsVersion"].empty()) {
      osVersion = make_shared<string>(boost::any_cast<string>(m["OsVersion"]));
    }
    if (m.find("PackageInfoId") != m.end() && !m["PackageInfoId"].empty()) {
      packageInfoId = make_shared<long>(boost::any_cast<long>(m["PackageInfoId"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("ProductId") != m.end() && !m["ProductId"].empty()) {
      productId = make_shared<string>(boost::any_cast<string>(m["ProductId"]));
    }
    if (m.find("ProductVersion") != m.end() && !m["ProductVersion"].empty()) {
      productVersion = make_shared<string>(boost::any_cast<string>(m["ProductVersion"]));
    }
    if (m.find("PublishMode") != m.end() && !m["PublishMode"].empty()) {
      publishMode = make_shared<long>(boost::any_cast<long>(m["PublishMode"]));
    }
    if (m.find("PublishType") != m.end() && !m["PublishType"].empty()) {
      publishType = make_shared<long>(boost::any_cast<long>(m["PublishType"]));
    }
    if (m.find("PushContent") != m.end() && !m["PushContent"].empty()) {
      pushContent = make_shared<string>(boost::any_cast<string>(m["PushContent"]));
    }
    if (m.find("QrcodeUrl") != m.end() && !m["QrcodeUrl"].empty()) {
      qrcodeUrl = make_shared<string>(boost::any_cast<string>(m["QrcodeUrl"]));
    }
    if (m.find("ReleaseType") != m.end() && !m["ReleaseType"].empty()) {
      releaseType = make_shared<string>(boost::any_cast<string>(m["ReleaseType"]));
    }
    if (m.find("RuleJsonList") != m.end() && !m["RuleJsonList"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleJsonList"].type()) {
        vector<QueryMdsUpgradeTaskDetailResponseBodyResultContentDataContentRuleJsonList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleJsonList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMdsUpgradeTaskDetailResponseBodyResultContentDataContentRuleJsonList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleJsonList = make_shared<vector<QueryMdsUpgradeTaskDetailResponseBodyResultContentDataContentRuleJsonList>>(expect1);
      }
    }
    if (m.find("SilentType") != m.end() && !m["SilentType"].empty()) {
      silentType = make_shared<long>(boost::any_cast<long>(m["SilentType"]));
    }
    if (m.find("SyncMode") != m.end() && !m["SyncMode"].empty()) {
      syncMode = make_shared<string>(boost::any_cast<string>(m["SyncMode"]));
    }
    if (m.find("SyncResult") != m.end() && !m["SyncResult"].empty()) {
      syncResult = make_shared<string>(boost::any_cast<string>(m["SyncResult"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<long>(boost::any_cast<long>(m["TaskStatus"]));
    }
    if (m.find("UpgradeContent") != m.end() && !m["UpgradeContent"].empty()) {
      upgradeContent = make_shared<string>(boost::any_cast<string>(m["UpgradeContent"]));
    }
    if (m.find("UpgradeType") != m.end() && !m["UpgradeType"].empty()) {
      upgradeType = make_shared<long>(boost::any_cast<long>(m["UpgradeType"]));
    }
    if (m.find("UpgradeValidTime") != m.end() && !m["UpgradeValidTime"].empty()) {
      upgradeValidTime = make_shared<long>(boost::any_cast<long>(m["UpgradeValidTime"]));
    }
    if (m.find("Whitelist") != m.end() && !m["Whitelist"].empty()) {
      if (typeid(vector<boost::any>) == m["Whitelist"].type()) {
        vector<QueryMdsUpgradeTaskDetailResponseBodyResultContentDataContentWhitelist> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Whitelist"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMdsUpgradeTaskDetailResponseBodyResultContentDataContentWhitelist model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        whitelist = make_shared<vector<QueryMdsUpgradeTaskDetailResponseBodyResultContentDataContentWhitelist>>(expect1);
      }
    }
    if (m.find("WhitelistIds") != m.end() && !m["WhitelistIds"].empty()) {
      whitelistIds = make_shared<string>(boost::any_cast<string>(m["WhitelistIds"]));
    }
  }


  virtual ~QueryMdsUpgradeTaskDetailResponseBodyResultContentDataContent() = default;
};
class QueryMdsUpgradeTaskDetailResponseBodyResultContentData : public Darabonba::Model {
public:
  shared_ptr<QueryMdsUpgradeTaskDetailResponseBodyResultContentDataContent> content{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  QueryMdsUpgradeTaskDetailResponseBodyResultContentData() {}

  explicit QueryMdsUpgradeTaskDetailResponseBodyResultContentData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        QueryMdsUpgradeTaskDetailResponseBodyResultContentDataContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<QueryMdsUpgradeTaskDetailResponseBodyResultContentDataContent>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryMdsUpgradeTaskDetailResponseBodyResultContentData() = default;
};
class QueryMdsUpgradeTaskDetailResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<QueryMdsUpgradeTaskDetailResponseBodyResultContentData> data{};
  shared_ptr<string> requestId{};

  QueryMdsUpgradeTaskDetailResponseBodyResultContent() {}

  explicit QueryMdsUpgradeTaskDetailResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryMdsUpgradeTaskDetailResponseBodyResultContentData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryMdsUpgradeTaskDetailResponseBodyResultContentData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMdsUpgradeTaskDetailResponseBodyResultContent() = default;
};
class QueryMdsUpgradeTaskDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<QueryMdsUpgradeTaskDetailResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  QueryMdsUpgradeTaskDetailResponseBody() {}

  explicit QueryMdsUpgradeTaskDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        QueryMdsUpgradeTaskDetailResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<QueryMdsUpgradeTaskDetailResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~QueryMdsUpgradeTaskDetailResponseBody() = default;
};
class QueryMdsUpgradeTaskDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMdsUpgradeTaskDetailResponseBody> body{};

  QueryMdsUpgradeTaskDetailResponse() {}

  explicit QueryMdsUpgradeTaskDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMdsUpgradeTaskDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMdsUpgradeTaskDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMdsUpgradeTaskDetailResponse() = default;
};
class QueryMgsApipageRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiStatus{};
  shared_ptr<string> apiType{};
  shared_ptr<string> appId{};
  shared_ptr<string> format{};
  shared_ptr<string> host{};
  shared_ptr<string> needEncrypt{};
  shared_ptr<string> needEtag{};
  shared_ptr<string> needSign{};
  shared_ptr<string> operationType{};
  shared_ptr<string> optFuzzy{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> sysId{};
  shared_ptr<string> sysName{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  QueryMgsApipageRequest() {}

  explicit QueryMgsApipageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiStatus) {
      res["ApiStatus"] = boost::any(*apiStatus);
    }
    if (apiType) {
      res["ApiType"] = boost::any(*apiType);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (needEncrypt) {
      res["NeedEncrypt"] = boost::any(*needEncrypt);
    }
    if (needEtag) {
      res["NeedEtag"] = boost::any(*needEtag);
    }
    if (needSign) {
      res["NeedSign"] = boost::any(*needSign);
    }
    if (operationType) {
      res["OperationType"] = boost::any(*operationType);
    }
    if (optFuzzy) {
      res["OptFuzzy"] = boost::any(*optFuzzy);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sysId) {
      res["SysId"] = boost::any(*sysId);
    }
    if (sysName) {
      res["SysName"] = boost::any(*sysName);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiStatus") != m.end() && !m["ApiStatus"].empty()) {
      apiStatus = make_shared<string>(boost::any_cast<string>(m["ApiStatus"]));
    }
    if (m.find("ApiType") != m.end() && !m["ApiType"].empty()) {
      apiType = make_shared<string>(boost::any_cast<string>(m["ApiType"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("NeedEncrypt") != m.end() && !m["NeedEncrypt"].empty()) {
      needEncrypt = make_shared<string>(boost::any_cast<string>(m["NeedEncrypt"]));
    }
    if (m.find("NeedEtag") != m.end() && !m["NeedEtag"].empty()) {
      needEtag = make_shared<string>(boost::any_cast<string>(m["NeedEtag"]));
    }
    if (m.find("NeedSign") != m.end() && !m["NeedSign"].empty()) {
      needSign = make_shared<string>(boost::any_cast<string>(m["NeedSign"]));
    }
    if (m.find("OperationType") != m.end() && !m["OperationType"].empty()) {
      operationType = make_shared<string>(boost::any_cast<string>(m["OperationType"]));
    }
    if (m.find("OptFuzzy") != m.end() && !m["OptFuzzy"].empty()) {
      optFuzzy = make_shared<string>(boost::any_cast<string>(m["OptFuzzy"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SysId") != m.end() && !m["SysId"].empty()) {
      sysId = make_shared<long>(boost::any_cast<long>(m["SysId"]));
    }
    if (m.find("SysName") != m.end() && !m["SysName"].empty()) {
      sysName = make_shared<string>(boost::any_cast<string>(m["SysName"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~QueryMgsApipageRequest() = default;
};
class QueryMgsApipageResponseBodyResultContentListApiInvokerHttpInvoker : public Darabonba::Model {
public:
  shared_ptr<string> charset{};
  shared_ptr<string> contentType{};
  shared_ptr<string> host{};
  shared_ptr<string> method{};
  shared_ptr<string> path{};

  QueryMgsApipageResponseBodyResultContentListApiInvokerHttpInvoker() {}

  explicit QueryMgsApipageResponseBodyResultContentListApiInvokerHttpInvoker(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charset) {
      res["Charset"] = boost::any(*charset);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Charset") != m.end() && !m["Charset"].empty()) {
      charset = make_shared<string>(boost::any_cast<string>(m["Charset"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~QueryMgsApipageResponseBodyResultContentListApiInvokerHttpInvoker() = default;
};
class QueryMgsApipageResponseBodyResultContentListApiInvoker : public Darabonba::Model {
public:
  shared_ptr<QueryMgsApipageResponseBodyResultContentListApiInvokerHttpInvoker> httpInvoker{};
  shared_ptr<string> rpcInvoker{};

  QueryMgsApipageResponseBodyResultContentListApiInvoker() {}

  explicit QueryMgsApipageResponseBodyResultContentListApiInvoker(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpInvoker) {
      res["HttpInvoker"] = httpInvoker ? boost::any(httpInvoker->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rpcInvoker) {
      res["RpcInvoker"] = boost::any(*rpcInvoker);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpInvoker") != m.end() && !m["HttpInvoker"].empty()) {
      if (typeid(map<string, boost::any>) == m["HttpInvoker"].type()) {
        QueryMgsApipageResponseBodyResultContentListApiInvokerHttpInvoker model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HttpInvoker"]));
        httpInvoker = make_shared<QueryMgsApipageResponseBodyResultContentListApiInvokerHttpInvoker>(model1);
      }
    }
    if (m.find("RpcInvoker") != m.end() && !m["RpcInvoker"].empty()) {
      rpcInvoker = make_shared<string>(boost::any_cast<string>(m["RpcInvoker"]));
    }
  }


  virtual ~QueryMgsApipageResponseBodyResultContentListApiInvoker() = default;
};
class QueryMgsApipageResponseBodyResultContentListCacheRule : public Darabonba::Model {
public:
  shared_ptr<string> cacheKey{};
  shared_ptr<bool> needCache{};
  shared_ptr<long> ttl{};

  QueryMgsApipageResponseBodyResultContentListCacheRule() {}

  explicit QueryMgsApipageResponseBodyResultContentListCacheRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cacheKey) {
      res["CacheKey"] = boost::any(*cacheKey);
    }
    if (needCache) {
      res["NeedCache"] = boost::any(*needCache);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CacheKey") != m.end() && !m["CacheKey"].empty()) {
      cacheKey = make_shared<string>(boost::any_cast<string>(m["CacheKey"]));
    }
    if (m.find("NeedCache") != m.end() && !m["NeedCache"].empty()) {
      needCache = make_shared<bool>(boost::any_cast<bool>(m["NeedCache"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
  }


  virtual ~QueryMgsApipageResponseBodyResultContentListCacheRule() = default;
};
class QueryMgsApipageResponseBodyResultContentListCircuitBreakerRule : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> defaultResponse{};
  shared_ptr<long> errorThreshold{};
  shared_ptr<long> id{};
  shared_ptr<string> model{};
  shared_ptr<long> openTimeoutSeconds{};
  shared_ptr<double> slowRatioThreshold{};
  shared_ptr<string> switchStatus{};
  shared_ptr<long> windowsInSeconds{};
  shared_ptr<string> workspaceId{};

  QueryMgsApipageResponseBodyResultContentListCircuitBreakerRule() {}

  explicit QueryMgsApipageResponseBodyResultContentListCircuitBreakerRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (defaultResponse) {
      res["DefaultResponse"] = boost::any(*defaultResponse);
    }
    if (errorThreshold) {
      res["ErrorThreshold"] = boost::any(*errorThreshold);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (openTimeoutSeconds) {
      res["OpenTimeoutSeconds"] = boost::any(*openTimeoutSeconds);
    }
    if (slowRatioThreshold) {
      res["SlowRatioThreshold"] = boost::any(*slowRatioThreshold);
    }
    if (switchStatus) {
      res["SwitchStatus"] = boost::any(*switchStatus);
    }
    if (windowsInSeconds) {
      res["WindowsInSeconds"] = boost::any(*windowsInSeconds);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DefaultResponse") != m.end() && !m["DefaultResponse"].empty()) {
      defaultResponse = make_shared<string>(boost::any_cast<string>(m["DefaultResponse"]));
    }
    if (m.find("ErrorThreshold") != m.end() && !m["ErrorThreshold"].empty()) {
      errorThreshold = make_shared<long>(boost::any_cast<long>(m["ErrorThreshold"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("OpenTimeoutSeconds") != m.end() && !m["OpenTimeoutSeconds"].empty()) {
      openTimeoutSeconds = make_shared<long>(boost::any_cast<long>(m["OpenTimeoutSeconds"]));
    }
    if (m.find("SlowRatioThreshold") != m.end() && !m["SlowRatioThreshold"].empty()) {
      slowRatioThreshold = make_shared<double>(boost::any_cast<double>(m["SlowRatioThreshold"]));
    }
    if (m.find("SwitchStatus") != m.end() && !m["SwitchStatus"].empty()) {
      switchStatus = make_shared<string>(boost::any_cast<string>(m["SwitchStatus"]));
    }
    if (m.find("WindowsInSeconds") != m.end() && !m["WindowsInSeconds"].empty()) {
      windowsInSeconds = make_shared<long>(boost::any_cast<long>(m["WindowsInSeconds"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~QueryMgsApipageResponseBodyResultContentListCircuitBreakerRule() = default;
};
class QueryMgsApipageResponseBodyResultContentListHeaderRule : public Darabonba::Model {
public:
  shared_ptr<string> headerKey{};
  shared_ptr<string> location{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  QueryMgsApipageResponseBodyResultContentListHeaderRule() {}

  explicit QueryMgsApipageResponseBodyResultContentListHeaderRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerKey) {
      res["HeaderKey"] = boost::any(*headerKey);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeaderKey") != m.end() && !m["HeaderKey"].empty()) {
      headerKey = make_shared<string>(boost::any_cast<string>(m["HeaderKey"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryMgsApipageResponseBodyResultContentListHeaderRule() = default;
};
class QueryMgsApipageResponseBodyResultContentListHeaderRules : public Darabonba::Model {
public:
  shared_ptr<string> headerKey{};
  shared_ptr<string> location{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  QueryMgsApipageResponseBodyResultContentListHeaderRules() {}

  explicit QueryMgsApipageResponseBodyResultContentListHeaderRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerKey) {
      res["HeaderKey"] = boost::any(*headerKey);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeaderKey") != m.end() && !m["HeaderKey"].empty()) {
      headerKey = make_shared<string>(boost::any_cast<string>(m["HeaderKey"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryMgsApipageResponseBodyResultContentListHeaderRules() = default;
};
class QueryMgsApipageResponseBodyResultContentListLimitRule : public Darabonba::Model {
public:
  shared_ptr<string> defaultResponse{};
  shared_ptr<string> i18nResponse{};
  shared_ptr<long> interval{};
  shared_ptr<long> limit{};
  shared_ptr<string> mode{};

  QueryMgsApipageResponseBodyResultContentListLimitRule() {}

  explicit QueryMgsApipageResponseBodyResultContentListLimitRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultResponse) {
      res["DefaultResponse"] = boost::any(*defaultResponse);
    }
    if (i18nResponse) {
      res["I18nResponse"] = boost::any(*i18nResponse);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultResponse") != m.end() && !m["DefaultResponse"].empty()) {
      defaultResponse = make_shared<string>(boost::any_cast<string>(m["DefaultResponse"]));
    }
    if (m.find("I18nResponse") != m.end() && !m["I18nResponse"].empty()) {
      i18nResponse = make_shared<string>(boost::any_cast<string>(m["I18nResponse"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
  }


  virtual ~QueryMgsApipageResponseBodyResultContentListLimitRule() = default;
};
class QueryMgsApipageResponseBodyResultContentListMigrateRule : public Darabonba::Model {
public:
  shared_ptr<long> flowPercent{};
  shared_ptr<bool> needMigrate{};
  shared_ptr<bool> needSwitchCompletely{};
  shared_ptr<long> sysId{};
  shared_ptr<string> sysName{};
  shared_ptr<string> upstreamType{};

  QueryMgsApipageResponseBodyResultContentListMigrateRule() {}

  explicit QueryMgsApipageResponseBodyResultContentListMigrateRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowPercent) {
      res["FlowPercent"] = boost::any(*flowPercent);
    }
    if (needMigrate) {
      res["NeedMigrate"] = boost::any(*needMigrate);
    }
    if (needSwitchCompletely) {
      res["NeedSwitchCompletely"] = boost::any(*needSwitchCompletely);
    }
    if (sysId) {
      res["SysId"] = boost::any(*sysId);
    }
    if (sysName) {
      res["SysName"] = boost::any(*sysName);
    }
    if (upstreamType) {
      res["UpstreamType"] = boost::any(*upstreamType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowPercent") != m.end() && !m["FlowPercent"].empty()) {
      flowPercent = make_shared<long>(boost::any_cast<long>(m["FlowPercent"]));
    }
    if (m.find("NeedMigrate") != m.end() && !m["NeedMigrate"].empty()) {
      needMigrate = make_shared<bool>(boost::any_cast<bool>(m["NeedMigrate"]));
    }
    if (m.find("NeedSwitchCompletely") != m.end() && !m["NeedSwitchCompletely"].empty()) {
      needSwitchCompletely = make_shared<bool>(boost::any_cast<bool>(m["NeedSwitchCompletely"]));
    }
    if (m.find("SysId") != m.end() && !m["SysId"].empty()) {
      sysId = make_shared<long>(boost::any_cast<long>(m["SysId"]));
    }
    if (m.find("SysName") != m.end() && !m["SysName"].empty()) {
      sysName = make_shared<string>(boost::any_cast<string>(m["SysName"]));
    }
    if (m.find("UpstreamType") != m.end() && !m["UpstreamType"].empty()) {
      upstreamType = make_shared<string>(boost::any_cast<string>(m["UpstreamType"]));
    }
  }


  virtual ~QueryMgsApipageResponseBodyResultContentListMigrateRule() = default;
};
class QueryMgsApipageResponseBodyResultContentListMockRule : public Darabonba::Model {
public:
  shared_ptr<string> mockData{};
  shared_ptr<bool> needMock{};
  shared_ptr<long> percentage{};
  shared_ptr<string> type{};

  QueryMgsApipageResponseBodyResultContentListMockRule() {}

  explicit QueryMgsApipageResponseBodyResultContentListMockRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mockData) {
      res["MockData"] = boost::any(*mockData);
    }
    if (needMock) {
      res["NeedMock"] = boost::any(*needMock);
    }
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MockData") != m.end() && !m["MockData"].empty()) {
      mockData = make_shared<string>(boost::any_cast<string>(m["MockData"]));
    }
    if (m.find("NeedMock") != m.end() && !m["NeedMock"].empty()) {
      needMock = make_shared<bool>(boost::any_cast<bool>(m["NeedMock"]));
    }
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryMgsApipageResponseBodyResultContentListMockRule() = default;
};
class QueryMgsApipageResponseBodyResultContentListRequestParams : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> appId{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> location{};
  shared_ptr<string> name{};
  shared_ptr<string> refType{};
  shared_ptr<string> type{};
  shared_ptr<string> workspaceId{};

  QueryMgsApipageResponseBodyResultContentListRequestParams() {}

  explicit QueryMgsApipageResponseBodyResultContentListRequestParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (refType) {
      res["RefType"] = boost::any(*refType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RefType") != m.end() && !m["RefType"].empty()) {
      refType = make_shared<string>(boost::any_cast<string>(m["RefType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~QueryMgsApipageResponseBodyResultContentListRequestParams() = default;
};
class QueryMgsApipageResponseBodyResultContentList : public Darabonba::Model {
public:
  shared_ptr<QueryMgsApipageResponseBodyResultContentListApiInvoker> apiInvoker{};
  shared_ptr<string> apiName{};
  shared_ptr<string> apiStatus{};
  shared_ptr<string> apiType{};
  shared_ptr<string> appId{};
  shared_ptr<string> authRuleName{};
  shared_ptr<QueryMgsApipageResponseBodyResultContentListCacheRule> cacheRule{};
  shared_ptr<string> charset{};
  shared_ptr<QueryMgsApipageResponseBodyResultContentListCircuitBreakerRule> circuitBreakerRule{};
  shared_ptr<string> contentType{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<vector<QueryMgsApipageResponseBodyResultContentListHeaderRule>> headerRule{};
  shared_ptr<vector<QueryMgsApipageResponseBodyResultContentListHeaderRules>> headerRules{};
  shared_ptr<string> host{};
  shared_ptr<long> id{};
  shared_ptr<string> interfaceType{};
  shared_ptr<QueryMgsApipageResponseBodyResultContentListLimitRule> limitRule{};
  shared_ptr<string> method{};
  shared_ptr<string> methodName{};
  shared_ptr<QueryMgsApipageResponseBodyResultContentListMigrateRule> migrateRule{};
  shared_ptr<QueryMgsApipageResponseBodyResultContentListMockRule> mockRule{};
  shared_ptr<string> needETag{};
  shared_ptr<string> needEncrypt{};
  shared_ptr<string> needJsonp{};
  shared_ptr<string> needSign{};
  shared_ptr<string> operationType{};
  shared_ptr<string> paramGetMethod{};
  shared_ptr<string> path{};
  shared_ptr<string> requestBodyModel{};
  shared_ptr<vector<QueryMgsApipageResponseBodyResultContentListRequestParams>> requestParams{};
  shared_ptr<string> responseBodyModel{};
  shared_ptr<long> sysId{};
  shared_ptr<string> sysName{};
  shared_ptr<string> timeout{};
  shared_ptr<string> workspaceId{};

  QueryMgsApipageResponseBodyResultContentList() {}

  explicit QueryMgsApipageResponseBodyResultContentList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInvoker) {
      res["ApiInvoker"] = apiInvoker ? boost::any(apiInvoker->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (apiStatus) {
      res["ApiStatus"] = boost::any(*apiStatus);
    }
    if (apiType) {
      res["ApiType"] = boost::any(*apiType);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (authRuleName) {
      res["AuthRuleName"] = boost::any(*authRuleName);
    }
    if (cacheRule) {
      res["CacheRule"] = cacheRule ? boost::any(cacheRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (charset) {
      res["Charset"] = boost::any(*charset);
    }
    if (circuitBreakerRule) {
      res["CircuitBreakerRule"] = circuitBreakerRule ? boost::any(circuitBreakerRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (headerRule) {
      vector<boost::any> temp1;
      for(auto item1:*headerRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HeaderRule"] = boost::any(temp1);
    }
    if (headerRules) {
      vector<boost::any> temp1;
      for(auto item1:*headerRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HeaderRules"] = boost::any(temp1);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (interfaceType) {
      res["InterfaceType"] = boost::any(*interfaceType);
    }
    if (limitRule) {
      res["LimitRule"] = limitRule ? boost::any(limitRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (migrateRule) {
      res["MigrateRule"] = migrateRule ? boost::any(migrateRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mockRule) {
      res["MockRule"] = mockRule ? boost::any(mockRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (needETag) {
      res["NeedETag"] = boost::any(*needETag);
    }
    if (needEncrypt) {
      res["NeedEncrypt"] = boost::any(*needEncrypt);
    }
    if (needJsonp) {
      res["NeedJsonp"] = boost::any(*needJsonp);
    }
    if (needSign) {
      res["NeedSign"] = boost::any(*needSign);
    }
    if (operationType) {
      res["OperationType"] = boost::any(*operationType);
    }
    if (paramGetMethod) {
      res["ParamGetMethod"] = boost::any(*paramGetMethod);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (requestBodyModel) {
      res["RequestBodyModel"] = boost::any(*requestBodyModel);
    }
    if (requestParams) {
      vector<boost::any> temp1;
      for(auto item1:*requestParams){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParams"] = boost::any(temp1);
    }
    if (responseBodyModel) {
      res["ResponseBodyModel"] = boost::any(*responseBodyModel);
    }
    if (sysId) {
      res["SysId"] = boost::any(*sysId);
    }
    if (sysName) {
      res["SysName"] = boost::any(*sysName);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInvoker") != m.end() && !m["ApiInvoker"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiInvoker"].type()) {
        QueryMgsApipageResponseBodyResultContentListApiInvoker model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiInvoker"]));
        apiInvoker = make_shared<QueryMgsApipageResponseBodyResultContentListApiInvoker>(model1);
      }
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("ApiStatus") != m.end() && !m["ApiStatus"].empty()) {
      apiStatus = make_shared<string>(boost::any_cast<string>(m["ApiStatus"]));
    }
    if (m.find("ApiType") != m.end() && !m["ApiType"].empty()) {
      apiType = make_shared<string>(boost::any_cast<string>(m["ApiType"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AuthRuleName") != m.end() && !m["AuthRuleName"].empty()) {
      authRuleName = make_shared<string>(boost::any_cast<string>(m["AuthRuleName"]));
    }
    if (m.find("CacheRule") != m.end() && !m["CacheRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["CacheRule"].type()) {
        QueryMgsApipageResponseBodyResultContentListCacheRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CacheRule"]));
        cacheRule = make_shared<QueryMgsApipageResponseBodyResultContentListCacheRule>(model1);
      }
    }
    if (m.find("Charset") != m.end() && !m["Charset"].empty()) {
      charset = make_shared<string>(boost::any_cast<string>(m["Charset"]));
    }
    if (m.find("CircuitBreakerRule") != m.end() && !m["CircuitBreakerRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["CircuitBreakerRule"].type()) {
        QueryMgsApipageResponseBodyResultContentListCircuitBreakerRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CircuitBreakerRule"]));
        circuitBreakerRule = make_shared<QueryMgsApipageResponseBodyResultContentListCircuitBreakerRule>(model1);
      }
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("HeaderRule") != m.end() && !m["HeaderRule"].empty()) {
      if (typeid(vector<boost::any>) == m["HeaderRule"].type()) {
        vector<QueryMgsApipageResponseBodyResultContentListHeaderRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HeaderRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMgsApipageResponseBodyResultContentListHeaderRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        headerRule = make_shared<vector<QueryMgsApipageResponseBodyResultContentListHeaderRule>>(expect1);
      }
    }
    if (m.find("HeaderRules") != m.end() && !m["HeaderRules"].empty()) {
      if (typeid(vector<boost::any>) == m["HeaderRules"].type()) {
        vector<QueryMgsApipageResponseBodyResultContentListHeaderRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HeaderRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMgsApipageResponseBodyResultContentListHeaderRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        headerRules = make_shared<vector<QueryMgsApipageResponseBodyResultContentListHeaderRules>>(expect1);
      }
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InterfaceType") != m.end() && !m["InterfaceType"].empty()) {
      interfaceType = make_shared<string>(boost::any_cast<string>(m["InterfaceType"]));
    }
    if (m.find("LimitRule") != m.end() && !m["LimitRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["LimitRule"].type()) {
        QueryMgsApipageResponseBodyResultContentListLimitRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LimitRule"]));
        limitRule = make_shared<QueryMgsApipageResponseBodyResultContentListLimitRule>(model1);
      }
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("MigrateRule") != m.end() && !m["MigrateRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["MigrateRule"].type()) {
        QueryMgsApipageResponseBodyResultContentListMigrateRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MigrateRule"]));
        migrateRule = make_shared<QueryMgsApipageResponseBodyResultContentListMigrateRule>(model1);
      }
    }
    if (m.find("MockRule") != m.end() && !m["MockRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["MockRule"].type()) {
        QueryMgsApipageResponseBodyResultContentListMockRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MockRule"]));
        mockRule = make_shared<QueryMgsApipageResponseBodyResultContentListMockRule>(model1);
      }
    }
    if (m.find("NeedETag") != m.end() && !m["NeedETag"].empty()) {
      needETag = make_shared<string>(boost::any_cast<string>(m["NeedETag"]));
    }
    if (m.find("NeedEncrypt") != m.end() && !m["NeedEncrypt"].empty()) {
      needEncrypt = make_shared<string>(boost::any_cast<string>(m["NeedEncrypt"]));
    }
    if (m.find("NeedJsonp") != m.end() && !m["NeedJsonp"].empty()) {
      needJsonp = make_shared<string>(boost::any_cast<string>(m["NeedJsonp"]));
    }
    if (m.find("NeedSign") != m.end() && !m["NeedSign"].empty()) {
      needSign = make_shared<string>(boost::any_cast<string>(m["NeedSign"]));
    }
    if (m.find("OperationType") != m.end() && !m["OperationType"].empty()) {
      operationType = make_shared<string>(boost::any_cast<string>(m["OperationType"]));
    }
    if (m.find("ParamGetMethod") != m.end() && !m["ParamGetMethod"].empty()) {
      paramGetMethod = make_shared<string>(boost::any_cast<string>(m["ParamGetMethod"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("RequestBodyModel") != m.end() && !m["RequestBodyModel"].empty()) {
      requestBodyModel = make_shared<string>(boost::any_cast<string>(m["RequestBodyModel"]));
    }
    if (m.find("RequestParams") != m.end() && !m["RequestParams"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParams"].type()) {
        vector<QueryMgsApipageResponseBodyResultContentListRequestParams> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParams"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMgsApipageResponseBodyResultContentListRequestParams model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParams = make_shared<vector<QueryMgsApipageResponseBodyResultContentListRequestParams>>(expect1);
      }
    }
    if (m.find("ResponseBodyModel") != m.end() && !m["ResponseBodyModel"].empty()) {
      responseBodyModel = make_shared<string>(boost::any_cast<string>(m["ResponseBodyModel"]));
    }
    if (m.find("SysId") != m.end() && !m["SysId"].empty()) {
      sysId = make_shared<long>(boost::any_cast<long>(m["SysId"]));
    }
    if (m.find("SysName") != m.end() && !m["SysName"].empty()) {
      sysName = make_shared<string>(boost::any_cast<string>(m["SysName"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<string>(boost::any_cast<string>(m["Timeout"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~QueryMgsApipageResponseBodyResultContentList() = default;
};
class QueryMgsApipageResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<long> current{};
  shared_ptr<vector<QueryMgsApipageResponseBodyResultContentList>> list{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QueryMgsApipageResponseBodyResultContent() {}

  explicit QueryMgsApipageResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<QueryMgsApipageResponseBodyResultContentList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMgsApipageResponseBodyResultContentList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<QueryMgsApipageResponseBodyResultContentList>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryMgsApipageResponseBodyResultContent() = default;
};
class QueryMgsApipageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<QueryMgsApipageResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  QueryMgsApipageResponseBody() {}

  explicit QueryMgsApipageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        QueryMgsApipageResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<QueryMgsApipageResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~QueryMgsApipageResponseBody() = default;
};
class QueryMgsApipageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMgsApipageResponseBody> body{};

  QueryMgsApipageResponse() {}

  explicit QueryMgsApipageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMgsApipageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMgsApipageResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMgsApipageResponse() = default;
};
class QueryMgsApirestRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> format{};
  shared_ptr<long> id{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> type{};
  shared_ptr<string> workspaceId{};

  QueryMgsApirestRequest() {}

  explicit QueryMgsApirestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~QueryMgsApirestRequest() = default;
};
class QueryMgsApirestResponseBodyResultContentValueApiInvokerHttpInvoker : public Darabonba::Model {
public:
  shared_ptr<string> charset{};
  shared_ptr<string> contentType{};
  shared_ptr<string> host{};
  shared_ptr<string> method{};
  shared_ptr<string> path{};

  QueryMgsApirestResponseBodyResultContentValueApiInvokerHttpInvoker() {}

  explicit QueryMgsApirestResponseBodyResultContentValueApiInvokerHttpInvoker(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charset) {
      res["Charset"] = boost::any(*charset);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Charset") != m.end() && !m["Charset"].empty()) {
      charset = make_shared<string>(boost::any_cast<string>(m["Charset"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~QueryMgsApirestResponseBodyResultContentValueApiInvokerHttpInvoker() = default;
};
class QueryMgsApirestResponseBodyResultContentValueApiInvoker : public Darabonba::Model {
public:
  shared_ptr<QueryMgsApirestResponseBodyResultContentValueApiInvokerHttpInvoker> httpInvoker{};
  shared_ptr<string> rpcInvoker{};

  QueryMgsApirestResponseBodyResultContentValueApiInvoker() {}

  explicit QueryMgsApirestResponseBodyResultContentValueApiInvoker(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpInvoker) {
      res["HttpInvoker"] = httpInvoker ? boost::any(httpInvoker->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rpcInvoker) {
      res["RpcInvoker"] = boost::any(*rpcInvoker);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpInvoker") != m.end() && !m["HttpInvoker"].empty()) {
      if (typeid(map<string, boost::any>) == m["HttpInvoker"].type()) {
        QueryMgsApirestResponseBodyResultContentValueApiInvokerHttpInvoker model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HttpInvoker"]));
        httpInvoker = make_shared<QueryMgsApirestResponseBodyResultContentValueApiInvokerHttpInvoker>(model1);
      }
    }
    if (m.find("RpcInvoker") != m.end() && !m["RpcInvoker"].empty()) {
      rpcInvoker = make_shared<string>(boost::any_cast<string>(m["RpcInvoker"]));
    }
  }


  virtual ~QueryMgsApirestResponseBodyResultContentValueApiInvoker() = default;
};
class QueryMgsApirestResponseBodyResultContentValueCacheRule : public Darabonba::Model {
public:
  shared_ptr<string> cacheKey{};
  shared_ptr<bool> needCache{};
  shared_ptr<long> ttl{};

  QueryMgsApirestResponseBodyResultContentValueCacheRule() {}

  explicit QueryMgsApirestResponseBodyResultContentValueCacheRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cacheKey) {
      res["CacheKey"] = boost::any(*cacheKey);
    }
    if (needCache) {
      res["NeedCache"] = boost::any(*needCache);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CacheKey") != m.end() && !m["CacheKey"].empty()) {
      cacheKey = make_shared<string>(boost::any_cast<string>(m["CacheKey"]));
    }
    if (m.find("NeedCache") != m.end() && !m["NeedCache"].empty()) {
      needCache = make_shared<bool>(boost::any_cast<bool>(m["NeedCache"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
  }


  virtual ~QueryMgsApirestResponseBodyResultContentValueCacheRule() = default;
};
class QueryMgsApirestResponseBodyResultContentValueCircuitBreakerRule : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> defaultResponse{};
  shared_ptr<long> errorThreshold{};
  shared_ptr<long> id{};
  shared_ptr<string> model{};
  shared_ptr<long> openTimeoutSeconds{};
  shared_ptr<double> slowRatioThreshold{};
  shared_ptr<string> switchStatus{};
  shared_ptr<long> windowsInSeconds{};
  shared_ptr<string> workspaceId{};

  QueryMgsApirestResponseBodyResultContentValueCircuitBreakerRule() {}

  explicit QueryMgsApirestResponseBodyResultContentValueCircuitBreakerRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (defaultResponse) {
      res["DefaultResponse"] = boost::any(*defaultResponse);
    }
    if (errorThreshold) {
      res["ErrorThreshold"] = boost::any(*errorThreshold);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (openTimeoutSeconds) {
      res["OpenTimeoutSeconds"] = boost::any(*openTimeoutSeconds);
    }
    if (slowRatioThreshold) {
      res["SlowRatioThreshold"] = boost::any(*slowRatioThreshold);
    }
    if (switchStatus) {
      res["SwitchStatus"] = boost::any(*switchStatus);
    }
    if (windowsInSeconds) {
      res["WindowsInSeconds"] = boost::any(*windowsInSeconds);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DefaultResponse") != m.end() && !m["DefaultResponse"].empty()) {
      defaultResponse = make_shared<string>(boost::any_cast<string>(m["DefaultResponse"]));
    }
    if (m.find("ErrorThreshold") != m.end() && !m["ErrorThreshold"].empty()) {
      errorThreshold = make_shared<long>(boost::any_cast<long>(m["ErrorThreshold"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("OpenTimeoutSeconds") != m.end() && !m["OpenTimeoutSeconds"].empty()) {
      openTimeoutSeconds = make_shared<long>(boost::any_cast<long>(m["OpenTimeoutSeconds"]));
    }
    if (m.find("SlowRatioThreshold") != m.end() && !m["SlowRatioThreshold"].empty()) {
      slowRatioThreshold = make_shared<double>(boost::any_cast<double>(m["SlowRatioThreshold"]));
    }
    if (m.find("SwitchStatus") != m.end() && !m["SwitchStatus"].empty()) {
      switchStatus = make_shared<string>(boost::any_cast<string>(m["SwitchStatus"]));
    }
    if (m.find("WindowsInSeconds") != m.end() && !m["WindowsInSeconds"].empty()) {
      windowsInSeconds = make_shared<long>(boost::any_cast<long>(m["WindowsInSeconds"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~QueryMgsApirestResponseBodyResultContentValueCircuitBreakerRule() = default;
};
class QueryMgsApirestResponseBodyResultContentValueDefaultLimitRule : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<bool> defaultLimit{};

  QueryMgsApirestResponseBodyResultContentValueDefaultLimitRule() {}

  explicit QueryMgsApirestResponseBodyResultContentValueDefaultLimitRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (defaultLimit) {
      res["DefaultLimit"] = boost::any(*defaultLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("DefaultLimit") != m.end() && !m["DefaultLimit"].empty()) {
      defaultLimit = make_shared<bool>(boost::any_cast<bool>(m["DefaultLimit"]));
    }
  }


  virtual ~QueryMgsApirestResponseBodyResultContentValueDefaultLimitRule() = default;
};
class QueryMgsApirestResponseBodyResultContentValueHeaderRule : public Darabonba::Model {
public:
  shared_ptr<string> headerKey{};
  shared_ptr<string> location{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  QueryMgsApirestResponseBodyResultContentValueHeaderRule() {}

  explicit QueryMgsApirestResponseBodyResultContentValueHeaderRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerKey) {
      res["HeaderKey"] = boost::any(*headerKey);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeaderKey") != m.end() && !m["HeaderKey"].empty()) {
      headerKey = make_shared<string>(boost::any_cast<string>(m["HeaderKey"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryMgsApirestResponseBodyResultContentValueHeaderRule() = default;
};
class QueryMgsApirestResponseBodyResultContentValueHeaderRules : public Darabonba::Model {
public:
  shared_ptr<string> headerKey{};
  shared_ptr<string> location{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  QueryMgsApirestResponseBodyResultContentValueHeaderRules() {}

  explicit QueryMgsApirestResponseBodyResultContentValueHeaderRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerKey) {
      res["HeaderKey"] = boost::any(*headerKey);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeaderKey") != m.end() && !m["HeaderKey"].empty()) {
      headerKey = make_shared<string>(boost::any_cast<string>(m["HeaderKey"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryMgsApirestResponseBodyResultContentValueHeaderRules() = default;
};
class QueryMgsApirestResponseBodyResultContentValueLimitRule : public Darabonba::Model {
public:
  shared_ptr<string> defaultResponse{};
  shared_ptr<string> i18nResponse{};
  shared_ptr<long> interval{};
  shared_ptr<long> limit{};
  shared_ptr<string> mode{};

  QueryMgsApirestResponseBodyResultContentValueLimitRule() {}

  explicit QueryMgsApirestResponseBodyResultContentValueLimitRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultResponse) {
      res["DefaultResponse"] = boost::any(*defaultResponse);
    }
    if (i18nResponse) {
      res["I18nResponse"] = boost::any(*i18nResponse);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultResponse") != m.end() && !m["DefaultResponse"].empty()) {
      defaultResponse = make_shared<string>(boost::any_cast<string>(m["DefaultResponse"]));
    }
    if (m.find("I18nResponse") != m.end() && !m["I18nResponse"].empty()) {
      i18nResponse = make_shared<string>(boost::any_cast<string>(m["I18nResponse"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
  }


  virtual ~QueryMgsApirestResponseBodyResultContentValueLimitRule() = default;
};
class QueryMgsApirestResponseBodyResultContentValueMigrateRule : public Darabonba::Model {
public:
  shared_ptr<long> flowPercent{};
  shared_ptr<bool> needMigrate{};
  shared_ptr<bool> needSwitchCompletely{};
  shared_ptr<long> sysId{};
  shared_ptr<string> sysName{};
  shared_ptr<string> upstreamType{};

  QueryMgsApirestResponseBodyResultContentValueMigrateRule() {}

  explicit QueryMgsApirestResponseBodyResultContentValueMigrateRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowPercent) {
      res["FlowPercent"] = boost::any(*flowPercent);
    }
    if (needMigrate) {
      res["NeedMigrate"] = boost::any(*needMigrate);
    }
    if (needSwitchCompletely) {
      res["NeedSwitchCompletely"] = boost::any(*needSwitchCompletely);
    }
    if (sysId) {
      res["SysId"] = boost::any(*sysId);
    }
    if (sysName) {
      res["SysName"] = boost::any(*sysName);
    }
    if (upstreamType) {
      res["UpstreamType"] = boost::any(*upstreamType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowPercent") != m.end() && !m["FlowPercent"].empty()) {
      flowPercent = make_shared<long>(boost::any_cast<long>(m["FlowPercent"]));
    }
    if (m.find("NeedMigrate") != m.end() && !m["NeedMigrate"].empty()) {
      needMigrate = make_shared<bool>(boost::any_cast<bool>(m["NeedMigrate"]));
    }
    if (m.find("NeedSwitchCompletely") != m.end() && !m["NeedSwitchCompletely"].empty()) {
      needSwitchCompletely = make_shared<bool>(boost::any_cast<bool>(m["NeedSwitchCompletely"]));
    }
    if (m.find("SysId") != m.end() && !m["SysId"].empty()) {
      sysId = make_shared<long>(boost::any_cast<long>(m["SysId"]));
    }
    if (m.find("SysName") != m.end() && !m["SysName"].empty()) {
      sysName = make_shared<string>(boost::any_cast<string>(m["SysName"]));
    }
    if (m.find("UpstreamType") != m.end() && !m["UpstreamType"].empty()) {
      upstreamType = make_shared<string>(boost::any_cast<string>(m["UpstreamType"]));
    }
  }


  virtual ~QueryMgsApirestResponseBodyResultContentValueMigrateRule() = default;
};
class QueryMgsApirestResponseBodyResultContentValueMockRule : public Darabonba::Model {
public:
  shared_ptr<string> mockData{};
  shared_ptr<bool> needMock{};
  shared_ptr<long> percentage{};
  shared_ptr<string> type{};

  QueryMgsApirestResponseBodyResultContentValueMockRule() {}

  explicit QueryMgsApirestResponseBodyResultContentValueMockRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mockData) {
      res["MockData"] = boost::any(*mockData);
    }
    if (needMock) {
      res["NeedMock"] = boost::any(*needMock);
    }
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MockData") != m.end() && !m["MockData"].empty()) {
      mockData = make_shared<string>(boost::any_cast<string>(m["MockData"]));
    }
    if (m.find("NeedMock") != m.end() && !m["NeedMock"].empty()) {
      needMock = make_shared<bool>(boost::any_cast<bool>(m["NeedMock"]));
    }
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryMgsApirestResponseBodyResultContentValueMockRule() = default;
};
class QueryMgsApirestResponseBodyResultContentValueRequestParams : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> appId{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> location{};
  shared_ptr<string> name{};
  shared_ptr<string> refType{};
  shared_ptr<string> type{};
  shared_ptr<string> workspaceId{};

  QueryMgsApirestResponseBodyResultContentValueRequestParams() {}

  explicit QueryMgsApirestResponseBodyResultContentValueRequestParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (refType) {
      res["RefType"] = boost::any(*refType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RefType") != m.end() && !m["RefType"].empty()) {
      refType = make_shared<string>(boost::any_cast<string>(m["RefType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~QueryMgsApirestResponseBodyResultContentValueRequestParams() = default;
};
class QueryMgsApirestResponseBodyResultContentValue : public Darabonba::Model {
public:
  shared_ptr<QueryMgsApirestResponseBodyResultContentValueApiInvoker> apiInvoker{};
  shared_ptr<string> apiName{};
  shared_ptr<string> apiStatus{};
  shared_ptr<string> apiType{};
  shared_ptr<string> appId{};
  shared_ptr<string> authRuleName{};
  shared_ptr<QueryMgsApirestResponseBodyResultContentValueCacheRule> cacheRule{};
  shared_ptr<string> charset{};
  shared_ptr<QueryMgsApirestResponseBodyResultContentValueCircuitBreakerRule> circuitBreakerRule{};
  shared_ptr<string> contentType{};
  shared_ptr<QueryMgsApirestResponseBodyResultContentValueDefaultLimitRule> defaultLimitRule{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<vector<QueryMgsApirestResponseBodyResultContentValueHeaderRule>> headerRule{};
  shared_ptr<vector<QueryMgsApirestResponseBodyResultContentValueHeaderRules>> headerRules{};
  shared_ptr<string> host{};
  shared_ptr<long> id{};
  shared_ptr<string> interfaceType{};
  shared_ptr<QueryMgsApirestResponseBodyResultContentValueLimitRule> limitRule{};
  shared_ptr<string> method{};
  shared_ptr<string> methodName{};
  shared_ptr<QueryMgsApirestResponseBodyResultContentValueMigrateRule> migrateRule{};
  shared_ptr<QueryMgsApirestResponseBodyResultContentValueMockRule> mockRule{};
  shared_ptr<string> needETag{};
  shared_ptr<string> needEncrypt{};
  shared_ptr<string> needJsonp{};
  shared_ptr<string> needSign{};
  shared_ptr<string> operationType{};
  shared_ptr<string> paramGetMethod{};
  shared_ptr<string> path{};
  shared_ptr<string> requestBodyModel{};
  shared_ptr<vector<QueryMgsApirestResponseBodyResultContentValueRequestParams>> requestParams{};
  shared_ptr<string> responseBodyModel{};
  shared_ptr<long> sysId{};
  shared_ptr<string> sysName{};
  shared_ptr<string> timeout{};
  shared_ptr<string> workspaceId{};

  QueryMgsApirestResponseBodyResultContentValue() {}

  explicit QueryMgsApirestResponseBodyResultContentValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInvoker) {
      res["ApiInvoker"] = apiInvoker ? boost::any(apiInvoker->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (apiStatus) {
      res["ApiStatus"] = boost::any(*apiStatus);
    }
    if (apiType) {
      res["ApiType"] = boost::any(*apiType);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (authRuleName) {
      res["AuthRuleName"] = boost::any(*authRuleName);
    }
    if (cacheRule) {
      res["CacheRule"] = cacheRule ? boost::any(cacheRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (charset) {
      res["Charset"] = boost::any(*charset);
    }
    if (circuitBreakerRule) {
      res["CircuitBreakerRule"] = circuitBreakerRule ? boost::any(circuitBreakerRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (defaultLimitRule) {
      res["DefaultLimitRule"] = defaultLimitRule ? boost::any(defaultLimitRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (headerRule) {
      vector<boost::any> temp1;
      for(auto item1:*headerRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HeaderRule"] = boost::any(temp1);
    }
    if (headerRules) {
      vector<boost::any> temp1;
      for(auto item1:*headerRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HeaderRules"] = boost::any(temp1);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (interfaceType) {
      res["InterfaceType"] = boost::any(*interfaceType);
    }
    if (limitRule) {
      res["LimitRule"] = limitRule ? boost::any(limitRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (migrateRule) {
      res["MigrateRule"] = migrateRule ? boost::any(migrateRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mockRule) {
      res["MockRule"] = mockRule ? boost::any(mockRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (needETag) {
      res["NeedETag"] = boost::any(*needETag);
    }
    if (needEncrypt) {
      res["NeedEncrypt"] = boost::any(*needEncrypt);
    }
    if (needJsonp) {
      res["NeedJsonp"] = boost::any(*needJsonp);
    }
    if (needSign) {
      res["NeedSign"] = boost::any(*needSign);
    }
    if (operationType) {
      res["OperationType"] = boost::any(*operationType);
    }
    if (paramGetMethod) {
      res["ParamGetMethod"] = boost::any(*paramGetMethod);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (requestBodyModel) {
      res["RequestBodyModel"] = boost::any(*requestBodyModel);
    }
    if (requestParams) {
      vector<boost::any> temp1;
      for(auto item1:*requestParams){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParams"] = boost::any(temp1);
    }
    if (responseBodyModel) {
      res["ResponseBodyModel"] = boost::any(*responseBodyModel);
    }
    if (sysId) {
      res["SysId"] = boost::any(*sysId);
    }
    if (sysName) {
      res["SysName"] = boost::any(*sysName);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInvoker") != m.end() && !m["ApiInvoker"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiInvoker"].type()) {
        QueryMgsApirestResponseBodyResultContentValueApiInvoker model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiInvoker"]));
        apiInvoker = make_shared<QueryMgsApirestResponseBodyResultContentValueApiInvoker>(model1);
      }
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("ApiStatus") != m.end() && !m["ApiStatus"].empty()) {
      apiStatus = make_shared<string>(boost::any_cast<string>(m["ApiStatus"]));
    }
    if (m.find("ApiType") != m.end() && !m["ApiType"].empty()) {
      apiType = make_shared<string>(boost::any_cast<string>(m["ApiType"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AuthRuleName") != m.end() && !m["AuthRuleName"].empty()) {
      authRuleName = make_shared<string>(boost::any_cast<string>(m["AuthRuleName"]));
    }
    if (m.find("CacheRule") != m.end() && !m["CacheRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["CacheRule"].type()) {
        QueryMgsApirestResponseBodyResultContentValueCacheRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CacheRule"]));
        cacheRule = make_shared<QueryMgsApirestResponseBodyResultContentValueCacheRule>(model1);
      }
    }
    if (m.find("Charset") != m.end() && !m["Charset"].empty()) {
      charset = make_shared<string>(boost::any_cast<string>(m["Charset"]));
    }
    if (m.find("CircuitBreakerRule") != m.end() && !m["CircuitBreakerRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["CircuitBreakerRule"].type()) {
        QueryMgsApirestResponseBodyResultContentValueCircuitBreakerRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CircuitBreakerRule"]));
        circuitBreakerRule = make_shared<QueryMgsApirestResponseBodyResultContentValueCircuitBreakerRule>(model1);
      }
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("DefaultLimitRule") != m.end() && !m["DefaultLimitRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["DefaultLimitRule"].type()) {
        QueryMgsApirestResponseBodyResultContentValueDefaultLimitRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DefaultLimitRule"]));
        defaultLimitRule = make_shared<QueryMgsApirestResponseBodyResultContentValueDefaultLimitRule>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("HeaderRule") != m.end() && !m["HeaderRule"].empty()) {
      if (typeid(vector<boost::any>) == m["HeaderRule"].type()) {
        vector<QueryMgsApirestResponseBodyResultContentValueHeaderRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HeaderRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMgsApirestResponseBodyResultContentValueHeaderRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        headerRule = make_shared<vector<QueryMgsApirestResponseBodyResultContentValueHeaderRule>>(expect1);
      }
    }
    if (m.find("HeaderRules") != m.end() && !m["HeaderRules"].empty()) {
      if (typeid(vector<boost::any>) == m["HeaderRules"].type()) {
        vector<QueryMgsApirestResponseBodyResultContentValueHeaderRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HeaderRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMgsApirestResponseBodyResultContentValueHeaderRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        headerRules = make_shared<vector<QueryMgsApirestResponseBodyResultContentValueHeaderRules>>(expect1);
      }
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InterfaceType") != m.end() && !m["InterfaceType"].empty()) {
      interfaceType = make_shared<string>(boost::any_cast<string>(m["InterfaceType"]));
    }
    if (m.find("LimitRule") != m.end() && !m["LimitRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["LimitRule"].type()) {
        QueryMgsApirestResponseBodyResultContentValueLimitRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LimitRule"]));
        limitRule = make_shared<QueryMgsApirestResponseBodyResultContentValueLimitRule>(model1);
      }
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("MigrateRule") != m.end() && !m["MigrateRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["MigrateRule"].type()) {
        QueryMgsApirestResponseBodyResultContentValueMigrateRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MigrateRule"]));
        migrateRule = make_shared<QueryMgsApirestResponseBodyResultContentValueMigrateRule>(model1);
      }
    }
    if (m.find("MockRule") != m.end() && !m["MockRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["MockRule"].type()) {
        QueryMgsApirestResponseBodyResultContentValueMockRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MockRule"]));
        mockRule = make_shared<QueryMgsApirestResponseBodyResultContentValueMockRule>(model1);
      }
    }
    if (m.find("NeedETag") != m.end() && !m["NeedETag"].empty()) {
      needETag = make_shared<string>(boost::any_cast<string>(m["NeedETag"]));
    }
    if (m.find("NeedEncrypt") != m.end() && !m["NeedEncrypt"].empty()) {
      needEncrypt = make_shared<string>(boost::any_cast<string>(m["NeedEncrypt"]));
    }
    if (m.find("NeedJsonp") != m.end() && !m["NeedJsonp"].empty()) {
      needJsonp = make_shared<string>(boost::any_cast<string>(m["NeedJsonp"]));
    }
    if (m.find("NeedSign") != m.end() && !m["NeedSign"].empty()) {
      needSign = make_shared<string>(boost::any_cast<string>(m["NeedSign"]));
    }
    if (m.find("OperationType") != m.end() && !m["OperationType"].empty()) {
      operationType = make_shared<string>(boost::any_cast<string>(m["OperationType"]));
    }
    if (m.find("ParamGetMethod") != m.end() && !m["ParamGetMethod"].empty()) {
      paramGetMethod = make_shared<string>(boost::any_cast<string>(m["ParamGetMethod"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("RequestBodyModel") != m.end() && !m["RequestBodyModel"].empty()) {
      requestBodyModel = make_shared<string>(boost::any_cast<string>(m["RequestBodyModel"]));
    }
    if (m.find("RequestParams") != m.end() && !m["RequestParams"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParams"].type()) {
        vector<QueryMgsApirestResponseBodyResultContentValueRequestParams> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParams"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMgsApirestResponseBodyResultContentValueRequestParams model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParams = make_shared<vector<QueryMgsApirestResponseBodyResultContentValueRequestParams>>(expect1);
      }
    }
    if (m.find("ResponseBodyModel") != m.end() && !m["ResponseBodyModel"].empty()) {
      responseBodyModel = make_shared<string>(boost::any_cast<string>(m["ResponseBodyModel"]));
    }
    if (m.find("SysId") != m.end() && !m["SysId"].empty()) {
      sysId = make_shared<long>(boost::any_cast<long>(m["SysId"]));
    }
    if (m.find("SysName") != m.end() && !m["SysName"].empty()) {
      sysName = make_shared<string>(boost::any_cast<string>(m["SysName"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<string>(boost::any_cast<string>(m["Timeout"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~QueryMgsApirestResponseBodyResultContentValue() = default;
};
class QueryMgsApirestResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<QueryMgsApirestResponseBodyResultContentValue> value{};

  QueryMgsApirestResponseBodyResultContent() {}

  explicit QueryMgsApirestResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (value) {
      res["Value"] = value ? boost::any(value->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(map<string, boost::any>) == m["Value"].type()) {
        QueryMgsApirestResponseBodyResultContentValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Value"]));
        value = make_shared<QueryMgsApirestResponseBodyResultContentValue>(model1);
      }
    }
  }


  virtual ~QueryMgsApirestResponseBodyResultContent() = default;
};
class QueryMgsApirestResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<QueryMgsApirestResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  QueryMgsApirestResponseBody() {}

  explicit QueryMgsApirestResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        QueryMgsApirestResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<QueryMgsApirestResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~QueryMgsApirestResponseBody() = default;
};
class QueryMgsApirestResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMgsApirestResponseBody> body{};

  QueryMgsApirestResponse() {}

  explicit QueryMgsApirestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMgsApirestResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMgsApirestResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMgsApirestResponse() = default;
};
class QueryMgsTestreqbodyautogenRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> format{};
  shared_ptr<string> mpaasMappcenterMgsTestreqbodyautogenQueryJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  QueryMgsTestreqbodyautogenRequest() {}

  explicit QueryMgsTestreqbodyautogenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (mpaasMappcenterMgsTestreqbodyautogenQueryJsonStr) {
      res["MpaasMappcenterMgsTestreqbodyautogenQueryJsonStr"] = boost::any(*mpaasMappcenterMgsTestreqbodyautogenQueryJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("MpaasMappcenterMgsTestreqbodyautogenQueryJsonStr") != m.end() && !m["MpaasMappcenterMgsTestreqbodyautogenQueryJsonStr"].empty()) {
      mpaasMappcenterMgsTestreqbodyautogenQueryJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMappcenterMgsTestreqbodyautogenQueryJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~QueryMgsTestreqbodyautogenRequest() = default;
};
class QueryMgsTestreqbodyautogenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultContent{};
  shared_ptr<string> resultMessage{};

  QueryMgsTestreqbodyautogenResponseBody() {}

  explicit QueryMgsTestreqbodyautogenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = boost::any(*resultContent);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      resultContent = make_shared<string>(boost::any_cast<string>(m["ResultContent"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~QueryMgsTestreqbodyautogenResponseBody() = default;
};
class QueryMgsTestreqbodyautogenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMgsTestreqbodyautogenResponseBody> body{};

  QueryMgsTestreqbodyautogenResponse() {}

  explicit QueryMgsTestreqbodyautogenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMgsTestreqbodyautogenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMgsTestreqbodyautogenResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMgsTestreqbodyautogenResponse() = default;
};
class QueryMpsSchedulerListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};
  shared_ptr<long> type{};
  shared_ptr<string> uniqueId{};
  shared_ptr<string> workspaceId{};

  QueryMpsSchedulerListRequest() {}

  explicit QueryMpsSchedulerListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uniqueId) {
      res["UniqueId"] = boost::any(*uniqueId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("UniqueId") != m.end() && !m["UniqueId"].empty()) {
      uniqueId = make_shared<string>(boost::any_cast<string>(m["UniqueId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~QueryMpsSchedulerListRequest() = default;
};
class QueryMpsSchedulerListResponseBodyResultContentDataList : public Darabonba::Model {
public:
  shared_ptr<long> createType{};
  shared_ptr<long> deliveryType{};
  shared_ptr<string> executedStatus{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> parentId{};
  shared_ptr<string> pushContent{};
  shared_ptr<long> pushTime{};
  shared_ptr<string> pushTitle{};
  shared_ptr<long> strategyType{};
  shared_ptr<long> type{};
  shared_ptr<string> uniqueId{};

  QueryMpsSchedulerListResponseBodyResultContentDataList() {}

  explicit QueryMpsSchedulerListResponseBodyResultContentDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createType) {
      res["CreateType"] = boost::any(*createType);
    }
    if (deliveryType) {
      res["DeliveryType"] = boost::any(*deliveryType);
    }
    if (executedStatus) {
      res["ExecutedStatus"] = boost::any(*executedStatus);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (pushContent) {
      res["PushContent"] = boost::any(*pushContent);
    }
    if (pushTime) {
      res["PushTime"] = boost::any(*pushTime);
    }
    if (pushTitle) {
      res["PushTitle"] = boost::any(*pushTitle);
    }
    if (strategyType) {
      res["StrategyType"] = boost::any(*strategyType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uniqueId) {
      res["UniqueId"] = boost::any(*uniqueId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateType") != m.end() && !m["CreateType"].empty()) {
      createType = make_shared<long>(boost::any_cast<long>(m["CreateType"]));
    }
    if (m.find("DeliveryType") != m.end() && !m["DeliveryType"].empty()) {
      deliveryType = make_shared<long>(boost::any_cast<long>(m["DeliveryType"]));
    }
    if (m.find("ExecutedStatus") != m.end() && !m["ExecutedStatus"].empty()) {
      executedStatus = make_shared<string>(boost::any_cast<string>(m["ExecutedStatus"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("PushContent") != m.end() && !m["PushContent"].empty()) {
      pushContent = make_shared<string>(boost::any_cast<string>(m["PushContent"]));
    }
    if (m.find("PushTime") != m.end() && !m["PushTime"].empty()) {
      pushTime = make_shared<long>(boost::any_cast<long>(m["PushTime"]));
    }
    if (m.find("PushTitle") != m.end() && !m["PushTitle"].empty()) {
      pushTitle = make_shared<string>(boost::any_cast<string>(m["PushTitle"]));
    }
    if (m.find("StrategyType") != m.end() && !m["StrategyType"].empty()) {
      strategyType = make_shared<long>(boost::any_cast<long>(m["StrategyType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("UniqueId") != m.end() && !m["UniqueId"].empty()) {
      uniqueId = make_shared<string>(boost::any_cast<string>(m["UniqueId"]));
    }
  }


  virtual ~QueryMpsSchedulerListResponseBodyResultContentDataList() = default;
};
class QueryMpsSchedulerListResponseBodyResultContentData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMpsSchedulerListResponseBodyResultContentDataList>> list{};
  shared_ptr<long> totalCount{};

  QueryMpsSchedulerListResponseBodyResultContentData() {}

  explicit QueryMpsSchedulerListResponseBodyResultContentData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<QueryMpsSchedulerListResponseBodyResultContentDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMpsSchedulerListResponseBodyResultContentDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<QueryMpsSchedulerListResponseBodyResultContentDataList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryMpsSchedulerListResponseBodyResultContentData() = default;
};
class QueryMpsSchedulerListResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<QueryMpsSchedulerListResponseBodyResultContentData> data{};

  QueryMpsSchedulerListResponseBodyResultContent() {}

  explicit QueryMpsSchedulerListResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryMpsSchedulerListResponseBodyResultContentData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryMpsSchedulerListResponseBodyResultContentData>(model1);
      }
    }
  }


  virtual ~QueryMpsSchedulerListResponseBodyResultContent() = default;
};
class QueryMpsSchedulerListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<QueryMpsSchedulerListResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  QueryMpsSchedulerListResponseBody() {}

  explicit QueryMpsSchedulerListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        QueryMpsSchedulerListResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<QueryMpsSchedulerListResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~QueryMpsSchedulerListResponseBody() = default;
};
class QueryMpsSchedulerListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMpsSchedulerListResponseBody> body{};

  QueryMpsSchedulerListResponse() {}

  explicit QueryMpsSchedulerListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMpsSchedulerListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMpsSchedulerListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMpsSchedulerListResponse() = default;
};
class QueryPushAnalysisCoreIndexRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> channel{};
  shared_ptr<long> endTime{};
  shared_ptr<string> platform{};
  shared_ptr<long> startTime{};
  shared_ptr<string> taskId{};
  shared_ptr<string> type{};
  shared_ptr<string> workspaceId{};

  QueryPushAnalysisCoreIndexRequest() {}

  explicit QueryPushAnalysisCoreIndexRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (channel) {
      res["Channel"] = boost::any(*channel);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["Channel"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~QueryPushAnalysisCoreIndexRequest() = default;
};
class QueryPushAnalysisCoreIndexResponseBodyResultContentData : public Darabonba::Model {
public:
  shared_ptr<double> arrivalNum{};
  shared_ptr<double> arrivalRate{};
  shared_ptr<double> ignoreNum{};
  shared_ptr<double> ignoreRate{};
  shared_ptr<double> openNum{};
  shared_ptr<double> openRate{};
  shared_ptr<double> pushNum{};
  shared_ptr<double> pushTotalNum{};

  QueryPushAnalysisCoreIndexResponseBodyResultContentData() {}

  explicit QueryPushAnalysisCoreIndexResponseBodyResultContentData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrivalNum) {
      res["ArrivalNum"] = boost::any(*arrivalNum);
    }
    if (arrivalRate) {
      res["ArrivalRate"] = boost::any(*arrivalRate);
    }
    if (ignoreNum) {
      res["IgnoreNum"] = boost::any(*ignoreNum);
    }
    if (ignoreRate) {
      res["IgnoreRate"] = boost::any(*ignoreRate);
    }
    if (openNum) {
      res["OpenNum"] = boost::any(*openNum);
    }
    if (openRate) {
      res["OpenRate"] = boost::any(*openRate);
    }
    if (pushNum) {
      res["PushNum"] = boost::any(*pushNum);
    }
    if (pushTotalNum) {
      res["PushTotalNum"] = boost::any(*pushTotalNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArrivalNum") != m.end() && !m["ArrivalNum"].empty()) {
      arrivalNum = make_shared<double>(boost::any_cast<double>(m["ArrivalNum"]));
    }
    if (m.find("ArrivalRate") != m.end() && !m["ArrivalRate"].empty()) {
      arrivalRate = make_shared<double>(boost::any_cast<double>(m["ArrivalRate"]));
    }
    if (m.find("IgnoreNum") != m.end() && !m["IgnoreNum"].empty()) {
      ignoreNum = make_shared<double>(boost::any_cast<double>(m["IgnoreNum"]));
    }
    if (m.find("IgnoreRate") != m.end() && !m["IgnoreRate"].empty()) {
      ignoreRate = make_shared<double>(boost::any_cast<double>(m["IgnoreRate"]));
    }
    if (m.find("OpenNum") != m.end() && !m["OpenNum"].empty()) {
      openNum = make_shared<double>(boost::any_cast<double>(m["OpenNum"]));
    }
    if (m.find("OpenRate") != m.end() && !m["OpenRate"].empty()) {
      openRate = make_shared<double>(boost::any_cast<double>(m["OpenRate"]));
    }
    if (m.find("PushNum") != m.end() && !m["PushNum"].empty()) {
      pushNum = make_shared<double>(boost::any_cast<double>(m["PushNum"]));
    }
    if (m.find("PushTotalNum") != m.end() && !m["PushTotalNum"].empty()) {
      pushTotalNum = make_shared<double>(boost::any_cast<double>(m["PushTotalNum"]));
    }
  }


  virtual ~QueryPushAnalysisCoreIndexResponseBodyResultContentData() = default;
};
class QueryPushAnalysisCoreIndexResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<QueryPushAnalysisCoreIndexResponseBodyResultContentData> data{};

  QueryPushAnalysisCoreIndexResponseBodyResultContent() {}

  explicit QueryPushAnalysisCoreIndexResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryPushAnalysisCoreIndexResponseBodyResultContentData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryPushAnalysisCoreIndexResponseBodyResultContentData>(model1);
      }
    }
  }


  virtual ~QueryPushAnalysisCoreIndexResponseBodyResultContent() = default;
};
class QueryPushAnalysisCoreIndexResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<QueryPushAnalysisCoreIndexResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  QueryPushAnalysisCoreIndexResponseBody() {}

  explicit QueryPushAnalysisCoreIndexResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        QueryPushAnalysisCoreIndexResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<QueryPushAnalysisCoreIndexResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~QueryPushAnalysisCoreIndexResponseBody() = default;
};
class QueryPushAnalysisCoreIndexResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryPushAnalysisCoreIndexResponseBody> body{};

  QueryPushAnalysisCoreIndexResponse() {}

  explicit QueryPushAnalysisCoreIndexResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryPushAnalysisCoreIndexResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryPushAnalysisCoreIndexResponseBody>(model1);
      }
    }
  }


  virtual ~QueryPushAnalysisCoreIndexResponse() = default;
};
class QueryPushAnalysisTaskDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> workspaceId{};

  QueryPushAnalysisTaskDetailRequest() {}

  explicit QueryPushAnalysisTaskDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~QueryPushAnalysisTaskDetailRequest() = default;
};
class QueryPushAnalysisTaskDetailResponseBodyResultContentData : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<long> endTime{};
  shared_ptr<double> pushArrivalNum{};
  shared_ptr<double> pushNum{};
  shared_ptr<double> pushSuccessNum{};
  shared_ptr<long> startTime{};
  shared_ptr<long> taskId{};

  QueryPushAnalysisTaskDetailResponseBodyResultContentData() {}

  explicit QueryPushAnalysisTaskDetailResponseBodyResultContentData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pushArrivalNum) {
      res["PushArrivalNum"] = boost::any(*pushArrivalNum);
    }
    if (pushNum) {
      res["PushNum"] = boost::any(*pushNum);
    }
    if (pushSuccessNum) {
      res["PushSuccessNum"] = boost::any(*pushSuccessNum);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("PushArrivalNum") != m.end() && !m["PushArrivalNum"].empty()) {
      pushArrivalNum = make_shared<double>(boost::any_cast<double>(m["PushArrivalNum"]));
    }
    if (m.find("PushNum") != m.end() && !m["PushNum"].empty()) {
      pushNum = make_shared<double>(boost::any_cast<double>(m["PushNum"]));
    }
    if (m.find("PushSuccessNum") != m.end() && !m["PushSuccessNum"].empty()) {
      pushSuccessNum = make_shared<double>(boost::any_cast<double>(m["PushSuccessNum"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~QueryPushAnalysisTaskDetailResponseBodyResultContentData() = default;
};
class QueryPushAnalysisTaskDetailResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<QueryPushAnalysisTaskDetailResponseBodyResultContentData> data{};

  QueryPushAnalysisTaskDetailResponseBodyResultContent() {}

  explicit QueryPushAnalysisTaskDetailResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryPushAnalysisTaskDetailResponseBodyResultContentData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryPushAnalysisTaskDetailResponseBodyResultContentData>(model1);
      }
    }
  }


  virtual ~QueryPushAnalysisTaskDetailResponseBodyResultContent() = default;
};
class QueryPushAnalysisTaskDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<QueryPushAnalysisTaskDetailResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  QueryPushAnalysisTaskDetailResponseBody() {}

  explicit QueryPushAnalysisTaskDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        QueryPushAnalysisTaskDetailResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<QueryPushAnalysisTaskDetailResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~QueryPushAnalysisTaskDetailResponseBody() = default;
};
class QueryPushAnalysisTaskDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryPushAnalysisTaskDetailResponseBody> body{};

  QueryPushAnalysisTaskDetailResponse() {}

  explicit QueryPushAnalysisTaskDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryPushAnalysisTaskDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryPushAnalysisTaskDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryPushAnalysisTaskDetailResponse() = default;
};
class QueryPushAnalysisTaskListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> workspaceId{};

  QueryPushAnalysisTaskListRequest() {}

  explicit QueryPushAnalysisTaskListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~QueryPushAnalysisTaskListRequest() = default;
};
class QueryPushAnalysisTaskListResponseBodyResultContentDataList : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<long> type{};

  QueryPushAnalysisTaskListResponseBodyResultContentDataList() {}

  explicit QueryPushAnalysisTaskListResponseBodyResultContentDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryPushAnalysisTaskListResponseBodyResultContentDataList() = default;
};
class QueryPushAnalysisTaskListResponseBodyResultContentData : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<vector<QueryPushAnalysisTaskListResponseBodyResultContentDataList>> list{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<long> type{};

  QueryPushAnalysisTaskListResponseBodyResultContentData() {}

  explicit QueryPushAnalysisTaskListResponseBodyResultContentData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<QueryPushAnalysisTaskListResponseBodyResultContentDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryPushAnalysisTaskListResponseBodyResultContentDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<QueryPushAnalysisTaskListResponseBodyResultContentDataList>>(expect1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryPushAnalysisTaskListResponseBodyResultContentData() = default;
};
class QueryPushAnalysisTaskListResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<vector<QueryPushAnalysisTaskListResponseBodyResultContentData>> data{};

  QueryPushAnalysisTaskListResponseBodyResultContent() {}

  explicit QueryPushAnalysisTaskListResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<QueryPushAnalysisTaskListResponseBodyResultContentData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryPushAnalysisTaskListResponseBodyResultContentData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<QueryPushAnalysisTaskListResponseBodyResultContentData>>(expect1);
      }
    }
  }


  virtual ~QueryPushAnalysisTaskListResponseBodyResultContent() = default;
};
class QueryPushAnalysisTaskListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<QueryPushAnalysisTaskListResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  QueryPushAnalysisTaskListResponseBody() {}

  explicit QueryPushAnalysisTaskListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        QueryPushAnalysisTaskListResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<QueryPushAnalysisTaskListResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~QueryPushAnalysisTaskListResponseBody() = default;
};
class QueryPushAnalysisTaskListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryPushAnalysisTaskListResponseBody> body{};

  QueryPushAnalysisTaskListResponse() {}

  explicit QueryPushAnalysisTaskListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryPushAnalysisTaskListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryPushAnalysisTaskListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryPushAnalysisTaskListResponse() = default;
};
class QueryPushSchedulerListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};
  shared_ptr<long> type{};
  shared_ptr<string> uniqueId{};
  shared_ptr<string> workspaceId{};

  QueryPushSchedulerListRequest() {}

  explicit QueryPushSchedulerListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uniqueId) {
      res["UniqueId"] = boost::any(*uniqueId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("UniqueId") != m.end() && !m["UniqueId"].empty()) {
      uniqueId = make_shared<string>(boost::any_cast<string>(m["UniqueId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~QueryPushSchedulerListRequest() = default;
};
class QueryPushSchedulerListResponseBodyResultContentDataList : public Darabonba::Model {
public:
  shared_ptr<long> createType{};
  shared_ptr<long> deliveryType{};
  shared_ptr<string> executedStatus{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> parentId{};
  shared_ptr<string> pushContent{};
  shared_ptr<long> pushTime{};
  shared_ptr<string> pushTitle{};
  shared_ptr<long> strategyType{};
  shared_ptr<long> type{};
  shared_ptr<string> uniqueId{};

  QueryPushSchedulerListResponseBodyResultContentDataList() {}

  explicit QueryPushSchedulerListResponseBodyResultContentDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createType) {
      res["CreateType"] = boost::any(*createType);
    }
    if (deliveryType) {
      res["DeliveryType"] = boost::any(*deliveryType);
    }
    if (executedStatus) {
      res["ExecutedStatus"] = boost::any(*executedStatus);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (pushContent) {
      res["PushContent"] = boost::any(*pushContent);
    }
    if (pushTime) {
      res["PushTime"] = boost::any(*pushTime);
    }
    if (pushTitle) {
      res["PushTitle"] = boost::any(*pushTitle);
    }
    if (strategyType) {
      res["StrategyType"] = boost::any(*strategyType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uniqueId) {
      res["UniqueId"] = boost::any(*uniqueId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateType") != m.end() && !m["CreateType"].empty()) {
      createType = make_shared<long>(boost::any_cast<long>(m["CreateType"]));
    }
    if (m.find("DeliveryType") != m.end() && !m["DeliveryType"].empty()) {
      deliveryType = make_shared<long>(boost::any_cast<long>(m["DeliveryType"]));
    }
    if (m.find("ExecutedStatus") != m.end() && !m["ExecutedStatus"].empty()) {
      executedStatus = make_shared<string>(boost::any_cast<string>(m["ExecutedStatus"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("PushContent") != m.end() && !m["PushContent"].empty()) {
      pushContent = make_shared<string>(boost::any_cast<string>(m["PushContent"]));
    }
    if (m.find("PushTime") != m.end() && !m["PushTime"].empty()) {
      pushTime = make_shared<long>(boost::any_cast<long>(m["PushTime"]));
    }
    if (m.find("PushTitle") != m.end() && !m["PushTitle"].empty()) {
      pushTitle = make_shared<string>(boost::any_cast<string>(m["PushTitle"]));
    }
    if (m.find("StrategyType") != m.end() && !m["StrategyType"].empty()) {
      strategyType = make_shared<long>(boost::any_cast<long>(m["StrategyType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("UniqueId") != m.end() && !m["UniqueId"].empty()) {
      uniqueId = make_shared<string>(boost::any_cast<string>(m["UniqueId"]));
    }
  }


  virtual ~QueryPushSchedulerListResponseBodyResultContentDataList() = default;
};
class QueryPushSchedulerListResponseBodyResultContentData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryPushSchedulerListResponseBodyResultContentDataList>> list{};
  shared_ptr<long> totalCount{};

  QueryPushSchedulerListResponseBodyResultContentData() {}

  explicit QueryPushSchedulerListResponseBodyResultContentData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<QueryPushSchedulerListResponseBodyResultContentDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryPushSchedulerListResponseBodyResultContentDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<QueryPushSchedulerListResponseBodyResultContentDataList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryPushSchedulerListResponseBodyResultContentData() = default;
};
class QueryPushSchedulerListResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<QueryPushSchedulerListResponseBodyResultContentData> data{};

  QueryPushSchedulerListResponseBodyResultContent() {}

  explicit QueryPushSchedulerListResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryPushSchedulerListResponseBodyResultContentData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryPushSchedulerListResponseBodyResultContentData>(model1);
      }
    }
  }


  virtual ~QueryPushSchedulerListResponseBodyResultContent() = default;
};
class QueryPushSchedulerListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<QueryPushSchedulerListResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  QueryPushSchedulerListResponseBody() {}

  explicit QueryPushSchedulerListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        QueryPushSchedulerListResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<QueryPushSchedulerListResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~QueryPushSchedulerListResponseBody() = default;
};
class QueryPushSchedulerListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryPushSchedulerListResponseBody> body{};

  QueryPushSchedulerListResponse() {}

  explicit QueryPushSchedulerListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryPushSchedulerListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryPushSchedulerListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryPushSchedulerListResponse() = default;
};
class RevokePushMessageRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> messageId{};
  shared_ptr<string> targetId{};
  shared_ptr<string> workspaceId{};

  RevokePushMessageRequest() {}

  explicit RevokePushMessageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (targetId) {
      res["TargetId"] = boost::any(*targetId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("TargetId") != m.end() && !m["TargetId"].empty()) {
      targetId = make_shared<string>(boost::any_cast<string>(m["TargetId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RevokePushMessageRequest() = default;
};
class RevokePushMessageResponseBodyPushResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  RevokePushMessageResponseBodyPushResult() {}

  explicit RevokePushMessageResponseBodyPushResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RevokePushMessageResponseBodyPushResult() = default;
};
class RevokePushMessageResponseBody : public Darabonba::Model {
public:
  shared_ptr<RevokePushMessageResponseBodyPushResult> pushResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  RevokePushMessageResponseBody() {}

  explicit RevokePushMessageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pushResult) {
      res["PushResult"] = pushResult ? boost::any(pushResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PushResult") != m.end() && !m["PushResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PushResult"].type()) {
        RevokePushMessageResponseBodyPushResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PushResult"]));
        pushResult = make_shared<RevokePushMessageResponseBodyPushResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~RevokePushMessageResponseBody() = default;
};
class RevokePushMessageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RevokePushMessageResponseBody> body{};

  RevokePushMessageResponse() {}

  explicit RevokePushMessageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokePushMessageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokePushMessageResponseBody>(model1);
      }
    }
  }


  virtual ~RevokePushMessageResponse() = default;
};
class RevokePushTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> workspaceId{};

  RevokePushTaskRequest() {}

  explicit RevokePushTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RevokePushTaskRequest() = default;
};
class RevokePushTaskResponseBodyPushResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  RevokePushTaskResponseBodyPushResult() {}

  explicit RevokePushTaskResponseBodyPushResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RevokePushTaskResponseBodyPushResult() = default;
};
class RevokePushTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<RevokePushTaskResponseBodyPushResult> pushResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  RevokePushTaskResponseBody() {}

  explicit RevokePushTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pushResult) {
      res["PushResult"] = pushResult ? boost::any(pushResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PushResult") != m.end() && !m["PushResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PushResult"].type()) {
        RevokePushTaskResponseBodyPushResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PushResult"]));
        pushResult = make_shared<RevokePushTaskResponseBodyPushResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~RevokePushTaskResponseBody() = default;
};
class RevokePushTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RevokePushTaskResponseBody> body{};

  RevokePushTaskResponse() {}

  explicit RevokePushTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokePushTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokePushTaskResponseBody>(model1);
      }
    }
  }


  virtual ~RevokePushTaskResponse() = default;
};
class RunMsaDiffRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMappcenterMsaDiffRunJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  RunMsaDiffRequest() {}

  explicit RunMsaDiffRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMappcenterMsaDiffRunJsonStr) {
      res["MpaasMappcenterMsaDiffRunJsonStr"] = boost::any(*mpaasMappcenterMsaDiffRunJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMappcenterMsaDiffRunJsonStr") != m.end() && !m["MpaasMappcenterMsaDiffRunJsonStr"].empty()) {
      mpaasMappcenterMsaDiffRunJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMappcenterMsaDiffRunJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunMsaDiffRequest() = default;
};
class RunMsaDiffResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  RunMsaDiffResponseBodyResultContent() {}

  explicit RunMsaDiffResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RunMsaDiffResponseBodyResultContent() = default;
};
class RunMsaDiffResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<RunMsaDiffResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  RunMsaDiffResponseBody() {}

  explicit RunMsaDiffResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        RunMsaDiffResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<RunMsaDiffResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~RunMsaDiffResponseBody() = default;
};
class RunMsaDiffResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunMsaDiffResponseBody> body{};

  RunMsaDiffResponse() {}

  explicit RunMsaDiffResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunMsaDiffResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunMsaDiffResponseBody>(model1);
      }
    }
  }


  virtual ~RunMsaDiffResponse() = default;
};
class SaveMgsApirestRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> mpaasMappcenterMgsApirestSaveJsonStr{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  SaveMgsApirestRequest() {}

  explicit SaveMgsApirestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (mpaasMappcenterMgsApirestSaveJsonStr) {
      res["MpaasMappcenterMgsApirestSaveJsonStr"] = boost::any(*mpaasMappcenterMgsApirestSaveJsonStr);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MpaasMappcenterMgsApirestSaveJsonStr") != m.end() && !m["MpaasMappcenterMgsApirestSaveJsonStr"].empty()) {
      mpaasMappcenterMgsApirestSaveJsonStr = make_shared<string>(boost::any_cast<string>(m["MpaasMappcenterMgsApirestSaveJsonStr"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~SaveMgsApirestRequest() = default;
};
class SaveMgsApirestResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<bool> value{};

  SaveMgsApirestResponseBodyResultContent() {}

  explicit SaveMgsApirestResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<bool>(boost::any_cast<bool>(m["Value"]));
    }
  }


  virtual ~SaveMgsApirestResponseBodyResultContent() = default;
};
class SaveMgsApirestResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<SaveMgsApirestResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  SaveMgsApirestResponseBody() {}

  explicit SaveMgsApirestResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        SaveMgsApirestResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<SaveMgsApirestResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~SaveMgsApirestResponseBody() = default;
};
class SaveMgsApirestResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveMgsApirestResponseBody> body{};

  SaveMgsApirestResponse() {}

  explicit SaveMgsApirestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveMgsApirestResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveMgsApirestResponseBody>(model1);
      }
    }
  }


  virtual ~SaveMgsApirestResponse() = default;
};
class StartUserAppAsyncEnhanceInMsaRequest : public Darabonba::Model {
public:
  shared_ptr<bool> apkProtector{};
  shared_ptr<string> appId{};
  shared_ptr<string> assetsFileList{};
  shared_ptr<string> classes{};
  shared_ptr<long> dalvikDebugger{};
  shared_ptr<long> emulatorEnvironment{};
  shared_ptr<long> id{};
  shared_ptr<long> javaHook{};
  shared_ptr<long> memoryDump{};
  shared_ptr<long> nativeDebugger{};
  shared_ptr<long> nativeHook{};
  shared_ptr<long> packageTampered{};
  shared_ptr<long> root{};
  shared_ptr<string> runMode{};
  shared_ptr<string> soFileList{};
  shared_ptr<string> taskType{};
  shared_ptr<string> tenantId{};
  shared_ptr<bool> totalSwitch{};
  shared_ptr<bool> useAShield{};
  shared_ptr<string> workspaceId{};

  StartUserAppAsyncEnhanceInMsaRequest() {}

  explicit StartUserAppAsyncEnhanceInMsaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apkProtector) {
      res["ApkProtector"] = boost::any(*apkProtector);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (assetsFileList) {
      res["AssetsFileList"] = boost::any(*assetsFileList);
    }
    if (classes) {
      res["Classes"] = boost::any(*classes);
    }
    if (dalvikDebugger) {
      res["DalvikDebugger"] = boost::any(*dalvikDebugger);
    }
    if (emulatorEnvironment) {
      res["EmulatorEnvironment"] = boost::any(*emulatorEnvironment);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (javaHook) {
      res["JavaHook"] = boost::any(*javaHook);
    }
    if (memoryDump) {
      res["MemoryDump"] = boost::any(*memoryDump);
    }
    if (nativeDebugger) {
      res["NativeDebugger"] = boost::any(*nativeDebugger);
    }
    if (nativeHook) {
      res["NativeHook"] = boost::any(*nativeHook);
    }
    if (packageTampered) {
      res["PackageTampered"] = boost::any(*packageTampered);
    }
    if (root) {
      res["Root"] = boost::any(*root);
    }
    if (runMode) {
      res["RunMode"] = boost::any(*runMode);
    }
    if (soFileList) {
      res["SoFileList"] = boost::any(*soFileList);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (totalSwitch) {
      res["TotalSwitch"] = boost::any(*totalSwitch);
    }
    if (useAShield) {
      res["UseAShield"] = boost::any(*useAShield);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApkProtector") != m.end() && !m["ApkProtector"].empty()) {
      apkProtector = make_shared<bool>(boost::any_cast<bool>(m["ApkProtector"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AssetsFileList") != m.end() && !m["AssetsFileList"].empty()) {
      assetsFileList = make_shared<string>(boost::any_cast<string>(m["AssetsFileList"]));
    }
    if (m.find("Classes") != m.end() && !m["Classes"].empty()) {
      classes = make_shared<string>(boost::any_cast<string>(m["Classes"]));
    }
    if (m.find("DalvikDebugger") != m.end() && !m["DalvikDebugger"].empty()) {
      dalvikDebugger = make_shared<long>(boost::any_cast<long>(m["DalvikDebugger"]));
    }
    if (m.find("EmulatorEnvironment") != m.end() && !m["EmulatorEnvironment"].empty()) {
      emulatorEnvironment = make_shared<long>(boost::any_cast<long>(m["EmulatorEnvironment"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("JavaHook") != m.end() && !m["JavaHook"].empty()) {
      javaHook = make_shared<long>(boost::any_cast<long>(m["JavaHook"]));
    }
    if (m.find("MemoryDump") != m.end() && !m["MemoryDump"].empty()) {
      memoryDump = make_shared<long>(boost::any_cast<long>(m["MemoryDump"]));
    }
    if (m.find("NativeDebugger") != m.end() && !m["NativeDebugger"].empty()) {
      nativeDebugger = make_shared<long>(boost::any_cast<long>(m["NativeDebugger"]));
    }
    if (m.find("NativeHook") != m.end() && !m["NativeHook"].empty()) {
      nativeHook = make_shared<long>(boost::any_cast<long>(m["NativeHook"]));
    }
    if (m.find("PackageTampered") != m.end() && !m["PackageTampered"].empty()) {
      packageTampered = make_shared<long>(boost::any_cast<long>(m["PackageTampered"]));
    }
    if (m.find("Root") != m.end() && !m["Root"].empty()) {
      root = make_shared<long>(boost::any_cast<long>(m["Root"]));
    }
    if (m.find("RunMode") != m.end() && !m["RunMode"].empty()) {
      runMode = make_shared<string>(boost::any_cast<string>(m["RunMode"]));
    }
    if (m.find("SoFileList") != m.end() && !m["SoFileList"].empty()) {
      soFileList = make_shared<string>(boost::any_cast<string>(m["SoFileList"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("TotalSwitch") != m.end() && !m["TotalSwitch"].empty()) {
      totalSwitch = make_shared<bool>(boost::any_cast<bool>(m["TotalSwitch"]));
    }
    if (m.find("UseAShield") != m.end() && !m["UseAShield"].empty()) {
      useAShield = make_shared<bool>(boost::any_cast<bool>(m["UseAShield"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~StartUserAppAsyncEnhanceInMsaRequest() = default;
};
class StartUserAppAsyncEnhanceInMsaResponseBodyResultContentDataEnhanceMapping : public Darabonba::Model {
public:
  shared_ptr<string> info{};
  shared_ptr<string> reason{};
  shared_ptr<string> type{};

  StartUserAppAsyncEnhanceInMsaResponseBodyResultContentDataEnhanceMapping() {}

  explicit StartUserAppAsyncEnhanceInMsaResponseBodyResultContentDataEnhanceMapping(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = boost::any(*info);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      info = make_shared<string>(boost::any_cast<string>(m["Info"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~StartUserAppAsyncEnhanceInMsaResponseBodyResultContentDataEnhanceMapping() = default;
};
class StartUserAppAsyncEnhanceInMsaResponseBodyResultContentData : public Darabonba::Model {
public:
  shared_ptr<string> afterMd5{};
  shared_ptr<long> afterSize{};
  shared_ptr<string> appCode{};
  shared_ptr<string> appPackage{};
  shared_ptr<vector<string>> assetsFileList{};
  shared_ptr<string> beforeMd5{};
  shared_ptr<long> beforeSize{};
  shared_ptr<string> classForest{};
  shared_ptr<vector<StartUserAppAsyncEnhanceInMsaResponseBodyResultContentDataEnhanceMapping>> enhanceMapping{};
  shared_ptr<vector<string>> enhanceRules{};
  shared_ptr<vector<string>> enhancedAssetsFiles{};
  shared_ptr<vector<string>> enhancedClasses{};
  shared_ptr<vector<string>> enhancedSoFiles{};
  shared_ptr<long> id{};
  shared_ptr<string> label{};
  shared_ptr<long> progress{};
  shared_ptr<vector<string>> soFileList{};
  shared_ptr<long> status{};
  shared_ptr<string> taskType{};
  shared_ptr<string> versionCode{};
  shared_ptr<string> versionName{};

  StartUserAppAsyncEnhanceInMsaResponseBodyResultContentData() {}

  explicit StartUserAppAsyncEnhanceInMsaResponseBodyResultContentData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (afterMd5) {
      res["AfterMd5"] = boost::any(*afterMd5);
    }
    if (afterSize) {
      res["AfterSize"] = boost::any(*afterSize);
    }
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (appPackage) {
      res["AppPackage"] = boost::any(*appPackage);
    }
    if (assetsFileList) {
      res["AssetsFileList"] = boost::any(*assetsFileList);
    }
    if (beforeMd5) {
      res["BeforeMd5"] = boost::any(*beforeMd5);
    }
    if (beforeSize) {
      res["BeforeSize"] = boost::any(*beforeSize);
    }
    if (classForest) {
      res["ClassForest"] = boost::any(*classForest);
    }
    if (enhanceMapping) {
      vector<boost::any> temp1;
      for(auto item1:*enhanceMapping){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnhanceMapping"] = boost::any(temp1);
    }
    if (enhanceRules) {
      res["EnhanceRules"] = boost::any(*enhanceRules);
    }
    if (enhancedAssetsFiles) {
      res["EnhancedAssetsFiles"] = boost::any(*enhancedAssetsFiles);
    }
    if (enhancedClasses) {
      res["EnhancedClasses"] = boost::any(*enhancedClasses);
    }
    if (enhancedSoFiles) {
      res["EnhancedSoFiles"] = boost::any(*enhancedSoFiles);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (soFileList) {
      res["SoFileList"] = boost::any(*soFileList);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    if (versionName) {
      res["VersionName"] = boost::any(*versionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AfterMd5") != m.end() && !m["AfterMd5"].empty()) {
      afterMd5 = make_shared<string>(boost::any_cast<string>(m["AfterMd5"]));
    }
    if (m.find("AfterSize") != m.end() && !m["AfterSize"].empty()) {
      afterSize = make_shared<long>(boost::any_cast<long>(m["AfterSize"]));
    }
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("AppPackage") != m.end() && !m["AppPackage"].empty()) {
      appPackage = make_shared<string>(boost::any_cast<string>(m["AppPackage"]));
    }
    if (m.find("AssetsFileList") != m.end() && !m["AssetsFileList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AssetsFileList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AssetsFileList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      assetsFileList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("BeforeMd5") != m.end() && !m["BeforeMd5"].empty()) {
      beforeMd5 = make_shared<string>(boost::any_cast<string>(m["BeforeMd5"]));
    }
    if (m.find("BeforeSize") != m.end() && !m["BeforeSize"].empty()) {
      beforeSize = make_shared<long>(boost::any_cast<long>(m["BeforeSize"]));
    }
    if (m.find("ClassForest") != m.end() && !m["ClassForest"].empty()) {
      classForest = make_shared<string>(boost::any_cast<string>(m["ClassForest"]));
    }
    if (m.find("EnhanceMapping") != m.end() && !m["EnhanceMapping"].empty()) {
      if (typeid(vector<boost::any>) == m["EnhanceMapping"].type()) {
        vector<StartUserAppAsyncEnhanceInMsaResponseBodyResultContentDataEnhanceMapping> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnhanceMapping"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartUserAppAsyncEnhanceInMsaResponseBodyResultContentDataEnhanceMapping model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        enhanceMapping = make_shared<vector<StartUserAppAsyncEnhanceInMsaResponseBodyResultContentDataEnhanceMapping>>(expect1);
      }
    }
    if (m.find("EnhanceRules") != m.end() && !m["EnhanceRules"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnhanceRules"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnhanceRules"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      enhanceRules = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnhancedAssetsFiles") != m.end() && !m["EnhancedAssetsFiles"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnhancedAssetsFiles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnhancedAssetsFiles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      enhancedAssetsFiles = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnhancedClasses") != m.end() && !m["EnhancedClasses"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnhancedClasses"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnhancedClasses"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      enhancedClasses = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnhancedSoFiles") != m.end() && !m["EnhancedSoFiles"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnhancedSoFiles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnhancedSoFiles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      enhancedSoFiles = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("SoFileList") != m.end() && !m["SoFileList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SoFileList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SoFileList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      soFileList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
    if (m.find("VersionName") != m.end() && !m["VersionName"].empty()) {
      versionName = make_shared<string>(boost::any_cast<string>(m["VersionName"]));
    }
  }


  virtual ~StartUserAppAsyncEnhanceInMsaResponseBodyResultContentData() = default;
};
class StartUserAppAsyncEnhanceInMsaResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<StartUserAppAsyncEnhanceInMsaResponseBodyResultContentData> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  StartUserAppAsyncEnhanceInMsaResponseBodyResultContent() {}

  explicit StartUserAppAsyncEnhanceInMsaResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        StartUserAppAsyncEnhanceInMsaResponseBodyResultContentData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<StartUserAppAsyncEnhanceInMsaResponseBodyResultContentData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~StartUserAppAsyncEnhanceInMsaResponseBodyResultContent() = default;
};
class StartUserAppAsyncEnhanceInMsaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<StartUserAppAsyncEnhanceInMsaResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  StartUserAppAsyncEnhanceInMsaResponseBody() {}

  explicit StartUserAppAsyncEnhanceInMsaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        StartUserAppAsyncEnhanceInMsaResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<StartUserAppAsyncEnhanceInMsaResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~StartUserAppAsyncEnhanceInMsaResponseBody() = default;
};
class StartUserAppAsyncEnhanceInMsaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartUserAppAsyncEnhanceInMsaResponseBody> body{};

  StartUserAppAsyncEnhanceInMsaResponse() {}

  explicit StartUserAppAsyncEnhanceInMsaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartUserAppAsyncEnhanceInMsaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartUserAppAsyncEnhanceInMsaResponseBody>(model1);
      }
    }
  }


  virtual ~StartUserAppAsyncEnhanceInMsaResponse() = default;
};
class UpdateMcubeWhitelistRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> id{};
  shared_ptr<string> keyIds{};
  shared_ptr<bool> onexFlag{};
  shared_ptr<string> ossUrl{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  UpdateMcubeWhitelistRequest() {}

  explicit UpdateMcubeWhitelistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (keyIds) {
      res["KeyIds"] = boost::any(*keyIds);
    }
    if (onexFlag) {
      res["OnexFlag"] = boost::any(*onexFlag);
    }
    if (ossUrl) {
      res["OssUrl"] = boost::any(*ossUrl);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("KeyIds") != m.end() && !m["KeyIds"].empty()) {
      keyIds = make_shared<string>(boost::any_cast<string>(m["KeyIds"]));
    }
    if (m.find("OnexFlag") != m.end() && !m["OnexFlag"].empty()) {
      onexFlag = make_shared<bool>(boost::any_cast<bool>(m["OnexFlag"]));
    }
    if (m.find("OssUrl") != m.end() && !m["OssUrl"].empty()) {
      ossUrl = make_shared<string>(boost::any_cast<string>(m["OssUrl"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~UpdateMcubeWhitelistRequest() = default;
};
class UpdateMcubeWhitelistResponseBodyAddWhitelistResultAddWhitelistInfo : public Darabonba::Model {
public:
  shared_ptr<long> failNum{};
  shared_ptr<string> failUserIds{};
  shared_ptr<long> successNum{};

  UpdateMcubeWhitelistResponseBodyAddWhitelistResultAddWhitelistInfo() {}

  explicit UpdateMcubeWhitelistResponseBodyAddWhitelistResultAddWhitelistInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failNum) {
      res["FailNum"] = boost::any(*failNum);
    }
    if (failUserIds) {
      res["FailUserIds"] = boost::any(*failUserIds);
    }
    if (successNum) {
      res["SuccessNum"] = boost::any(*successNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailNum") != m.end() && !m["FailNum"].empty()) {
      failNum = make_shared<long>(boost::any_cast<long>(m["FailNum"]));
    }
    if (m.find("FailUserIds") != m.end() && !m["FailUserIds"].empty()) {
      failUserIds = make_shared<string>(boost::any_cast<string>(m["FailUserIds"]));
    }
    if (m.find("SuccessNum") != m.end() && !m["SuccessNum"].empty()) {
      successNum = make_shared<long>(boost::any_cast<long>(m["SuccessNum"]));
    }
  }


  virtual ~UpdateMcubeWhitelistResponseBodyAddWhitelistResultAddWhitelistInfo() = default;
};
class UpdateMcubeWhitelistResponseBodyAddWhitelistResult : public Darabonba::Model {
public:
  shared_ptr<UpdateMcubeWhitelistResponseBodyAddWhitelistResultAddWhitelistInfo> addWhitelistInfo{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  UpdateMcubeWhitelistResponseBodyAddWhitelistResult() {}

  explicit UpdateMcubeWhitelistResponseBodyAddWhitelistResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addWhitelistInfo) {
      res["AddWhitelistInfo"] = addWhitelistInfo ? boost::any(addWhitelistInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddWhitelistInfo") != m.end() && !m["AddWhitelistInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["AddWhitelistInfo"].type()) {
        UpdateMcubeWhitelistResponseBodyAddWhitelistResultAddWhitelistInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AddWhitelistInfo"]));
        addWhitelistInfo = make_shared<UpdateMcubeWhitelistResponseBodyAddWhitelistResultAddWhitelistInfo>(model1);
      }
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateMcubeWhitelistResponseBodyAddWhitelistResult() = default;
};
class UpdateMcubeWhitelistResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateMcubeWhitelistResponseBodyAddWhitelistResult> addWhitelistResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};

  UpdateMcubeWhitelistResponseBody() {}

  explicit UpdateMcubeWhitelistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addWhitelistResult) {
      res["AddWhitelistResult"] = addWhitelistResult ? boost::any(addWhitelistResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddWhitelistResult") != m.end() && !m["AddWhitelistResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["AddWhitelistResult"].type()) {
        UpdateMcubeWhitelistResponseBodyAddWhitelistResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AddWhitelistResult"]));
        addWhitelistResult = make_shared<UpdateMcubeWhitelistResponseBodyAddWhitelistResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~UpdateMcubeWhitelistResponseBody() = default;
};
class UpdateMcubeWhitelistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMcubeWhitelistResponseBody> body{};

  UpdateMcubeWhitelistResponse() {}

  explicit UpdateMcubeWhitelistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMcubeWhitelistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMcubeWhitelistResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMcubeWhitelistResponse() = default;
};
class UpdateMpaasAppInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> iconFileUrl{};
  shared_ptr<string> identifier{};
  shared_ptr<bool> onexFlag{};
  shared_ptr<string> systemType{};
  shared_ptr<string> tenantId{};

  UpdateMpaasAppInfoRequest() {}

  explicit UpdateMpaasAppInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (iconFileUrl) {
      res["IconFileUrl"] = boost::any(*iconFileUrl);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (onexFlag) {
      res["OnexFlag"] = boost::any(*onexFlag);
    }
    if (systemType) {
      res["SystemType"] = boost::any(*systemType);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("IconFileUrl") != m.end() && !m["IconFileUrl"].empty()) {
      iconFileUrl = make_shared<string>(boost::any_cast<string>(m["IconFileUrl"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("OnexFlag") != m.end() && !m["OnexFlag"].empty()) {
      onexFlag = make_shared<bool>(boost::any_cast<bool>(m["OnexFlag"]));
    }
    if (m.find("SystemType") != m.end() && !m["SystemType"].empty()) {
      systemType = make_shared<string>(boost::any_cast<string>(m["SystemType"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~UpdateMpaasAppInfoRequest() = default;
};
class UpdateMpaasAppInfoResponseBodyResultContentData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  UpdateMpaasAppInfoResponseBodyResultContentData() {}

  explicit UpdateMpaasAppInfoResponseBodyResultContentData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateMpaasAppInfoResponseBodyResultContentData() = default;
};
class UpdateMpaasAppInfoResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<UpdateMpaasAppInfoResponseBodyResultContentData> data{};
  shared_ptr<string> requestId{};

  UpdateMpaasAppInfoResponseBodyResultContent() {}

  explicit UpdateMpaasAppInfoResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateMpaasAppInfoResponseBodyResultContentData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateMpaasAppInfoResponseBodyResultContentData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMpaasAppInfoResponseBodyResultContent() = default;
};
class UpdateMpaasAppInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<UpdateMpaasAppInfoResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  UpdateMpaasAppInfoResponseBody() {}

  explicit UpdateMpaasAppInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        UpdateMpaasAppInfoResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<UpdateMpaasAppInfoResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~UpdateMpaasAppInfoResponseBody() = default;
};
class UpdateMpaasAppInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMpaasAppInfoResponseBody> body{};

  UpdateMpaasAppInfoResponse() {}

  explicit UpdateMpaasAppInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMpaasAppInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMpaasAppInfoResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMpaasAppInfoResponse() = default;
};
class UploadBitcodeToMsaRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> bitcode{};
  shared_ptr<string> codeVersion{};
  shared_ptr<string> license{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> type{};
  shared_ptr<string> workspaceId{};

  UploadBitcodeToMsaRequest() {}

  explicit UploadBitcodeToMsaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (bitcode) {
      res["Bitcode"] = boost::any(*bitcode);
    }
    if (codeVersion) {
      res["CodeVersion"] = boost::any(*codeVersion);
    }
    if (license) {
      res["License"] = boost::any(*license);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Bitcode") != m.end() && !m["Bitcode"].empty()) {
      bitcode = make_shared<string>(boost::any_cast<string>(m["Bitcode"]));
    }
    if (m.find("CodeVersion") != m.end() && !m["CodeVersion"].empty()) {
      codeVersion = make_shared<string>(boost::any_cast<string>(m["CodeVersion"]));
    }
    if (m.find("License") != m.end() && !m["License"].empty()) {
      license = make_shared<string>(boost::any_cast<string>(m["License"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~UploadBitcodeToMsaRequest() = default;
};
class UploadBitcodeToMsaResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  UploadBitcodeToMsaResponseBodyResultContent() {}

  explicit UploadBitcodeToMsaResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UploadBitcodeToMsaResponseBodyResultContent() = default;
};
class UploadBitcodeToMsaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<UploadBitcodeToMsaResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  UploadBitcodeToMsaResponseBody() {}

  explicit UploadBitcodeToMsaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        UploadBitcodeToMsaResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<UploadBitcodeToMsaResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~UploadBitcodeToMsaResponseBody() = default;
};
class UploadBitcodeToMsaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadBitcodeToMsaResponseBody> body{};

  UploadBitcodeToMsaResponse() {}

  explicit UploadBitcodeToMsaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadBitcodeToMsaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadBitcodeToMsaResponseBody>(model1);
      }
    }
  }


  virtual ~UploadBitcodeToMsaResponse() = default;
};
class UploadMcubeMiniPackageRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> autoInstall{};
  shared_ptr<string> clientVersionMax{};
  shared_ptr<string> clientVersionMin{};
  shared_ptr<string> enableKeepAlive{};
  shared_ptr<string> enableOptionMenu{};
  shared_ptr<long> enableTabBar{};
  shared_ptr<string> extendInfo{};
  shared_ptr<string> h5Id{};
  shared_ptr<string> h5Name{};
  shared_ptr<string> h5Version{};
  shared_ptr<string> iconFileUrl{};
  shared_ptr<string> iconUrl{};
  shared_ptr<long> installType{};
  shared_ptr<string> mainUrl{};
  shared_ptr<bool> onexFlag{};
  shared_ptr<long> packageType{};
  shared_ptr<string> platform{};
  shared_ptr<string> resourceFileUrl{};
  shared_ptr<long> resourceType{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> userId{};
  shared_ptr<string> uuid{};
  shared_ptr<string> vhost{};
  shared_ptr<string> workspaceId{};

  UploadMcubeMiniPackageRequest() {}

  explicit UploadMcubeMiniPackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (autoInstall) {
      res["AutoInstall"] = boost::any(*autoInstall);
    }
    if (clientVersionMax) {
      res["ClientVersionMax"] = boost::any(*clientVersionMax);
    }
    if (clientVersionMin) {
      res["ClientVersionMin"] = boost::any(*clientVersionMin);
    }
    if (enableKeepAlive) {
      res["EnableKeepAlive"] = boost::any(*enableKeepAlive);
    }
    if (enableOptionMenu) {
      res["EnableOptionMenu"] = boost::any(*enableOptionMenu);
    }
    if (enableTabBar) {
      res["EnableTabBar"] = boost::any(*enableTabBar);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (h5Id) {
      res["H5Id"] = boost::any(*h5Id);
    }
    if (h5Name) {
      res["H5Name"] = boost::any(*h5Name);
    }
    if (h5Version) {
      res["H5Version"] = boost::any(*h5Version);
    }
    if (iconFileUrl) {
      res["IconFileUrl"] = boost::any(*iconFileUrl);
    }
    if (iconUrl) {
      res["IconUrl"] = boost::any(*iconUrl);
    }
    if (installType) {
      res["InstallType"] = boost::any(*installType);
    }
    if (mainUrl) {
      res["MainUrl"] = boost::any(*mainUrl);
    }
    if (onexFlag) {
      res["OnexFlag"] = boost::any(*onexFlag);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (resourceFileUrl) {
      res["ResourceFileUrl"] = boost::any(*resourceFileUrl);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (vhost) {
      res["Vhost"] = boost::any(*vhost);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AutoInstall") != m.end() && !m["AutoInstall"].empty()) {
      autoInstall = make_shared<long>(boost::any_cast<long>(m["AutoInstall"]));
    }
    if (m.find("ClientVersionMax") != m.end() && !m["ClientVersionMax"].empty()) {
      clientVersionMax = make_shared<string>(boost::any_cast<string>(m["ClientVersionMax"]));
    }
    if (m.find("ClientVersionMin") != m.end() && !m["ClientVersionMin"].empty()) {
      clientVersionMin = make_shared<string>(boost::any_cast<string>(m["ClientVersionMin"]));
    }
    if (m.find("EnableKeepAlive") != m.end() && !m["EnableKeepAlive"].empty()) {
      enableKeepAlive = make_shared<string>(boost::any_cast<string>(m["EnableKeepAlive"]));
    }
    if (m.find("EnableOptionMenu") != m.end() && !m["EnableOptionMenu"].empty()) {
      enableOptionMenu = make_shared<string>(boost::any_cast<string>(m["EnableOptionMenu"]));
    }
    if (m.find("EnableTabBar") != m.end() && !m["EnableTabBar"].empty()) {
      enableTabBar = make_shared<long>(boost::any_cast<long>(m["EnableTabBar"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      extendInfo = make_shared<string>(boost::any_cast<string>(m["ExtendInfo"]));
    }
    if (m.find("H5Id") != m.end() && !m["H5Id"].empty()) {
      h5Id = make_shared<string>(boost::any_cast<string>(m["H5Id"]));
    }
    if (m.find("H5Name") != m.end() && !m["H5Name"].empty()) {
      h5Name = make_shared<string>(boost::any_cast<string>(m["H5Name"]));
    }
    if (m.find("H5Version") != m.end() && !m["H5Version"].empty()) {
      h5Version = make_shared<string>(boost::any_cast<string>(m["H5Version"]));
    }
    if (m.find("IconFileUrl") != m.end() && !m["IconFileUrl"].empty()) {
      iconFileUrl = make_shared<string>(boost::any_cast<string>(m["IconFileUrl"]));
    }
    if (m.find("IconUrl") != m.end() && !m["IconUrl"].empty()) {
      iconUrl = make_shared<string>(boost::any_cast<string>(m["IconUrl"]));
    }
    if (m.find("InstallType") != m.end() && !m["InstallType"].empty()) {
      installType = make_shared<long>(boost::any_cast<long>(m["InstallType"]));
    }
    if (m.find("MainUrl") != m.end() && !m["MainUrl"].empty()) {
      mainUrl = make_shared<string>(boost::any_cast<string>(m["MainUrl"]));
    }
    if (m.find("OnexFlag") != m.end() && !m["OnexFlag"].empty()) {
      onexFlag = make_shared<bool>(boost::any_cast<bool>(m["OnexFlag"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<long>(boost::any_cast<long>(m["PackageType"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("ResourceFileUrl") != m.end() && !m["ResourceFileUrl"].empty()) {
      resourceFileUrl = make_shared<string>(boost::any_cast<string>(m["ResourceFileUrl"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<long>(boost::any_cast<long>(m["ResourceType"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Vhost") != m.end() && !m["Vhost"].empty()) {
      vhost = make_shared<string>(boost::any_cast<string>(m["Vhost"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~UploadMcubeMiniPackageRequest() = default;
};
class UploadMcubeMiniPackageResponseBodyUploadMiniPackageResultReturnPackageResult : public Darabonba::Model {
public:
  shared_ptr<string> debugUrl{};
  shared_ptr<string> packageId{};
  shared_ptr<string> userId{};

  UploadMcubeMiniPackageResponseBodyUploadMiniPackageResultReturnPackageResult() {}

  explicit UploadMcubeMiniPackageResponseBodyUploadMiniPackageResultReturnPackageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (debugUrl) {
      res["DebugUrl"] = boost::any(*debugUrl);
    }
    if (packageId) {
      res["PackageId"] = boost::any(*packageId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DebugUrl") != m.end() && !m["DebugUrl"].empty()) {
      debugUrl = make_shared<string>(boost::any_cast<string>(m["DebugUrl"]));
    }
    if (m.find("PackageId") != m.end() && !m["PackageId"].empty()) {
      packageId = make_shared<string>(boost::any_cast<string>(m["PackageId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~UploadMcubeMiniPackageResponseBodyUploadMiniPackageResultReturnPackageResult() = default;
};
class UploadMcubeMiniPackageResponseBodyUploadMiniPackageResult : public Darabonba::Model {
public:
  shared_ptr<string> resultMsg{};
  shared_ptr<UploadMcubeMiniPackageResponseBodyUploadMiniPackageResultReturnPackageResult> returnPackageResult{};
  shared_ptr<bool> success{};

  UploadMcubeMiniPackageResponseBodyUploadMiniPackageResult() {}

  explicit UploadMcubeMiniPackageResponseBodyUploadMiniPackageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (returnPackageResult) {
      res["ReturnPackageResult"] = returnPackageResult ? boost::any(returnPackageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("ReturnPackageResult") != m.end() && !m["ReturnPackageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReturnPackageResult"].type()) {
        UploadMcubeMiniPackageResponseBodyUploadMiniPackageResultReturnPackageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReturnPackageResult"]));
        returnPackageResult = make_shared<UploadMcubeMiniPackageResponseBodyUploadMiniPackageResultReturnPackageResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UploadMcubeMiniPackageResponseBodyUploadMiniPackageResult() = default;
};
class UploadMcubeMiniPackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<UploadMcubeMiniPackageResponseBodyUploadMiniPackageResult> uploadMiniPackageResult{};

  UploadMcubeMiniPackageResponseBody() {}

  explicit UploadMcubeMiniPackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (uploadMiniPackageResult) {
      res["UploadMiniPackageResult"] = uploadMiniPackageResult ? boost::any(uploadMiniPackageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("UploadMiniPackageResult") != m.end() && !m["UploadMiniPackageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["UploadMiniPackageResult"].type()) {
        UploadMcubeMiniPackageResponseBodyUploadMiniPackageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UploadMiniPackageResult"]));
        uploadMiniPackageResult = make_shared<UploadMcubeMiniPackageResponseBodyUploadMiniPackageResult>(model1);
      }
    }
  }


  virtual ~UploadMcubeMiniPackageResponseBody() = default;
};
class UploadMcubeMiniPackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadMcubeMiniPackageResponseBody> body{};

  UploadMcubeMiniPackageResponse() {}

  explicit UploadMcubeMiniPackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadMcubeMiniPackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadMcubeMiniPackageResponseBody>(model1);
      }
    }
  }


  virtual ~UploadMcubeMiniPackageResponse() = default;
};
class UploadMcubeRsaKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> fileUrl{};
  shared_ptr<bool> onexFlag{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  UploadMcubeRsaKeyRequest() {}

  explicit UploadMcubeRsaKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (onexFlag) {
      res["OnexFlag"] = boost::any(*onexFlag);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("OnexFlag") != m.end() && !m["OnexFlag"].empty()) {
      onexFlag = make_shared<bool>(boost::any_cast<bool>(m["OnexFlag"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~UploadMcubeRsaKeyRequest() = default;
};
class UploadMcubeRsaKeyResponseBodyUploadRsaResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> resultMsg{};
  shared_ptr<bool> success{};

  UploadMcubeRsaKeyResponseBodyUploadRsaResult() {}

  explicit UploadMcubeRsaKeyResponseBodyUploadRsaResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UploadMcubeRsaKeyResponseBodyUploadRsaResult() = default;
};
class UploadMcubeRsaKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<UploadMcubeRsaKeyResponseBodyUploadRsaResult> uploadRsaResult{};

  UploadMcubeRsaKeyResponseBody() {}

  explicit UploadMcubeRsaKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (uploadRsaResult) {
      res["UploadRsaResult"] = uploadRsaResult ? boost::any(uploadRsaResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("UploadRsaResult") != m.end() && !m["UploadRsaResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["UploadRsaResult"].type()) {
        UploadMcubeRsaKeyResponseBodyUploadRsaResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UploadRsaResult"]));
        uploadRsaResult = make_shared<UploadMcubeRsaKeyResponseBodyUploadRsaResult>(model1);
      }
    }
  }


  virtual ~UploadMcubeRsaKeyResponseBody() = default;
};
class UploadMcubeRsaKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadMcubeRsaKeyResponseBody> body{};

  UploadMcubeRsaKeyResponse() {}

  explicit UploadMcubeRsaKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadMcubeRsaKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadMcubeRsaKeyResponseBody>(model1);
      }
    }
  }


  virtual ~UploadMcubeRsaKeyResponse() = default;
};
class UploadUserAppToMsaRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> workspaceId{};

  UploadUserAppToMsaRequest() {}

  explicit UploadUserAppToMsaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~UploadUserAppToMsaRequest() = default;
};
class UploadUserAppToMsaResponseBodyResultContentDataApkInfoEnhanceMapping : public Darabonba::Model {
public:
  shared_ptr<string> info{};
  shared_ptr<string> reason{};
  shared_ptr<string> type{};

  UploadUserAppToMsaResponseBodyResultContentDataApkInfoEnhanceMapping() {}

  explicit UploadUserAppToMsaResponseBodyResultContentDataApkInfoEnhanceMapping(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = boost::any(*info);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      info = make_shared<string>(boost::any_cast<string>(m["Info"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UploadUserAppToMsaResponseBodyResultContentDataApkInfoEnhanceMapping() = default;
};
class UploadUserAppToMsaResponseBodyResultContentDataApkInfo : public Darabonba::Model {
public:
  shared_ptr<string> afterMd5{};
  shared_ptr<long> afterSize{};
  shared_ptr<string> appCode{};
  shared_ptr<string> appPackage{};
  shared_ptr<string> beforeMd5{};
  shared_ptr<long> beforeSize{};
  shared_ptr<string> classForest{};
  shared_ptr<UploadUserAppToMsaResponseBodyResultContentDataApkInfoEnhanceMapping> enhanceMapping{};
  shared_ptr<vector<string>> enhanceRules{};
  shared_ptr<vector<string>> enhancedClasses{};
  shared_ptr<long> id{};
  shared_ptr<string> label{};
  shared_ptr<long> progress{};
  shared_ptr<long> status{};
  shared_ptr<string> taskType{};
  shared_ptr<string> versionCode{};
  shared_ptr<string> versionName{};

  UploadUserAppToMsaResponseBodyResultContentDataApkInfo() {}

  explicit UploadUserAppToMsaResponseBodyResultContentDataApkInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (afterMd5) {
      res["AfterMd5"] = boost::any(*afterMd5);
    }
    if (afterSize) {
      res["AfterSize"] = boost::any(*afterSize);
    }
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (appPackage) {
      res["AppPackage"] = boost::any(*appPackage);
    }
    if (beforeMd5) {
      res["BeforeMd5"] = boost::any(*beforeMd5);
    }
    if (beforeSize) {
      res["BeforeSize"] = boost::any(*beforeSize);
    }
    if (classForest) {
      res["ClassForest"] = boost::any(*classForest);
    }
    if (enhanceMapping) {
      res["EnhanceMapping"] = enhanceMapping ? boost::any(enhanceMapping->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (enhanceRules) {
      res["EnhanceRules"] = boost::any(*enhanceRules);
    }
    if (enhancedClasses) {
      res["EnhancedClasses"] = boost::any(*enhancedClasses);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    if (versionName) {
      res["VersionName"] = boost::any(*versionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AfterMd5") != m.end() && !m["AfterMd5"].empty()) {
      afterMd5 = make_shared<string>(boost::any_cast<string>(m["AfterMd5"]));
    }
    if (m.find("AfterSize") != m.end() && !m["AfterSize"].empty()) {
      afterSize = make_shared<long>(boost::any_cast<long>(m["AfterSize"]));
    }
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("AppPackage") != m.end() && !m["AppPackage"].empty()) {
      appPackage = make_shared<string>(boost::any_cast<string>(m["AppPackage"]));
    }
    if (m.find("BeforeMd5") != m.end() && !m["BeforeMd5"].empty()) {
      beforeMd5 = make_shared<string>(boost::any_cast<string>(m["BeforeMd5"]));
    }
    if (m.find("BeforeSize") != m.end() && !m["BeforeSize"].empty()) {
      beforeSize = make_shared<long>(boost::any_cast<long>(m["BeforeSize"]));
    }
    if (m.find("ClassForest") != m.end() && !m["ClassForest"].empty()) {
      classForest = make_shared<string>(boost::any_cast<string>(m["ClassForest"]));
    }
    if (m.find("EnhanceMapping") != m.end() && !m["EnhanceMapping"].empty()) {
      if (typeid(map<string, boost::any>) == m["EnhanceMapping"].type()) {
        UploadUserAppToMsaResponseBodyResultContentDataApkInfoEnhanceMapping model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EnhanceMapping"]));
        enhanceMapping = make_shared<UploadUserAppToMsaResponseBodyResultContentDataApkInfoEnhanceMapping>(model1);
      }
    }
    if (m.find("EnhanceRules") != m.end() && !m["EnhanceRules"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnhanceRules"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnhanceRules"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      enhanceRules = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnhancedClasses") != m.end() && !m["EnhancedClasses"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnhancedClasses"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnhancedClasses"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      enhancedClasses = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
    if (m.find("VersionName") != m.end() && !m["VersionName"].empty()) {
      versionName = make_shared<string>(boost::any_cast<string>(m["VersionName"]));
    }
  }


  virtual ~UploadUserAppToMsaResponseBodyResultContentDataApkInfo() = default;
};
class UploadUserAppToMsaResponseBodyResultContentData : public Darabonba::Model {
public:
  shared_ptr<UploadUserAppToMsaResponseBodyResultContentDataApkInfo> apkInfo{};
  shared_ptr<long> enhanceTaskId{};
  shared_ptr<long> id{};
  shared_ptr<long> progress{};
  shared_ptr<long> status{};

  UploadUserAppToMsaResponseBodyResultContentData() {}

  explicit UploadUserAppToMsaResponseBodyResultContentData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apkInfo) {
      res["ApkInfo"] = apkInfo ? boost::any(apkInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (enhanceTaskId) {
      res["EnhanceTaskId"] = boost::any(*enhanceTaskId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApkInfo") != m.end() && !m["ApkInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApkInfo"].type()) {
        UploadUserAppToMsaResponseBodyResultContentDataApkInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApkInfo"]));
        apkInfo = make_shared<UploadUserAppToMsaResponseBodyResultContentDataApkInfo>(model1);
      }
    }
    if (m.find("EnhanceTaskId") != m.end() && !m["EnhanceTaskId"].empty()) {
      enhanceTaskId = make_shared<long>(boost::any_cast<long>(m["EnhanceTaskId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~UploadUserAppToMsaResponseBodyResultContentData() = default;
};
class UploadUserAppToMsaResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<UploadUserAppToMsaResponseBodyResultContentData> data{};
  shared_ptr<string> extra{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  UploadUserAppToMsaResponseBodyResultContent() {}

  explicit UploadUserAppToMsaResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UploadUserAppToMsaResponseBodyResultContentData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UploadUserAppToMsaResponseBodyResultContentData>(model1);
      }
    }
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["Extra"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UploadUserAppToMsaResponseBodyResultContent() = default;
};
class UploadUserAppToMsaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultCode{};
  shared_ptr<UploadUserAppToMsaResponseBodyResultContent> resultContent{};
  shared_ptr<string> resultMessage{};

  UploadUserAppToMsaResponseBody() {}

  explicit UploadUserAppToMsaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultContent) {
      res["ResultContent"] = resultContent ? boost::any(resultContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultContent") != m.end() && !m["ResultContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultContent"].type()) {
        UploadUserAppToMsaResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultContent"]));
        resultContent = make_shared<UploadUserAppToMsaResponseBodyResultContent>(model1);
      }
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
  }


  virtual ~UploadUserAppToMsaResponseBody() = default;
};
class UploadUserAppToMsaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadUserAppToMsaResponseBody> body{};

  UploadUserAppToMsaResponse() {}

  explicit UploadUserAppToMsaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadUserAppToMsaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadUserAppToMsaResponseBody>(model1);
      }
    }
  }


  virtual ~UploadUserAppToMsaResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddMdsMiniConfigResponse addMdsMiniConfigWithOptions(shared_ptr<AddMdsMiniConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddMdsMiniConfigResponse addMdsMiniConfig(shared_ptr<AddMdsMiniConfigRequest> request);
  CancelPushSchedulerResponse cancelPushSchedulerWithOptions(shared_ptr<CancelPushSchedulerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelPushSchedulerResponse cancelPushScheduler(shared_ptr<CancelPushSchedulerRequest> request);
  ChangeMcubeMiniTaskStatusResponse changeMcubeMiniTaskStatusWithOptions(shared_ptr<ChangeMcubeMiniTaskStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeMcubeMiniTaskStatusResponse changeMcubeMiniTaskStatus(shared_ptr<ChangeMcubeMiniTaskStatusRequest> request);
  ChangeMcubeNebulaTaskStatusResponse changeMcubeNebulaTaskStatusWithOptions(shared_ptr<ChangeMcubeNebulaTaskStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeMcubeNebulaTaskStatusResponse changeMcubeNebulaTaskStatus(shared_ptr<ChangeMcubeNebulaTaskStatusRequest> request);
  ChangeMcubePublicTaskStatusResponse changeMcubePublicTaskStatusWithOptions(shared_ptr<ChangeMcubePublicTaskStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeMcubePublicTaskStatusResponse changeMcubePublicTaskStatus(shared_ptr<ChangeMcubePublicTaskStatusRequest> request);
  CopyMcdpGroupResponse copyMcdpGroupWithOptions(shared_ptr<CopyMcdpGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopyMcdpGroupResponse copyMcdpGroup(shared_ptr<CopyMcdpGroupRequest> request);
  CreateMasCrowdResponse createMasCrowdWithOptions(shared_ptr<CreateMasCrowdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMasCrowdResponse createMasCrowd(shared_ptr<CreateMasCrowdRequest> request);
  CreateMasFunnelResponse createMasFunnelWithOptions(shared_ptr<CreateMasFunnelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMasFunnelResponse createMasFunnel(shared_ptr<CreateMasFunnelRequest> request);
  CreateMcdpEventResponse createMcdpEventWithOptions(shared_ptr<CreateMcdpEventRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMcdpEventResponse createMcdpEvent(shared_ptr<CreateMcdpEventRequest> request);
  CreateMcdpEventAttributeResponse createMcdpEventAttributeWithOptions(shared_ptr<CreateMcdpEventAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMcdpEventAttributeResponse createMcdpEventAttribute(shared_ptr<CreateMcdpEventAttributeRequest> request);
  CreateMcdpGroupResponse createMcdpGroupWithOptions(shared_ptr<CreateMcdpGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMcdpGroupResponse createMcdpGroup(shared_ptr<CreateMcdpGroupRequest> request);
  CreateMcdpMaterialResponse createMcdpMaterialWithOptions(shared_ptr<CreateMcdpMaterialRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMcdpMaterialResponse createMcdpMaterial(shared_ptr<CreateMcdpMaterialRequest> request);
  CreateMcdpZoneResponse createMcdpZoneWithOptions(shared_ptr<CreateMcdpZoneRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMcdpZoneResponse createMcdpZone(shared_ptr<CreateMcdpZoneRequest> request);
  CreateMcubeMiniAppResponse createMcubeMiniAppWithOptions(shared_ptr<CreateMcubeMiniAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMcubeMiniAppResponse createMcubeMiniApp(shared_ptr<CreateMcubeMiniAppRequest> request);
  CreateMcubeMiniTaskResponse createMcubeMiniTaskWithOptions(shared_ptr<CreateMcubeMiniTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMcubeMiniTaskResponse createMcubeMiniTask(shared_ptr<CreateMcubeMiniTaskRequest> request);
  CreateMcubeNebulaAppResponse createMcubeNebulaAppWithOptions(shared_ptr<CreateMcubeNebulaAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMcubeNebulaAppResponse createMcubeNebulaApp(shared_ptr<CreateMcubeNebulaAppRequest> request);
  CreateMcubeNebulaResourceResponse createMcubeNebulaResourceWithOptions(shared_ptr<CreateMcubeNebulaResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMcubeNebulaResourceResponse createMcubeNebulaResource(shared_ptr<CreateMcubeNebulaResourceRequest> request);
  CreateMcubeNebulaTaskResponse createMcubeNebulaTaskWithOptions(shared_ptr<CreateMcubeNebulaTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMcubeNebulaTaskResponse createMcubeNebulaTask(shared_ptr<CreateMcubeNebulaTaskRequest> request);
  CreateMcubeUpgradePackageResponse createMcubeUpgradePackageWithOptions(shared_ptr<CreateMcubeUpgradePackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMcubeUpgradePackageResponse createMcubeUpgradePackage(shared_ptr<CreateMcubeUpgradePackageRequest> request);
  CreateMcubeUpgradeTaskResponse createMcubeUpgradeTaskWithOptions(shared_ptr<CreateMcubeUpgradeTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMcubeUpgradeTaskResponse createMcubeUpgradeTask(shared_ptr<CreateMcubeUpgradeTaskRequest> request);
  CreateMcubeVhostResponse createMcubeVhostWithOptions(shared_ptr<CreateMcubeVhostRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMcubeVhostResponse createMcubeVhost(shared_ptr<CreateMcubeVhostRequest> request);
  CreateMcubeWhitelistResponse createMcubeWhitelistWithOptions(shared_ptr<CreateMcubeWhitelistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMcubeWhitelistResponse createMcubeWhitelist(shared_ptr<CreateMcubeWhitelistRequest> request);
  CreateMcubeWhitelistForIdeResponse createMcubeWhitelistForIdeWithOptions(shared_ptr<CreateMcubeWhitelistForIdeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMcubeWhitelistForIdeResponse createMcubeWhitelistForIde(shared_ptr<CreateMcubeWhitelistForIdeRequest> request);
  CreateMdsMiniprogramTaskResponse createMdsMiniprogramTaskWithOptions(shared_ptr<CreateMdsMiniprogramTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMdsMiniprogramTaskResponse createMdsMiniprogramTask(shared_ptr<CreateMdsMiniprogramTaskRequest> request);
  CreateMsaEnhanceResponse createMsaEnhanceWithOptions(shared_ptr<CreateMsaEnhanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMsaEnhanceResponse createMsaEnhance(shared_ptr<CreateMsaEnhanceRequest> request);
  CreateOpenGlobalDataResponse createOpenGlobalDataWithOptions(shared_ptr<CreateOpenGlobalDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOpenGlobalDataResponse createOpenGlobalData(shared_ptr<CreateOpenGlobalDataRequest> request);
  CreateOpenSingleDataResponse createOpenSingleDataWithOptions(shared_ptr<CreateOpenSingleDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOpenSingleDataResponse createOpenSingleData(shared_ptr<CreateOpenSingleDataRequest> request);
  DeleteCubecardWhitelistContentResponse deleteCubecardWhitelistContentWithOptions(shared_ptr<DeleteCubecardWhitelistContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCubecardWhitelistContentResponse deleteCubecardWhitelistContent(shared_ptr<DeleteCubecardWhitelistContentRequest> request);
  DeleteMcdpAimResponse deleteMcdpAimWithOptions(shared_ptr<DeleteMcdpAimRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMcdpAimResponse deleteMcdpAim(shared_ptr<DeleteMcdpAimRequest> request);
  DeleteMcdpCrowdResponse deleteMcdpCrowdWithOptions(shared_ptr<DeleteMcdpCrowdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMcdpCrowdResponse deleteMcdpCrowd(shared_ptr<DeleteMcdpCrowdRequest> request);
  DeleteMcdpEventAttributeByIdResponse deleteMcdpEventAttributeByIdWithOptions(shared_ptr<DeleteMcdpEventAttributeByIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMcdpEventAttributeByIdResponse deleteMcdpEventAttributeById(shared_ptr<DeleteMcdpEventAttributeByIdRequest> request);
  DeleteMcdpEventByIdResponse deleteMcdpEventByIdWithOptions(shared_ptr<DeleteMcdpEventByIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMcdpEventByIdResponse deleteMcdpEventById(shared_ptr<DeleteMcdpEventByIdRequest> request);
  DeleteMcdpMaterialResponse deleteMcdpMaterialWithOptions(shared_ptr<DeleteMcdpMaterialRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMcdpMaterialResponse deleteMcdpMaterial(shared_ptr<DeleteMcdpMaterialRequest> request);
  DeleteMcdpZoneResponse deleteMcdpZoneWithOptions(shared_ptr<DeleteMcdpZoneRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMcdpZoneResponse deleteMcdpZone(shared_ptr<DeleteMcdpZoneRequest> request);
  DeleteMcubeMiniAppResponse deleteMcubeMiniAppWithOptions(shared_ptr<DeleteMcubeMiniAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMcubeMiniAppResponse deleteMcubeMiniApp(shared_ptr<DeleteMcubeMiniAppRequest> request);
  DeleteMcubeNebulaAppResponse deleteMcubeNebulaAppWithOptions(shared_ptr<DeleteMcubeNebulaAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMcubeNebulaAppResponse deleteMcubeNebulaApp(shared_ptr<DeleteMcubeNebulaAppRequest> request);
  DeleteMcubeUpgradeResourceResponse deleteMcubeUpgradeResourceWithOptions(shared_ptr<DeleteMcubeUpgradeResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMcubeUpgradeResourceResponse deleteMcubeUpgradeResource(shared_ptr<DeleteMcubeUpgradeResourceRequest> request);
  DeleteMcubeWhitelistResponse deleteMcubeWhitelistWithOptions(shared_ptr<DeleteMcubeWhitelistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMcubeWhitelistResponse deleteMcubeWhitelist(shared_ptr<DeleteMcubeWhitelistRequest> request);
  DeleteMdsWhitelistContentResponse deleteMdsWhitelistContentWithOptions(shared_ptr<DeleteMdsWhitelistContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMdsWhitelistContentResponse deleteMdsWhitelistContent(shared_ptr<DeleteMdsWhitelistContentRequest> request);
  ExistMcubeRsaKeyResponse existMcubeRsaKeyWithOptions(shared_ptr<ExistMcubeRsaKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExistMcubeRsaKeyResponse existMcubeRsaKey(shared_ptr<ExistMcubeRsaKeyRequest> request);
  ExportMappCenterAppConfigResponse exportMappCenterAppConfigWithOptions(shared_ptr<ExportMappCenterAppConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportMappCenterAppConfigResponse exportMappCenterAppConfig(shared_ptr<ExportMappCenterAppConfigRequest> request);
  GetFileTokenForUploadToMsaResponse getFileTokenForUploadToMsaWithOptions(shared_ptr<GetFileTokenForUploadToMsaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFileTokenForUploadToMsaResponse getFileTokenForUploadToMsa(shared_ptr<GetFileTokenForUploadToMsaRequest> request);
  GetLogUrlInMsaResponse getLogUrlInMsaWithOptions(shared_ptr<GetLogUrlInMsaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLogUrlInMsaResponse getLogUrlInMsa(shared_ptr<GetLogUrlInMsaRequest> request);
  GetMcubeFileTokenResponse getMcubeFileTokenWithOptions(shared_ptr<GetMcubeFileTokenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMcubeFileTokenResponse getMcubeFileToken(shared_ptr<GetMcubeFileTokenRequest> request);
  GetMcubeNebulaResourceResponse getMcubeNebulaResourceWithOptions(shared_ptr<GetMcubeNebulaResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMcubeNebulaResourceResponse getMcubeNebulaResource(shared_ptr<GetMcubeNebulaResourceRequest> request);
  GetMcubeNebulaTaskDetailResponse getMcubeNebulaTaskDetailWithOptions(shared_ptr<GetMcubeNebulaTaskDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMcubeNebulaTaskDetailResponse getMcubeNebulaTaskDetail(shared_ptr<GetMcubeNebulaTaskDetailRequest> request);
  GetMcubeUpgradePackageInfoResponse getMcubeUpgradePackageInfoWithOptions(shared_ptr<GetMcubeUpgradePackageInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMcubeUpgradePackageInfoResponse getMcubeUpgradePackageInfo(shared_ptr<GetMcubeUpgradePackageInfoRequest> request);
  GetMcubeUpgradeTaskInfoResponse getMcubeUpgradeTaskInfoWithOptions(shared_ptr<GetMcubeUpgradeTaskInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMcubeUpgradeTaskInfoResponse getMcubeUpgradeTaskInfo(shared_ptr<GetMcubeUpgradeTaskInfoRequest> request);
  GetMdsMiniConfigResponse getMdsMiniConfigWithOptions(shared_ptr<GetMdsMiniConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMdsMiniConfigResponse getMdsMiniConfig(shared_ptr<GetMdsMiniConfigRequest> request);
  GetUserAppDonwloadUrlInMsaResponse getUserAppDonwloadUrlInMsaWithOptions(shared_ptr<GetUserAppDonwloadUrlInMsaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserAppDonwloadUrlInMsaResponse getUserAppDonwloadUrlInMsa(shared_ptr<GetUserAppDonwloadUrlInMsaRequest> request);
  GetUserAppEnhanceProcessInMsaResponse getUserAppEnhanceProcessInMsaWithOptions(shared_ptr<GetUserAppEnhanceProcessInMsaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserAppEnhanceProcessInMsaResponse getUserAppEnhanceProcessInMsa(shared_ptr<GetUserAppEnhanceProcessInMsaRequest> request);
  GetUserAppUploadProcessInMsaResponse getUserAppUploadProcessInMsaWithOptions(shared_ptr<GetUserAppUploadProcessInMsaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserAppUploadProcessInMsaResponse getUserAppUploadProcessInMsa(shared_ptr<GetUserAppUploadProcessInMsaRequest> request);
  ListMappCenterAppsResponse listMappCenterAppsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMappCenterAppsResponse listMappCenterApps();
  ListMappCenterWorkspacesResponse listMappCenterWorkspacesWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMappCenterWorkspacesResponse listMappCenterWorkspaces();
  ListMcdpAimResponse listMcdpAimWithOptions(shared_ptr<ListMcdpAimRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMcdpAimResponse listMcdpAim(shared_ptr<ListMcdpAimRequest> request);
  ListMcubeMiniAppsResponse listMcubeMiniAppsWithOptions(shared_ptr<ListMcubeMiniAppsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMcubeMiniAppsResponse listMcubeMiniApps(shared_ptr<ListMcubeMiniAppsRequest> request);
  ListMcubeMiniPackagesResponse listMcubeMiniPackagesWithOptions(shared_ptr<ListMcubeMiniPackagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMcubeMiniPackagesResponse listMcubeMiniPackages(shared_ptr<ListMcubeMiniPackagesRequest> request);
  ListMcubeMiniTasksResponse listMcubeMiniTasksWithOptions(shared_ptr<ListMcubeMiniTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMcubeMiniTasksResponse listMcubeMiniTasks(shared_ptr<ListMcubeMiniTasksRequest> request);
  ListMcubeNebulaAppsResponse listMcubeNebulaAppsWithOptions(shared_ptr<ListMcubeNebulaAppsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMcubeNebulaAppsResponse listMcubeNebulaApps(shared_ptr<ListMcubeNebulaAppsRequest> request);
  ListMcubeNebulaResourcesResponse listMcubeNebulaResourcesWithOptions(shared_ptr<ListMcubeNebulaResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMcubeNebulaResourcesResponse listMcubeNebulaResources(shared_ptr<ListMcubeNebulaResourcesRequest> request);
  ListMcubeNebulaTasksResponse listMcubeNebulaTasksWithOptions(shared_ptr<ListMcubeNebulaTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMcubeNebulaTasksResponse listMcubeNebulaTasks(shared_ptr<ListMcubeNebulaTasksRequest> request);
  ListMcubeUpgradePackagesResponse listMcubeUpgradePackagesWithOptions(shared_ptr<ListMcubeUpgradePackagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMcubeUpgradePackagesResponse listMcubeUpgradePackages(shared_ptr<ListMcubeUpgradePackagesRequest> request);
  ListMcubeUpgradeTasksResponse listMcubeUpgradeTasksWithOptions(shared_ptr<ListMcubeUpgradeTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMcubeUpgradeTasksResponse listMcubeUpgradeTasks(shared_ptr<ListMcubeUpgradeTasksRequest> request);
  ListMcubeWhitelistsResponse listMcubeWhitelistsWithOptions(shared_ptr<ListMcubeWhitelistsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMcubeWhitelistsResponse listMcubeWhitelists(shared_ptr<ListMcubeWhitelistsRequest> request);
  ListMgsApiResponse listMgsApiWithOptions(shared_ptr<ListMgsApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMgsApiResponse listMgsApi(shared_ptr<ListMgsApiRequest> request);
  LogMsaQueryResponse logMsaQueryWithOptions(shared_ptr<LogMsaQueryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  LogMsaQueryResponse logMsaQuery(shared_ptr<LogMsaQueryRequest> request);
  MTRSOCRServiceResponse mTRSOCRServiceWithOptions(shared_ptr<MTRSOCRServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MTRSOCRServiceResponse mTRSOCRService(shared_ptr<MTRSOCRServiceRequest> request);
  OpenApiAddActiveCodeResponse openApiAddActiveCodeWithOptions(shared_ptr<OpenApiAddActiveCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenApiAddActiveCodeResponse openApiAddActiveCode(shared_ptr<OpenApiAddActiveCodeRequest> request);
  OpenApiAddActiveSceneResponse openApiAddActiveSceneWithOptions(shared_ptr<OpenApiAddActiveSceneRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenApiAddActiveSceneResponse openApiAddActiveScene(shared_ptr<OpenApiAddActiveSceneRequest> request);
  OpenApiCallbackResponse openApiCallbackWithOptions(shared_ptr<OpenApiCallbackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenApiCallbackResponse openApiCallback(shared_ptr<OpenApiCallbackRequest> request);
  OpenApiDecodeResponse openApiDecodeWithOptions(shared_ptr<OpenApiDecodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenApiDecodeResponse openApiDecode(shared_ptr<OpenApiDecodeRequest> request);
  OpenApiDeleteActiveCodeResponse openApiDeleteActiveCodeWithOptions(shared_ptr<OpenApiDeleteActiveCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenApiDeleteActiveCodeResponse openApiDeleteActiveCode(shared_ptr<OpenApiDeleteActiveCodeRequest> request);
  OpenApiEncodeResponse openApiEncodeWithOptions(shared_ptr<OpenApiEncodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenApiEncodeResponse openApiEncode(shared_ptr<OpenApiEncodeRequest> request);
  OpenApiQueryActiveCodeResponse openApiQueryActiveCodeWithOptions(shared_ptr<OpenApiQueryActiveCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenApiQueryActiveCodeResponse openApiQueryActiveCode(shared_ptr<OpenApiQueryActiveCodeRequest> request);
  OpenApiQueryActiveSceneResponse openApiQueryActiveSceneWithOptions(shared_ptr<OpenApiQueryActiveSceneRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenApiQueryActiveSceneResponse openApiQueryActiveScene(shared_ptr<OpenApiQueryActiveSceneRequest> request);
  OpenApiUniqueEncodeResponse openApiUniqueEncodeWithOptions(shared_ptr<OpenApiUniqueEncodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenApiUniqueEncodeResponse openApiUniqueEncode(shared_ptr<OpenApiUniqueEncodeRequest> request);
  OpenApiUpdateActiveCodeResponse openApiUpdateActiveCodeWithOptions(shared_ptr<OpenApiUpdateActiveCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenApiUpdateActiveCodeResponse openApiUpdateActiveCode(shared_ptr<OpenApiUpdateActiveCodeRequest> request);
  OpenApiUpdateActiveSceneResponse openApiUpdateActiveSceneWithOptions(shared_ptr<OpenApiUpdateActiveSceneRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenApiUpdateActiveSceneResponse openApiUpdateActiveScene(shared_ptr<OpenApiUpdateActiveSceneRequest> request);
  PushBindResponse pushBindWithOptions(shared_ptr<PushBindRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PushBindResponse pushBind(shared_ptr<PushBindRequest> request);
  PushBroadcastResponse pushBroadcastWithOptions(shared_ptr<PushBroadcastRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PushBroadcastResponse pushBroadcast(shared_ptr<PushBroadcastRequest> request);
  PushMultipleResponse pushMultipleWithOptions(shared_ptr<PushMultipleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PushMultipleResponse pushMultiple(shared_ptr<PushMultipleRequest> request);
  PushReportResponse pushReportWithOptions(shared_ptr<PushReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PushReportResponse pushReport(shared_ptr<PushReportRequest> request);
  PushSimpleResponse pushSimpleWithOptions(shared_ptr<PushSimpleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PushSimpleResponse pushSimple(shared_ptr<PushSimpleRequest> request);
  PushTemplateResponse pushTemplateWithOptions(shared_ptr<PushTemplateRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PushTemplateResponse pushTemplate(shared_ptr<PushTemplateRequest> request);
  PushUnBindResponse pushUnBindWithOptions(shared_ptr<PushUnBindRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PushUnBindResponse pushUnBind(shared_ptr<PushUnBindRequest> request);
  QueryInfoFromMdpResponse queryInfoFromMdpWithOptions(shared_ptr<QueryInfoFromMdpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryInfoFromMdpResponse queryInfoFromMdp(shared_ptr<QueryInfoFromMdpRequest> request);
  QueryMappCenterAppResponse queryMappCenterAppWithOptions(shared_ptr<QueryMappCenterAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMappCenterAppResponse queryMappCenterApp(shared_ptr<QueryMappCenterAppRequest> request);
  QueryMcdpAimResponse queryMcdpAimWithOptions(shared_ptr<QueryMcdpAimRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMcdpAimResponse queryMcdpAim(shared_ptr<QueryMcdpAimRequest> request);
  QueryMcdpZoneResponse queryMcdpZoneWithOptions(shared_ptr<QueryMcdpZoneRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMcdpZoneResponse queryMcdpZone(shared_ptr<QueryMcdpZoneRequest> request);
  QueryMcubeMiniPackageResponse queryMcubeMiniPackageWithOptions(shared_ptr<QueryMcubeMiniPackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMcubeMiniPackageResponse queryMcubeMiniPackage(shared_ptr<QueryMcubeMiniPackageRequest> request);
  QueryMcubeMiniTaskResponse queryMcubeMiniTaskWithOptions(shared_ptr<QueryMcubeMiniTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMcubeMiniTaskResponse queryMcubeMiniTask(shared_ptr<QueryMcubeMiniTaskRequest> request);
  QueryMcubeVhostResponse queryMcubeVhostWithOptions(shared_ptr<QueryMcubeVhostRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMcubeVhostResponse queryMcubeVhost(shared_ptr<QueryMcubeVhostRequest> request);
  QueryMdsUpgradeTaskDetailResponse queryMdsUpgradeTaskDetailWithOptions(shared_ptr<QueryMdsUpgradeTaskDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMdsUpgradeTaskDetailResponse queryMdsUpgradeTaskDetail(shared_ptr<QueryMdsUpgradeTaskDetailRequest> request);
  QueryMgsApipageResponse queryMgsApipageWithOptions(shared_ptr<QueryMgsApipageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMgsApipageResponse queryMgsApipage(shared_ptr<QueryMgsApipageRequest> request);
  QueryMgsApirestResponse queryMgsApirestWithOptions(shared_ptr<QueryMgsApirestRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMgsApirestResponse queryMgsApirest(shared_ptr<QueryMgsApirestRequest> request);
  QueryMgsTestreqbodyautogenResponse queryMgsTestreqbodyautogenWithOptions(shared_ptr<QueryMgsTestreqbodyautogenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMgsTestreqbodyautogenResponse queryMgsTestreqbodyautogen(shared_ptr<QueryMgsTestreqbodyautogenRequest> request);
  QueryMpsSchedulerListResponse queryMpsSchedulerListWithOptions(shared_ptr<QueryMpsSchedulerListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMpsSchedulerListResponse queryMpsSchedulerList(shared_ptr<QueryMpsSchedulerListRequest> request);
  QueryPushAnalysisCoreIndexResponse queryPushAnalysisCoreIndexWithOptions(shared_ptr<QueryPushAnalysisCoreIndexRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryPushAnalysisCoreIndexResponse queryPushAnalysisCoreIndex(shared_ptr<QueryPushAnalysisCoreIndexRequest> request);
  QueryPushAnalysisTaskDetailResponse queryPushAnalysisTaskDetailWithOptions(shared_ptr<QueryPushAnalysisTaskDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryPushAnalysisTaskDetailResponse queryPushAnalysisTaskDetail(shared_ptr<QueryPushAnalysisTaskDetailRequest> request);
  QueryPushAnalysisTaskListResponse queryPushAnalysisTaskListWithOptions(shared_ptr<QueryPushAnalysisTaskListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryPushAnalysisTaskListResponse queryPushAnalysisTaskList(shared_ptr<QueryPushAnalysisTaskListRequest> request);
  QueryPushSchedulerListResponse queryPushSchedulerListWithOptions(shared_ptr<QueryPushSchedulerListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryPushSchedulerListResponse queryPushSchedulerList(shared_ptr<QueryPushSchedulerListRequest> request);
  RevokePushMessageResponse revokePushMessageWithOptions(shared_ptr<RevokePushMessageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokePushMessageResponse revokePushMessage(shared_ptr<RevokePushMessageRequest> request);
  RevokePushTaskResponse revokePushTaskWithOptions(shared_ptr<RevokePushTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokePushTaskResponse revokePushTask(shared_ptr<RevokePushTaskRequest> request);
  RunMsaDiffResponse runMsaDiffWithOptions(shared_ptr<RunMsaDiffRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunMsaDiffResponse runMsaDiff(shared_ptr<RunMsaDiffRequest> request);
  SaveMgsApirestResponse saveMgsApirestWithOptions(shared_ptr<SaveMgsApirestRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveMgsApirestResponse saveMgsApirest(shared_ptr<SaveMgsApirestRequest> request);
  StartUserAppAsyncEnhanceInMsaResponse startUserAppAsyncEnhanceInMsaWithOptions(shared_ptr<StartUserAppAsyncEnhanceInMsaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartUserAppAsyncEnhanceInMsaResponse startUserAppAsyncEnhanceInMsa(shared_ptr<StartUserAppAsyncEnhanceInMsaRequest> request);
  UpdateMcubeWhitelistResponse updateMcubeWhitelistWithOptions(shared_ptr<UpdateMcubeWhitelistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMcubeWhitelistResponse updateMcubeWhitelist(shared_ptr<UpdateMcubeWhitelistRequest> request);
  UpdateMpaasAppInfoResponse updateMpaasAppInfoWithOptions(shared_ptr<UpdateMpaasAppInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMpaasAppInfoResponse updateMpaasAppInfo(shared_ptr<UpdateMpaasAppInfoRequest> request);
  UploadBitcodeToMsaResponse uploadBitcodeToMsaWithOptions(shared_ptr<UploadBitcodeToMsaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadBitcodeToMsaResponse uploadBitcodeToMsa(shared_ptr<UploadBitcodeToMsaRequest> request);
  UploadMcubeMiniPackageResponse uploadMcubeMiniPackageWithOptions(shared_ptr<UploadMcubeMiniPackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadMcubeMiniPackageResponse uploadMcubeMiniPackage(shared_ptr<UploadMcubeMiniPackageRequest> request);
  UploadMcubeRsaKeyResponse uploadMcubeRsaKeyWithOptions(shared_ptr<UploadMcubeRsaKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadMcubeRsaKeyResponse uploadMcubeRsaKey(shared_ptr<UploadMcubeRsaKeyRequest> request);
  UploadUserAppToMsaResponse uploadUserAppToMsaWithOptions(shared_ptr<UploadUserAppToMsaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadUserAppToMsaResponse uploadUserAppToMsa(shared_ptr<UploadUserAppToMsaRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_MPaaS20201028

#endif
